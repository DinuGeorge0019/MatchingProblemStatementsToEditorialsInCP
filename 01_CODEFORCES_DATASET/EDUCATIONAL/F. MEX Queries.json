{"link": "https://codeforces.com//contest/817/problem/F", "problemId": "110092", "shortId": "817F", "contest_number": "817", "name": "F. MEX Queries", "statement": "You are given a set of integer numbers, initially it is empty. You should perform  queries.There are three different types of queries:      \u2014 Add all missing numbers from the interval      \u2014 Remove all present numbers from the interval      \u2014 Invert the interval  \u2014 add all missing and remove all present numbers from the interval  After each query you should output  of the set \u2014 the smallest positive ( ) integer number which is not presented in the set.", "input": "The first line contains one integer number  (). Next  lines contain three integer numbers  () \u2014 type of the query, left and right bounds.", "output": "Print  of the set after each query.", "tutorial": "There are many ways to solve this problem, you can use cartesian tree, segment tree, sqrt decomposition, maybe something else. I personally see the solution with the segment tree the easiest one so let me describe it.Firstly, let's notice that the queries are offline. So we can compress the numbers by taking  and  of each query.  will be either one of these numbers or . So now we have numbers up to  and pretty basic task on segment tree.The first two types of queries are translated to \"assign value  or  on a segment\" (set the number on some position is either present or not). The third is \"for each  in segment  assign  to \" (this will inverse the segment as described in statement).Segment tree should keep sum of the segment in its nodes. XOR on segment will turn  into ,  is the length of the segment being covered by the node.The leftmost zero cell is .While standing in some node , check if its left son is full (has  in every cell of the segment, like  if you use 1-indexed tree and intervals for it). If it is full then go down to the right son, otherwise there exists some zero cell in a segment of the left child and you should go down to it.You should use lazy propagation to guarantee  per query.Overall complexity: .", "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ms(s, n) memset(s, n, sizeof(s))\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define FORd(i, a, b) for (int i = (a) - 1; i >= (b); i--)\n#define FORall(it, a) for (__typeof((a).begin()) it = (a).begin(); it != (a).end(); it++)\n#define sz(a) int((a).size())\n#define present(t, x) (t.find(x) != t.end())\n#define all(a) (a).begin(), (a).end()\n#define uni(a) (a).erase(unique(all(a)), (a).end())\n#define pb push_back\n#define pf push_front\n#define mp make_pair\n#define fi first\n#define se second\n#define prec(n) fixed<<setprecision(n)\n#define bit(n, i) (((n) >> (i)) & 1)\n#define bitcount(n) __builtin_popcountll(n)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pi;\ntypedef vector<int> vi;\ntypedef vector<pi> vii;\nconst int MOD = (int) 1e9 + 7;\nconst int MOD2 = (int) 1e8 + 7;\nconst int INF = (int) 1e9;\nconst ll LINF = (ll) 1e18;\nconst ld PI = acos((ld) -1);\nconst ld EPS = 1e-9;\ninline ll gcd(ll a, ll b) {ll r; while (b) {r = a % b; a = b; b = r;} return a;}\ninline ll lcm(ll a, ll b) {return a / gcd(a, b) * b;}\ninline ll fpow(ll n, ll k, int p = MOD) {ll r = 1; for (; k; k >>= 1) {if (k & 1) r = r * n % p; n = n * n % p;} return r;}\ntemplate<class T> inline int chkmin(T& a, const T& val) {return val < a ? a = val, 1 : 0;}\ntemplate<class T> inline int chkmax(T& a, const T& val) {return a < val ? a = val, 1 : 0;}\ninline ll isqrt(ll k) {ll r = sqrt(k) + 1; while (r * r > k) r--; return r;}\ninline ll icbrt(ll k) {ll r = cbrt(k) + 1; while (r * r * r > k) r--; return r;}\ninline void addmod(int& a, int val, int p = MOD) {if ((a = (a + val)) >= p) a -= p;}\ninline void submod(int& a, int val, int p = MOD) {if ((a = (a - val)) < 0) a += p;}\ninline int mult(int a, int b, int p = MOD) {return (ll) a * b % p;}\ninline int inv(int a, int p = MOD) {return fpow(a, p - 2, p);}\ninline int sign(ld x) {return x < -EPS ? -1 : x > +EPS;}\ninline int sign(ld x, ld y) {return sign(x - y);}\n#define db(x) cerr << #x << \" = \" << (x) << \", \";\n#define endln cerr << \"\\n\";\n\nconst int maxn = 1e6 + 5;\nint n;\nint op[maxn];\nlong long l[maxn];\nlong long r[maxn];\n\nint st[maxn << 2];\nint lz1[maxn << 2];\nint lz2[maxn << 2];\n\nvoid pushdown(int p, int L, int R) {\n    if (lz1[p]) {\n        st[p] = (R - L + 1) - st[p];\n        if (L < R) {\n            if (~lz2[p << 1]) {\n                lz1[p << 1] = 0;\n                lz2[p << 1] ^= 1;\n            }\n            else {\n                lz1[p << 1] ^= 1;\n            }\n            if (~lz2[p << 1 | 1]) {\n                lz1[p << 1 | 1] = 0;\n                lz2[p << 1 | 1] ^= 1;\n            }\n            else {\n                lz1[p << 1 | 1] ^= 1;\n            }\n        }\n        lz1[p] = 0;\n    }\n    if (~lz2[p]) {\n        st[p] = lz2[p] * (R - L + 1);\n        if (L < R) {\n            lz2[p << 1] = lz2[p];\n            lz1[p << 1] = 0;\n            lz2[p << 1 | 1] = lz2[p];\n            lz1[p << 1 | 1] = 0;\n        }\n        lz2[p] = -1;\n    }\n}\n\nvoid upd1(int p, int l, int r, int L, int R) {\n    pushdown(p, L, R);\n    if (l > R || r < L) return;\n    if (l <= L && r >= R) {\n        lz1[p] = 1;\n        pushdown(p, L, R);\n        return;\n    }\n    upd1(p << 1, l, r, L, L + R >> 1);\n    upd1(p << 1 | 1, l, r, (L + R >> 1) + 1, R);\n    st[p] = st[p << 1] + st[p << 1 | 1];\n}\n\nvoid upd2(int p, int l, int r, int L, int R, int val) {\n    pushdown(p, L, R);\n    if (l > R || r < L) return;\n    if (l <= L && r >= R) {\n        lz2[p] = val;\n        pushdown(p, L, R);\n        return;\n    }\n    upd2(p << 1, l, r, L, L + R >> 1, val);\n    upd2(p << 1 | 1, l, r, (L + R >> 1) + 1, R, val);\n    st[p] = st[p << 1] + st[p << 1 | 1];\n}\n\nint query(int p, int L, int R) {\n    pushdown(p, L, R);\n    if (L == R) return L;\n    pushdown(p << 1, L, L + R >> 1);\n    pushdown(p << 1 | 1, (L + R >> 1) + 1, R);\n    if (st[p << 1] < (L + R >> 1) - L + 1) return query(p << 1, L, L + R >> 1);\n    return query(p << 1 | 1, (L + R >> 1) + 1, R);\n}\n\nvoid solve() {\n    cin >> n;\n    vector<long long> dc;\n    FOR(i, 0, n) {\n        cin >> op[i] >> l[i] >> r[i];\n        FOR(k, -1, 1 + 1) {\n            if (l[i] + k > 0) {\n                dc.pb(l[i] + k);\n            }\n            if (r[i] + k > 0) {\n                dc.pb(r[i] + k);\n            }\n        }\n    }\n    dc.pb(1);\n    sort(all(dc)), uni(dc);\n    FOR(i, 0, n) {\n        int x = lower_bound(all(dc), l[i]) - dc.begin();\n        int y = lower_bound(all(dc), r[i]) - dc.begin();\n        if (op[i] == 1) {\n            upd2(1, x, y, 0, sz(dc) - 1, 1);\n        }\n        else if (op[i] == 2) {\n            upd2(1, x, y, 0, sz(dc) - 1, 0);\n        }\n        else if (op[i] == 3) {\n            upd1(1, x, y, 0, sz(dc) - 1);\n        }\n        cout << dc[query(1, 0, sz(dc) - 1)] << \"\\n\";\n    }\n}\n\nint main() {\n    int JUDGE_ONLINE = 1;\n    if (fopen(\"in.txt\", \"r\")) {\n        JUDGE_ONLINE = 0;\n        assert(freopen(\"in.txt\", \"r\", stdin));\n        //assert(freopen(\"out.txt\", \"w\", stdout));\n    }\n    else {\n        ios_base::sync_with_stdio(0), cin.tie(0);\n    }\n    solve();\n    if (!JUDGE_ONLINE) {\n        //cout << \"\\nTime elapsed: \" << 1000 * clock() / CLOCKS_PER_SEC << \"ms\\n\";\n    }\n    return 0;\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}