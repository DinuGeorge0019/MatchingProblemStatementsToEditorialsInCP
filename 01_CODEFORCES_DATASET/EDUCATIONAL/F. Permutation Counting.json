{"link": "https://codeforces.com//contest/1671/problem/F", "problemId": "1376220", "shortId": "1671F", "contest_number": "1671", "name": "F. Permutation Counting", "statement": "Calculate the number of permutations  of size  with exactly  inversions (pairs of indices  such that  and ) and exactly  indices  such that .Yep, that's the whole problem. Good luck!", "input": "The first line contains one integer  () \u2014 the number of test cases. Each test case consists of one line which contains three integers ,  and  (; ; ).", "output": "For each test case, print one integer \u2014 the answer to the problem, taken modulo .", "tutorial": "A lot of solutions which were written during the contest use Berlekamp-Messey or some other algorithms related to analyzing linear recurrences, but the model solution is based on other principles.First of all, if the number of inversions is at most , it means that most elements of the permutation will stay at their own places, and those which don't stay at their places can't be too far away from them.Let's denote a block  in a permutation as a segment of indices  such that:  all elements less than  are to the left of the block;  all elements greater than  are to the right of the block;  all elements from  belong to the block. Let's say that a block is non-trivial if it contains at least two elements.Suppose we split a permutation into the maximum number of blocks. Then, for each block, we can see that:  if its length is , it has at least  inversions (to prove it, you can use the fact that the number of inversions is equal to the number of swaps of adjacent elements required to sort the permutation; and if we cannot split the block into other blocks, it means that we have to swap each pair of adjacent elements in it at least once to sort it)  if the block is non-trivial, it has at least one  such that . From these two facts, we can see that:  there will be at most  non-trivial blocks;  there will be at most  elements in total belonging to non-trivial blocks;  the maximum possible length of a block is . The main idea of the solution is to calculate the following dynamic programming:  is the number of ways to split  elements into  non-trivial blocks such that there are exactly  inversions in them and exactly  pairs . Then, to get the answer for the test case \"  \", we can iterate on the number of non-trivial blocks and the number of elements in them, and choose the elements belonging to that blocks with a binomial coefficient.The only thing that's left is how to calculate this dynamic programming efficiently. There are a few ways to do it, but the model solution uses a table  \u2014 the number of different non-trivial blocks of length  with  elements  and  inversions \u2014 to handle transitions. This table is not very big, so you can run an exhaustive search for - minutes to calculate it and then just paste its results into the source code of your program. Note that you have to make sure that you consider only the blocks which cannot be split any further.", "solution": "#include <bits/stdc++.h>\n \nusing namespace std;\n\nconst int K = 13;\nconst int MOD = 998244353;\n\nint n, k, x;\n\nint cnt[K][K][K];\nint dp[K][2 * K][K][K];\n\nint add(int x, int y)\n{\n    x += y;\n    while(x >= MOD) x -= MOD;\n    while(x < 0) x += MOD;\n    return x;\n}   \n\nint sub(int x, int y)\n{\n    return add(x, -y);\n}   \n\nint mul(int x, int y)\n{\n    return (x * 1ll * y) % MOD;\n}\n\nint binpow(int x, int y)\n{\n    int z = 1;\n    while(y > 0)\n    {\n        if(y % 2 == 1) z = mul(z, x);\n        y /= 2;\n        x = mul(x, x);\n    }   \n    return z;\n}\n\nvoid precalc()\n{\n    cnt[2][1][1] = 1;\n    cnt[3][1][2] = 2;\n    cnt[3][2][3] = 1;\n    cnt[4][1][3] = 3;\n    cnt[4][1][4] = 1;\n    cnt[4][2][3] = 1;\n    cnt[4][2][4] = 4;\n    cnt[4][2][5] = 3;\n    cnt[4][3][6] = 1;\n    cnt[5][1][4] = 4;\n    cnt[5][1][5] = 2;\n    cnt[5][1][6] = 2;\n    cnt[5][2][4] = 4;\n    cnt[5][2][5] = 12;\n    cnt[5][2][6] = 12;\n    cnt[5][2][7] = 9;\n    cnt[5][2][8] = 3;\n    cnt[5][3][5] = 2;\n    cnt[5][3][6] = 4;\n    cnt[5][3][7] = 6;\n    cnt[5][3][8] = 6;\n    cnt[5][3][9] = 4;\n    cnt[5][4][10] = 1;\n    cnt[6][1][5] = 5;\n    cnt[6][1][6] = 3;\n    cnt[6][1][7] = 4;\n    cnt[6][1][8] = 3;\n    cnt[6][1][9] = 1;\n    cnt[6][2][5] = 10;\n    cnt[6][2][6] = 28;\n    cnt[6][2][7] = 35;\n    cnt[6][2][8] = 35;\n    cnt[6][2][9] = 30;\n    cnt[6][2][10] = 17;\n    cnt[6][2][11] = 8;\n    cnt[6][3][5] = 1;\n    cnt[6][3][6] = 13;\n    cnt[6][3][7] = 29;\n    cnt[6][3][8] = 41;\n    cnt[6][3][9] = 44;\n    cnt[6][3][10] = 45;\n    cnt[6][3][11] = 30;\n    cnt[6][4][7] = 1;\n    cnt[6][4][8] = 4;\n    cnt[6][4][9] = 7;\n    cnt[6][4][10] = 7;\n    cnt[6][4][11] = 11;\n    cnt[7][1][6] = 6;\n    cnt[7][1][7] = 4;\n    cnt[7][1][8] = 6;\n    cnt[7][1][9] = 6;\n    cnt[7][1][10] = 6;\n    cnt[7][1][11] = 2;\n    cnt[7][2][6] = 20;\n    cnt[7][2][7] = 55;\n    cnt[7][2][8] = 80;\n    cnt[7][2][9] = 95;\n    cnt[7][2][10] = 101;\n    cnt[7][2][11] = 94;\n    cnt[7][3][6] = 6;\n    cnt[7][3][7] = 50;\n    cnt[7][3][8] = 118;\n    cnt[7][3][9] = 186;\n    cnt[7][3][10] = 230;\n    cnt[7][3][11] = 260;\n    cnt[7][4][7] = 3;\n    cnt[7][4][8] = 18;\n    cnt[7][4][9] = 48;\n    cnt[7][4][10] = 85;\n    cnt[7][4][11] = 113;\n    cnt[7][5][10] = 2;\n    cnt[7][5][11] = 4;\n    cnt[8][1][7] = 7;\n    cnt[8][1][8] = 5;\n    cnt[8][1][9] = 8;\n    cnt[8][1][10] = 9;\n    cnt[8][1][11] = 11;\n    cnt[8][2][7] = 35;\n    cnt[8][2][8] = 96;\n    cnt[8][2][9] = 155;\n    cnt[8][2][10] = 207;\n    cnt[8][2][11] = 250;\n    cnt[8][3][7] = 21;\n    cnt[8][3][8] = 145;\n    cnt[8][3][9] = 358;\n    cnt[8][3][10] = 616;\n    cnt[8][3][11] = 859;\n    cnt[8][4][7] = 1;\n    cnt[8][4][8] = 26;\n    cnt[8][4][9] = 124;\n    cnt[8][4][10] = 313;\n    cnt[8][4][11] = 567;\n    cnt[8][5][9] = 3;\n    cnt[8][5][10] = 16;\n    cnt[8][5][11] = 53;\n    cnt[9][1][8] = 8;\n    cnt[9][1][9] = 6;\n    cnt[9][1][10] = 10;\n    cnt[9][1][11] = 12;\n    cnt[9][2][8] = 56;\n    cnt[9][2][9] = 154;\n    cnt[9][2][10] = 268;\n    cnt[9][2][11] = 389;\n    cnt[9][3][8] = 56;\n    cnt[9][3][9] = 350;\n    cnt[9][3][10] = 898;\n    cnt[9][3][11] = 1654;\n    cnt[9][4][8] = 8;\n    cnt[9][4][9] = 126;\n    cnt[9][4][10] = 552;\n    cnt[9][4][11] = 1404;\n    cnt[9][5][9] = 4;\n    cnt[9][5][10] = 48;\n    cnt[9][5][11] = 204;\n    cnt[9][6][11] = 1;\n    cnt[10][1][9] = 9;\n    cnt[10][1][10] = 7;\n    cnt[10][1][11] = 12;\n    cnt[10][2][9] = 84;\n    cnt[10][2][10] = 232;\n    cnt[10][2][11] = 427;\n    cnt[10][3][9] = 126;\n    cnt[10][3][10] = 742;\n    cnt[10][3][11] = 1967;\n    cnt[10][4][9] = 36;\n    cnt[10][4][10] = 448;\n    cnt[10][4][11] = 1887;\n    cnt[10][5][9] = 1;\n    cnt[10][5][10] = 43;\n    cnt[10][5][11] = 357;\n    cnt[10][6][11] = 6;\n    cnt[11][1][10] = 10;\n    cnt[11][1][11] = 8;\n    cnt[11][2][10] = 120;\n    cnt[11][2][11] = 333;\n    cnt[11][3][10] = 252;\n    cnt[11][3][11] = 1428;\n    cnt[11][4][10] = 120;\n    cnt[11][4][11] = 1302;\n    cnt[11][5][10] = 10;\n    cnt[11][5][11] = 252;\n    cnt[11][6][11] = 5;\n    cnt[12][1][11] = 11;\n    cnt[12][2][11] = 165;\n    cnt[12][3][11] = 462;\n    cnt[12][4][11] = 330;\n    cnt[12][5][11] = 55;\n    cnt[12][6][11] = 1;    \n}\n\nint inv[K];\n\nint C(int n, int k)\n{\n    if(n < 0 || n < k || k < 0) return 0;\n    int res = 1;\n    for(int i = n; i > n - k; i--)\n        res = mul(res, i);\n    for(int i = 1; i <= k; i++)\n        res = mul(res, inv[i]);\n    return res;\n}\n\nvoid prepare()\n{\n    for(int i = 1; i < K; i++)\n        inv[i] = binpow(i, MOD - 2);\n    precalc();\n    dp[0][0][0][0] = 1;\n    for(int i = 0; i < K; i++)\n        for(int j = 0; j < 2 * K; j++)\n            for(int a = 0; a < K - 2; a++)\n                for(int b = 0; b < K - 2; b++)\n                {\n                    if(dp[i][j][a][b] == 0) continue;\n                    for(int add_cnt = 2; add_cnt < K; add_cnt++)\n                        for(int add_desc = 1; add_desc <= K - 2; add_desc++)\n                            for(int add_inv = 1; add_inv <= K - 2; add_inv++)\n                            {\n                                if(j + add_cnt >= 2 * K || a + add_desc > K - 2 || b + add_inv > K - 2) continue;\n                                int& nw = dp[i + 1][j + add_cnt][a + add_desc][b + add_inv];\n                                nw = add(nw, mul(dp[i][j][a][b], cnt[add_cnt][add_desc][add_inv]));    \n                            }\n                }       \n}\n\nvoid solve() \n{\n    scanf(\"%d %d %d\", &n, &k, &x);\n    if(k == 0 && x == 0)\n    {\n        puts(\"1\");\n        return;\n    }\n    int ans = 0;\n    for(int i = 1; i < K; i++)\n        for(int j = 1; j < 2 * K; j++)\n            if(dp[i][j][x][k] != 0)\n            {\n                ans = add(ans, mul(dp[i][j][x][k], C(n - j + i, i)));        \n            }\n    printf(\"%d\\n\", ans);\n}\n\nint main()\n{\n    prepare();\n    int t;\n    scanf(\"%d\", &t);\n    for(int i = 0; i < t; i++)\n        solve();\n}", "interactive": false, "noSolution": false, "noTutorial": false}