{"link": "https://codeforces.com//contest/845/problem/G", "problemId": "119177", "shortId": "845G", "contest_number": "845", "name": "G. Shortest Path Problem ", "statement": "You are given an undirected graph with weighted edges. The length of some path between two vertices is the bitwise xor of weights of all edges belonging to this path (if some edge is traversed more than once, then it is included in bitwise xor the same number of times). You have to find the minimum length of path between vertex  and vertex .", "input": "The first line contains two numbers  and  (, ) \u2014 the number of vertices and the number of edges, respectively. Then  lines follow, each line containing three integer numbers ,  and  (, ). These numbers denote an edge that connects vertices  and  and has weight .", "output": "Print one number \u2014 the minimum length of path between vertices  and .", "tutorial": "Let's find some path from  to . Let its length be , then the answer to the problem can be represented as , where  is the total length of some set of cycles in the graph (they can be disconnected; it doesn't matter because we can traverse the whole graph and return to the starting vertex with cost ).Let's treat each cycle's cost as a vector  where  is the -th bit in binary representation of cycle's cost. We can use Gaussian elimination to find the independent set of vectors that generates all these vectors. To do this, let's build any spanning tree of the graph, and then for any edge  not belonging to the spanning tree we can try to add  to the independent set ( is the length of the path from the root to  in the spanning tree). When trying to add some vector, we firstly need to check if it can be represented as a combination of some vectors from the set, and only if it's impossible, then we add it to the set. The number of vectors in the set won't exceed , so we can use Gaussian elimination to check if the vector is a combination of elements from the set.Then, after we found the basis, let's build the answer greedily from the most significant bit to the least: we will check if we can set the current bit so it is equal to the corresponding bit of , while maintaining all the previous bit. To check it, we also can use Gaussian elimination.", "solution": "//package educational.round27;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class G {\n\tInputStream is;\n\tPrintWriter out;\n\tString INPUT = \"\";\n\t\n\tvoid solve()\n\t{\n\t\tint n = ni(), m = ni();\n\t\tint[] from = new int[m];\n\t\tint[] to = new int[m];\n\t\tlong[] w = new long[m];\n\t\tfor(int i = 0;i < m;i++){\n\t\t\tfrom[i] = ni()-1;\n\t\t\tto[i] = ni()-1;\n\t\t\tw[i] = nl();\n\t\t}\n\t\t\n\t\t// \u5168\u57df\u6728\u3064\u304f\u308b\n\t\tDJSet ds = new DJSet(n);\n\t\tint[] ff = new int[n-1];\n\t\tint[] tt = new int[n-1];\n\t\tint[] id = new int[n-1];\n\t\t\n\t\tboolean[] ise = new boolean[m];\n\t\tint p = 0;\n\t\tfor(int i = 0;i < m;i++){\n\t\t\tif(!ds.equiv(from[i], to[i])){\n\t\t\t\tds.union(from[i], to[i]);\n\t\t\t\tff[p] = from[i]; tt[p] = to[i]; id[p] = i;\n\t\t\t\tp++;\n\t\t\t\tise[i] = true;\n\t\t\t}\n\t\t}\n\t\tint[][][] g = packWU(n, ff, tt, id);\n\t\tint[][] pars = parents(g, 0);\n\t\tint[] par = pars[0];\n\t\tint[] ord = pars[1];\n\t\t\n\t\t// \u30eb\u30fc\u30c8\u304b\u3089\u306e\u8ddd\u96e2\u3092\u6c42\u3081\u3066\u304a\u304f\n\t\tlong[] d = new long[n];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tint cur = ord[i];\n\t\t\tfor(int[] e : g[cur]){\n\t\t\t\tif(e[0] != par[cur]){\n\t\t\t\t\td[e[0]] = d[cur] ^ w[e[1]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// \u30b5\u30a4\u30af\u30eb\u57fa\u5e95\u3092\u6c42\u3081\u308b\n\t\tlong[] inde = new long[70];\n\t\tint ip = 0;\n\t\tfor(int i = 0;i < m;i++){\n\t\t\tif(!ise[i]){\n\t\t\t\tlong x = d[from[i]] ^ d[to[i]] ^ w[i];\n\t\t\t\tfor(int j = ip-1;j >= 0;j--){\n\t\t\t\t\tif(Long.highestOneBit(x) == Long.highestOneBit(inde[j])){\n\t\t\t\t\t\tx ^= inde[j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(x != 0){\n\t\t\t\t\tinde[ip++] = x;\n\t\t\t\t\tArrays.sort(inde, 0, ip);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tlong x = d[0]^d[n-1];\n\t\tfor(int j = ip-1;j >= 0;j--){\n\t\t\tif(x > (x^inde[j])){\n\t\t\t\tx ^= inde[j];\n\t\t\t}\n\t\t}\n\t\tout.println(x);\n\t}\n\t\n\tpublic static int[][] parents(int[][][] g, int root) {\n\t\tint n = g.length;\n\t\tint[] par = new int[n];\n\t\tArrays.fill(par, -1);\n \n\t\tint[] q = new int[n];\n\t\tq[0] = root;\n\t\tfor(int p = 0, r = 1;p < r;p++){\n\t\t\tint cur = q[p];\n\t\t\tfor(int[] nex : g[cur]){\n\t\t\t\tif(par[cur] != nex[0]){\n\t\t\t\t\tq[r++] = nex[0];\n\t\t\t\t\tpar[nex[0]] = cur;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn new int[][] { par, q };\n\t}\n\t\n\tpublic static int[][][] packWU(int n, int[] from, int[] to, int[] w) {\n\t\tint[][][] g = new int[n][][];\n\t\tint[] p = new int[n];\n\t\tfor(int f : from)\n\t\t\tp[f]++;\n\t\tfor(int t : to)\n\t\t\tp[t]++;\n\t\tfor(int i = 0;i < n;i++)\n\t\t\tg[i] = new int[p[i]][2];\n\t\tfor(int i = 0;i < from.length;i++){\n\t\t\t--p[from[i]];\n\t\t\tg[from[i]][p[from[i]]][0] = to[i];\n\t\t\tg[from[i]][p[from[i]]][1] = w[i];\n\t\t\t--p[to[i]];\n\t\t\tg[to[i]][p[to[i]]][0] = from[i];\n\t\t\tg[to[i]][p[to[i]]][1] = w[i];\n\t\t}\n\t\treturn g;\n\t}\n\t\n\tpublic static class DJSet { public int[] upper; public DJSet(int n){ upper = new int[n]; Arrays.fill(upper, -1);} public int root(int x){\treturn upper[x] < 0 ? x : (upper[x] = root(upper[x]));}\tpublic boolean equiv(int x, int y){ return root(x) == root(y);} public void union(int x, int y){ x = root(x);y = root(y);if(x != y) { if(upper[y] < upper[x]) { int d = x; x = y; y = d;\t} upper[x] += upper[y]; upper[y] = x;}} public int count(){\tint ct = 0;\tfor(int i = 0;i < upper.length;i++){ if(upper[i] < 0)ct++; } return ct; }}\n\t\n\tvoid run() throws Exception\n\t{\n\t\tis = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tlong s = System.currentTimeMillis();\n\t\tsolve();\n\t\tout.flush();\n\t\ttr(System.currentTimeMillis()-s+\"ms\");\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception { new G().run(); }\n\t\n\tprivate byte[] inbuf = new byte[1024];\n\tpublic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n\tprivate int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate double nd() { return Double.parseDouble(ns()); }\n\tprivate char nc() { return (char)skip(); }\n\t\n\tprivate String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\tprivate void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}