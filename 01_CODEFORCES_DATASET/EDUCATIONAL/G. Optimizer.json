{"link": "https://codeforces.com//contest/1156/problem/G", "problemId": "338454", "shortId": "1156G", "contest_number": "1156", "name": "G. Optimizer", "statement": "Let's analyze a program written on some strange programming language. The variables in this language have names consisting of  to  characters, and each character is a lowercase or an uppercase Latin letter, or a digit. There is an extra constraint that the first character should not be a digit.There are four types of operations in the program, each denoted by one of the characters: , ,  or .Each line of the program has one of the following formats:   , where  and  are valid variable names;  , where ,  and  are valid variable names, and <op> is an operation character. The program is executed line-by-line, and the result of execution is stored in a variable having the name . If  is never assigned in the program, then the result will be equal to the value of  before running the program.Two programs are called equivalent if no matter which operations do characters , ,  and  denote (but, obviously, performing the same operation on the same arguments gives the same result) and which values do variables have before execution of program, the value of  after running the first program is equal to the value of  after running the second program (the programs are executed independently).You are given a program consisting of  lines. Your task is to write a program consisting of minimum possible number of lines that is equivalent to the program you are given.", "input": "The first line contains one integer  () \u2014 the number of lines in the program. Then  lines follow \u2014 the program itself. Each line corresponds to the format described in the statement and has no extra whitespaces.", "output": "In the first line print  \u2014 the minimum number of lines in the equivalent program. Then print  lines without any whitespaces \u2014 an equivalent program having exactly  lines, in the same format it is described in the statement.", "tutorial": "I could've explained the jury solution, however, after the contest I found a much easier and more understandable solution by one of the participants. I put one of jury's solutions under the spoiler along with a link to the solution I'm explaining.Let's restate the problem in a more convinient way. Initially we are given some directed acyclic graph. Let there be nodes of two kinds:  For a direct set operation. These will have a single outgoing edge to another node.  For a binary operation. These will have two outgoing edges to other nodes. However, it's important which edge is the \"left\" one and which is the \"right\" one. We also have to make dummy vertices for the variables which only appeared at the right side of some operation.We are allowed to remove any direct set operations, we will simulate this by compressing the edges of the graph. Instead of doing (), we'll do (). Value-wise this is the same but variable  don't rely on  anymore, so  might be deleted.We'll build the entire graph line by line. Let's maintain array  which will keep the current value of each variable. It will store the node itself. It's probably better to store both kinds of nodes in a separate array so that  and the pointers to the ends of the edges could be integers.If we encountered no \"\" variable getting set, then the answer is 0.Otherwise let's traverse from the node representing the current value of \"\" to every reachable node. While building the graph we were compressing every unoptimal operation, thus all reachable nodes matter.Finally, the last operation on \"\" might have been just a direct set. That's unoptimal, so we'll handle that case separately.", "solution": "#include <algorithm>\n#include <iostream>\n#include <map>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n\nstruct expr {\n\tstring t; // variable name or operation\n\texpr * l, * r; // only if operation\n\tlong long hash;\n\t\n\texpr (string var)\n\t\t: t(var), l(0), r(0), hash(0)\n\t\t{ }\n\texpr (char op, expr * l, expr * r)\n\t\t: t(1,op), l(l), r(r), hash(0)\n\t\t{ }\n\n\tlong long calc_hash() {\n\t\tif (!hash)\n\t\t\tif (!l) {\n\t\t\t\tlong long pw = 257;\n\t\t\t\tfor (size_t i=0; i<t.length(); ++i,  pw*=97)\n\t\t\t\t\thash += t[i] * pw;\n\t\t\t}\n\t\t\telse\n\t\t\t\thash += l->calc_hash() * t[0] + r->calc_hash() * 31;\n\t\treturn hash;\n\t}\n};\n\nmap<string,expr*> var;\n\nvoid inc_var_name (string & cur) {\n\tfor (size_t i=cur.length()-1; ; --i)\n\t\tif (cur[i] < 'z') {\n\t\t\t++cur[i];\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t\tcur[i] = 'a';\n}\n\nstring generate_var() {\n\tstatic string cur = \"aaaa\";\n\twhile (var.count(cur))\n\t\tinc_var_name (cur);\n\tstring res = cur;\n\tinc_var_name (cur);\n\treturn res;\n}\n\nvector<string> ans;\nmap<long long,string> calced;\n\nstring restore (expr * e, string name = \"\") {\n\tif (!e->l)  return e->t;\n\tlong long h = e->calc_hash();\n\tif (calced.count(h))  return calced[h];\n\tstring l = restore (e->l),  r = restore (e->r);\n\tstring my = name.empty() ? generate_var() : name;\n\tcalced[h] = my;\n\tans.push_back (my + \"=\" + l + e->t + r);\n\treturn my;\n}\n\nint main() {\n\tint n;\n\tscanf (\"%d\\n\", &n);\n\tfor (int i=0; i<n; ++i) {\n\t\tstatic char buf[100];\n\t\tgets (buf);\n\t\tstring s = buf;\n\n\t\tsize_t pos1 = s.find ('='),  pos2 = s.find_first_of (\"&^$#\");\n\t\tstring lname = s.substr (0, pos1);\n\t\tstring r1name = s.substr (pos1 + 1, pos2 - pos1 - 1);\n\t\tif (!var.count(r1name))\n\t\t\tvar[r1name] = new expr (r1name);\n\t\tif (pos2 != -1) {\n\t\t\tstring r2name = s.substr (pos2 + 1);\n\t\t\tif (!var.count(r2name))\n\t\t\t\tvar[r2name] = new expr (r2name);\n\t\t\tvar[lname] = new expr (s [ s.find_first_of (\"&^$#\") ], var[r1name], var[r2name]);\n\t\t}\n\t\telse\n\t\t\tvar[lname] = var[r1name];\n\t}\n\n\tif (!var.count(\"res\")) {\n\t\tcout << 0;\n\t\treturn 0;\n\t}\n\n\tstring name = restore (var[\"res\"], \"res\");\n\tif (name != \"res\")\n\t\tans.push_back (\"res=\" + name);\n\n\tcout << ans.size() << endl;\n\tfor (size_t i=0; i<ans.size(); ++i)\n\t\tputs (ans[i].c_str());\n\n}", "interactive": false, "noSolution": false, "noTutorial": false}