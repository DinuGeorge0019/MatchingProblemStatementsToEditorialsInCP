{"link": "https://codeforces.com//contest/1373/problem/F", "problemId": "657375", "shortId": "1373F", "contest_number": "1373", "name": "F. Network Coverage", "statement": "The government of Berland decided to improve network coverage in his country. Berland has a unique structure: the capital in the center and  cities  around the capital. The capital already has a good network coverage (so the government ignores it), but the -th city contains  households that require a connection.The government designed a plan to build  network stations between all pairs of neighboring cities which will maintain connections only for these cities. In other words, the -th network station will provide service only for the -th and the -th city (the -th station is connected to the -th and the -st city).All network stations have capacities: the -th station can provide the connection to at most  households.Now the government asks you to check can the designed stations meet the needs of all cities or not \u2014 that is, is it possible to assign each household a network station so that each network station  provides the connection to at most  households.", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of test cases. The first line of each test case contains the single integer  ()\u00a0\u2014 the number of cities and stations. The second line of each test case contains  integers ()\u00a0\u2014 the number of households in the -th city. The third line of each test case contains  integers ()\u00a0\u2014 the capacities of the designed stations. It's guaranteed that the sum of  over test cases doesn't exceed .", "output": "For each test case, print , if the designed stations can meet the needs of all cities, or  otherwise (case insensitive).", "tutorial": "There are plenty of different solutions to this problem. Here is one that doesn't use Hall's theorem.Let's look at pair  as fuction : how many connections  will be left for the -th city if we take  connections from the -th station. This function has the following structure: there is a minimum required  (let's name it ) to meet the needs of the -th city and with  borrowed connections there will be  free connections to the -th city. Increasing  by some  we can get  free connections, but there is upper bound to number of free connections . In other words, the function  where .For example, let's calculate the corresponding coefficients for the -th function:   if  then ,  and ;  if  then ,  and . Why did we define such functions? If we can calculate result function  then we can check the possibility of meeting all needs by checking that this fuction exists and , i. e. the minimum free  can be used as borrowed .Fortunately, it turns out that the superposition  is either don't exists (if, for example, ) or it has the same structure as any function . So we can calculate  in one pass and find the answer.We will skip the detailed formulas to calculate : you can either find them by yourself or look at function  in author's solution.The resulting complexity is .", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) int((a).size())\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef pair<int, int> pt;\n\nconst int INF = int(1e9);\nconst li INF64 = li(1e18);\n\nint n;\nvector<int> a, b;\n\ninline bool read() {\n\tif(!(cin >> n))\n\t\treturn false;\n\ta.resize(n);\n\tfore(i, 0, n)\n\t\tcin >> a[i];\n\tb.resize(n);\n\tfore(i, 0, n)\n\t\tcin >> b[i];\n\treturn true;\n}\n\nstruct func {\n\tint minx, mink, maxk;\n\tfunc() : minx(0), mink(0), maxk(0) {}\n\tfunc(int minx, int mink, int maxk) : minx(minx), mink(mink), maxk(maxk) {}\n};\n\nfunc getFunc(int a, int b) {\n\tif (a <= b)\n\t\treturn func(0, b - a, b);\n\telse\n\t\treturn func(a - b, 0, b);\n}\n\nfunc merge(func a, func b) {\n\tif (a.minx == -1 || b.minx == -1)\n\t\treturn func(-1, -1, -1);\n\t\n\tif (a.maxk < b.minx)\n\t\treturn func(-1, -1, -1);\n\tif (a.mink >= b.minx)\n\t\treturn func(a.minx, min(b.maxk, b.mink + (a.mink - b.minx)), min(b.maxk, b.mink + (a.maxk - b.minx)));\n\telse {\n\t\tint add = b.minx - a.mink;\n\t\treturn func(a.minx + add, b.mink, min(b.maxk, b.mink + (a.maxk - b.minx)));\n\t}\n}\n\ninline void solve() {\n\tfunc total = getFunc(a[0], b[0]);\n\tfore(i, 1, n)\n\t\ttotal = merge(total, getFunc(a[i], b[i]));\n\t\n\tif (total.minx != -1 && total.minx <= total.mink)\n\t\tcout << \"YES\\n\";\n\telse\n\t\tcout << \"NO\\n\";\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint tt = clock();\n#endif\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0), cout.tie(0);\n\tcout << fixed << setprecision(15);\n\t\n\tint tc; cin >> tc;\n\t\n\twhile(tc--) {\n\t\tread();\n\t\tsolve();\n\t\t\n#ifdef _DEBUG\n\t\tcerr << \"TIME = \" << clock() - tt << endl;\n\t\ttt = clock();\n#endif\n\t}\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}