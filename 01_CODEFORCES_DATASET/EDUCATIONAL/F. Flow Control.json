{"link": "https://codeforces.com//contest/990/problem/F", "problemId": "188995", "shortId": "990F", "contest_number": "990", "name": "F. Flow Control", "statement": "You have to handle a very complex water distribution system. The system consists of  junctions and  pipes, -th pipe connects junctions  and .The only thing you can do is adjusting the pipes. You have to choose  integer numbers , , ...,  and use them as pipe settings. -th pipe will distribute  units of water per second from junction  to junction  (if  is negative, then the pipe will distribute  units of water per second from junction  to junction ). It is allowed to set  to any integer from  to .In order for the system to work properly, there are some constraints: for every , -th junction has a number  associated with it meaning that the difference between incoming and outcoming flow for -th junction must be   (if  is not negative, then -th junction must receive  units of water per second; if it is negative, then -th junction must transfer  units of water per second to other junctions).Can you choose the integers , , ...,  in such a way that all requirements on incoming and outcoming flows are satisfied?", "input": "The first line contains an integer  () \u2014 the number of junctions. The second line contains  integers  () \u2014 constraints for the junctions. The third line contains an integer  () \u2014 the number of pipes. -th of the next  lines contains two integers  and  (, ) \u2014 the description of -th pipe. It is guaranteed that each unordered pair  will appear no more than once in the input (it means that there won't be any pairs  or  after the first occurrence of ). It is guaranteed that for each pair of junctions there exists a path along the pipes connecting them.", "output": "If you can choose such integer numbers  in such a way that all requirements on incoming and outcoming flows are satisfied, then output  in the first line. Then output  lines, -th line should contain  \u2014 the chosen setting numbers for the pipes. Pipes are numbered in order they appear in the input. Otherwise output  in the only line.", "tutorial": "The answer is  if and only if the sum of values is not equal to . Writing some number on edge does not change the total sum and the goal of the problem is to make  in each vertex, thus getting  in total.The algorithm is simple: you get an arbitrary spanning tree (with dfs or dsu), output the difference between sums of values of subtrees (can be calculated with dfs) for edges in this tree and  for the rest of edges.Let's take an arbitrary correct answer. If is has some cycle in graph of edges with non-zero numbers on them, then you can remove it. For example, select any edge on it and subtract the number on it from all the edges of the cycle. This doesn't break the correctness of the answer, as you change both in and out flows for each vertex by the same value. Now that edge has . This way, any answer can be transformed to tree. And for any edge on tree we want to tranfer excess water units from the larger subtree to the smaller.Overall complexity: .", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nmt19937 rnd(time(NULL));\n\nconst int N = 1'000'013;\n\nint n, m;\npair<int, int> e[N];\nint a[N], rk[N];\nlong long sum[N], ans[N];\n\nint p[N];\n\nint getP(int a){\n\treturn (a == p[a] ? a : p[a] = getP(p[a]));\n}\n\nbool merge(int a, int b){\n\ta = getP(a);\n\tb = getP(b);\n\tif (a == b) return false;\n\tif (rk[a] > rk[b]) swap(a, b);\n\tp[a] = b;\n\trk[b] += rk[a];\n\treturn true;\n}\n\nbool used[N];\nvector<int> g[N];\nint h[N];\n\nvoid dfs(int v, int p){\n\tsum[v] = a[v];\n\tfor (auto u : g[v]){\n\t\tif (u != p){\n\t\t\th[u] = h[v] + 1;\n\t\t\tdfs(u, v);\n\t\t\tsum[v] += sum[u];\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tforn(i, n)\n\t\tscanf(\"%d\", &a[i]);\n\t\n\tforn(i, n) p[i] = i, rk[i] = 1;\n\tscanf(\"%d\", &m);\n\tforn(i, m){\n\t\tint &v = e[i].first;\n\t\tint &u = e[i].second;\n\t\tscanf(\"%d%d\", &v, &u);\n\t\t--v, --u;\n\t\tif (merge(v, u)){\n\t\t\tg[v].push_back(u);\n\t\t\tg[u].push_back(v);\n\t\t\tused[i] = true;\n\t\t}\n\t}\n\t\n\tlong long tot = 0;\n\tforn(i, n) tot += a[i];\n\tif (tot != 0){\n\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\t\n\tdfs(0, -1);\n\t\n\tputs(\"Possible\");\n\tforn(i, m){\n\t\tif (used[i]){\n\t\t\tint v = e[i].first, u = e[i].second;\n\t\t\tif (h[v] < h[u])\n\t\t\t\tans[i] = sum[u];\n\t\t\telse\n\t\t\t\tans[i] = -sum[v];\n\t\t}\n\t\tprintf(\"%lld\\n\", ans[i]);\n\t}\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}