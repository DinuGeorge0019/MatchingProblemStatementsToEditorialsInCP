{"link": "https://codeforces.com//contest/1354/problem/B", "problemId": "623445", "shortId": "1354B", "contest_number": "1354", "name": "B. Ternary String", "statement": "You are given a string  such that each its character is either , , or . You have to choose the shortest contiguous substring of  such that it contains each of these three characters at least once.A contiguous substring of string  is a string that can be obtained from  by removing some (possibly zero) characters from the beginning of  and some (possibly zero) characters from the end of .", "input": "The first line contains one integer  () \u2014 the number of test cases. Each test case consists of one line containing the string  (). It is guaranteed that each character of  is either , , or . The sum of lengths of all strings in all test cases does not exceed .", "output": "For each test case, print one integer \u2014 the length of the shortest contiguous substring of  containing all three types of characters at least once. If there is no such substring, print  instead.", "tutorial": "There are multiple solutions involving advanced methods such as binary search or two pointers, but I'll try to describe a simpler one.The main idea of my solution is that the answer should look like : one character of type , a block of characters of type , and one character of type . If we find all blocks of consecutive equal characters in our string, each candidate for the answer can be obtained by expanding a block to the left and to the right by exactly one character. So the total length of all candidates is , and we can check them all.Why does the answer look like ? If the first character of the substring appears somewhere else in it, it can be deleted. The same applies for the last character. So, the first and the last characters should be different, and should not appear anywhere else within the string. Since there are only three types of characters, the answer always looks like .", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nchar buf[200043];\n\nint main()\n{\n\tint t;\n\tscanf(\"%d\", &t);\n\tfor(int i = 0; i < t; i++)\n\t{\n\t\tscanf(\"%s\", buf);\n\t\tstring s = buf;\n\t\tint ans = int(1e9);\n\t\tint n = s.size();\n\t\tvector<pair<char, int> > c;\n\t\tfor(auto x : s)\n\t\t{\n\t\t\tif(c.empty() || c.back().first != x)\n\t\t\t\tc.push_back(make_pair(x, 1));\n\t\t\telse\n\t\t\t\tc.back().second++;\n\t\t}\n\t\tint m = c.size();\n\t\tfor(int i = 1; i < m - 1; i++)\n\t\t\tif(c[i - 1].first != c[i + 1].first)\n\t\t\t\tans = min(ans, c[i].second + 2);\n\t\tif(ans > n)\n\t\t\tans = 0;\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}", "interactive": false, "noSolution": false, "noTutorial": false}