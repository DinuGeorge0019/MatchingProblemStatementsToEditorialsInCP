{"link": "https://codeforces.com//contest/915/problem/D", "problemId": "146471", "shortId": "915D", "contest_number": "915", "name": "D. Almost Acyclic Graph", "statement": "You are given a directed graph consisting of  vertices and  edges (each edge is directed, so it can be traversed in only one direction). You are allowed to remove at most one edge from it.Can you make this graph acyclic by removing at most one edge from it? A directed graph is called acyclic iff it doesn't contain any cycle (a non-empty path that starts and ends in the same vertex).", "input": "The first line contains two integers  and  (, ) \u2014 the number of vertices and the number of edges, respectively. Then  lines follow. Each line contains two integers  and  denoting a directed edge going from vertex  to vertex  (, ). Each ordered pair  is listed at most once (there is at most one directed edge from  to ).", "output": "If it is possible to make this graph acyclic by removing at most one edge, print . Otherwise, print .", "tutorial": "The constraits are set in such a way that naive  solution won't pass (unmark every edge one by one and check if graph of marked edges doesn't contain cycles with dfs/bfs). Thus we should somehow limit the number of edges to check. Let's take arbitrary cycle in graph. Do dfs, store the vertex you used to travel to any other vertex and restore edges with this data if cycle is met. With this algo length of cycle will not exceed . Then do the naive algo but check only edges from this cycle.Overall complexity: .", "solution": "#define _CRT_SECURE_NO_DEPRECATE\n#pragma comment(linker, \"/STACK:167772160000\")\n#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <stdio.h>\n#include <cstdlib>\n#include <stdlib.h>\n#include <string>\n#include <list>\n#include <fstream>\n#include <algorithm>\n#include <cmath>\n#include <map>\n#include <vector>\n#include <iomanip>\n#include <queue>\n#include <deque>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <assert.h>\n#include <functional>\n#include <climits>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\n//typedef uint64_t ull;\n//typedef std::pair<long double,long double> pdd;\n#define for8(i) for( i = 1; i<=8; i++)\n#define fori(N)          for(int i = 0; i<(N); i++)\n#define forj(N)         for(int j = 0; j<(N); j++)\n#define fork(N)         for(int k = 0; k<(N); k++)\n#define forl(N)         for(int l = 0; l<(N); l++)\n#define ford(N)         for(int d = 0; d<(N); d++)\n#define fori1(N)          for(int i = 1; i<=(N); i++)\n#define forj1(N)         for(int j = 1; j<=(N); j++)\n#define fork1(N)         for(int k = 1; k<=(N); k++)\n#define ford1(N)         for(int d = 1; d<=(N); d++)\n#define PI (2*asin(1))\n#define read(n) scanf(\"%d\", &n);\n#define read2(n, m) scanf(\"%d%d\", &n, &m);\n#define readll(n) scanf(\"%I64d\", &n);\n#define mp make_pair\n\nvector<int>edges[510];\nint t1, t2;\n\nvector<int>curCycle;\nbool vis[510];\nbool tVis[510];\nint dfsC(int a) {\n\tif (tVis[a])return -1;\n\tif (vis[a]) {\n\t\tcurCycle.push_back(a);\n\t\treturn a;\n\t}\n\tvis[a] = true;\n\tint ret = -1;\n\tfor (auto x : edges[a]) {\n\t\tif (t1 == a && t2 == x)continue;\n\t\tint d = dfsC(x);\n\t\tif (d == -1)continue;\n\t\tif (d == 0) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (d == a) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tret = d;\n\t\tcurCycle.push_back(a);\n\t\tbreak;\n\t}\n\ttVis[a] = true;\n\treturn ret;\n}\n\n\nint main()\n{\n\tios::sync_with_stdio(false); cin.tie(0);\n#if defined(_DEBUG) || defined(_RELEASE)\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\tint n, m; cin >> n >> m;\n\tfori(m) {\n\t\tint a, b; cin >> a >> b;\n\t\tedges[a].push_back(b);\n\t}\n\tfori1(n) {\n\t\tint x = dfsC(i);\n\t\tif (x == 0)break;\n\t}\n\tif (curCycle.empty()) {\n\t\tcout << \"YES\";\n\t\treturn 0;\n\t}\n\tvector<int>cycle = curCycle;\n\treverse(cycle.begin(), cycle.end());\n\tfori(cycle.size()) {\n\t\tt1 = cycle[i];\n\t\tt2 = cycle[(i + 1) % cycle.size()];\n\t\tforj1(n)vis[j] = tVis[j] = false;\n\t\tbool haveC = false;\n\t\tforj1(n) {\n\t\t\tint x = dfsC(j);\n\t\t\tif (x == 0) {\n\t\t\t\thaveC = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!haveC) {\n\t\t\tcout << \"YES\";\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout << \"NO\";\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}