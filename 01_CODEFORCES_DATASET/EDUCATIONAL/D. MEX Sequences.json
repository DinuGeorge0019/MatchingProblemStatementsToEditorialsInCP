{"link": "https://codeforces.com//contest/1613/problem/D", "problemId": "1209364", "shortId": "1613D", "contest_number": "1613", "name": "D. MEX Sequences", "statement": "Let's call a sequence of integers   if for all  ()  holds. Where  is the minimum non-negative integer that doesn't belong to the set . For example,  and .You are given an array  consisting of  non-negative integers. Calculate the number of non-empty  subsequences of a given array. The number of subsequences can be very large, so print it modulo . Note: a subsequence of an array  is a sequence  meeting the constraints . If two different ways to choose the sequence of indices  yield the same subsequence, the resulting subsequence should be counted twice (i.\u2009e. two subsequences are different if their sequences of indices  are not the same).", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of test cases. The first line of each test case contains a single integer  (). The second line contains  integers  (). The sum of  over all test cases doesn't exceed .", "output": "For each test case, print a single integer\u00a0\u2014 the number of non-empty  subsequences of a given array, taken modulo .", "tutorial": "Let's understand what MEX-correct sequences look like. It turns out there are only two types:  and . For example, the sequences  and the empty sequence are MEX-correct sequences of the first type, and  and  of the second one.Let's calculate the dynamic programming \u00a0\u2014 the number of MEX-correct subsequences of the first type on the prefix of length  with  equal to  and similarly \u00a0\u2014 the number of MEX-correct subsequences of the second type on the prefix of length  with  equal to .Let's look at the transitions in these dps, and show that there are no other MEX-correct sequences at the same time.Let the current state be , and we are trying to add an element equal to :  if , then such an element cannot be added;  if , then the value of  will not change and the sequence is still of the first type, which means we have a transition to ;  if , then the value of  will increase by , but it will still be of the first type, which means we have a transition to   if , then the value of  will not change, but the sequence will become of the second type, which means we have a transition to ;  if , then such an element cannot be added. Let the current state be , and we are trying to add an element equal to :  if , then such an element cannot be added;  if , then the value of  will not change and the sequence is still of the second type, which means we have a transition to ;  if , then such an element cannot be added, because  will increase by , which means the absolute difference between  and  is greater than ;  if , then the value of  will not change and the sequence is still of the second type, which means we have a transition to ;  if , then such an element cannot be added. Thus, we considered all possible transitions (adding a new element to the already MEX-correct sequences) and made sure that there are only two types.While the solution itself works in  time (because each element  has  possible transitions in the dps), it uses  memory, which does not allow us to write that solution as is. However, note that  and  (similarly for ) differ in only a few positions (in those that the element  allowed us to make), which means we can store only one-dimensional arrays,  and . Thus, the final complexity of the solution is .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MOD = 998244353;\n\nint add(int x, int y) {\n  x += y;\n  if (x >= MOD) x -= MOD;\n  return x;\n}\n\nint main() {\n  int t;\n  scanf(\"%d\", &t);\n  while (t--) {\n    int n;\n    scanf(\"%d\", &n);\n    vector<int> dp1(n + 2), dp2(n + 2);\n    dp1[0] = 1;\n    while (n--) {\n      int x;\n      scanf(\"%d\", &x);\n      dp1[x + 1] = add(dp1[x + 1], dp1[x + 1]);\n      dp1[x + 1] = add(dp1[x + 1], dp1[x]);\n      if (x > 0) dp2[x - 1] = add(dp2[x - 1], dp2[x - 1]);\n      if (x > 0) dp2[x - 1] = add(dp2[x - 1], dp1[x - 1]);\n      dp2[x + 1] = add(dp2[x + 1], dp2[x + 1]);\n    }\n    int ans = 0;\n    for (int x : dp1) ans = add(ans, x);\n    for (int x : dp2) ans = add(ans, x);\n    printf(\"%d\\n\", add(ans, MOD - 1));\n  }\n} \n", "interactive": false, "noSolution": false, "noTutorial": false}