{"link": "https://codeforces.com//contest/1101/problem/E", "problemId": "281058", "shortId": "1101E", "contest_number": "1101", "name": "E. Polycarp's New Job", "statement": "Polycarp has recently got himself a new job. He now earns so much that his old wallet can't even store all the money he has.Berland bills somehow come in lots of different sizes. However, all of them are shaped as rectangles (possibly squares). All wallets are also produced in form of rectangles (possibly squares).A bill  fits into some wallet  if either  and  or  and . Bills can overlap with each other in a wallet and an infinite amount of bills can fit into a wallet. That implies that all the bills Polycarp currently have fit into a wallet if every single one of them fits into it independently of the others.Now you are asked to perform the queries of two types:   \u2014 Polycarp earns a bill of size ;   \u2014 Polycarp wants to check if all the bills he has earned to this moment fit into a wallet of size . It is guaranteed that there is at least one query of type  before the first query of type  and that there is at least one query of type  in the input data.For each query of type  print \"\" if all the bills he has earned to this moment fit into a wallet of given size. Print \"\" otherwise.", "input": "The first line contains a single integer  () \u2014 the number of queries. Each of the next  lines contains a query of one of these two types:    () \u2014 Polycarp earns a bill of size ;   () \u2014 Polycarp wants to check if all the bills he has earned to this moment fit into a wallet of size .  It is guaranteed that there is at least one query of type  before the first query of type  and that there is at least one query of type  in the input data.", "output": "For each query of type  print \"\" if all the bills he has earned to this moment fit into a wallet of given size. Print \"\" otherwise.", "tutorial": "Let's find the smallest wallet to fit all bills. One its side is the maximum side of any bill. Now we orient the bills in such a way that their longer side is put against this side of the wallet. The second side of the wallet is the maximum of the other sides. More formally, for set of bills , , ... ( for each ), the minimum wallet is (, ).The minimum wallet fits all sufficient wallets.So the solution is maintaining the maximum of all  and  and checking if  and  ().Choose your i/o functions wisely.Overall complexity: .", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tint mxa = 0, mxb = 0;\n\tstatic char buf[5];\n\tforn(i, n){\n\t\tint x, y;\n\t\tscanf(\"%s%d%d\", buf, &x, &y);\n\t\tif (x < y)\n\t\t\tswap(x, y);\n\t\tif (buf[0] == '+'){\n\t\t\tmxa = max(mxa, x);\n\t\t\tmxb = max(mxb, y);\n\t\t}\n\t\telse{\n\t\t\tputs(mxa <= x && mxb <= y ? \"YES\" : \"NO\");\n\t\t}\n\t}\n}", "interactive": false, "noSolution": false, "noTutorial": false}