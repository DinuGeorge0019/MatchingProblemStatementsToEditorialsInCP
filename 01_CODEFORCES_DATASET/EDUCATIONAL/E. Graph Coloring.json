{"link": "https://codeforces.com//contest/1354/problem/E", "problemId": "623448", "shortId": "1354E", "contest_number": "1354", "name": "E. Graph Coloring", "statement": "You are given an undirected graph without self-loops or multiple edges which consists of  vertices and  edges. Also you are given three integers ,  and .Can you label each vertex with one of three numbers ,  or  in such way, that:   Each vertex should be labeled by exactly one number ,  or ;  The total number of vertices with label  should be equal to ;  The total number of vertices with label  should be equal to ;  The total number of vertices with label  should be equal to ;   for each edge , where  is the label of vertex\u00a0. If there are multiple valid labelings, print any of them.", "input": "The first line contains two integers  and  (; )\u00a0\u2014 the number of vertices and edges in the graph. The second line contains three integers ,  and  ()\u00a0\u2014 the number of labels ,  and , respectively. It's guaranteed that . Next  lines contan description of edges: the -th line contains two integers ,  (; ) \u2014 the vertices the -th edge connects. It's guaranteed that the graph doesn't contain self-loops or multiple edges.", "output": "If valid labeling exists then print \"\" (without quotes) in the first line. In the second line print string of length  consisting of ,  and . The -th letter should be equal to the label of the -th vertex. If there is no valid labeling, print \"\" (without quotes).", "tutorial": "Let's rephrase the fifth condition. Each edge should connect two vertices with the numbers of different parity (either  to  or  to ). So the graph should actually be bipartite and the first partition should have only the odd numbers ( or ) and the second partition should have only the even numbers (only ).Notice how  and  are completely interchangeable in the sense that if you have exactly  vertices which should be assigned odd numbers then you can assign whichever  of them to  and the rest to  you want.So you can guess that the first step is to check if the given graph is bipartite. If it isn't then the answer doesn't exist. It can be done with a single dfs. Actually the algorithm for that extracts the exact partitions, which comes pretty handy.If the graph was a single connected component then the problem would be easy. Just check if either the first partition or the second one has size  and assigned its vertices color . If neither of them are of size  then the answer obviously doesn't exist.However, the issue is that there might be multiple connected components and for each of them you can choose the partition to assign  to independently. Still, each of the connected components should be bipartite for the answer to exist.This can be done with a knapsack-like dp. Let the -th connected component have partitions of sizes . Then the state can be  is true if  connected components are processed and it's possible to assign  to exactly  vertices of these components. As for transitions, for the -th component you can either take the partition with  vertices or with  vertices. Thus, if  is true then both of  and  are also true.If  is false then there is no answer. Otherwise, you can always restore the answer through the dp. The easiest way is probably to store not true/false in  but three values:  for false,  for the case the state is reached by taking the first partition of the -th component and  for the second partition. Also, you should store not only the sizes of the partitions but the vertices in each of them as well. This way you can recover the answer by backtracking from the final state.Overall complexity: .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n#define mp make_pair\n#define pb push_back\n#define sqr(a) ((a) * (a))\n#define sz(a) int(a.size())\n#define all(a) a.begin(), a.end()\n#define forn(i, n) for(int i = 0; i < int(n); i++) \n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n\ntypedef long long li;\ntypedef long double ld;\ntypedef pair<int, int> pt;\n\ntemplate <class A, class B> ostream& operator << (ostream& out, const pair<A, B> &a) {\n\treturn out << \"(\" << a.x << \", \" << a.y << \")\";\n}\n\ntemplate <class A> ostream& operator << (ostream& out, const vector<A> &v) {\n\tout << \"[\";\n\tforn(i, sz(v)) {\n\t\tif(i) out << \", \";\n\t\tout << v[i];\n\t}\n\treturn out << \"]\";\n}\n\nmt19937 rnd(time(NULL));\n\nconst int INF = int(1e9);\nconst li INF64 = li(1e18);\nconst int MOD = int(1e9) + 7;\nconst ld EPS = 1e-9;\nconst ld PI = acos(-1.0);\n\nconst int N = 5000 + 7;\n\nint n, m;\nint a[3];\nvector<int> g[N];\n\nbool read () {\n\tif (scanf(\"%d%d\", &n, &m) != 2)\n\t\treturn false;\n\tforn(i, 3) scanf(\"%d\", &a[i]);\n\tforn(i, n)\n\t\tg[i].clear();\n\tforn(i, m){\n\t\tint v, u;\n\t\tscanf(\"%d%d\", &v, &u);\n\t\t--v, --u;\n\t\tg[v].pb(u);\n\t\tg[u].pb(v);\n\t}\n\treturn true;\n}\n\nint tot0, tot1;\nint clr[N];\nvector<vector<int>> vts[2];\nbool ok;\n\nvoid dfs(int v){\n\ttot0 += clr[v] == 0;\n\ttot1 += clr[v] == 1;\n\tvts[clr[v]].back().pb(v);\n\tfor (auto u : g[v]){\n\t\tif (clr[u] == -1){\n\t\t\tclr[u] = clr[v] ^ 1;\n\t\t\tdfs(u);\n\t\t}\n\t\telse if (clr[u] == clr[v]){\n\t\t\tok = false;\n\t\t}\n\t}\n}\n\nint dp[N][N];\nint res[N];\n\nvoid solve() {\n\tvector<pt> siz;\n\tmemset(clr, -1, sizeof(clr));\n\tvts[0].clear();\n\tvts[1].clear();\n\tforn(i, n) if (clr[i] == -1){\n\t\ttot0 = tot1 = 0;\n\t\tclr[i] = 0;\n\t\tok = true;\n\t\tvts[0].pb(vector<int>());\n\t\tvts[1].pb(vector<int>());\n\t\tdfs(i);\n\t\tif (!ok){\n\t\t\tputs(\"NO\");\n\t\t\treturn;\n\t\t}\n\t\tsiz.pb(mp(tot0, tot1));\n\t}\n\t\n\tmemset(dp, -1, sizeof(dp));\n\tdp[0][0] = 0;\n\tforn(i, sz(siz)) forn(j, N) if (dp[i][j] != -1){\n\t\tdp[i + 1][j + siz[i].x] = 0;\n\t\tdp[i + 1][j + siz[i].y] = 1;\n\t}\n\t\n\tif (dp[sz(siz)][a[1]] == -1){\n\t\tputs(\"NO\");\n\t\treturn;\n\t}\n\t\n\tputs(\"YES\");\n\tmemset(res, -1, sizeof(res));\n\tint cur = a[1];\n\tfor (int i = sz(siz); i > 0; --i){\n\t\tfor (auto it : vts[dp[i][cur]][i - 1])\n\t\t\tres[it] = 2;\n\t\tcur -= sz(vts[dp[i][cur]][i - 1]);\n\t}\n\t\n\tforn(i, n) if (res[i] == -1){\n\t\tif (a[0] > 0){\n\t\t\tres[i] = 1;\n\t\t\t--a[0];\n\t\t}\n\t\telse{\n\t\t\tres[i] = 3;\n\t\t\t--a[2];\n\t\t}\n\t}\n\t\n\tforn(i, n) printf(\"%d\", res[i]);\n\tputs(\"\");\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\t\n\tint tt = clock();\n\t\n#endif\n\t\n\tcerr.precision(15);\n\tcout.precision(15);\n\tcerr << fixed;\n\tcout << fixed;\n\n\twhile(read()) {\t\n\t\tsolve();\n\t\t\n#ifdef _DEBUG\n\tcerr << \"TIME = \" << clock() - tt << endl;\n\ttt = clock();\n#endif\n\n\t}\n}", "interactive": false, "noSolution": false, "noTutorial": false}