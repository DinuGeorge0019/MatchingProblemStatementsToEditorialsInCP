{"link": "https://codeforces.com//contest/873/problem/E", "problemId": "127823", "shortId": "873E", "contest_number": "873", "name": "E. Awards For Contestants", "statement": "Alexey recently held a programming contest for students from Berland.  students participated in a contest, -th of them solved  problems. Now he wants to award some contestants. Alexey can award the students with diplomas of three different degrees. Each student either will receive one diploma of some degree, or won't receive any diplomas at all. Let  be the number of students that are awarded with diplomas of degree  (). The following conditions must hold:  For each  () ;  For any two degrees  and  . Of course, there are a lot of ways to distribute the diplomas. Let  be the degree of diploma -th student will receive (or  if -th student won't receive any diplomas). Also for any  such that  let  be the maximum number of problems solved by a student that receives a diploma of degree , and  be the minimum number of problems solved by a student that receives a diploma of degree . Alexey wants to distribute the diplomas in such a way that:  If student  solved more problems than student , then he has to be awarded not worse than student  (it's impossible that student  receives a diploma and  doesn't receive any, and also it's impossible that both of them receive a diploma, but );   is maximum possible;  Among all ways that maximize the previous expression,  is maximum possible;  Among all ways that correspond to the two previous conditions,  is maximum possible, where  is the maximum number of problems solved by a student that doesn't receive any diploma (or  if each student is awarded with some diploma). Help Alexey to find a way to award the contestants!", "input": "The first line contains one integer number  (). The second line contains  integer numbers  ().", "output": "Output  numbers. -th number must be equal to the degree of diploma -th contestant will receive (or  if he doesn't receive any diploma). If there are multiple optimal solutions, print any of them. It is guaranteed that the answer always exists.", "tutorial": "Let's consider naive solution: make three loops to fix amounts of people to get dimplomas of each degree, take the best. Obviously, sorting the scores will regroup optimal blocks for each degree in such a way that they come in segments of initial array. We tried to make these solutions fail but underestimated the abilities of contestants to optimize this kind of stuff and couple of such made it to the end of contest. :(To be honest, we just need to get rid of the last loop. Let  be the difference between  and  ( is sorted, ). Then let  be the position of the last diploma of second degree and ,  be the amounts of diplomas of the first ans the second degrees. Thus the best position to put the separator between the third degree and no diploma is the postion with the maximum number in array  over segment . This are the borders of possible amount of the dimplomas of the third degree.Maximum over segment can be implemented with segment tree, sparse table or even naive square matrix with  precalc time and  memory.Overall complexity: /.", "solution": "#include <bits/stdc++.h>\n\n#define all(a) (a).begin(), (a).end()\n#define sz(a) (int)(a).size()\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef double ld;\ntypedef pair<ll, ll> pll;\n\nconst int rmax = 15;\nconst int nmax = 100500;\n\nvector<pii> vals;\nvector<vector<pii> > sparse;\nint deg[nmax];\n\npii get(int l, int r) {\n\tint len = r - l + 1;\n\tint k = deg[len];\n\treturn max(sparse[l][k], sparse[l + len - (1 << k)][k]);\n}\n\nint main() {\n\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\n\t//ifstream cin(\"input.txt\");\n\t//ofstream cout(\"output.txt\");\n\n\tint n;\n\tcin >> n;\n\n\tvector<int> x(n);\n\tvector<pii> a;\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> x[i];\n\t\ta.pb({x[i], i});\n\t}\n\tsort(all(a));\n\n\tvals.pb({a[0].first, 0});\n\tfor (int i = 1; i < n; ++i) {\n\t\tvals.pb({a[i]. first - a[i - 1].first, i});\n\t}\n\n\tsparse = vector<vector<pii> >(n, vector<pii>(rmax));\n\tfor (int i = 0; i < n; ++i) {\n\t\tsparse[i][0] = vals[i];\n\t}\n\tfor (int r = 0; r + 1 < rmax; ++r) {\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint t = min(i + (1 << r), n - 1);\n\t\t\tsparse[i][r + 1] = max(sparse[i][r], sparse[t][r]);\n\t\t}\n\t}\n\n\tdeg[0] = -1;\n\tfor (int i = 1; i < nmax; ++i) {\n\t\tdeg[i] = deg[i - 1];\n\t\tif (!(i & (i - 1))) {\n\t\t\t++deg[i];\n\t\t}\n\t}\n\n\tint bestx = -1, besty = -1, bestz = -1;\n\tint besti, bestj, bestk;\n\n\tfor (int i = n - 1; i >= 0; --i) {\n\t\tfor (int j = i - 1; j >= 0; --j) {\n\t\t\tint lena = n - 1 - i + 1;\n\t\t\tint lenb = i - 1 - j + 1;\n\t\t\tif (lena > 2 * lenb || lenb > 2 * lena) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint minlen = max({1, (lena + 1) / 2, (lenb + 1) / 2});\n\t\t\tint maxlen = min({j, 2 * lena, 2 * lenb});\n\t\t\tif (minlen > maxlen) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tpii p = get(j - maxlen, j - minlen);\n\t\t\t/*if (i == n - 1 && j == n - 2) {\n\t\t\t\tcout << p.first << \" \" << p.second << \"\\n\";\n\t\t\t}*/\n\t\t\tif ((a[i].first - a[i - 1].first > bestx) || (a[i].first - a[i - 1].first == bestx && \n\t\t\t\t(a[j].first - a[j - 1].first > besty || (a[j].first - a[j - 1].first == besty && p.first > bestz)))) {\n\t\t\t\tbestx = a[i].first - a[i - 1].first;\n\t\t\t\tbesty = a[j].first - a[j - 1].first;\n\t\t\t\tbestz = p.first;\n\t\t\t\tbesti = i, bestj = j, bestk = p.second;\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<int> ans(n);\n\tfor (int i = 0; i < bestk; ++i) {\n\t\tans[a[i].second] = -1;\n\t}\n\tfor (int i = bestk; i < bestj; ++i) {\n\t\tans[a[i].second] = 3;\n\t}\n\tfor (int i = bestj; i < besti; ++i) {\n\t\tans[a[i].second] = 2;\n\t}\n\tfor (int i = besti; i < n; ++i) {\n\t\tans[a[i].second] = 1;\n\t}\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tcout << ans[i] << \" \";\n\t}\n\tcout << \"\\n\";\n\n}", "interactive": false, "noSolution": false, "noTutorial": false}