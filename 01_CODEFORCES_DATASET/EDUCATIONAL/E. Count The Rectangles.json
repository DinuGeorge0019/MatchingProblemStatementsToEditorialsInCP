{"link": "https://codeforces.com//contest/1194/problem/E", "problemId": "372219", "shortId": "1194E", "contest_number": "1194", "name": "E. Count The Rectangles", "statement": "There are  segments drawn on a plane; the -th segment connects two points (, ) and (, ). Each segment is non-degenerate, and is either horizontal or vertical \u2014 formally, for every  either  or  (but only one of these conditions holds). Only segments of different types may intersect: no pair of horizontal segments shares any common points, and no pair of vertical segments shares any common points.We say that four segments having indices , ,  and  such that  and  form a rectangle if the following conditions hold:  segments  and  are horizontal;  segments  and  are vertical;  segment  intersects with segment ;  segment  intersects with segment ;  segment  intersects with segment ;  segment  intersects with segment . Please calculate the number of ways to choose four segments so they form a rectangle. Note that the conditions  and  should hold.", "input": "The first line contains one integer  () \u2014 the number of segments. Then  lines follow. The -th line contains four integers , ,  and  denoting the endpoints of the -th segment. All coordinates of the endpoints are in the range . It is guaranteed that each segment is non-degenerate and is either horizontal or vertical. Furthermore, if two segments share a common point, one of these segments is horizontal, and another one is vertical.", "output": "Print one integer \u2014 the number of ways to choose four segments so they form a rectangle.", "tutorial": "Let's iterate over the lower horizontal segment. Denote its coordinates as () and (), where . We call vertical segment (, ), (, ) good, if followings conditions holds:  ;  . Now let's use the scanline method. At first, for each good vertical segment  we increment the value of element in position  in some data structure (for example, Fenwick Tree). Next we will process two types of queries in order of increasing their y-coordinate:  horizontal segments with coordinates (, ), (, );  upper point of some vertical segment with coordinates . And if two events of different types have the same y-coordinate then the event of first type must be processed first.For event of first type we need to find sum on range  () in our data structure. Let's denote this sum as . Then we need to add  to the answer (because we have  vertical segments which intersect with both fixed horizontal segments and we can choose two of them in so many ways).For event of second type we just need decrement the value of element in position  in our data structure.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define mp make_pair\n\nconst int N = 10009;\nconst int INF = 1000000009;\n \nint n;\nvector <pair<int, int> > vs[N], hs[N];\nint f[N];\nvector <int> d[N];\n\nvoid upd(int pos, int x){\n\tfor(; pos < N; pos |= pos + 1)\n\t\tf[pos] += x;\n}\n\nint get(int pos){\n\tint res = 0;\n\tfor(; pos >= 0; pos = (pos & (pos + 1)) - 1)\n\t\tres += f[pos];\n\treturn res;\n}\n\nint get(int l, int r){\n\treturn get(r) - get(l - 1);\n}\n\nconst int D = 5000;\n\nint main() {\n\tcin >> n;\n\tfor(int i = 0; i < n; ++i){\n\t\tint x1, y1, x2, y2;\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\tx1 += D, y1 += D, x2 += D, y2 += D; \n\t\tif(y1 == y2) \n\t\t\ths[y1].push_back( mp(min(x1, x2), max(x1, x2)) );\t\n\t\telse \n\t\t\tvs[x1].push_back( mp(min(y1, y2), max(y1, y2)) );\t\n\t}\n\n\tlong long res = 0;\n\tfor(int y = 0; y < N; ++y) for(auto s : hs[y]){\n\t\tfor(int i = 0; i < N; ++i) d[i].clear();\n\t\tmemset(f, 0, sizeof f);\n\n\t\tint l = s.first, r = s.second;\n\t\tfor(int x = l; x <= r; ++x) for(auto s2 : vs[x])\n\t\t\tif(s2.first <= y && s2.second > y) {\n\t\t\t\td[s2.second].push_back(x);\n\t\t\t\tupd(x, 1);\n\t\t\t}\n\n\t\tfor(int y2 = y + 1; y2 < N; ++y2){\n\t\t\tfor(auto s2 : hs[y2]){\t\t\t\n\t\t\t\tint cur = get(s2.first, s2.second);\n\t\t\t\tres += cur * (cur - 1) / 2;\n\t\t\t}\n\t\t\tfor(auto x : d[y2]) upd(x, -1);\n\t\t}\n\t}\n\n\tcout << res << endl;\n\treturn 0;\n}                             \t\n\n\n\n", "interactive": false, "noSolution": false, "noTutorial": false}