{"link": "https://codeforces.com//contest/1612/problem/D", "problemId": "1198238", "shortId": "1612D", "contest_number": "1612", "name": "D. X-Magic Pair", "statement": "You are given a pair of integers  and an integer .You can change the pair in two different ways:   set (assign) ;  set (assign) ,  where  is the absolute difference between  and .The pair  is called -magic if  is obtainable either as  or as  using only the given operations (i.e. the pair  is -magic if  or  after some number of operations applied). You can apply the operations any number of times (even zero).Your task is to find out if the pair  is -magic or not.You have to answer  independent test cases.", "input": "The first line of the input contains one integer  () \u2014 the number of test cases. The next  lines describe test cases. The only line of the test case contains three integers ,  and  ().", "output": "For the -th test case, print  if the corresponding pair  is -magic and  otherwise.", "tutorial": "This problem has a GCD-based solution.Firstly, lets' try to solve it naively. Always suppose that . If this is not true, let's swap  and . Firstly, if , let's do . Okay, now let's subtract  from  until  again and repeat this algorithm till  or . If, after some step, we get  or , we are done, and the answer is . If  or , and we didn't get  then the answer is .Okay, we can see that we always subtract the minimum possible  from  and trying to maintain this condition. It can be proven that this algorithm yields all possible integers that are obtainable by any sequence of the operations from the problem statement (either in  or in ).Now we have to speed up this solution somehow. Obviously, most operations are redundant for us in this particular problem. The first thing is that we can skip all operations till  becomes greater than . The number of such operations is . And the second thing is that we can skip all operations till we get  in . The number of such operations is . For simplicity, this part can be also written as . This doesn't affect the time complexity much, but the formula for the final number of operations we can skip will be simpler. This number equals  (in fact, we take the minimum between two values written above, because we don't want to skip any of these two cases). So, we can transform the pair  to the pair  and continue this algorithm.There are also simpler approaches using the same idea but in a cooler way.Time complexity:  per test case.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nbool get(long long a, long long b, long long x) {\n    if (a == x || b == x) return true;\n    if (a < b) swap(a, b);\n    if (b > a - b) b = a - b;\n    if (x > max(a, b) || a == 0 || b == 0) return false;\n    long long cnt = max(1ll, (a - max(x, b)) / (2 * b));\n    return get(a - b * cnt, b, x);\n}\n\nint main() {\n#ifdef _DEBUG\n    freopen(\"input.txt\", \"r\", stdin);\n//  freopen(\"output.txt\", \"w\", stdout);\n#endif\n    \n    int t;\n    cin >> t;\n    while (t--) {\n        long long a, b, x;\n        cin >> a >> b >> x;\n        if (get(a, b, x)) {\n            cout << \"YES\" << endl;\n        } else {\n            cout << \"NO\" << endl;\n        }\n    }\n    \n    return 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}