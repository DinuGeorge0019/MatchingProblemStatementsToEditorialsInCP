{"link": "https://codeforces.com//contest/1499/problem/F", "problemId": "928254", "shortId": "1499F", "contest_number": "1499", "name": "F. Diameter Cuts", "statement": "You are given an integer  and an undirected tree, consisting of  vertices.The length of a simple path (a path in which each vertex appears at most once) between some pair of vertices is the number of edges in this path. A diameter of a tree is the maximum length of a simple path between all pairs of vertices of this tree.You are about to remove a set of edges from the tree. The tree splits into multiple smaller trees when the edges are removed. The set of edges is valid if all the resulting trees have diameter less than or equal to .Two sets of edges are different if there is an edge such that it appears in only one of the sets.Count the number of valid sets of edges modulo .", "input": "The first line contains two integers  and  (, )\u00a0\u2014 the number of vertices of the tree and the maximum allowed diameter, respectively. Each of the next  lines contains a description of an edge: two integers  and  (, ). The given edges form a tree.", "output": "Print a single integer\u00a0\u2014 the number of valid sets of edges modulo .", "tutorial": "The task is obviously solved by dynamic programming, so our first reaction should be to start looking for meaningful states for it. Obviously, one of the states is the vertex which subtree we are processing. We can choose the root for the tree arbitrarily, let it be vertex . What can be the other helpful state?Consider the method to find the diameter of the subtree of vertex . The diameter can be one of the following paths: either the longest path that is completely in some subtree of  or the concatenation of the longest paths that start in vertex  and end in different subtrees.The diameter is the longest path. Thus, the diameter being less than or equal to  means that all paths should have length less than or equal to .If we can guarantee that no path that is completely in some subtree of  have length greater than , then we will only have to worry about not concatenating long paths from different subtrees. Phrase it the other way around: if we never concatenate the paths from the different subtrees in such a way that their total length is greater than , then no diameter will be greater than .Thus, we can attempt to have \u00a0\u2014 the number of ways to cut some edges in the subtree of  in such a way that there is no path of length greater than  and the longest path starting at vertex  has length .Now for the transitions. For the simplicity, let vertex  have exactly two children. It's not too hard to merge their 's. Iterate over the length  of the first child, the length  of the second child. If , then you can concatenate their longest paths and the longest path for  will be of length . You can also cut either of the edges from  to the first child or to the second child.The approach is good, however, it's not clear how to make it work on a larger number of children. Also, the complexity sounds pretty bad.Instead of merging children to each other, let's merge each child to the  of  one by one.  can store the current maximum length over all processed children. When processing a new child, you can choose to cut or not to cut the edge to it. So you can iterate over the current longest path from  and the longest path from that child.So far, the only way to estimate the complexity is to say that each child has to merge its dp to the parent in , thus making the algorithm . That's obviously too slow.The trick that makes the solution fast is to iterate not to  but to the height of the subtree of  and the subtree of a child. Surely, that is allowed, since the path just can't grow longer than that value.Consider the even worse option: not the height but the size of the subtree. It's easy to see that the size is always greater or equal than the height. Interpret the merge the following way: enumerate the vertices inside all the subtrees of the processed children and the vertices inside the subtree of the new child. Iterating up to the size of the subtree is the same number of moves as going over the vertices in it. The merge will go over all the pairs of vertices such that the first vertex of the pair is in the first set and the second vertex is in the second set. Thus, each pair of vertices of the tree will be processed exactly once (in lca of these vertices). There are  such pairs, thus, such 's work in .Overall complexity: .", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int MOD = 998244353;\n\nint add(int a, int b){\n\ta += b;\n\tif (a >= MOD)\n\t\ta -= MOD;\n\tif (a < 0)\n\t\ta += MOD;\n\treturn a;\n}\n\nint mul(int a, int b){\n\treturn a * 1ll * b % MOD;\n}\n\nint k;\nvector<vector<int>> g;\nvector<vector<int>> dp;\n\nint dfs(int v, int p = -1){\n\tdp[v][0] = 1;\n\tint h = 0;\n\tfor (int u : g[v]) if (u != p){\n\t\tint nh = dfs(u, v);\n\t\tvector<int> tmp(max(h, nh + 1) + 1);\n\t\tforn(i, h + 1) forn(j, nh + 1){\n\t\t\tif (i + j + 1 <= k)\n\t\t\t\ttmp[max(i, j + 1)] = add(tmp[max(i, j + 1)], mul(dp[v][i], dp[u][j]));\n\t\t\tif (i <= k && j <= k)\n\t\t\t\ttmp[i] = add(tmp[i], mul(dp[v][i], dp[u][j]));\n\t\t}\n\t\th = max(h, nh + 1);\n\t\tforn(i, h + 1){\n\t\t\tdp[v][i] = tmp[i];\n\t\t}\n\t}\n\treturn h;\n}\n\nint main() {\n\tint n;\n\tscanf(\"%d%d\", &n, &k);\n\tg.resize(n);\n\tdp.resize(n, vector<int>(n, 0));\n\tforn(i, n - 1){\n\t\tint v, u;\n\t\tscanf(\"%d%d\", &v, &u);\n\t\t--v, --u;\n\t\tg[v].push_back(u);\n\t\tg[u].push_back(v);\n\t}\n\tdfs(0);\n\tint ans = 0;\n\tforn(i, k + 1) ans = add(ans, dp[0][i]);\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}