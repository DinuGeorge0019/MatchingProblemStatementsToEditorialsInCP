{"link": "https://codeforces.com//contest/817/problem/D", "problemId": "110090", "shortId": "817D", "contest_number": "817", "name": "D. Imbalanced Array", "statement": "You are given an array  consisting of  elements. The  of some subsegment of this array is the difference between the maximum and minimum element from this segment. The  of the array is the sum of  of all subsegments of this array.For example, the  of array  is , because there are  different subsegments of this array:    (from index  to index ),  is ;   (from index  to index ),  is ;   (from index  to index ),  is ;   (from index  to index ),  is ;   (from index  to index ),  is ;   (from index  to index ),  is ; You have to determine the  of the array .", "input": "The first line contains one integer  () \u2014 size of the array . The second line contains  integers  () \u2014 elements of the array.", "output": "Print one integer \u2014 the  of .", "tutorial": "First of all, we will calculate the sum of maximum and minimum values on all segments separatedly. Then the answer is the difference between the sum of maximum values and minimum values.How can we calculate the sum of minimum values, for example? For each element we will try to find the number of segments where it is the . So, we will calculate two arrays  ( means that  is the maximum index such that  and ) and  ( means that  is the minimum index such that  and ). So actually,  and  represent the borders of the largest segment where  is the  (and we need to exclude those borders). While knowing these values, we can calculate the number of subsegments where  is the .How can we calculate, for example, the array ? We will use a stack where we will store some indices in the array  in such a way that, if we change all indices to the values in the array , they will be in sorted order (the maximum element will be at the top of the stack, and the minimum \u2014 at the bottom). Let's calculate  from the minimum index to the maximum. When we calculate , we remove all elements  such that  from the stack (since the stack is \"sorted\", all these elements will be at the top of the stack, and when we encounter the first element  such that , it is guaranteed that all elements below it don't need to be deleted). Then, if there's any element on top of the stack, it becomes the value of , then we push  into the stack. Since every element will be added (and deleted) not more than one time, the complexity of this algorithm is linear.We can apply the same technique to calculate the values of  and the sum of maximums.", "solution": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ms(s, n) memset(s, n, sizeof(s))\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define FORd(i, a, b) for (int i = (a) - 1; i >= (b); i--)\n#define FORall(it, a) for (__typeof((a).begin()) it = (a).begin(); it != (a).end(); it++)\n#define sz(a) int((a).size())\n#define present(t, x) (t.find(x) != t.end())\n#define all(a) (a).begin(), (a).end()\n#define uni(a) (a).erase(unique(all(a)), (a).end())\n#define pb push_back\n#define pf push_front\n#define mp make_pair\n#define fi first\n#define se second\n#define prec(n) fixed<<setprecision(n)\n#define bit(n, i) (((n) >> (i)) & 1)\n#define bitcount(n) __builtin_popcountll(n)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pi;\ntypedef vector<int> vi;\ntypedef vector<pi> vii;\nconst int MOD = (int) 1e9 + 7;\nconst int MOD2 = (int) 1e8 + 7;\nconst int INF = (int) 1e9;\nconst ll LINF = (ll) 1e18;\nconst ld PI = acos((ld) -1);\nconst ld EPS = 1e-9;\ninline ll gcd(ll a, ll b) {ll r; while (b) {r = a % b; a = b; b = r;} return a;}\ninline ll lcm(ll a, ll b) {return a / gcd(a, b) * b;}\ninline ll fpow(ll n, ll k, int p = MOD) {ll r = 1; for (; k; k >>= 1) {if (k & 1) r = r * n % p; n = n * n % p;} return r;}\ntemplate<class T> inline int chkmin(T& a, const T& val) {return val < a ? a = val, 1 : 0;}\ntemplate<class T> inline int chkmax(T& a, const T& val) {return a < val ? a = val, 1 : 0;}\ninline ll isqrt(ll k) {ll r = sqrt(k) + 1; while (r * r > k) r--; return r;}\ninline ll icbrt(ll k) {ll r = cbrt(k) + 1; while (r * r * r > k) r--; return r;}\ninline void addmod(int& a, int val, int p = MOD) {if ((a = (a + val)) >= p) a -= p;}\ninline void submod(int& a, int val, int p = MOD) {if ((a = (a - val)) < 0) a += p;}\ninline int mult(int a, int b, int p = MOD) {return (ll) a * b % p;}\ninline int inv(int a, int p = MOD) {return fpow(a, p - 2, p);}\ninline int sign(ld x) {return x < -EPS ? -1 : x > +EPS;}\ninline int sign(ld x, ld y) {return sign(x - y);}\n#define db(x) cerr << #x << \" = \" << (x) << \", \";\n#define endln cerr << \"\\n\";\n\nconst int maxn = 1e6 + 5;\nint n;\nint a[maxn];\nint l[maxn];\nint r[maxn];\nlong long ans;\n\nvoid work() {\n    FOR(i, 0, n) l[i] = r[i] = i;\n    FOR(i, 1, n) {\n        int st = i;\n        while (st && a[i] >= a[st - 1]) st = l[st - 1];\n        l[i] = st;\n    }\n    FORd(i, n - 1, 0) {\n        int st = i;\n        while (st < n - 1 && a[i] > a[st + 1]) st = r[st + 1];\n        r[i] = st;\n    }\n    FOR(i, 0, n) {\n        ans += (long long) a[i] * (i - l[i] + 1) * (r[i] - i + 1);\n    }\n}\n\nvoid solve() {\n   scanf(\"%d\", &n);\n   FOR(i, 0, n) scanf(\"%d\", a + i);\n   work();\n   FOR(i, 0, n) a[i] *= -1;\n   work();\n   cout << ans << \"\\n\";\n}\n\nint main() {\n    int JUDGE_ONLINE = 1;\n    if (fopen(\"in.txt\", \"r\")) {\n        JUDGE_ONLINE = 0;\n        assert(freopen(\"in.txt\", \"r\", stdin));\n        //assert(freopen(\"out.txt\", \"w\", stdout));\n    }\n    else {\n        //ios_base::sync_with_stdio(0), cin.tie(0);\n    }\n    solve();\n    if (!JUDGE_ONLINE) {\n        //cout << \"\\nTime elapsed: \" << 1000 * clock() / CLOCKS_PER_SEC << \"ms\\n\";\n    }\n    return 0;\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}