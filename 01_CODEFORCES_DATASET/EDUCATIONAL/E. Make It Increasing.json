{"link": "https://codeforces.com//contest/1437/problem/E", "problemId": "775843", "shortId": "1437E", "contest_number": "1437", "name": "E. Make It Increasing", "statement": "You are given an array of  integers , , ..., , and a set  of  distinct integers from  to .In one operation, you may choose two integers  and  (,  can be any integer) and assign . This operation can be done only if  does not belong to the set .Calculate the minimum number of operations you should perform so the array  is increasing (that is, ), or report that it is impossible.", "input": "The first line contains two integers  and  (, ) \u2014 the size of the array  and the set , respectively. The second line contains  integers , , ...,  (). Then, if , the third line follows, containing  integers , , ...,  (). .", "output": "If it is impossible to make the array  increasing using the given operations, print . Otherwise, print one integer \u2014 the minimum number of operations you have to perform.", "tutorial": "First, let's solve the problem without blocked positions.Let's look at the array . Obviously, if  strictly increases, then  does not decrease, and vice versa. Now we have to find the maximum number of positions in the  array that can be left unchanged. And you can always choose an integer that will not break the non-decreasing array  for the rest of positions. This problem can be solved in  by analogy with the largest increasing subsequence, but now you can take equal elements.Now you can realize that the segments between two blocked positions do not depend on each other, and the initial problem can be solved as the problem described above. All that remains is to check that all blocked positions do not break the strict array increment.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n\nconst int N = 500 * 1000 + 13;\n\nint n, k;\nint a[N], b[N];\n\nint main() {\n\tscanf(\"%d%d\", &n, &k);\n\tforn(i, n) scanf(\"%d\", &a[i + 1]);\n\ta[0] = -1e9;\n\ta[n + 1] = 2e9;\n\tforn(i, n + 2) a[i] -= i;\n\tforn(i, k) scanf(\"%d\", &b[i + 1]);\n\tb[k + 1] = n + 1;\n\t\n\tint ans = 0;\n\tforn(i, k + 1) {\n\t\tint l = b[i], r = b[i + 1];\n\t\tif (a[l] > a[r]) {\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tvector<int> lis;\n\t\tfor (int j = l + 1; j < r; ++j) if (a[l] <= a[j] && a[j] <= a[r]) {\n\t\t\tauto pos = upper_bound(lis.begin(), lis.end(), a[j]);\n\t\t\tif (pos == lis.end()) lis.push_back(a[j]);\n\t\t\telse *pos = a[j];\n\t\t}\n\t\tans += (r - l - 1) - int(lis.size());\n\t}\n\t\n\tprintf(\"%d\\n\", ans);\n}", "interactive": false, "noSolution": false, "noTutorial": false}