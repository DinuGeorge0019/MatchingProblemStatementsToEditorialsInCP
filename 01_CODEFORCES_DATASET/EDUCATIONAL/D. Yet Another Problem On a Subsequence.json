{"link": "https://codeforces.com//contest/1000/problem/D", "problemId": "193657", "shortId": "1000D", "contest_number": "1000", "name": "D. Yet Another Problem On a Subsequence", "statement": "The sequence of integers  is called a good array if  and . For example, the sequences  are good arrays, and the sequences  \u2014 are not.A sequence of integers is called good if it can be divided into a positive number of good arrays. Each good array should be a subsegment of sequence and each element of the sequence should belong to exactly one array. For example, the sequences ,  are good, and the sequences ,  \u2014 are not.For a given sequence of numbers, count the number of its  that are good sequences, and print the number of such subsequences modulo .", "input": "The first line contains the number  \u2014 the length of the initial sequence. The following line contains  integers  \u2014 the sequence itself.", "output": "In the single line output one integer \u2014 the number of subsequences of the original sequence that are good sequences, taken modulo .", "tutorial": "The problem is solved by the dynamic programming.Let  be the answer for the prefix of the array starting at  (it contains the indices ).If , then .Otherwise, let's go over the position , with which the next good array begins. Then we need to select  positions among  positions, which will be elements of the array. The number of ways to choose an unordered set of  items from  of different objects is calculated using the formula . Thus, the dynamics is as follows:.The basis of dynamics is the value .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1009;\nconst int MOD = 998244353;\n\nint n;\nint a[N];\nint dp[N];\nint C[N][N];\n\nint main() {\n\tfor(int i = 0; i < N; ++i){\n\t\tC[i][0] = C[i][i] = 1;\n\t\tfor(int j = 1; j < i; ++j)\n\t\t\tC[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % MOD;\n\t}\n\t\n\tcin >> n;\n\tfor(int i = 0; i < n; ++i)\n\t\tcin >> a[i];\n\t\n\tdp[n] = 1;\n\tfor(int i = n - 1; i >= 0; --i){\n\t\tif(a[i] <= 0) continue;\n\t\t\n\t\tfor(int j = i + a[i] + 1; j <= n; ++j){\n\t\t\t\tdp[i] += (dp[j] * 1LL * C[j - i - 1][a[i]]) % MOD;\n\t\t\t\tdp[i] %= MOD;\n\t\t}\n\t}\n\n\tint sum = 0;\n\tfor(int i = 0; i < n; ++i){\n\t\tsum += dp[i];\n\t\tsum %= MOD;\n\t}\n\tcout << sum << endl;\n\t\n    return 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}