{"link": "https://codeforces.com//contest/620/problem/C", "problemId": "45929", "shortId": "620C", "contest_number": "620", "name": "C. Pearls in a Row", "statement": "There are  pearls in a row. Let's enumerate them with integers from  to  from the left to the right. The pearl number  has the type .Let's call a sequence of consecutive pearls a . Let's call a segment  if it contains two pearls of the same type.Split the row of the pearls to the maximal number of good segments. Note that each pearl should appear in exactly one segment of the partition.As input/output can reach huge size it is recommended to use fast input/output methods: for example, prefer to use  instead of  in C++, prefer to use  instead of  in .", "input": "The first line contains integer  () \u2014 the number of pearls in a row. The second line contains  integers  () \u2013 the type of the -th pearl.", "output": "On the first line print integer  \u2014 the maximal number of segments in a partition of the row. Each of the next  lines should contain two integers  () \u2014 the number of the leftmost and the rightmost pearls in the -th segment. Note you should print the correct partition of the row of the pearls, so each pearl should be in exactly one segment and all segments should contain two pearls of the same type. If there are several optimal solutions print any of them. You can print the segments in any order. If there are no correct partitions of the row print the number \"\".", "tutorial": "Let's solve the problem greedily. Let's make the first segment by adding elements until the segment will be good. After that let's make the second segment in the same way and so on. If we couldn't make any good segment then the answer is . Otherwise let's add all uncovered elements at the end to the last segment. Easy to prove that our construction is optimal: consider the first two segments of the optimal answer, obviously we can extend the second segment until the first segment will be equal to the first segment in our construction.\n", "solution": "\n            #include <bits/stdc++.h>\n\u00a0\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n#define ford(i, n) for (int i = int(n) - 1; i >= 0; i--)\n#define fore(i, l, r) for (int i = int(l); i < int(r); i++)\n#define correct(x, y, n, m) (0 <= (x) && (x) < (n) && 0 <= (y) && (y) < (m))\n#define all(a) (a).begin(), (a).end()\n#define sz(a) int((a).size())\n#define pb(a) push_back(a)\n#define mp(x, y) make_pair((x), (y))\n#define x first\n#define y second\n\u00a0\nusing namespace std;\n\u00a0\ntypedef long long li;\ntypedef long double ld;\ntypedef pair<int, int> pt;\n\u00a0\ntemplate<typename X> inline X abs(const X& a) { return a < 0? -a: a; }\ntemplate<typename X> inline X sqr(const X& a) { return a * a; }\n\u00a0\nconst int INF = int(1e9);\nconst li INF64 = li(1e18);\nconst ld EPS = 1e-9, PI = 3.1415926535897932384626433832795;\n\u00a0\nconst int N = 300300;\n\u00a0\nint n, a[N];\n\u00a0\ninline bool read() {\n\u00a0 \u00a0 if (!(cin >> n)) return false;\n\u00a0 \u00a0 forn(i, n) assert(scanf(\"%d\", &a[i]) == 1);\n\u00a0 \u00a0 return true;\n}\n\u00a0\ninline void solve() {\n\u00a0 \u00a0 vector<pt> ans;\n\u00a0 \u00a0 for (int i = 0, j = 0; i < n; i = j) {\n\u00a0 \u00a0 \u00a0 \u00a0 set<int> used;\n\u00a0 \u00a0 \u00a0 \u00a0 while (j < n && !used.count(a[j])) {\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 used.insert(a[j++]);\n\u00a0 \u00a0 \u00a0 \u00a0 }\n\u00a0 \u00a0 \u00a0 \u00a0 if (j == n) break;\n\u00a0 \u00a0 \u00a0 \u00a0 ans.pb(mp(i, j));\n\u00a0 \u00a0 \u00a0 \u00a0 j++;\n\u00a0 \u00a0 }\n\u00a0\n\u00a0 \u00a0 if (ans.empty()) {\n\u00a0 \u00a0 \u00a0 \u00a0 puts(\"-1\");\n\u00a0 \u00a0 \u00a0 \u00a0 return;\n\u00a0 \u00a0 }\n\u00a0\n\u00a0 \u00a0 ans.back().y = max(ans.back().y, n - 1);\n\u00a0\n\u00a0 \u00a0 cout << sz(ans) << endl;\n\u00a0 \u00a0 forn(i, sz(ans)) printf(\"%d %d\\n\", ans[i].x + 1, ans[i].y + 1);\n}\n\u00a0\nint main() {\n#ifdef SU1\n\u00a0 \u00a0 assert(freopen(\"input.txt\", \"rt\", stdin));\n\u00a0 \u00a0 //assert(freopen(\"output.txt\", \"wt\", stdout));\n#endif\n\u00a0 \u00a0 \n\u00a0 \u00a0 cout << setprecision(10) << fixed;\n\u00a0 \u00a0 cerr << setprecision(5) << fixed;\n\u00a0\n\u00a0 \u00a0 while (read()) {\n\u00a0 \u00a0 \u00a0 \u00a0 solve();\n\u00a0 \u00a0 \u00a0 \u00a0 //break;\n\u00a0 \u00a0 }\n\u00a0 \u00a0 \n\u00a0 \u00a0 return 0;\n}\n        ", "interactive": false, "noSolution": false, "noTutorial": false}