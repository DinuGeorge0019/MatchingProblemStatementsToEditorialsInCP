{"link": "https://codeforces.com//contest/1009/problem/B", "problemId": "197473", "shortId": "1009B", "contest_number": "1009", "name": "B. Minimum Ternary String", "statement": "You are given a ternary string (it is a string which consists only of characters '', '' and '').You can swap any two adjacent (consecutive) characters '' and '' (i.e. replace \"\" with \"\" or vice versa) or any two adjacent (consecutive) characters '' and '' (i.e. replace \"\" with \"\" or vice versa).For example, for string \"\" we can perform the following moves:   \"\"  \"\";  \"\"  \"\";  \"\"  \"\";  \"\"  \"\". Note than you cannot swap \"\"  \"\" and vice versa. You cannot perform any other operations with the given string excluding described above.You task is to obtain the minimum possible (lexicographically) string by using these swaps arbitrary number of times ().String  is lexicographically less than string  (if strings  and  have the same length) if there exists some position  (, where  is the length of the string ) such that for every  holds , and .", "input": "The first line of the input contains the string  consisting only of characters '', '' and '', its length is between  and  (inclusive).", "output": "Print a single string \u2014 the minimum possible (lexicographically) string you can obtain by using the swaps described above arbitrary number of times ().", "tutorial": "Let's notice that described swaps allows us to place any '' character to any position of the string  (relative order of '' and '' obviously cannot be changed). Let's remove all '' characters from the string  (and keep their count in some variable). Now more profitable move is to place all the '{1}' characters right before the first '' character of  (and if there is no '' character in , then place they after the end of the string).", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tstring s;\n\tcin >> s;\n\t\n\tstring ans;\n\t\n\tint cnt = 0;\n\tfor (auto c : s) {\n\t\tif (c == '1') ++cnt;\n\t\telse ans += c;\n\t}\n\t\n\tint n = ans.size();\n\tint pos = -1;\n\twhile (pos + 1 < n && ans[pos + 1] == '0') ++pos;\n\tans.insert(pos + 1, string(cnt, '1'));\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}