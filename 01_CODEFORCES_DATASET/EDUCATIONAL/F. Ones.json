{"link": "https://codeforces.com//contest/1487/problem/F", "problemId": "897752", "shortId": "1487F", "contest_number": "1487", "name": "F. Ones", "statement": "You are given a positive (greater than zero) integer .You have to represent  as the sum of integers (possibly negative) consisting only of ones (digits ''). For example,  and . Among all possible representations, you have to find the one that uses the minimum number of ones in total.", "input": "The single line contains one integer  ().", "output": "Print one integer  \u2014 the minimum number of ones, such that there exist a representation of  as the sum of integers (possibly negative) that uses  ones in total.", "tutorial": "Let's build the number from the lowest digit to the highest digit with the following dynamic programming:  \u2014 the minimum number of ones, if  least significant digits are already fixed, the carry to the next digit is  (can be negative), there are  positive numbers (of the form ) of length greater than or equal to  and  negative numbers of length greater than or equal to .First, consider the transitions when we reduce the values of  and/or . Such transitions correspond to the fact that in the optimal answer there were several numbers of length exactly , and they should not be considered further.If the value of  matches the -th least significant digit in , then we can use transition to -th state with the new value of  and the number of ones in the answer increased by .It remains to estimate what the maximum value of  () and  we need. The value of  doesn't exceed the total number of numbers that we use in the answer. Using at most  numbers we can decrease the length of  by at least . Thus, the maximum value of  and  is at most  (where |n| is the length of the number ). For the value of , the condition  should be met (similarly for a negative value). Thus, we can assume that the absolute value of  doesn't exceed . The total complexity of this solution is , yet with a high constant factor.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define sz(a) int((a).size())\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n\nconst int N = 250;\nconst int M = 28;\nconst int INF = 1e9;\n\nint dp[2][M * 2 + 1][N][N];\n\nint main() {\n  string s;\n  cin >> s;\n  reverse(s.begin(), s.end());\n  s += \"0\";\n  \n  forn(carry, M * 2 + 1) forn(cp, N) forn(cn, N) dp[0][carry][cp][cn] = INF;\n  dp[0][M][N - 1][N - 1] = 0;\n  \n  forn(i, sz(s)) {\n    forn(carry, M * 2 + 1) forn(cp, N) forn(cn, N) dp[1][carry][cp][cn] = INF;\n    forn(carry, M * 2 + 1) for (int cp = N - 1; cp >= 0; --cp) for (int cn = N - 1; cn >= 0; --cn) if (dp[0][carry][cp][cn] != INF) {\n      if (cp > 0) dp[0][carry][cp - 1][cn] = min(dp[0][carry][cp - 1][cn], dp[0][carry][cp][cn]);\n      if (cn > 0) dp[0][carry][cp][cn - 1] = min(dp[0][carry][cp][cn - 1], dp[0][carry][cp][cn]);\n      int rcarry = carry - M;\n      int val = rcarry + cp - cn;\n      int digit = val % 10;\n      if (digit < 0) digit += 10;\n      int ncarry = val / 10;\n      if (val < 0 && digit != 0) --ncarry;\n      if (digit == s[i] - '0') dp[1][ncarry + M][cp][cn] = min(dp[1][ncarry + M][cp][cn], dp[0][carry][cp][cn] + cp + cn);\n    }\n    swap(dp[0], dp[1]);\n  }\n  \n  int ans = INF;\n  forn(i, N) forn(j, N) ans = min(ans, dp[0][M][i][j]);\n  cout << ans << endl;\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}