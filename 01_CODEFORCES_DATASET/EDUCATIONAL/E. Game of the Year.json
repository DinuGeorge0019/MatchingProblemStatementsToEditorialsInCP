{"link": "https://codeforces.com//contest/1783/problem/E", "problemId": "1728814", "shortId": "1783E", "contest_number": "1783", "name": "E. Game of the Year", "statement": "Monocarp and Polycarp are playing a computer game. This game features  bosses for the playing to kill, numbered from  to .They will fight  boss the following way:   Monocarp makes  attempts to kill the boss;  Polycarp makes  attempts to kill the boss;  Monocarp makes  attempts to kill the boss;  Polycarp makes  attempts to kill the boss;  ... Monocarp kills the -th boss on  -th attempt. Polycarp kills the -th boss on  -th attempt. After one of them kills the -th boss, they move on to the -st boss. The attempt counters reset for both of them. Once one of them kills the -th boss, the game ends.Find all values of  from  to  such that Monocarp kills .", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of testcases. The first line of each testcase contains a single integer  ()\u00a0\u2014 the number of bosses. The second line contains  integers  ()\u00a0\u2014 the index of attempt Monocarp kills each boss on. The third line contains  integers  ()\u00a0\u2014 the index of attempt Polycarp kills each boss on. The sum of  over all testcases doesn't exceed .", "output": "For each testcase, print two lines. The first line should contain a single integer \u00a0\u2014 the number of values of  from  to  such that Monocarp kills . The second line should contain  distinct integers\u00a0\u2014 the values of  themselves.", "tutorial": "Consider some value of . When is it included in the answer? When Monocarp spends a lower or an equal amount of \"blocks\" of attempts than Polycarp for killing every boss.Formally,  for all  from  to .Let's reverse this condition.  is not in the answer if there exists such  from  to  that . So, there exists at least one value between  and . Let's call it . Now it's . I set the  and  signs arbitrarily, just so that it shows that such a value exists. You can't put both  or both , because that will accept  values or at least  values, respectively.Would be cool if we could multiply everything by  and it still worked. Is it completely impossible, though? Take a look at . What it says is that there exists a multiple of  between  and . A multiple of  is a number that's the last in each \"block\" of attempts (the block of value that are rounded up the same). Turns out, this is what we are looking for already. Right after the multiple of , the new block starts. Thus, we are wrong we our signs. It should be \u00a0\u2014  is in the block after , so it requires more blocks of attempts.So for  to not be included in the answer, there should exist at least one  such that there exists a multiple of  in the half-interval .That is pretty easy to implement. For each , calculate the number of half-intervals that cover . I think this is called delta-encoding. Iterate over all half-intervals and make two updates for each one: increment by  on position  and decrement by  on position . Then make a prefix sum over these updates. Now the value in the -th position tells you the number of half-intervals that cover .To check a particular value of , iterate over all multiples of  and check that none are covered by half-intervals. It's known that the total number of multiples over all numbers from  to  is .Overall complexity:  per testcase.", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\n\nint main() {\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--){\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\t\tvector<int> a(n), b(n);\n\t\tforn(i, n) scanf(\"%d\", &a[i]);\n\t\tforn(i, n) scanf(\"%d\", &b[i]);\n\t\tvector<int> dx(n + 1);\n\t\tforn(i, n) if (b[i] < a[i]){\n\t\t\t++dx[b[i]];\n\t\t\t--dx[a[i]];\n\t\t}\n\t\tforn(i, n) dx[i + 1] += dx[i];\n\t\tvector<int> ans;\n\t\tfor (int k = 1; k <= n; ++k){\n\t\t\tbool ok = true;\n\t\t\tfor (int nk = k; nk <= n; nk += k)\n\t\t\t\tok &= dx[nk] == 0;\n\t\t\tif (ok)\n\t\t\t\tans.push_back(k);\n\t\t}\n\t\tprintf(\"%d\\n\", int(ans.size()));\n\t\tfor (int k : ans) printf(\"%d \", k);\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}