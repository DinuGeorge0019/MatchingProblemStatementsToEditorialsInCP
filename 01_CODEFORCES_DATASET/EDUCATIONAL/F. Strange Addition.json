{"link": "https://codeforces.com//contest/1380/problem/F", "problemId": "670988", "shortId": "1380F", "contest_number": "1380", "name": "F. Strange Addition", "statement": "Let  and  be some non-negative integers. Let's define  of  and  as following:  write down the numbers one under another and align them by their least significant digit;  add them up digit by digit and concatenate the respective sums together. Assume that both numbers have an infinite number of leading zeros.For example, let's take a look at a  of numbers  and :  You are given a string , consisting of  digits from  to . You are also given  updates of form:   \u00a0\u2014 replace the digit at the -th position of  with a digit . Note that string  might have leading zeros at any point of time.After each update print the number of pairs  such that both  and  are non-negative integers and the result of a  of  and  is equal to .Note that the numbers of pairs can be quite large, so print them modulo .", "input": "The first line contains two integers  and  ()\u00a0\u2014 the length of the number  and the number of updates. The second line contains a string , consisting of exactly  digits from  to . Each of the next  lines contains two integers  and  (, )\u00a0\u2014 the descriptions of updates.", "output": "Print  integers\u00a0\u2014 the -th value should be equal to the number of pairs  such that both  and  are non-negative integers and the result of a  of  and  is equal to  after  updates are applied. Note that the numbers of pairs can be quite large, so print them modulo .", "tutorial": "Let's solve the task as if there are no updates. This can be done with a pretty straightforward dp. is the number of pairs  such that the result of the strange addition of  and  is the prefix of  of length . . From each state you can add a single digit to  and to  at the same time. You can either go to  and multiply the answer by the number of pairs of digits than sum up to . Or go to  and multiply the answer by the number of pairs of digits than sum up to . Note that no pair of digits can sum up to a three-digit value, so it makes no sense to go further.Let's optimize this dp with some data structure. Segment tree will work well. Let the node store the number of ways to split the segment  into blocks of size  or  so that:  both the leftmost character and the rightmost character are not taken into any block;  the leftmost character is taken into some block and the rightmost character is not taken into any block;  the leftmost character is not taken into any block and the rightmost character is taken into some block;  both the leftmost and the rightmost characters are taken into some blocks. This structure makes the merge pretty manageable. You should glue up the segments in such a way that all the middle characters are taken into some block: either in separate blocks in their own segments or into the same block of length .The answer will be in the root of the tree in a value such that both characters are taken.The update in the segment tree will still work in .Overall complexity: .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define forn(i, n) for(int i = 0; i < int(n); i++) \n\nconst int MOD = 998244353;\nconst int N = 500 * 1000 + 13;\n\nstring s;\n\nint add(int a, int b){\n\ta += b;\n\tif (a >= MOD)\n\t\ta -= MOD;\n\treturn a;\n}\n\nint mul(int a, int b){\n\treturn a * 1ll * b % MOD;\n}\n\nstruct node{\n\tint val[4], len;\n};\n\nnode merge(const node &a, const node &b, int l, int r){\n\tnode c;\n\tint na = a.len == 1 ? 0 : 1;\n\tint nb = b.len == 1 ? 0 : 2;\n\tc.len = a.len + b.len;\n\tc.val[0] = mul(a.val[na], b.val[nb]);\n\tc.val[1] = mul(a.val[na], b.val[3]);\n\tc.val[2] = mul(a.val[3], b.val[nb]);\n\tc.val[3] = mul(a.val[3], b.val[3]);\n\tif (l == 1){\n\t\tna = a.len == 1 ? 2 : 0;\n\t\tnb = b.len == 1 ? 1 : 0;\n\t\tc.val[na + nb] = add(c.val[na + nb], mul(mul(a.val[0], b.val[0]), 19 - (l * 10 + r)));\n\t\tc.val[1 + na] = add(c.val[1 + na], mul(mul(a.val[0], b.val[1]), 19 - (l * 10 + r)));\n\t\tc.val[2 + nb] = add(c.val[2 + nb], mul(mul(a.val[2], b.val[0]), 19 - (l * 10 + r)));\n\t\tc.val[3] = add(c.val[3], mul(mul(a.val[2], b.val[1]), 19 - (l * 10 + r)));\n\t}\n\treturn c;\n}\n\nnode t[4 * N];\n\nvoid build(int v, int l, int r){\n\tt[v].len = r - l;\n\tif (l == r - 1){\n\t\tt[v].val[0] = 1;\n\t\tt[v].val[3] = s[l] + 1;\n\t\treturn;\n\t}\n\tint m = (l + r) / 2;\n\tbuild(v * 2, l, m);\n\tbuild(v * 2 + 1, m, r);\n\tt[v] = merge(t[v * 2], t[v * 2 + 1], s[m - 1], s[m]);\n}\n\nvoid upd(int v, int l, int r, int x, int val){\n\tif (l == r - 1){\n\t\ts[l] = val;\n\t\tt[v].val[3] = s[l] + 1;\n\t\treturn;\n\t}\n\tint m = (l + r) / 2;\n\tif (x < m)\n\t\tupd(v * 2, l, m, x, val);\n\telse\n\t\tupd(v * 2 + 1, m, r, x, val);\n\tt[v] = merge(t[v * 2], t[v * 2 + 1], s[m - 1], s[m]);\n}\n\nint main(){\n\tint n, m;\n\n\tscanf(\"%d%d\", &n, &m);\n\tstatic char buf[N];\n\tscanf(\"%s\", buf);\n\ts = buf;\n\tforn(i, n) s[i] -= '0';\n\t\n\tmemset(t, 0, sizeof(t));\n\tbuild(1, 0, n);\n\t\n\tforn(i, m){\n\t\tint x, v;\n\t\tscanf(\"%d%d\", &x, &v);\n\t\t--x;\n\t\tupd(1, 0, n, x, v);\n\t\tprintf(\"%d\\n\", t[1].val[3]);\n\t}\n}", "interactive": false, "noSolution": false, "noTutorial": false}