{"link": "https://codeforces.com//contest/837/problem/D", "problemId": "116710", "shortId": "837D", "contest_number": "837", "name": "D. Round Subset", "statement": "Let's call the  of the number the number of zeros to which it ends.You have an array of  numbers. You need to choose a subset of exactly  numbers so that the  of the product of the selected numbers will be maximum possible.", "input": "The first line contains two integer numbers  and  (). The second line contains  space-separated integer numbers  ().", "output": "Print maximal roundness of product of the chosen subset of length .", "tutorial": "Let's use dynamic programming to solve this task.Obviously, the  of the number is determined by minimum of powers of  and  in the number. Let  be the maximal power of  in the number and  be the maximal power of .Let  be the maximum amount of twos we can collect by checking first  numbers, taking  of them with total power of five equal to . It is usually called \"the knapsack problem\".There are two types of transitions. You can either take current element or skip it:     The answer will be maximum of  for every . Also keeping this many states can cause ML, the first dimension should be stored in two layers and recalced on the fly.Overall complexity: .", "solution": "#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, \"/STACK:1048576\")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n#define rf(x) (x)=0;while(*p<48)p++;while(47<*p)(x)=((x)<<3)+((x)<<1)+(*p++&15);\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\ntypedef tuple <int, int, int> t3;\n\nint IT_MAX = 1 << 18;\nconst ll MOD = 1000000009;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 1234567890123456789ll;\nconst db PI = acos(-1);\nconst db EPS = 1e-8;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<(n);i++)\n\nint dp[205][8010];\nint tdp[205][8010];\nint in[205][2];\nint main() {\n\tint N, K, i, j, k;\n\tscanf(\"%d %d\", &N, &K);\n\tfor (i = 1; i <= N; i++) {\n\t\tll t;\n\t\tscanf(\"%lld\", &t);\n\t\twhile (t % 2 == 0) {\n\t\t\tin[i][0]++;\n\t\t\tt /= 2;\n\t\t}\n\t\twhile (t % 5 == 0) {\n\t\t\tin[i][1]++;\n\t\t\tt /= 5;\n\t\t}\n\t}\n\n\tfor (i = 0; i <= K; i++) for (j = 0; j <= 8000; j++) dp[i][j] = -INF;\n\tdp[0][0] = 0;\n\tfor (i = 1; i <= N; i++) {\n\t\tfor (j = 0; j <= K; j++) for (k = 0; k <= 8000; k++) tdp[j][k] = dp[j][k];\n\t\tfor (j = 0; j < K; j++) {\n\t\t\tfor (k = 0; k <= 8000; k++) {\n\t\t\t\tint j2 = j + 1, k2 = k + in[i][1];\n\t\t\t\tif (k2 <= 8000) tdp[j2][k2] = max(tdp[j2][k2], dp[j][k] + in[i][0]);\n\t\t\t}\n\t\t}\n\t\tfor (j = 0; j <= K; j++) for (k = 0; k <= 8000; k++) dp[j][k] = tdp[j][k];\n\t}\n\n\tint ans = 0;\n\tfor (i = 0; i <= K; i++) for (j = 0; j <= 8000; j++) ans = max(ans, min(j, dp[i][j]));\n\treturn !printf(\"%d\\n\", ans);\n}", "interactive": false, "noSolution": false, "noTutorial": false}