{"link": "https://codeforces.com//contest/1814/problem/D", "problemId": "1867159", "shortId": "1814D", "contest_number": "1814", "name": "D. Balancing Weapons", "statement": "You've got a job in a game studio that developed an online shooter, and your first big task is to help to balance weapons. The game has  weapons: the -th gun has an integer fire rate  and an integer damage per bullet . The -th gun's total firepower is equal to .You have to modify the values  of some guns in such a way that the new values  will still be integers, and the firepower of all guns will become balanced. Given an integer , the guns are said to be  if .Since gamers that play your game don't like big changes, you need to change the values  for the minimum possible number of guns. What is the minimum number of guns for which you have to change these values to make the guns balanced?Note that the new values  must be integers greater than .", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of test cases. The first line of each test case contains two integers  and  (; )\u00a0\u2014 the number of guns to balance, and the maximum allowed gap between the most and the least powerful weapons. The second line contains  integers  (), where  is the fire rate of the -th gun. The third line contains  integers  (), where  is the damage per bullet of the -th gun. It's guaranteed that the sum of  over all test cases doesn't exceed .", "output": "For each test case, print the minimum number of guns which damage  you have to change in order to make the guns balanced. Note that the new values  must be integers greater than .", "tutorial": "Note that the answer $$$n$$$ is always possible: for example, we can set $$$d_i = \\frac{\\prod{f_j}}{f_i}$$$, then $$$p_1 = \\dots = p_n = \\prod{f_j}$$$ and $$$\\max{p_i} - \\min{p_i} = 0$$$.If the answer is less than $$$n$$$ then there is at least one gun $$$id$$$ we won't change. It means that all other guns' firepower should be \"around\" $$$p_{id}$$$, i.\u00a0e. $$$|p_i - p_{id}| \\le k$$$. So we can look at segment $$$[p_{id} - k, p_{id} + k]$$$ and, for each gun $$$i$$$, find what values $$$d'_i$$$ we should set to get into this segment. After that we can rephrase our task into the next one: we should choose segment $$$[l, l + k] \\subset [p_{id} - k, p_{id} + k]$$$ such that each gun occurs in $$$[l, l + k]$$$ at least once and the number of corresponding $$$d'_i$$$ that are equal to $$$d_i$$$ is maximum possible.It can be solved with two pointers technique. Note that there are at most three interesting values $$$d'_i$$$ we should consider: $$$v_1 = \\left\\lfloor \\frac{p_{id}}{f_i} \\right\\rfloor$$$, $$$v_2 = v_1 + 1$$$ and $$$v_3 = d_i$$$. For each  value $$$v_j$$$ such that $$$v_j \\cdot f_i \\in [p_{id} - k, p_{id} + k]$$$ we can add an event $$$(i, c_j)$$$ in position $$$v_j f_i$$$, where $$$c_j$$$ is $$$1$$$ if $$$v_j = d_i$$$ or $$$0$$$ otherwise.Now, with two pointers technique, we can iterate over all subsegments of length $$$k + 1$$$ of segment $$$[p_{id} - k, p_{id} + k]$$$. To get the desired answer we should maintain the number of unique $$$i$$$ from events that are present in the subsegment and the sum $$$s$$$ of $$$c_j$$$ from that events. Since there is only one $$$c_j = 1$$$ for each gun $$$i$$$ then the sum $$$s$$$ of $$$c_j$$$ we have is equal exactly to the number of guns we  change. Then we take the maximum $$$mx$$$ over sums $$$s$$$ of all subsegments where all guns occur, and the answer for a fixed $$$p_{id}$$$ is $$$n - mx$$$.Let's iterate over all \"fixed\" $$$id$$$ and take the minimum from all $$$n - mx$$$: that will be the answer for the initial task.Checking answer for a fixed $$$id$$$ involves creating $$$3 n$$$ events and two pointers over segment $$$[p_{id} - k, p_{id} + k]$$$, so it takes $$$O(n + k)$$$ time and $$$O(n + k)$$$ space. So, the total complexity is $$$O(n^2 + n k)$$$ time and $$$O(n + k)$$$ space.", "solution": "fun main() {\n    repeat(readln().toInt()) {\n        val (n, k) = readln().split(' ').map { it.toInt() }\n        val f = readln().split(' ').map { it.toLong() }\n        val d = readln().split(' ').map { it.toLong() }\n\n        fun checkAround(pos : Long) : Int {\n            val qs = Array(2 * k + 1) { MutableList(0) { 0 } }\n\n            fun inside(x : Long, pos: Long) = (pos - k <= x) && (x <= pos + k)\n            for (i in f.indices) {\n                var newD = maxOf(1L, pos / f[i])\n                if (newD != d[i] && newD + 1 != d[i] && inside(d[i] * f[i], pos)) {\n                    val id = (i + 1)\n                    qs[(d[i] * f[i] - pos + k).toInt()].add(id)\n                }\n                repeat(2) {\n                    if (inside(newD * f[i], pos)) {\n                        val id = if (newD == d[i]) (i + 1) else -(i + 1)\n                        qs[(newD * f[i] - pos + k).toInt()].add(id)\n                    }\n                    newD++\n                }\n                \n            }\n\n            val cntPerId = IntArray(n) { 0 }\n            var cntDistinct = 0\n            var cntGood = 0\n\n            fun addToSeg(cid : Int) {\n                val id = -1 + if (cid > 0) cid else -cid\n                val c = if (cid > 0) 1 else 0\n\n                if (cntPerId[id] == 0)\n                    cntDistinct++\n                cntPerId[id]++\n\n                cntGood += c\n            }\n            fun eraseFromSeg(cid : Int) {\n                val id = -1 + if (cid > 0) cid else -cid\n                val c = if (cid > 0) 1 else 0\n\n                cntPerId[id]--\n                if (cntPerId[id] == 0)\n                    cntDistinct--\n\n                cntGood -= c\n            }\n            var ans = 0\n            for (p in 0 until k)\n                qs[p].forEach { addToSeg(it) }\n            for (p in 0..k) {\n                qs[p + k].forEach { addToSeg(it) }\n                if (cntDistinct == n)\n                    ans = maxOf(ans, cntGood)\n                qs[p].forEach { eraseFromSeg(it) }\n            }\n            return n - ans\n        }\n\n        var ans = n\n        for (i in f.indices) {\n            ans = minOf(ans, checkAround(d[i] * f[i]))\n        }\n        println(ans)\n    }\n}", "interactive": false, "noSolution": false, "noTutorial": false}