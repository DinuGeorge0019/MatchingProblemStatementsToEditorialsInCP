{"link": "https://codeforces.com//contest/1354/problem/C2", "problemId": "623446", "shortId": "1354C2", "contest_number": "1354", "name": "C2. Not So Simple Polygon Embedding", "statement": "You are given a regular polygon with  vertices (it's convex and has equal sides and equal angles) and all its sides have length . Let's name it as -gon.Your task is to find the square of the minimum size such that you can embed -gon in the square. Embedding -gon in the square means that you need to place -gon in the square in such way that each point which lies inside or on a border of -gon should also lie inside or on a border of the square.You can rotate -gon and/or the square.", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of test cases. Next  lines contain descriptions of test cases\u00a0\u2014 one per line. Each line contains single  integer  (). Don't forget you need to embed -gon, not an -gon.", "output": "Print  real numbers\u00a0\u2014 one per test case. For each test case, print the minimum length of a side of the square -gon can be embedded in. Your answer will be considered correct if its absolute or relative error doesn't exceed .", "tutorial": "At first, lets place -gon in such way that the lowest side of -gon is horizontal. Now we can, without loss of generality, think that the square has horizontal and vertical sides and we just rotate -gon around its center. If we rotate the -gon at angle  then it will move on itself. Moreover, after rotating at angle  we'll get left and right sides vertical and the following rotation is meaningless since it's the same as if we just swap  and  coordinates. So we don't we to rotate more than .  Also, we can see that while rotating the difference between max  and min  decreasing while the distance between max  and min  increasing. The answer is, obviously, the maximum among these differences. So, for example, we can just ternary search the optimal answer.Or we can note that the behavior of differences is symmetrical (just swap  and  coordinates) so the answer is in the middle angle, i.e. we just need to rotate -gon at angle .Finally, observing several right triangles we can come up with quite an easy answer:", "solution": "import kotlin.math.*\n\nfun main() {\n    val PI = acos(-1.0)\n    val T = readLine()!!.toInt()\n    for (tc in 1..T) {\n        val n = readLine()!!.toInt()\n        var ans : Double\n        if (n % 2 == 0) {\n            ans = 1.0 / tan(PI / (2 * n))\n        } else {\n            ans = cos(PI / (4 * n)) / sin(PI / (2 * n))\n        }\n        println(\"%.9f\".format(ans))\n    }\n}", "interactive": false, "noSolution": false, "noTutorial": false}