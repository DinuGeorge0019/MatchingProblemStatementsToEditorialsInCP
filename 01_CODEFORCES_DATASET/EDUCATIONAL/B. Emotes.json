{"link": "https://codeforces.com//contest/1117/problem/B", "problemId": "300042", "shortId": "1117B", "contest_number": "1117", "name": "B. Emotes", "statement": "There are  emotes in very popular digital collectible card game (the game is pretty famous so we won't say its name). The -th emote increases the opponent's happiness by  units (we all know that emotes in this game are used to make opponents happy).You have time to use some emotes only  times. You are allowed to use any emotion once, more than once, or not use it at all. The only restriction is that you  (otherwise the opponent will think that you're trolling him)..You have to make your opponent as happy as possible. Find the maximum possible opponent's happiness.", "input": "The first line of the input contains three integers  and  (, ) \u2014 the number of emotes, the number of times you can use emotes and the maximum number of times you may use the same emote in a row. The second line of the input contains  integers  (), where  is value of the happiness of the -th emote.", "output": "Print one integer \u2014 the maximum opponent's happiness if you use emotes in a way satisfying the problem statement.", "tutorial": "It is obvious that we always can use only two emotes with maximum . Let their values be  and  ().We have to solve the problem by some formula. The best way to use emotes \u2014 use the emote with the value   times, then use the emotion with the value , then again use the emote with value   times, and so on.So the \"\" has length , and we can use the emote with the value  the remaining number of times. So the answer is , where  is the first maximum of ,  is the second maximum of ,  is  divided by  rounded down, and  is  modulo .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, m, k;\n\tcin >> n >> m >> k;\n\t\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t}\n\tsort(a.rbegin(), a.rend());\n\t\n\tcout << m / (k + 1) * 1ll * (a[0] * 1ll * k + a[1]) + m % (k + 1) * 1ll * a[0] << endl;\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}