{"link": "https://codeforces.com//contest/808/problem/G", "problemId": "106403", "shortId": "808G", "contest_number": "808", "name": "G. Anthem of Berland", "statement": "Berland has a long and glorious history. To increase awareness about it among younger citizens, King of Berland decided to compose an anthem.Though there are lots and lots of victories in history of Berland, there is the one that stand out the most. King wants to mention it in the anthem as many times as possible.He has already composed major part of the anthem and now just needs to fill in some letters. King asked you to help him with this work.The anthem is the string  of no more than  small Latin letters and question marks. The most glorious victory is the string  of no more than  small Latin letters. You should replace all the question marks with small Latin letters in such a way that the number of occurrences of string  in string  is maximal.Note that the occurrences of string  in  can overlap. Check the third example for clarification.", "input": "The first line contains string of small Latin letters and question marks  (). The second line contains string of small Latin letters  (). ", "output": "Output the maximum number of occurrences of string  you can achieve by replacing all the question marks in string  with small Latin letters.", "tutorial": "Let's denote the string obtained by concatenation  (where  is some dividing character that isn't a part of the alphabet) as . Recall that KMP algorithm builds the prefix function for this string.We can calculate  on this string, where  is the position in this string and  is the value of prefix function in this position. The value of  is the maximum number of occurences of  found so far (or  if this situation is impossible). If th character is a Latin letter, then we just recalculate prefix function for this position (the fact that in KMP the value of prefix function won't exceed  allows us to do so). If th character is a question mark, then we check all  possible characters and recalculate prefix function for all of these characters (and update the corresponding  values). The size of  and  is pretty big, so we need to recalculate these values in  time; this can be done by precalculating the values of  ( is the value of prefix function,  is a new character and  is the value of prefix function after adding this character).", "solution": "import java.io.*;\nimport java.util.*;\n\npublic class ER21qG {\n\n\tpublic static void main(String[] args) {\n\t\tInputReader in = new InputReader(System.in);\n\t\tPrintWriter w = new PrintWriter(System.out);\n\n\t\tchar s[] = in.readString().toCharArray();\n\t\tint n = s.length;\n\n\t\tchar t[] = in.readString().toCharArray();\n\t\tint m = t.length;\n\t\tint kmp[] = getLPSArray(t);\n\n\t\tint v[][] = new int[m][26];\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tfor (int j = 0; j < 26; j++) {\n\t\t\t\tif (t[i] - 'a' == j) {\n\t\t\t\t\tv[i][j] = i + 1;\n\t\t\t\t} else if (i > 0) {\n\t\t\t\t\tv[i][j] = v[kmp[i - 1]][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t/*\n\t\tSystem.out.println(v[2][0]);\n\t\tSystem.out.println(v[4][0]);\n\t\tSystem.out.println(kmp[4]);\n\t\t*/\n\n\t\tint dp[][] = new int[n + 1][m];\n\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tif (s[i] == '?') {\n\t\t\t\t\tfor (int x = 0; x < 26; x++) {\n\t\t\t\t\t\tint newj = v[j][x];\n\t\t\t\t\t\t//if (i == 4 && j == 4 && x == 0)\n\t\t\t\t\t\t\t//System.out.println(\"newj \" + newj);\n\t\t\t\t\t\tif (newj == m) {\n\t\t\t\t\t\t\tnewj = kmp[m - 1];\n\t\t\t\t\t\t\tdp[i][j] = Math.max(dp[i][j], 1 + dp[i + 1][newj]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdp[i][j] = Math.max(dp[i][j], dp[i + 1][newj]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tint newj = v[j][s[i] - 'a'];\n\t\t\t\t\tif (newj == m) {\n\t\t\t\t\t\tnewj = kmp[m - 1];\n\t\t\t\t\t\tdp[i][j] = Math.max(dp[i][j], 1 + dp[i + 1][newj]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdp[i][j] = Math.max(dp[i][j], dp[i + 1][newj]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//System.out.println(i + \" \" + j + \" \" + dp[i][j]);\n\t\t\t}\n\t\t}\n\n\t\tw.println(dp[0][0]);\n\t\tw.close();\n\t}\n\n\tpublic static int[] getLPSArray(char s[]) {\n\t\tint n = s.length;\n\t\tint lps[] = new int[n];\n\t\tlps[0] = 0;\n\t\tint len = 0;\n\t\tfor (int i = 1; i < n;) {\n\t\t\tif (s[i] == s[len]) {\n\t\t\t\tlps[i++] = ++len;\n\t\t\t} else {\n\t\t\t\tif (len == 0) {\n\t\t\t\t\tlps[i++] = 0;\n\t\t\t\t} else {\n\t\t\t\t\tlen = lps[len - 1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn lps;\n\t}\n\t\n\tstatic class InputReader {\n\n\t\tprivate final InputStream stream;\n\t\tprivate final byte[] buf = new byte[8192];\n\t\tprivate int curChar, snumChars;\n\n\t\tpublic InputReader(InputStream st) {\n\t\t\tthis.stream = st;\n\t\t}\n\n\t\tpublic int read() {\n\t\t\tif (snumChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= snumChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tsnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (snumChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint a[] = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\ta[i] = nextInt();\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic String readString() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic String nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndOfLine(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic boolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tprivate boolean isEndOfLine(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t}\n\n}", "interactive": false, "noSolution": false, "noTutorial": false}