{"link": "https://codeforces.com//contest/1430/problem/F", "problemId": "755158", "shortId": "1430F", "contest_number": "1430", "name": "F. Realistic Gameplay", "statement": "Recently you've discovered a new shooter. They say it has realistic game mechanics.Your character has a gun with magazine size equal to  and should exterminate  waves of monsters. The -th wave consists of  monsters and happens from the -th moment of time up to the -th moments of time. All  monsters spawn at moment  and you have to exterminate all of them before the moment  ends (you can kill monsters right at moment ). For every two consecutive waves, the second wave starts not earlier than the first wave ends (though the second wave can start at the same moment when the first wave ends) \u2014 formally, the condition  holds. Take a look at the notes for the examples to understand the process better.You are confident in yours and your character's skills so you can assume that aiming and shooting are instant and you need exactly one bullet to kill one monster. But reloading takes exactly  unit of time.One of the realistic mechanics is a mechanic of reloading: when you reload you throw away the old magazine with all remaining bullets in it. That's why constant reloads may cost you excessive amounts of spent bullets.You've taken a liking to this mechanic so now you are wondering: what is the minimum possible number of bullets you need to spend (both used and thrown) to exterminate all waves.Note that you don't throw the remaining bullets away after eradicating all monsters, and you start with a full magazine.", "input": "The first line contains two integers  and  (; )\u00a0\u2014 the number of waves and magazine size. The next  lines contain descriptions of waves. The -th line contains three integers ,  and  (; )\u00a0\u2014 the period of time when the -th wave happens and the number of monsters in it. It's guaranteed that waves don't overlap (but may touch) and are given in the order they occur, i. e. .", "output": "If there is no way to clear all waves, print . Otherwise, print the minimum possible number of bullets you need to spend (both used and thrown) to clear all waves.", "tutorial": "Note some observations: if we meet a new wave and start shooting it's optimal to shoot monsters in the wave using full magazines while we can and there are no reasons to take breaks between shooting monsters from one wave. That's why we can track only moments when waves start and the number of remaining bullets in magazine we have at these moments.Moreover, since the next wave starts not earlier than the previous ends, we can think that when we start dealing with one wave we've already dealt with the previous one. Also, instead of keeping track of the remaining bullets, let's just look only at such indices of waves when we reloaded and threw remaining bullets before reaching them.So, we can write the next dp:  is the minimum number of bullets we spend dealing with the first  waves and now we standing at the moment  with full magazine. Obviously, .Now, with fixed  we can iterate over the index  of a wave before which we'll reload throwing away remaining bullets. And for waves  we need to check that we are able to exterminate all these waves without throwing away any bullets. We can check it with several formulas.If it's possible for segment  then the possibility for the segment  is just checking that we can exterminate the -th wave having  bullets in the start in no more than  reloads plus checking that we have at least one unit before  for a reload.As a result, the time complexity of the solution is .", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) int((a).size())\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef long double ld;\ntypedef pair<int, int> pt;\n\nconst int INF = int(1e9);\nconst li INF64 = li(1e18);\nconst ld EPS = 1e-9;\n\nint n, k;\nvector<int> l, r, a;\n\ninline bool read() {\n\tif(!(cin >> n >> k))\n\t\treturn false;\n\tl.resize(n);\n\tr.resize(n);\n\ta.resize(n);\n\t\n\tfore(i, 0, n)\n\t\tcin >> l[i] >> r[i] >> a[i];\n\t\n\treturn true;\n}\n\ninline void solve() {\n\tvector<li> d(n + 1, INF64);\n\td[0] = 0;\n\t\n\tli ans = INF64;\n\tfore(i, 0, n) {\n\t\tli rem = k, total = d[i];\n\t\tfor (int j = i; j < n; j++) {\n\t\t\tli cntReloads = (max(0LL, a[j] - rem) + k - 1) / k;\n\t\t\tif (cntReloads > r[j] - l[j])\n\t\t\t\tbreak;\n\t\t\t\n\t\t\tli newRem = (rem + cntReloads * k) - a[j];\n\t\t\ttotal += a[j];\n\t\t\tif (j + 1 < n) {\n\t\t\t\tif (l[j] + cntReloads < l[j + 1])\n\t\t\t\t\td[j + 1] = min(d[j + 1], total + newRem);\n\t\t\t} else\n\t\t\t\tans = min(ans, total);\n\t\t\trem = newRem;\n\t\t}\n\t}\n\tif (ans > INF64 / 2)\n\t\tans = -1;\n\tcout << ans << endl;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint tt = clock();\n#endif\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0), cout.tie(0);\n\tcout << fixed << setprecision(15);\n\t\n\tif(read()) {\n\t\tsolve();\n\t\t\n#ifdef _DEBUG\n\t\tcerr << \"TIME = \" << clock() - tt << endl;\n\t\ttt = clock();\n#endif\n\t}\n\treturn 0;\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}