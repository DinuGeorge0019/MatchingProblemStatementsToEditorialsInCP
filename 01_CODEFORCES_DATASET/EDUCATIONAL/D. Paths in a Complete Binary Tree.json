{"link": "https://codeforces.com//contest/792/problem/D", "problemId": "100427", "shortId": "792D", "contest_number": "792", "name": "D. Paths in a Complete Binary Tree", "statement": " is a complete binary tree consisting of  vertices. It means that exactly one vertex is a root, and each vertex is either a leaf (and doesn't have children) or an inner node (and has exactly two children). All leaves of a complete binary tree have the same depth (distance from the root). So  is a number such that  is a power of .In the picture you can see a complete binary tree with .  Vertices are numbered from  to  in a special recursive way: we recursively assign numbers to all vertices from the left subtree (if current vertex is not a leaf), then assign a number to the current vertex, and then recursively assign numbers to all vertices from the right subtree (if it exists). In the picture vertices are numbered exactly using this algorithm. It is clear that for each size of a complete binary tree exists exactly one way to give numbers to all vertices. This way of numbering is called .You have to write a program that for given  answers  queries to the tree.Each query consists of an integer number  () and a string , where  is the number of vertex, and  represents the path starting from this vertex. String  doesn't contain any characters other than '', '' and '', which mean traverse to the left child, to the right child and to the parent, respectively. Characters from  have to be processed from left to right, considering that  is the vertex where the path starts. If it's impossible to process a character (for example, to go to the left child of a leaf), then you have to skip it. The answer is the number of vertex where the path represented by  ends.For example, if  and \u00ab\u00bb, then the answer is .", "input": "The first line contains two integer numbers  and  (, ).  is such that  is a power of . The next  lines represent queries; each query consists of two consecutive lines. The first of these two lines contains  (), the second contains non-empty string .  doesn't contain any characters other than '', '' and ''. It is guaranteed that the sum of lengths of  (for each  such that ) doesn't exceed .", "output": "Print  numbers, -th number must be the answer to the -th query.", "tutorial": "In this editorial  represents the number of vertex we are currently in.Let  be the maximum integer number such that  is divisible by  (or the number of zeroes at the end of the binary representation of ). It is easy to prove that if , then  is a leaf; if , then both children of  are leaves, and so on. Even more, the difference between  and any of his children is exactly . So to traverse to the left child, we have to subtract  from  (if  is not a leaf), and to traverse to the right child, we add  to . How can we process traversions up? Let  be the number of the parent node.  has exactly  zeroes at the end of its binary representation, so to traverse from  to , we need to either add or subtract  from . And to traverse from  to  we also have to either subtract or add  to . One of these operations will lead us to the number divisible by  and not divisible by , and we need to choose this operation.Time complexity is .", "solution": "#include <iostream>\n#include <fstream>\n#include <set>\n#include <map>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <queue>\n\n#define mp make_pair\n#define pb push_back\n\n\ntypedef long long ll;\ntypedef long double ld;\n\nusing namespace std;\n\n#ifndef LOCAL\n#define cerr _cer\nstruct _cert\n{\n    template <typename T> _cert& operator << (T) { return *this; }\n};\n_cert _cer;\n#endif\n\ntemplate <typename T> void dprint(T begin, T end) {\n    for (auto i = begin; i != end; i++) {\n\t\tcerr << (*i) << \" \";\n    }\n    cerr << \"\\n\";\n}\n\nll n;\nint q;\nchar s[120000];\n\nint main() {\n\tscanf(\"%lld%d\", &n, &q);\n\tfor (int i = 0; i < q; ++i) {\n\t\tll u;\n\t\tscanf(\"%lld %s\", &u, s);\n\t\tint l = strlen(s);\n\t\tll now = 1;\n\t\twhile (u % (2 * now) == 0)\n\t\t\tnow *= 2;\n\t\tfor (int j = 0; j < l; ++j) {\n\t\t\tif (s[j] == 'U') {\n\t\t\t\tif (2 * now > n)\n\t\t\t\t\tcontinue;\n\t\t\t\tif ((u + now) % (4 * now) == 0)\n\t\t\t\t\tu -= now;\n\t\t\t\telse\n\t\t\t\t\tu += now;\n\t\t\t\tnow *= 2;\n\t\t\t}\n\t\t\telse if (s[j] == 'L') {\n\t\t\t\tif (u % 2 == 1)\n\t\t\t\t\tcontinue;\n\t\t\t\tnow /= 2;\n\t\t\t\tu -= now;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (u % 2 == 1)\n\t\t\t\t\tcontinue;\n\t\t\t\tnow /= 2;\n\t\t\t\tu += now;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\", u);\n\t}\n\treturn 0;\n}\n\n\n", "interactive": false, "noSolution": false, "noTutorial": false}