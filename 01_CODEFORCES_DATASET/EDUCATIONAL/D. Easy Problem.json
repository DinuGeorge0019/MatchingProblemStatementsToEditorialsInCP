{"link": "https://codeforces.com//contest/1096/problem/D", "problemId": "275411", "shortId": "1096D", "contest_number": "1096", "name": "D. Easy Problem", "statement": "Vasya is preparing a contest, and now he has written a statement for an easy problem. The statement is a string of length  consisting of lowercase Latin latters. Vasya thinks that the statement can be considered hard if it contains a subsequence ; otherwise the statement is easy. For example, , ,  can be considered hard statements, while ,  and  are easy statements. Vasya doesn't want the statement to be hard. He may remove some characters from the statement in order to make it easy. But, of course, some parts of the statement can be crucial to understanding. Initially the  of the statement is , and removing -th character increases the  by  (the index of each character is considered as it was in the original statement, so, for example, if you delete character  from , and then character , the index of  is still  even though you delete it from the string ).Vasya wants to calculate the minimum  of the statement, if he removes some characters (possibly zero) so that the statement is easy. Help him to do it!Recall that subsequence is a sequence that can be derived from another sequence by deleting some elements without changing the order of the remaining elements.", "input": "The first line contains one integer  () \u2014 the length of the statement. The second line contains one string  of length , consisting of lowercase Latin letters \u2014 the statement written by Vasya. The third line contains  integers  ().", "output": "Print minimum possible  of the statement after Vasya deletes some (possibly zero) characters so the resulting statement is easy.", "tutorial": "Denote string  as .We will solve this problem with dynamic programming. Denote  \u2014 the minimum possible ambiguity if we considered first  letters of statement and got prefix  having length  as a subsequence of the string.If -th letter of the statement is not equal to , then  \u2014 we don't have to change it.Otherwise we either change the letter, or let it stay as it is (and the length of the prefix we found so far increases): .", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int N = 100 * 1000 + 13;\nconst long long INF64 = 1e18;\n\nint n;\nstring s;\nint a[N];\nlong long dp[N][5];\n\nconst string h = \"hard\";\n\nint main() {\n\tscanf(\"%d\", &n);\n\tstatic char buf[N];\n\tscanf(\"%s\", buf);\n\ts = buf;\n\tforn(i, n)\n\t\tscanf(\"%d\", &a[i]);\n\t\n\tforn(i, N) forn(j, 5) dp[i][j] = INF64;\n\tdp[0][0] = 0;\n\tforn(i, n) forn(j, 4){\n\t\tdp[i + 1][j + (s[i] == h[j])] = min(dp[i + 1][j + (s[i] == h[j])], dp[i][j]);\n\t\tdp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + a[i]);\n\t}\n\t\n\tprintf(\"%lld\\n\", *min_element(dp[n], dp[n] + 4));\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}