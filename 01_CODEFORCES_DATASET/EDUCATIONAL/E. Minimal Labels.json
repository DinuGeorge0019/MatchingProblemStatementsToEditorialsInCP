{"link": "https://codeforces.com//contest/825/problem/E", "problemId": "114548", "shortId": "825E", "contest_number": "825", "name": "E. Minimal Labels", "statement": "You are given a directed acyclic graph with  vertices and  edges. There are no self-loops or multiple edges between any pair of vertices. Graph can be disconnected.You should assign labels to all vertices in such a way that:  Labels form a valid permutation of length  \u2014 an integer sequence such that each integer from  to  appears exactly once in it.  If there exists an edge from vertex  to vertex  then  should be smaller than .  Permutation should be lexicographically smallest among all suitable. Find such sequence of labels to satisfy all the conditions.", "input": "The first line contains two integer numbers ,  (). Next  lines contain two integer numbers  and  () \u2014 edges of the graph. Edges are directed, graph doesn't contain loops or multiple edges.", "output": "Print  numbers \u2014 lexicographically smallest correct permutation of labels of vertices.", "tutorial": "This problem is usually called \"Topological labelling\". Though it's pretty common problem, we decided that it might be educational to some of participants.Let's set labels in descending order starting from label  to label . Look at first step. Vertex with label  should have out-degree equal to zero. Among all such vertices we should put the label on the one that has the largest index. Ok, but why will this produce the lexicographically smallest labelling?We can prove this by contradiction. Let this vertex be labeled  (). Change it to  and renumerate vertices with label  to labels . Labelling will come lexicographically smaller than it was, this leads to contradiction.So the algorithm comes as following. On step  () we find vertices with out-degree equal to zero, select the one with the largest index, set its label to  and remove this vertex (and all edges connected to it) from the graph.Current minimal out-degree can be maintained with set, for example.Overall complexity: .", "solution": "#ifdef __GNUC__\n#pragma GCC target(\"sse4,avx\")\n#endif\n#include <immintrin.h>\n#include <algorithm>\n#include <string>\n#include <iostream>\n#include <vector>\n#include <cstdint>\n#include <numeric>\n#include <queue>\n\nvoid run(std::istream &in, std::ostream &out) {\n    int n, m;\n    in >> n >> m;\n    std::vector<std::vector<int>> graph(n);\n    std::vector<int> deg(n);\n    for (int i = 0; i < m; i++) {\n        int from, to;\n        in >> from >> to;\n        from--;to--;\n        deg[from]++;\n        graph[to].push_back(from);\n    }\n    std::vector<int> answer(n);\n    std::priority_queue<int, std::vector<int>, std::less<int>> queue;\n    for (int i = 0; i < n; i++) {\n        if (deg[i] == 0) {\n            queue.push(i);\n        }\n    }\n    for (int i = n; i >= 1; i--) {\n        int v = queue.top();\n        queue.pop();\n        for (int nv : graph[v]) {\n            deg[nv]--;\n            if (deg[nv] == 0) {\n                queue.push(nv);\n            }\n        }\n        answer[v] = i;\n    }\n    for (int i = 0; i < n; i++) {\n        out << answer[i] << \" \";\n    }\n    out << std::endl;\n}\n\nint main() {\n  std::cin.sync_with_stdio(false);\n  std::cin.tie(nullptr);\n  run(std::cin, std::cout);\n  return 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}