{"link": "https://codeforces.com//contest/1167/problem/F", "problemId": "344635", "shortId": "1167F", "contest_number": "1167", "name": "F. Scalar Queries", "statement": "You are given an array . All  are pairwise distinct.Let's define function  as follows:   let's define array , where ;  sort array  in increasing order;  result of the function  is . Calculate , i.e. total sum of  for all subsegments of  modulo .", "input": "The first line contains one integer  () \u2014 the length of array . The second line contains  integers  (,  for ) \u2014 array .", "output": "Print one integer \u2014 the total sum of  for all subsegments of  modulo ", "tutorial": "Let's define some functions at first: indicator function  if  is true and  otherwise.  is a number of  that  and . Good observation: .Another observation: .Now, it's time to transform what we'd like to calculate: Since transformation of the second sum was standard, we'll look at the first sum: So, we can iterate over  and we'd like to calculate this two sums fast enough. So, more transformations: So, while iterating over  we need to make queries of two types: set value  in position  and calculate . It can be done by BIT with coordinate compression. can be calculated in the same way iterating over  in reverse order.Result complexity is .", "solution": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) int((a).size())\n\ntypedef long long li;\n\nconst int MOD = int(1e9) + 7;\n\nint add(int a, int b) {\n\ta += b;\n\twhile(a >= MOD)\n\t\ta -= MOD;\n\twhile(a < 0)\n\t\ta += MOD;\n\treturn a;\n}\nint mul(int a, int b) {\n\treturn int(a * 1ll * b % MOD);\n}\n\nint n;\nvector<int> a;\n\ninline bool read() {\n\tif(!(cin >> n))\n\t\treturn false;\n\ta.resize(n);\n\tfore(i, 0, n)\n\t\tcin >> a[i];\n\treturn true;\n}\n\nvector<li> f;\nvoid inc(int pos, int val) {\n\tfor(; pos < sz(f); pos |= pos + 1)\n\t\tf[pos] += val;\n}\nli sum(int pos) {\n\tli ans = 0;\n\tfor(; pos >= 0; pos = (pos & (pos + 1)) - 1)\n\t\tans += f[pos];\n\treturn ans;\n}\n\nvector<int> S[2];\n\ninline void solve() {\n\tfore(k, 0, 2) {\n\t\tS[k].assign(n, 0);\n\t\tf.assign(n, 0);\n\t\t\n\t\tvector<int> dx(a.begin(), a.end());\n\t\tsort(dx.begin(), dx.end());\n\t\t\n\t\tfore(i, 0, n) {\n\t\t\tint pos = int(lower_bound(dx.begin(), dx.end(), a[i]) - dx.begin());\n\t\t\tS[k][i] = int(sum(pos) % MOD);\n\t\t\tinc(pos, i + 1);\n\t\t}\n\t\treverse(a.begin(), a.end());\n\t}\n\t\n\treverse(S[1].begin(), S[1].end());\n\tint ans = 0;\n\tfore(i, 0, n) \n\t\tans = add(ans, mul(a[i], add(mul(i + 1, n - i), add(mul(S[0][i], n - i), mul(S[1][i], i + 1)))));\n\t\n\tcout << ans << endl;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint tt = clock();\n#endif\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0), cout.tie(0);\n\t\n\tif(read()) {\n\t\tsolve();\n\t\t\n#ifdef _DEBUG\n\t\tcerr << \"TIME = \" << clock() - tt << endl;\n\t\ttt = clock();\n#endif\n\t}\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}