{"link": "https://codeforces.com//contest/1167/problem/E", "problemId": "344634", "shortId": "1167E", "contest_number": "1167", "name": "E. Range Deleting", "statement": "You are given an array consisting of  integers  and an integer . It is guaranteed that for every , .Let's denote a function  which erases all values such that  from the array  and returns the resulting array. For example, if , then .Your task is to calculate the number of pairs  such that  and  is sorted in non-descending order. Note that the empty array is also considered sorted.", "input": "The first line contains two integers  and  () \u2014 the length of array  and the upper limit for its elements, respectively. The second line contains  integers  ().", "output": "Print the number of pairs  such that  is sorted in non-descending order.", "tutorial": "Lets find the maximum number  such that all values  form the non-descending order array. It can be done the following way. Let values  form the non-descending order array. Then values  will form the non-descending order array if the first occurrence of  in array  is after the last occurrence of . In similar manner we can find the minimum number  such that all values  form the non-descending order array.Now let's find out how to get the minimum number  such that all values  form the non-descending order array if we fixed the value . We denote this value  for some fixed value  as . Firstly, conditions ,  and  should hold. Secondly, there should be no such a pair  that conditions ,  and  hold. Since the condition  is satisfied, it means that  must be greater than , where  is the last occurrence of  in array .In this way the answer is .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(1e6) + 99;\nint n, x;\nint a[N];\nvector <int> pos[N];\nint prefMax[N];\n\nint main() {\n\tscanf(\"%d %d\", &n, &x);\n\tfor(int i = 0; i < n; ++i){\n\t\tscanf(\"%d\", a + i);\n\t\tpos[a[i]].push_back(i);\t\n\t\tprefMax[i] = max(a[i], (i > 0 ? prefMax[i - 1] : a[i]));\n\t}\n\t\n\tint p = 1;\n\tint lst = n + 5;\n\tfor(int i = x; i >= 1; --i){\n\t\tif(pos[i].empty()){\n\t\t    p = i;\n\t\t    continue;\n\t\t}\n\t\tif(pos[i].back() > lst) break;\n\t\tp = i;\n\t\tlst = pos[i][0];\n\t}\t\n\n\tlong long res = 0;\n\tlst = -1;\n\tfor(int l = 1; l <= x; ++l){\n\t\tint r = max(l, p - 1);\n\t\tif(lst != -1) r = max(r, prefMax[lst]);\n\t\tres += x - r + 1;\n\t\tif(!pos[l].empty()){\n    \t\tif(pos[l][0] < lst) break;\n    \t\tlst = pos[l].back();\n\t\t}\n\t}\t\n\n\tcout << res << endl;\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}