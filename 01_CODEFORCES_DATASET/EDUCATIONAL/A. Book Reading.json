{"link": "https://codeforces.com//contest/884/problem/A", "problemId": "130887", "shortId": "884A", "contest_number": "884", "name": "A. Book Reading", "statement": "Recently Luba bought a very interesting book. She knows that it will take  seconds to read the book. Luba wants to finish reading as fast as she can.But she has some work to do in each of  next days. The number of seconds that Luba has to spend working during -th day is . If some free time remains, she can spend it on reading.Help Luba to determine the minimum number of day when she finishes reading.", "input": "The first line contains two integers  and  (, ) \u2014 the number of days and the time required to read the book. The second line contains  integers  () \u2014 the time Luba has to spend on her work during -th day.", "output": "Print the minimum day Luba can finish reading the book. .", "tutorial": "Let's read the book greedily. On -th day Luba will read for  seconds. Subtract value for each day from  until  becomes less or equal to zero. That will be the day Luba finishes the book.Overall complexity: .", "solution": "#include <functional>\n#include <utility>\n#include <map>\n#include <array>\n#include <cstdio>\n#include <iterator>\n#include <vector>\ntemplate<typename T> struct ScanfSpecifier{};\n#define DEF(T,V) template<> struct ScanfSpecifier<T>{static constexpr const char* value = V;};\nDEF(char*,\"%s\")DEF(int,\"%d\")DEF(double,\"%lf\")DEF(float,\"%f\")DEF(char,\"%c\")DEF(const char*,\"%s\")DEF(unsigned long,\"%lu\")DEF(unsigned int, \"%u\")DEF(long double, \"%Lf\")\n#ifdef _MSC_VER\nDEF(long long int,\"%I64d\")\n#else\nDEF(long long int,\"%lld\")\n#endif\n#undef DEF\ntemplate<typename T> int RD(T& arg){return std::scanf(ScanfSpecifier<T>::value, &arg);}\ntemplate<int S> int RD(char (&arg)[S]){return std::scanf(\"%s\", arg);}\nint RD(char* arg){return std::scanf(\"%s\", arg);}\ntemplate<> int RD<char>(char& arg){return std::scanf(\" %c\", &arg);}\ntemplate<typename T, typename... Args> int RD(T& arg1, Args&... args) {return RD(arg1) + RD(args...);}\ntemplate<typename T> T RD(){T ret; RD(ret); return ret;}\ntemplate<typename It> void RDV(It begin, It end) { while(begin != end) RD(*begin++); }\ntemplate<typename C> void RDV(C& c) {RDV(std::begin(c), std::end(c));}\ntemplate<typename T> void WT(T arg) {std::printf(ScanfSpecifier<T>::value, arg); }\ntemplate<typename T, typename U> void WT(std::pair<T, U> arg) {std::printf(\"(\"); WT(arg.first); std::printf(\", \"); WT(arg.second); std::printf(\")\");}\ntemplate<typename... Args> void WT(Args... args) { int alc = 0; int dummy[] = {((alc++? std::printf(\" \"): 0), WT(args), 0)...}; }\n\ntemplate<typename... Args> void WTL(Args... args) { WT(args...); std::printf(\"\\n\"); }\ntemplate<typename It> void WTV(It begin, It end) { int alc = 0; while(begin != end) (alc++? std::printf(\" \"): 0), WT(*begin++); }\ntemplate<typename C> void WTV(const C& c) {WTV(std::begin(c), std::end(c));}\ntemplate<typename It> void WTVL(It begin, It end) { WTV(begin, end); std::printf(\"\\n\"); }\ntemplate<typename C> void WTVL(const C& c) {WTVL(std::begin(c), std::end(c));}\n\n#define _M_VARGS_NUM_IMPL(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, N, ...) N\n#define _M_VARGS_NUM(...) _M_VARGS_NUM_IMPL(__VA_ARGS__, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1)\n#define _W1(_1) (#_1[0] == '\"' || #_1[0] == '\\''? WT(\"\", _1, \"\"): WT('[', #_1, '=', _1, ']'))\n#define _W2(_1, _2) (_W1(_1), _W1(_2))\n#define _W3(_1, _2, _3) (_W1(_1), _W2(_2, _3))\n#define _W4(_1, _2, _3, _4) (_W1(_1), _W3(_2, _3, _4))\n#define _W5(_1, _2, _3, _4, _5) (_W1(_1), _W4(_2, _3, _4, _5))\n#define _W6(_1, _2, _3, _4, _5, _6) (_W1(_1), _W5(_2, _3, _4, _5, _6))\n#define _W7(_1, _2, _3, _4, _5, _6, _7) (_W1(_1), _W6(_2, _3, _4, _5, _6, _7))\n#define _W8(_1, _2, _3, _4, _5, _6, _7, _8) (_W1(_1), _W7(_2, _3, _4, _5, _6, _7, _8))\n#define _WW_IMPL2(num, ...) _W ## num(__VA_ARGS__)\n#define _WW_IMPL(num, ...) _WW_IMPL2(num, __VA_ARGS__)\n#define WW(...) (std::printf(\"(%03d) \", __LINE__), _WW_IMPL(_M_VARGS_NUM(__VA_ARGS__), __VA_ARGS__), WTL(\"\"))\n\n\n\n\nstruct Range\n{   \n    struct It {   int num, step; int operator*(){return num;} void operator++(){num += step;} bool operator!=(const It& other){return num != other.num;} };\n    Range(int ee):b(0),e(ee){}\n    Range(int bb, int ee):b(bb), e(ee){}\n    It begin(){return {b, (b < e? 1: -1)};}\n    It end(){return {e, 0};}\n    int b, e;\n};\n\ntemplate<typename T> inline T& UMAX(T& x, T y){if(x < y)x = y; return x;}\ntemplate<typename T> inline T& UMIN(T& x, T y){if(y < x)x = y; return x;}\ntemplate<typename T, typename... Args> struct ArithmiticPromotion { typedef decltype(T() + typename ArithmiticPromotion<Args...>::type()) type; };\ntemplate<typename T, typename U> struct ArithmiticPromotion<T, U> { typedef decltype(T() + U()) type; };\ntemplate<typename T> struct ArithmiticPromotion<T, T> { typedef T type; };\ntemplate<typename T> struct ArithmiticPromotion<T> { typedef T type; };\ntemplate<typename T, typename U> typename ArithmiticPromotion<T, U>::type MAX(T a, U b) { return a < b? b: a; }\ntemplate<typename T, typename... Args> typename ArithmiticPromotion<T, Args...>::type MAX(T a, Args... args) { return MAX(a, MAX(args...)); }\ntemplate<typename T, typename U> typename ArithmiticPromotion<T, U>::type MIN(T a, U b) { return a < b? a: b; }\ntemplate<typename T, typename... Args> typename ArithmiticPromotion<T, Args...>::type MIN(T a, Args... args) { return MIN(a, MIN(args...)); }\n\n\n\n\n\n//alias\n//RD[L],RDV[L],WT[L],WTV[L] for i/o\nusing RG = Range;\n//template\n#include <vector>\n#include <string>\n#include <cstring>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdlib>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\ntypedef long long int ll;\n\nint main()\n{\n    int N, T;\n    RD(N, T);\n    \n    int ans = 0;\n    int alc = 0;\n    for(int i: RG(N))\n    {\n        ans++;\n        int a;\n        RD(a);\n\n        if((alc += 86400 - a) >= T)\n            break;\n    }\n    WTL(ans);\n\n}\n\n\n\n\n", "interactive": false, "noSolution": false, "noTutorial": false}