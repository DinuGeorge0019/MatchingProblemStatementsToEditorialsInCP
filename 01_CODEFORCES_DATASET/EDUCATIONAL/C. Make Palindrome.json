{"link": "https://codeforces.com//contest/600/problem/C", "problemId": "41575", "shortId": "600C", "contest_number": "600", "name": "C. Make Palindrome", "statement": "A string is called palindrome if it reads the same from left to right and from right to left. For example \"\", \"\", \"\" and \"\" are palindroms, but strings \"\" and \"\" are not.You are given string  consisting of lowercase Latin letters. At once you can choose any position in the string and change letter in that position to any other lowercase letter. So after each changing the length of the string doesn't change. At first you can change some letters in . Then you can permute the order of letters as you want. Permutation doesn't count as changes. You should obtain palindrome with the minimal number of changes. If there are several ways to do that you should get the lexicographically (alphabetically) smallest palindrome. So firstly you should minimize the number of changes and then minimize the palindrome lexicographically.", "input": "The only line contains string  () consisting of only lowercase Latin letters.", "output": "Print the lexicographically smallest palindrome that can be obtained with the minimal number of changes.", "tutorial": "Let's denote cntc \u2014 the number of occurences of symbol c. Let's consider odd values cntc. Palindrome can not contain more than one symbol c with odd cntc. Let's denote symbols with odd cntc as a1,\u2009a2...ak (in alphabetical order). Let's replace any one of symbols ak with symbol a1, ak\u2009-\u20091 with a2 and so on until the middle of a. Now we have no more than one odd symbol. If we have some let's place it in the middle of the answer. First half of answer will contain  occurences of symbol c in alphabetical order. The second half will contain the same symbols in reverse order. For example for string s\u2009=\u2009aabcd at first we will replace d by \nUnable to parse markup [type=CF_TEX]\nabcba\nCompexity: O(n).\n", "solution": "/*\nYour insecurities makes me feel\nSo helpless, feel like letting go\nYour insincerities, it makes a world\nOf difference, you will never know\n\nAnother voiced rejection\nThrow it at me, please just let me go\nAnother selfish reason\nThrow it at me, please just let me go\n\nIt's all too much for me, I cannot hide\nThe sickness you bring on in me\nFree of sympathy, you'll never know\nHow it hurts, you will never know\n\nAnother voiced rejection\nThrow it at me, please just let me go\nAnother selfish reason\nThrow it at me, please just let me go\n\nThrow it at me, please just let me go\nAnother selfish reason\nThrow it at me, please just let me go\nAnother voiced rejection\nThrow it at me, please just let me go\n\nAnother selfish reason, throw it at me\nPlease just let me go, let me go\n*/\n\n//#pragma comment(linker, \"/STACK:16777216\")\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <complex>\n#include <math.h>\n#include <set>\n#include <vector>\n#include <map>  \n#include <queue>\n#include <stdio.h>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <ctime>\n#include <memory.h>\n#include <ctime> \n#include <assert.h>\n\n#define y0 sdkfaslhagaklsldk\n#define y1 aasdfasdfasdf\n#define yn askfhwqriuperikldjk\n#define j1 assdgsdgasghsf\n#define tm sdfjahlfasfh\n#define lr asgasgash\n\n#define eps 1e-8\n#define M_PI 3.141592653589793\n#define bs 1000000007\n#define bsize 512\n\nconst int N = 200005;\n\nusing namespace std;\n\nstring st;\nint cnt[N];\ndeque<char> qu;\nvector<int> odd;\n\nint main(){\n\t//freopen(\"beavers.in\",\"r\",stdin);\n\t//freopen(\"beavers.out\",\"w\",stdout);\n\t//freopen(\"F:/in.txt\",\"r\",stdin);\n\t//freopen(\"F:/output.txt\",\"w\",stdout);\n\tios_base::sync_with_stdio(0);\n\t//cin.tie(0);\n\t\n\tcin>>st;\n\tfor (int i=0;i<st.size();i++)\n\t{\n\t\tcnt[st[i]]++;\n\t}\n\t\n\tfor (int i='a';i<='z';i++)\n\t\tif (cnt[i]%2)\n\t\t\todd.push_back(i);\n\t\n\tsort(odd.begin(),odd.end());\n\t/*\n\tif (odd.size()%2)\n\t{\n\t\tfor (int i=2;i<odd.size();i++)\n\t\t{\n\t\t\tcnt[odd[i]]--;\n\t\t\tcnt[odd[0]]++;\n\t\t}\n\t}\n\telse\n\t\n\tfor (int i=1;i<odd.size();i++)\n\t{\n\t\tcnt[odd[i]]--;\n\t\tcnt[odd[0]]++;\n\t}\n\t*/\n\t\n\tint sz=odd.size();\n\tint l=0;\n\tint r=sz-1;\n\twhile (l<r)\n\t{\n\t\tcnt[odd[l]]++;\n\t\tcnt[odd[r]]--;\n\t\t++l;\n\t\t--r;\n\t}\n\t\n\tint op=-1;\n\t\n\tfor (int i='a';i<='z';i++)\n\t{\n\t\tif (cnt[i]%2)\n\t\t{\n\t\t\tcnt[i]--;\n\t\t\tqu.push_back(i);\n\t\t}\n\t}\n\tfor (int i='z';i>='a';i--)\n\t{\n\t\twhile (cnt[i])\n\t\t{\n\t\t\tqu.push_back(i);\n\t\t\tqu.push_front(i);\n\t\t\tcnt[i]-=2;\n\t\t}\n\t}\n\t\n\twhile (qu.size())\n\t{\n\t\tcout<<qu.front();\n\t\tqu.pop_front();\n\t}\n\tcout<<endl;\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}