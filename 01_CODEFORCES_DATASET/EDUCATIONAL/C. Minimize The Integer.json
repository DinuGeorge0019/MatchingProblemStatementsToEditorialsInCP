{"link": "https://codeforces.com//contest/1251/problem/C", "problemId": "449546", "shortId": "1251C", "contest_number": "1251", "name": "C. Minimize The Integer", "statement": "You are given a huge integer  consisting of  digits ( is between  and , inclusive). It may contain leading zeros.You can swap two digits on adjacent (neighboring) positions if the swapping digits are of different parity (that is, they have different remainders when divided by ). For example, if  you can get the following integers in a single operation:    if you swap the first and the second digits;   if you swap the second and the third digits;   if you swap the fifth and the sixth digits;   if you swap the sixth and the seventh digits;   if you swap the seventh and the eighth digits. Note, that you can't swap digits on positions  and  because the positions are not adjacent. Also, you can't swap digits on positions  and  because the digits have the same parity.You can perform any number (possibly, zero) of such operations.Find the minimum integer you can obtain.", "input": "The first line contains one integer  () \u2014 the number of test cases in the input. The only line of each test case contains the integer , its length  is between  and , inclusive. It is guaranteed that the sum of all values  does not exceed .", "output": "For each test case print line \u2014 the minimum integer you can obtain.", "tutorial": "Let's consider two sequences of digits:  and , there  is the first even digit in ,  is the second even digit and so on and  is the first odd digit in ,  is the second odd digit and so on.Since you can't swap digits of same parity, the sequence  of even digits of  never changed. Sequence  of odd digits of  also never changed. So the first digit in the answer will be equal to  or to . And since we have to minimize the answer, we have to chose the  as the first digit in answer and them delete it from the corresponding sequence (in this way sequence  turn into  or sequence  turn into ). Second, third and followings digits need to choose in the same way.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint t;\nstring a;\n\nint main() {\t\n\tcin >> t;\n\tfor(int tc = 0; tc < t; ++tc){\n\t\tcin >> a;\n\t\tstring s[2];\n\t\tfor(auto x : a)\n\t\t\ts[int(x - '0') & 1] += x;\n\t\t\n\t\treverse(s[0].begin(), s[0].end());\n\t\treverse(s[1].begin(), s[1].end());\n\n\t\tstring res = \"\";\n\t\twhile(!(s[0].empty() && s[1].empty())){\n\t\t\tif(s[0].empty()){\n\t\t\t\tres += s[1].back();\n\t\t\t\ts[1].pop_back();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(s[1].empty()){\n\t\t\t\tres += s[0].back();\n\t\t\t\ts[0].pop_back();\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif(s[0].back() < s[1].back()){\n\t\t\t\tres += s[0].back();\n\t\t\t\ts[0].pop_back();\n\t\t\t}\n\t\t\telse{\n\t\t\t\tres += s[1].back();\n\t\t\t\ts[1].pop_back();\n\t\t\t}\n\t\t}\n\n\t\tcout << res << endl;\n\t}\t\n\treturn 0;\n} \n\n", "interactive": false, "noSolution": false, "noTutorial": false}