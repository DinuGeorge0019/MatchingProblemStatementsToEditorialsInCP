{"link": "https://codeforces.com//contest/1525/problem/E", "problemId": "987015", "shortId": "1525E", "contest_number": "1525", "name": "E. Assimilation IV", "statement": "Monocarp is playing a game \"Assimilation IV\". In this game he manages a great empire: builds cities and conquers new lands.Monocarp's empire has  cities. In order to conquer new lands he plans to build . The game is turn-based and, since Monocarp is still amateur, he builds exactly one Monument per turn.Monocarp has  points on the map he'd like to control using the constructed Monuments. For each point he knows the distance between it and each city. Monuments work in the following way: when built in some city, a Monument controls all points at distance at most  to this city. Next turn, the Monument controls all points at distance at most , the turn after\u00a0\u2014 at distance at most , and so on. Monocarp will build  Monuments in  turns and his empire will conquer all points that are controlled by at least one Monument.Monocarp can't figure out any strategy, so during each turn he will choose a city for a Monument randomly among all remaining cities (cities without Monuments). Monocarp wants to know how many points (among  of them) he will conquer at the end of turn number . Help him to calculate the expected number of conquered points!", "input": "The first line contains two integers  and  (; )\u00a0\u2014 the number of cities and the number of points. Next  lines contains  integers each: the -th integer of the -th line  () is the distance between the -th city and the -th point.", "output": "It can be shown that the expected number of points Monocarp conquers at the end of the -th turn can be represented as an irreducible fraction . Print this fraction modulo , i.\u00a0e. value  where  is such number that .", "tutorial": "Let  be the indicator function equal to  if the -th point is controlled by any city and  otherwise. Then the expected number of controlled points  can be written as  (by linearity of expected value).The expected value of the indicator function is equal to the probability of this function equal to  (). In other words, for each point we need to calculate the probability of this point being controlled by any city.Let's instead calculate the probability of point  not being controlled by any city. Suppose, the distance between point  and some city  is equal to . If we build a Monument in city  at step  (zero indexed) then the point will be controlled by city . But building the Monument at any step greater or equal than  is fine.Let's for each turn  calculate the number of cities that you can build Monument in starting this turn as . Our task is to calculate the number of permutations that are consistent with array .At first turn, we can choose one of  cities, at second turn we have  choices, at third step\u00a0\u2014  choices, and so on. Using this idea, it's not hard to calculate the number of good permutations and then the initial probablity   .The expected value .", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) int((a).size())\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef pair<int, int> pt;\n\nconst int MOD = 998244353;\n\nint norm(int a) {\n\twhile (a >= MOD)\n\t\ta -= MOD;\n\twhile (a < 0)\n\t\ta += MOD;\n\treturn a;\n}\nint mul(int a, int b) {\n\treturn int(a * 1ll * b % MOD);\n}\nint binPow(int a, int k) {\n\tint ans = 1;\n\twhile (k > 0) {\n\t\tif (k & 1)\n\t\t\tans = mul(ans, a);\n\t\ta = mul(a, a);\n\t\tk >>= 1;\n\t}\n\treturn ans;\n}\nint inv(int a) {\n\treturn binPow(a, MOD - 2);\n}\n\nvector< vector<int> > d;\nint n, m;\n\ninline bool read() {\n\tif(!(cin >> n >> m))\n\t\treturn false;\n\td.resize(n, vector<int>(m));\n\tfore (i, 0, n) fore (j, 0, m)\n\t\tcin >> d[i][j];\n\treturn true;\n}\n\ninline void solve() {\n\tint invFact = 1;\n\tfore (i, 1, n + 1)\n\t\tinvFact = mul(invFact, i);\n\tinvFact = inv(invFact);\n\t\n\tint E = 0;\n\tfore (j, 0, m) {\n\t\tvector<int> cnt(n + 1, 0);\n\t\tfore (i, 0, n)\n\t\t\tcnt[n + 1 - d[i][j]]++;\n\t\t\n\t\tvector<int> d(n + 1, 0);\n\t\td[0] = 1;\n\t\tint rem = 0;\n\t\tfore (i, 0, n) {\n\t\t\trem += cnt[i];\n\t\t\td[i + 1] = norm(d[i + 1] + mul(d[i], rem));\n\t\t\trem = max(0, rem - 1);\n\t\t}\n//\t\tcerr << d[n] << \" - \" << norm(1 - mul(d[n], invFact)) << endl;\n\t\tE = norm(E + 1 - mul(d[n], invFact));\n\t}\n\tcout << E << endl;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint tt = clock();\n#endif\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0), cout.tie(0);\n\tcout << fixed << setprecision(15);\n\t\n\tif(read()) {\n\t\tsolve();\n\t\t\n#ifdef _DEBUG\n\t\tcerr << \"TIME = \" << clock() - tt << endl;\n\t\ttt = clock();\n#endif\n\t}\n\treturn 0;\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}