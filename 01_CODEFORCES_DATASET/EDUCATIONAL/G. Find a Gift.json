{"link": "https://codeforces.com//contest/1354/problem/G", "problemId": "623450", "shortId": "1354G", "contest_number": "1354", "name": "G. Find a Gift", "statement": "There are  gift boxes in a row, numbered from  to  from left to right. It's known that exactly  of them contain valuable gifts\u00a0\u2014 other boxes contain just lucky stones. All boxes look the same and differ only in weight. All  than boxes with valuable items. But valuable gifts may be different, so the boxes with valuable items may have different weights.You can ask no more than  queries (printing an answer doesn't count). By each query you can compare total weights of two non-intersecting subsets of boxes  and . In return you'll get one of four results:  , if subset  is strictly ;  , if subset  is strictly ;  , if subsets have equal total weights;  , if the query is incorrect or the limit of queries is exceeded. Using such queries (or, maybe, intuition) find the box with a valuable gift with .", "input": "The input consists of several cases. In the beginning, you receive the integer  ()\u00a0\u2014 the number of test cases. At the beginning of each test case, you receive two integers  and  (, )\u00a0\u2014 the number of boxes in a row and the number of boxes with valuable gifts. It's guaranteed that the order of boxes is fixed beforehand and that the sum of  in one test doesn't exceed .", "output": "For each test case print the minimum index among all boxes with a valuable gift in the following format: \"\" where  ()\u00a0\u2014 the index of the box.", "tutorial": "The solution consists of several steps. Let's find out \"does the first box contain stone or valuable gift\" using random. Let's make  queries to compare the weight of the first box with the weight of another random box. If the first box is lighter than we found an answer, otherwise the probability of the first box having stones is at least . Let's compare the weights of the first box and the second one. If they are equal then let's compare the weights of boxes  and . If they are equal then let's compare the boxes  and  and so on. In other words, let's find the minimum  such that  contains only boxes with stones but  contain at least one box with a valuable gift. It's easy to see that we'd spend no more than  queries. We have segment  with only stones and  with at least one gift. Let's just binary search the leftmost gift in the segment  using boxes from  as reference: if we need to know \"does segment of boxes  have at least one gift\", let's just compare it with segment  which have only stones. if  is lighter then it has, otherwise doesn't have. This part also requires no more than  queries.", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) int((a).size())\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef pair<int, int> pt;\n\nconst int MAG = 30;\nint lst;\n\nint n, k;\n\ninline bool read() {\n\tif(!(cin >> n >> k))\n\t\treturn false;\n\treturn true;\n}\n\nint ask(int l1, int r1, int l2, int r2) {\n\tassert(l1 < r1 && l2 < r2);\n\tassert(r1 <= l2 || r2 <= l1);\n\t\n\tcout << \"? \" << r1 - l1 << \" \" << r2 - l2 << endl;\n\tfore(i, l1, r1) {\n\t\tif (i > l1) cout << \" \";\n\t\tcout << i + 1;\n\t}\n\tcout << endl;\n\tfore(i, l2, r2) {\n\t\tif (i > l2) cout << \" \";\n\t\tcout << i + 1;\n\t}\n\tcout << endl;\n\tcout.flush();\n\t\n\tstring resp;\n\tcin >> resp;\n\t\n\tif (resp == \"FIRST\")\n\t\treturn -1;\n\tif (resp == \"SECOND\")\n\t\treturn 1;\n\tif (resp == \"EQUAL\")\n\t\treturn 0;\n\t\n\texit(0);\n}\n\ninline void solve() {\n\t//check first position\n\tmt19937 rnd(lst ^ (n * 1024 + k));\n\tfor(int q = 0; q < MAG; q++) {\n\t\tint cur = 1 + rnd() % (n - 1);\n\t\t\n\t\tint resp = ask(0, 1, cur, cur + 1);\n\t\tif (resp == 1) {\n\t\t\tcout << \"! 1\" << endl;\n\t\t\tcout.flush();\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\tint len = 1;\n\twhile(true) {\n\t\tint cnt = min(len, n - len);\n\t\tint resp = ask(0, cnt, len, len + cnt);\n\t\tif (resp != 0) {\n\t\t\tassert(resp == -1);\n\t\t\tbreak;\n\t\t}\n\t\tlen <<= 1;\n\t}\n\t\n\tint lf = len, rg = min(2 * len, n);\n\twhile(rg - lf > 1) {\n\t\tint mid = (lf + rg) >> 1;\n\t\tint resp = ask(0, mid - lf, lf, mid);\n\t\tassert(resp != 1);\n\t\t\n\t\tif (resp == 0)\n\t\t\tlf = mid;\n\t\telse\n\t\t\trg = mid;\n\t}\n\tcout << \"! \" << lf + 1 << endl;\n\tcout.flush();\n\t\n\tlst = lf + 1;\n}\n\nint main() {\n\tint tc;\n\tcin >> tc;\n\t\n\tlst = tc;\n\twhile(tc--) {\n\t\tassert(read());\n\t\tsolve();\n\t}\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}