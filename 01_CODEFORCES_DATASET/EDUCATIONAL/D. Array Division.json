{"link": "https://codeforces.com//contest/808/problem/D", "problemId": "106400", "shortId": "808D", "contest_number": "808", "name": "D. Array Division", "statement": "Vasya has an array  consisting of positive integer numbers. Vasya wants to divide this array into two non-empty consecutive parts (the prefix and the suffix) so that the sum of all elements in the first part equals to the sum of elements in the second part. It is not always possible, so Vasya will move some element before dividing the array (Vasya will erase some element and insert it into an arbitrary position).Can Vasya divide the array after choosing the right element to move and its new position?", "input": "The first line contains single integer  () \u2014 the size of the array. The second line contains  integers  () \u2014 the elements of the array.", "output": "Print  if Vasya can divide the array after moving one element. Otherwise print .", "tutorial": "Suppose we want to move an element from the prefix to the suffix (if we need to move an element from the suffix to the prefix, we can just reverse the array and do the same thing).Suppose the resulting prefix will contain  elements. Then we need to check that the prefix with  elements contains an element such that the sum of this prefix without this element is equal to the half of the sum of the whole array (and then we can move this element to the suffix).To check all the prefixes, we can scan the array from left to right while maintaining the set of elements on the prefix and the sum of these elements.", "solution": "import java.io.*;\nimport java.util.*;\n\npublic class ER21qD {\n\n\tpublic static void main(String[] args) {\n\t\tInputReader in = new InputReader(System.in);\n\t\tPrintWriter w = new PrintWriter(System.out);\n\n\t\tint n = in.nextInt();\n\n\t\tint a[] = in.nextIntArray(n);\n\n\t\tlong tot = 0;\n\t\tfor (int x : a)\n\t\t\ttot += x;\n\n\t\t{\n\t\t\tlong pre = 0;\n\t\t\tTreeSet<Long> set = new TreeSet<Long>();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tpre += a[i];\n\t\t\t\tset.add((long)a[i]);\n\t\t\t\tlong suf = tot - pre;\n\t\t\t\tif (pre == suf) {\n\t\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif ((pre-suf) %2 == 0 && set.contains((pre - suf)/2)) {\n\t\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t{\n\t\t\tlong suf = 0;\n\t\t\tTreeSet<Long> set = new TreeSet<Long>();\n\t\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\t\tsuf += a[i];\n\t\t\t\tset.add((long)a[i]);\n\t\t\t\tlong pre = tot - suf;\n\t\t\t\tif (pre == suf) {\n\t\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif ((suf - pre) % 2 == 0 && set.contains((suf - pre)/2)) {\n\t\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(\"NO\");\n\t\tw.close();\n\t}\n\n\tstatic class InputReader {\n\n\t\tprivate final InputStream stream;\n\t\tprivate final byte[] buf = new byte[8192];\n\t\tprivate int curChar, snumChars;\n\n\t\tpublic InputReader(InputStream st) {\n\t\t\tthis.stream = st;\n\t\t}\n\n\t\tpublic int read() {\n\t\t\tif (snumChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= snumChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tsnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (snumChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint a[] = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\ta[i] = nextInt();\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic String readString() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic String nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndOfLine(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic boolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tprivate boolean isEndOfLine(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t}\n\n}", "interactive": false, "noSolution": false, "noTutorial": false}