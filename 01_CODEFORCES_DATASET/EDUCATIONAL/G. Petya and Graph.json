{"link": "https://codeforces.com//contest/1082/problem/G", "problemId": "64169", "shortId": "1082G", "contest_number": "1082", "name": "G. Petya and Graph", "statement": "Petya has a simple graph (that is, a graph without loops or multiple edges) consisting of  vertices and  edges.The weight of the -th vertex is .The weight of the -th edge is .A subgraph of a graph is some set of the graph vertices and some set of the graph edges. The set of edges must meet the condition: both ends of each edge from the set must belong to the chosen set of vertices. The weight of a subgraph is the sum of the weights of its edges, minus the sum of the weights of its vertices. You need to find the maximum weight of subgraph of given graph. .", "input": "The first line contains two numbers  and  () - the number of vertices and edges in the graph, respectively. The next line contains  integers  () - the weights of the vertices of the graph. The following  lines contain edges: the -e edge is defined by a triple of integers  (). This triple means that between the vertices  and  there is an edge of weight . It is guaranteed that the graph does not contain loops and multiple edges.", "output": "Print one integer \u2014 the maximum weight of the subgraph of the given graph.", "tutorial": "This problem can be reduced to one of well-known flow problems: \"Projects and Instruments\". In this problem, we have a set of projects we can do, each with its cost, and a set of instruments (each also having some cost). Each project depends on some instruments, and each instrument can be used any number of times. We have to choose a subset of projects and a subset of instruments so that if a project is chosen, all instruments that this project depends on are also chosen, and we have to maximize the difference between the sum of costs of chosen projects and the sum of costs of chosen instruments.The problem about projects and instruments can be solved with the following flow network:  for each project, create a vertex and add a directed edge from the source to this vertex with capacity equal to the cost of this project;  for each instrument, create a vertex and add a directed edge from this vertex to the sink with capacity equal to the cost of this instrument;  for each project, create edges with infinite capacity from the vertex denoting this project to all vertices denoting the required instruments for this project. Let's analyze an  cut between the source and the sink in this vertex, and construct some answer based on this cut as follows: if a project-vertex belongs to , then we take this project; if an instrument-vertex belongs to , then we take this instrument; all other projects and instruments are discarded. If an edge between some project and some instrument is cut, then it means that the answer is incorrect (we try to take a project requiring some instrument we don't take), and the cut value is infinite. Otherwise, the value of the cut is equal to the total cost of taken instruments and discarded projects, and we need to minimize it. So the minimum cut in this network denotes the best answer.Reducing the given problem to this problem is easy: edges of the given graph are \"projects\", vertices of the given graph are \"instruments\".Regarding implementation, any flow algorithm using capacity scaling should be sufficient. It seems that Dinic also passes, even though its complexity is .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long li;\n\nconst int N = 2009;\nconst int INF = int(1e9) + 777;\n\nstruct edge{\n\tint to, f, c;\n\tedge () {}\n\tedge (int to, int f, int c) : to(to), f(f), c(c) {}\n};\n\nint n, m;\nint s, t;\nvector<edge> edges;\nvector <int> g[N];\nint u[N], cu;\n\nvoid addEdge(int v, int to, int cap){\n\n\tg[v].push_back(edges.size());\n\tedges.push_back(edge(to, 0, cap));\n\n\tg[to].push_back(edges.size());\n\tedges.push_back(edge(v, 0, 0));\n}\n\nint dfs(int v, int need){\n\tif(v == t) return need;\n\tu[v] = cu;\n\tfor(auto to : g[v]){\n\t\tedge &e = edges[to];\n\t\tif(u[e.to] != cu && e.c - e.f >= need){\n\t\t\tint add = dfs(e.to, need);\n\t\t\tif(add > 0){\n\t\t\t\tedges[to].f += add;\n\t\t\t\tedges[to ^ 1].f -= add;\n\t\t\t\treturn add;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nli enlarge(int k){\n\tli res = 0;\n\twhile(true){\n\t\t++cu;\n\t\tint add = dfs(s, k);\n\t\tres += add;\n\t\tif(add == 0) break;\n\t}\n\treturn res;\n}\n\nli maxFlow(){\n\tli flow = 0;\n\tfor(int k = (1 << 29); k > 0; k >>= 1){\n\t\tflow += enlarge(k);\n\t}\n\treturn flow;\n}\n\nint main() {\n\t//freopen(\"input.txt\", \"r\", stdin);\n\tint nn, mm;\n\tcin >> nn >> mm;\n\tn = nn + mm + 5;\n\tm = nn + mm + mm + mm + 5;\n\ts = n - 1, t = n - 2;\n\t\n\tfor(int i = 0; i < nn; ++i){\n\t\tint a;\n\t\tcin >> a;\n\t\taddEdge(i + mm, t, a);\n\t}\n\n\tli sum = 0;\n\tfor(int i = 0; i < mm; ++i){\n\t\tint u, v, w;\n\t\tcin >> u >> v >> w;\n\t\t--u, --v;\n\t\tsum += w;\n\t\t\n\t\taddEdge(s, i, w);\n\t\taddEdge(i, u + mm, INF);\n\t\taddEdge(i, v + mm, INF);\n\t}\n\t\n\tli fl = maxFlow();\n\tcout << sum - fl << endl;\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}