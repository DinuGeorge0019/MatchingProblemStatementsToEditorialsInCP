{"link": "https://codeforces.com//contest/1783/problem/B", "problemId": "1728811", "shortId": "1783B", "contest_number": "1783", "name": "B. Matrix of Differences", "statement": "For a square matrix of integers of size , let's define its  as follows: for each pair of side-adjacent elements  and , write out the number , and then find the number of different numbers among them.For example, for the matrix  the numbers we consider are , ,  and ; there are  different numbers among them (,  and ), which means that its beauty is equal to .You are given an integer . You have to find a matrix of size , where each integer from  to  occurs exactly once, such that its  is the maximum possible among all such matrices.", "input": "The first line contains a single integer  ()\u00a0\u2013 the number of test cases. The first (and only) line of each test case contains a single integer  ().", "output": "For each test case, print  rows of  integers\u00a0\u2014 a matrix of integers of size , where each number from  to  occurs exactly once, such that its beauty is the maximum possible among all such matrices. If there are multiple answers, print any of them.", "tutorial": "The first step is to notice that beauty doesn't exceed , because the minimum difference between two elements is at least , and the maximum difference does not exceed  (the difference between the maximum element  and the minimum element ).At first, finding a matrix with maximum beauty seems to be a quite difficult task. So let's try to find an array of  elements of maximum beauty. In this case, it is not difficult to come up with an array of the form . In such an array, there are all possible differences from  to . So we found an array with the maximum possible beauty.It remains to find a way to \"convert\" the array to the matrix, i.e. to find such a sequence of matrix cells that each two adjacent cells in it are side-adjacent. One of the ways is the following: traverse the first row of the matrix from left to right, go down to the second row, traverse it from right to left, go down to the third row, traverse it from left to right, and so on.Thus, we constructed a matrix with the maximum possible beauty .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n\nint main() {\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    vector<vector<int>> a(n, vector<int>(n));\n    int l = 1, r = n * n, t = 0;\n    forn(i, n) {\n      forn(j, n) {\n        if (t) a[i][j] = l++;\n        else a[i][j] = r--;\n        t ^= 1;\n      }\n      if (i & 1) reverse(a[i].begin(), a[i].end());\n    }\n    forn(i, n) forn(j, n) cout << a[i][j] << \" \\n\"[j == n - 1];\n  }\n}", "interactive": false, "noSolution": false, "noTutorial": false}