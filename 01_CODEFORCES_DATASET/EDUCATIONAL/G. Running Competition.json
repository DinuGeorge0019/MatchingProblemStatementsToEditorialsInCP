{"link": "https://codeforces.com//contest/1398/problem/G", "problemId": "699507", "shortId": "1398G", "contest_number": "1398", "name": "G. Running Competition", "statement": "A running competition is going to be held soon. The stadium where the competition will be held can be represented by several segments on the coordinate plane:  two horizontal segments: one connecting the points  and , the other connecting the points  and ;   vertical segments, numbered from  to . The -th segment connects the points  and ; . For example, here is a picture of the stadium with , ,  and :  A  is a route that goes along the segments, starts and finishes at the same point, and never intersects itself (the only two points of a lap that coincide are its starting point and ending point). The length of a lap is a total distance travelled around it. For example, the red route in the picture representing the stadium is a lap of length .The competition will be held in  stages. The -th stage has length , and the organizers want to choose a lap for each stage such that the length of the lap is a . The organizers don't want to choose short laps for the stages, so for each stage, they want to find the maximum possible length of a suitable lap.Help the organizers to calculate the maximum possible lengths of the laps for the stages! In other words, for every , find the maximum possible integer  such that , and there exists a lap of length  .If it is impossible to choose such a lap then print .", "input": "The first line contains three integers ,  and  (, ). The second line contains  integers , , ...,  (). The third line contains one integer  ()\u00a0\u2014 the number of stages. The fourth line contains   integers , , ...,  ()\u00a0\u2014 the lengths of the stages. ", "output": "Print  numbers. The -th number should be equal to the maximum possible length of a suitable lap for the -th stage, or  if it is impossible to choose a lap for that stage.", "tutorial": "First of all, let's find all possible lengths of the laps (after doing that, we can just check every divisor of  to find the maximum possible length of a lap for a given query). A lap is always a rectangle \u2014 you can't construct a lap without using any vertical segments or using an odd number of vertical segments, and if you try to use  or more vertical segments, you can't go back to the point where you started because both horizontal segments are already partially visited. So, a lap is a rectangle bounded by two vertical segments; and if we use vertical segments  and , the perimeter of this rectangle is .Let's find all values that can be represented as . A naive  approach will be too slow, we have to speed it up somehow. Let's build an array  of  numbers where  ( is some integer greater than ). Each number that can be represented as  can also be represented as , so we have to find all possible sums of two elements belonging to different arrays.The key observation here is that, if  and  are small, we can treat each array as a polynomial: let , and similarly, . Let's look at the product of that polynomials. The coefficient for  is non-zero if and only if there exist  and  such that , so finding all possible sums (and all possible differences) can be reduced to multiplying two polynomials, which can be done faster than  using Karatsuba's algorithm or FFT.", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define forn(i, n) for(int i = 0; i < n; i++)\n#define sz(a) ((int)(a).size())\n\nconst int LOGN = 20;\nconst int N = (1 << LOGN);\nconst int K = 200043;\nconst int M = 1000043;\n\ntypedef double ld;\ntypedef long long li;\n\nconst ld PI = acos(-1.0);\n\nstruct comp \n{\n    ld x, y;\n    comp(ld x = .0, ld y = .0) : x(x), y(y) {}\n    inline comp conj() { return comp(x, -y); }\n};\n\ninline comp operator +(const comp &a, const comp &b) \n{\n    return comp(a.x + b.x, a.y + b.y);\n}\n\ninline comp operator -(const comp &a, const comp &b) \n{\n    return comp(a.x - b.x, a.y - b.y);\n}\n\ninline comp operator *(const comp &a, const comp &b) \n{\n    return comp(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\ninline comp operator /(const comp &a, const ld &b) \n{\n    return comp(a.x / b, a.y / b);\n}\n\nvector<comp> w[LOGN];\nvector<int> rv[LOGN];\n\nvoid precalc() \n{\n    for(int st = 0; st < LOGN; st++) \n    {\n        w[st].assign(1 << st, comp());\n        for(int k = 0; k < (1 << st); k++) \n        {\n            double ang = PI / (1 << st) * k;\n            w[st][k] = comp(cos(ang), sin(ang));\n        }\n        \n        rv[st].assign(1 << st, 0);\n        if(st == 0) \n        {\n            rv[st][0] = 0;\n            continue;\n        }\n        int h = (1 << (st - 1));\n        for(int k = 0; k < (1 << st); k++)\n            rv[st][k] = (rv[st - 1][k & (h - 1)] << 1) | (k >= h);\n    }\n}\n\ninline void fft(comp a[N], int n, int ln, bool inv) \n{\n    for(int i = 0; i < n; i++) \n    {\n        int ni = rv[ln][i];\n        if(i < ni)\n            swap(a[i], a[ni]);\n    }\n    \n    for(int st = 0; (1 << st) < n; st++) \n    {\n        int len = (1 << st);\n        for(int k = 0; k < n; k += (len << 1)) \n        {\n            for(int pos = k; pos < k + len; pos++) \n            {\n                comp l = a[pos];\n                comp r = a[pos + len] * (inv ? w[st][pos - k].conj() : w[st][pos - k]);\n                \n                a[pos] = l + r;\n                a[pos + len] = l - r;\n            }\n        }\n    }\n    \n    if(inv) for(int i = 0; i < n; i++)\n        a[i] = a[i] / n;\n}\n\ncomp aa[N];\ncomp bb[N];\ncomp cc[N];\n\ninline void multiply(comp a[N], int sza, comp b[N], int szb, comp c[N], int &szc) \n{\n    int n = 1, ln = 0;\n    while(n < (sza + szb))\n        n <<= 1, ln++;\n    for(int i = 0; i < n; i++)\n        aa[i] = (i < sza ? a[i] : comp());\n    for(int i = 0; i < n; i++)\n        bb[i] = (i < szb ? b[i] : comp());\n        \n    fft(aa, n, ln, false);\n    fft(bb, n, ln, false);\n    \n    for(int i = 0; i < n; i++)\n        cc[i] = aa[i] * bb[i];\n        \n    fft(cc, n, ln, true);\n    \n    szc = n;\n    for(int i = 0; i < n; i++)\n        c[i] = cc[i];\n}\n\ncomp a[N];\ncomp b[N];\ncomp c[N];\nint used[M];\nint dp[M];\n\nint main()\n{\n    precalc();\n    int n, x, y;\n    for(int i = 0; i < M; i++)\n        dp[i] = -1;\n    scanf(\"%d %d %d\", &n, &x, &y);\n    vector<int> A(n + 1);\n    for(int i = 0; i <= n; i++)\n        scanf(\"%d\", &A[i]);\n    for(int i = 0; i <= n; i++)\n    {\n        a[A[i]] = comp(1.0, 0.0);\n        b[K - A[i]] = comp(1.0, 0.0);\n    }\n    int s = 0;\n    multiply(a, K + 1, b, K + 1, c, s);\n    for(int i = K + 1; i < s; i++)\n        if(c[i].x > 0.5)\n            used[(i - K + y) * 2] = 1;\n    for(int i = 1; i < M; i++)\n    {\n        if(!used[i]) continue;\n        for(int j = i; j < M; j += i)\n            dp[j] = max(dp[j], i);\n    }\n    int q;\n    scanf(\"%d\", &q);\n    for(int i = 0; i < q; i++)\n    {\n        int l;\n        scanf(\"%d\", &l);\n        printf(\"%d \", dp[l]);\n    }\n}", "interactive": false, "noSolution": false, "noTutorial": false}