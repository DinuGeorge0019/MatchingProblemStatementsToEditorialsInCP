{"link": "https://codeforces.com//contest/1202/problem/B", "problemId": "385663", "shortId": "1202B", "contest_number": "1202", "name": "B. You Are Given a Decimal String...", "statement": "Suppose you have a special --counter. This counter can store some value as a decimal number; at first, the counter has value . The counter performs the following algorithm: it prints its lowest digit and, after that, adds either  or  to its value. So all sequences this counter generates are starting from . For example, a --counter can act as follows:  it prints , and adds  to its value, so the current value is , and the output is ;  it prints , and adds  to its value, so the current value is , and the output is ;  it prints , and adds  to its value, so the current value is , and the output is ;  it prints , and adds  to its value, so the current value is , and the output is ;  it prints , and adds  to its value, so the current value is , and the output is . This is only one of the possible outputs; for example, the same counter could generate  as the output, if we chose to add  during each step.You wrote down a printed sequence from one of such --counters. But the sequence was corrupted and several elements from the sequence could be erased.Now you'd like to recover data you've lost, but you don't even know the type of the counter you used. You have a decimal string  \u2014 the remaining data of the sequence. For all , calculate the minimum number of digits you have to insert in the string  to make it a possible output of the --counter. Note that you can't change the order of digits in string  or erase any of them; only insertions are allowed.", "input": "The first line contains a single string  (, ) \u2014 the remaining data you have. It's guaranteed that .", "output": "Print a  matrix, where the -th integer (-indexed) on the -th line (-indexed too) is equal to the minimum number of digits you have to insert in the string  to make it a possible output of the --counter, or  if there is no way to do so.", "tutorial": "All you need to know to solve this task is the minimal number of steps to move from any digit  to any digit  for fixed  and  (let's denote it as ). Shortest path? BFS? Floyd? Of course, you can use it, but you can think a little harder and save nerves and time.Since order of choosing operations  and  doesn't matter for transferring from  to , so only number of -s and -s are matter. Let's denote them as  and . Since adding any fixed value  times are meaningless, so .Now you can, for each , for each , for each  iterate over all possible  and . Digit  you'd move to is equal to . Just relax value of  by .Now you can, for each  and , calculate the answer by iterating over string  by summing  (number of inserted values is less by one than number of steps).But, it will work only in C++, since the language is fast and  basic operations are executed in less than 0.5 second. But the model solution is written in Kotlin. How is it? The string  can be long, but there are only  different neighbouring digits, so you can just one time precalculate  \u2014 the number of such  that  and . And calculate the answer not by iterating over  but by multiplying  by .The result complexity is , where . But  will pass on fast languages like C++.P.S.: There are no real problem with I/O \u2014 both Python and Kotlin read one string up to  in less than 0.5 seconds.", "solution": "const val INF = 1e9.toInt()\n\nfun main(args: Array<String>) {\n    val s = readLine()!!.map { it - '0' }\n    val cf = Array(10) {Array(10) {0}}\n    for (i in 1 until s.size)\n        cf[s[i - 1]][s[i]]++\n\n    for (x in 0..9) {\n        for (y in 0..9) {\n            val ds = Array(10) {Array(10) {INF + 7}}\n\n            for (v in 0..9) {\n                for (cx in 0..9) {\n                    for (cy in 0..9) {\n                        if (cx + cy == 0)\n                            continue\n\n                        val to = (v + cx * x + cy * y) % 10\n                        ds[v][to] = minOf(ds[v][to], cx + cy)\n                    }\n                }\n            }\n\n            var res = 0\n            for (v in 0..9) {\n                for (to in 0..9) {\n                    if (ds[v][to] > INF && cf[v][to] > 0) {\n                        res = -1\n                        break\n                    }\n                    res += (ds[v][to] - 1) * cf[v][to]\n                }\n                if (res == -1)\n                    break\n            }\n\n            print(\"$res \")\n        }\n        println()\n    }\n}", "interactive": false, "noSolution": false, "noTutorial": false}