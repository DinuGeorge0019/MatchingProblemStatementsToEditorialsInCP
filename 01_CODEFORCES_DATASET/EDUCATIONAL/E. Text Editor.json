{"link": "https://codeforces.com//contest/1701/problem/E", "problemId": "1455053", "shortId": "1701E", "contest_number": "1701", "name": "E. Text Editor", "statement": "You wanted to write a text  consisting of  lowercase Latin letters. But instead, you have written a text  consisting of  lowercase Latin letters, and now you want to fix it by obtaining the text  from the text .Initially, the cursor of your text editor is at the end of the text  (after its last character). In one move, you can do one of the following actions:  press the \"left\" button, so the cursor is moved to the left by one position (or does nothing if it is pointing at the beginning of the text, i.\u2009e. before its first character);  press the \"right\" button, so the cursor is moved to the right by one position (or does nothing if it is pointing at the end of the text, i.\u2009e. after its last character);  press the \"home\" button, so the cursor is moved to the beginning of the text (before the first character of the text);  press the \"end\" button, so the cursor is moved to the end of the text (after the last character of the text);  press the \"backspace\" button, so the character before the cursor is removed from the text (if there is no such character, nothing happens). Your task is to calculate the minimum number of moves required to obtain the text  from the text  using the given set of actions, or determine it is impossible to obtain the text  from the text .You have to answer  independent test cases.", "input": "The first line of the input contains one integer  () \u2014 the number of test cases. Then  test cases follow. The first line of the test case contains two integers  and  () \u2014 the length of  and the length of , respectively. The second line of the test case contains the string  consisting of  lowercase Latin letters. The third line of the test case contains the string  consisting of  lowercase Latin letters. It is guaranteed that the sum of  over all test cases does not exceed  ().", "output": "For each test case, print one integer \u2014 the minimum number of moves required to obtain the text  from the text  using the given set of actions, or  if it is impossible to obtain the text  from the text  in the given test case.", "tutorial": "Of course, there is no need to press \"home\" more than once (and no need to press \"end\" at all), because suppose we did something on suffix, then pressed \"home\", did something on prefix and then pressed \"end\" and continue doing something on suffix. Then we can merge these two sequences of moves on suffix and press \"home\" after we did anything we wanted on suffix, and the answer will not get worse.Now, let's iterate over the position  at which we will press \"home\" (in range from  to ). In other words, we iterate over the position till which we press only \"left\" and \"backspace\" to fix the suffix. So now we have the string  and we want to get some suffix of  from this string, but we actually don't know which suffix of  we want. So let's iterate over the length of this suffix  in a range from  to . Now we have the string  and the string  and we have to check if we can obtain this suffix of  from this suffix of . This part can be precalculated in  greedily (we just can store for each suffix of  the rightmost position in  in which this suffix is obtainable). If we can obtain the current suffix, then we obviously can say the number of moves to do that \u2014 it is  and actually do not depend on the suffix length (because if we meet the character we need, we just press \"left\" and move to the next character, otherwise we press \"backspace\" and move to the next character deleting the one we don't need).After that, we press \"home\" and now we have to check if we can obtain  from . This part can also be precalculated greedily in  like the part with rightmost positions for suffixes. But the minimum number of moves required to obtain the prefix is tricky. Actually, if we consider these prefixes from right to left, we want to match as many characters from the beginning as possible. In other words, if we reverse  and , we want to find their longest common prefix, and this will be the number of characters we don't want to touch at all (and if it is the longest common prefix, it means that the next character is bad, and we want to remove it anyway, so the length of LCP of these two reversed prefixes is the only thing affecting the number of moves on the prefix). This part can be precalculated in  with simple dynamic programming (using  memory) or with z-function in  time and  memory \u2014 we just need to build a z-function on a string , where  is the concatenation of strings and  is the reverse operation. The required value of the z-function for the fixed values  and  will be in the position . And the answer for the prefix will be  (this is the number of extra characters on the prefix we have to delete) plus  plus  because we have to press \"home\". But there is a corner case. If the prefix is empty, then we don't need to do all of this and the answer for prefix will be .Complexity:  time and  memory.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector<int> zf(const string &s) {\n    int n = s.size();\n    vector<int> z(n);\n    int l = 0, r = 0;\n    for (int i = 1; i < n; ++i) {\n        if (i <= r) {\n            z[i] = min(r - i + 1, z[i - l]);\n        }\n        while (i + z[i] < n && s[z[i]] == s[i + z[i]]) {\n            ++z[i];\n        }\n        if (i + z[i] - 1 > r) {\n            l = i;\n            r = i + z[i] - 1;\n        }\n    }\n    return z;\n}\n\nint main() {\n#ifdef _DEBUG\n    freopen(\"input.txt\", \"r\", stdin);\n//  freopen(\"output.txt\", \"w\", stdout);\n#endif\n    \n    int T;\n    cin >> T;\n    while (T--) {\n        int n, m;\n        string s, t;\n        cin >> n >> m >> s >> t;\n        \n        int ans = 1e9;\n        \n        bool bad = false;\n        vector<int> lpos(m), rpos(m);\n        for (int i = 0; i < m; ++i) {\n            if (i > 0) {\n                lpos[i] = lpos[i - 1] + 1;\n            } else {\n                lpos[i] = 0;\n            }\n            while (lpos[i] < n && s[lpos[i]] != t[i]) {\n                ++lpos[i];\n            }\n            if (lpos[i] >= n) {\n                bad = true;\n                break;\n            }\n        }\n        for (int i = m - 1; i >= 0; --i) {\n            if (i + 1 < m) {\n                rpos[i] = rpos[i + 1] - 1;\n            } else {\n                rpos[i] = n - 1;\n            }\n            while (rpos[i] >= 0 && s[rpos[i]] != t[i]) {\n                --rpos[i];\n            }\n            if (rpos[i] < 0) {\n                bad = true;\n                break;\n            }\n        }\n        if (bad) {\n            cout << -1 << endl;\n            continue;\n        }\n        \n        for (int pos = 0; pos <= n; ++pos) {\n            string tmp = s.substr(0, pos);\n            reverse(tmp.begin(), tmp.end());\n            tmp += \"#\" + t;\n            reverse(tmp.begin() + pos + 1, tmp.end());\n            vector<int> z = zf(tmp);\n            for (int suf = 0; suf <= m; ++suf) {\n                if (pos - suf < 0) {\n                    continue;\n                }\n                if (suf < m && rpos[suf] < pos) {\n                    continue;\n                }\n                if (suf - 1 >= 0 && lpos[suf - 1] > pos) {\n                    continue;\n                }\n                int rg = 0;\n                if (suf != 0) {\n                    int sum = (pos - z[pos + 1 + m - suf]) + (pos - suf);\n                    rg = (sum != 0) + sum;\n                } else {\n                    rg = pos;\n                }\n                ans = min(ans, (n - pos) + rg);\n            }\n        }\n        cout << ans << endl;\n    }\n    \n    return 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}