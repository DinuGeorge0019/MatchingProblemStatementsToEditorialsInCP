{"link": "https://codeforces.com//contest/1207/problem/F", "problemId": "393976", "shortId": "1207F", "contest_number": "1207", "name": "F. Remainder Problem", "statement": "You are given an array  consisting of  integers (numbered from  to ). Initially all elements of  are zero.You have to process two types of queries to this array:    \u00a0\u2014 increase  by ;    \u00a0\u2014 compute , where  is the set of all integers from  to  which have remainder  modulo . Can you process all the queries?", "input": "The first line contains one integer  () \u2014 the number of queries. Then  lines follow, each describing a query. The -th line contains three integers ,  and  (). If , then it is a query of the first type, , and . If , then it it a query of the second type, , and . It is guaranteed that there will be at least one query of type .", "output": "For each query of type  print one integer \u2014 the answer to it.", "tutorial": "Let's notice that if we process the queries of type  naively, then each such query consumes  time (where  is the size of the array). So queries with large  can be processed naively.For queries with small  (), we may notice two things:  there are only  possible queries;  each number in the array affects only  possible queries. So, for small , we may maintain the exact answer for each query and modify it each time we modify an element in the array.If we process naively all queries with  and maintain the answers for all queries with , we will obtain a solution having time complexity . Note that, as in most problems related to sqrt-heuristics, it may be optimal to choose the constant that is not exactly , but something similar to it (but most solutions should pass without tuning the constant).", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 500043;\nconst int K = 750;\n\nint a[N];\nint sum[K][K];\n\nint main()\n{\n    int q;\n    scanf(\"%d\", &q);\n    for(int i = 0; i < q; i++)\n    {\n        int t, x, y;\n        scanf(\"%d %d %d\", &t, &x, &y);\n        if(t == 1)\n        {\n            a[x] += y;\n            for(int i = 1; i < K; i++)\n                sum[i][x % i] += y;\n        }\n        else\n        {\n            if(x >= K)\n            {\n                int ans = 0;\n                for(int i = y; i <= 500000; i += x)\n                    ans += a[i];\n                printf(\"%d\\n\", ans);\n            }\n            else\n                printf(\"%d\\n\", sum[x][y]);\n        }\n    }\n    return 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}