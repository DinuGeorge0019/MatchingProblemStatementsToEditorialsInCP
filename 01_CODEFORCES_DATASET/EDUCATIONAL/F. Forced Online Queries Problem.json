{"link": "https://codeforces.com//contest/1217/problem/F", "problemId": "404648", "shortId": "1217F", "contest_number": "1217", "name": "F. Forced Online Queries Problem", "statement": "You are given an undirected graph with  vertices numbered from  to . Initially there are no edges.You are asked to perform some queries on the graph. Let  be the answer to the latest query of the second type, it is set to  before the first such query. Then the queries are the following:   (, ) \u2014 add an undirected edge between the vertices  and  if it doesn't exist yet, otherwise remove it;   (, ) \u2014 check if there exists a path between the vertices  and , which goes only through currently existing edges, and set  to  if so and  otherwise. Good luck!", "input": "The first line contains two integer numbers  and  () \u2014 the number of vertices and the number of queries, respectively. Each of the following  lines contains a query of one of two aforementioned types. It is guaranteed that there is at least one query of the second type.", "output": "Print a string, consisting of characters '0' and '1'. The -th character should be the answer to the -th query of the second type. Therefore the length of the string should be equal to the number of queries of the second type.", "tutorial": "The problem directly tells you do solve some kind of Dynamic Connectivity Problem. You could use the online approach with Link-Cut Tree if you'd had its implementation beforehand. There is also a nice modification to the  solution of the offline version of DCP (check out the comment).I'd tell the solution which is probably the easiest to come up with and to code.Let's recall the sqrt-optimization method of solving DCP. Process blocks of queries of size  one at a time. Split the edges into two groups:   The edges which were added on queries before the block and aren't touched by the queries in the block;  the edges modified by the queries in the block. The first type of edges can be added to the graph before the block processing starts. You can use DSU for that. The second type contains no more than  edges. Maintain the list of those of them which exist in the graph. On each ask query add them to graph, then delete them. This can be done explicitly by doing DFS only over these edges and the vertices which correspond to the connected components on the edges of the first type. Implicitly doing DSU merges for these edges and rolling them back is a viable option as well (costs extra log factor but has lower constant).It's easy to see that it isn't hard to modify this solution to our problem. Let's define the edges of the first type more generally: the edges which were added on queries before the block and  touched by the queries in the block. So neither  from the add query, nor  could be of the first type. Now there might be  edges of the second type in the list. However, that doesn't make the complexity any worse.Process block the same way, rebuild the DSU with the edges of the first type every  queries.The overall complexity can be  if you use DFS or  if you use DSU (notice how the rebuild is  and the query is  and set the size of the block so that these parts are about the same).", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int BUF = 10 * 1000 * 1000 + 13;\nconst int N = 300 * 1000 + 13;\nconst int M = 300 * 1000 + 13;\nconst int P = 400;\n\nstruct query{\n\tint t, x, y;\n\tint e0, e1;\n};\n\nint n, m;\nquery q[M];\n\nint p[N], rk[N];\n\nint cnt;\nint* where[BUF];\nint val[BUF];\n\nvoid rollback(){\n\twhile (cnt > 0){\n\t\t*where[cnt - 1] = val[cnt - 1];\n\t\t--cnt;\n\t}\n}\n\nint getp(int a){\n\treturn (a == p[a] ? a : getp(p[a]));\n}\n\nvoid unite(int a, int b){\n\ta = getp(a), b = getp(b);\n\tif (a == b) return;\n\tif (rk[a] < rk[b]) swap(a, b);\n\twhere[cnt] = &rk[a];\n\tval[cnt++] = rk[a];\n\twhere[cnt] = &p[b];\n\tval[cnt++] = p[b];\n\tassert(cnt <= BUF);\n\trk[a] += rk[b];\n\tp[b] = a;\n}\n\nint getpFast(int a){\n\treturn (a == p[a] ? a : p[a] = getpFast(p[a]));\n}\n\nvoid uniteFast(int a, int b){\n\ta = getpFast(a), b = getpFast(b);\n\tif (a == b) return;\n\tif (rk[a] < rk[b]) swap(a, b);\n\trk[a] += rk[b];\n\tp[b] = a;\n}\n\nstruct edge{\n\tint v, u;\n};\n\nbool operator <(const edge &a, const edge &b){\n\tif (a.v != b.v)\n\t\treturn a.v < b.v;\n\treturn a.u < b.u;\n}\n\nedge edges[2 * M];\nmap<edge, int> rev;\n\nbool used[2 * M];\nbool state[2 * M];\nint ans[M];\nvector<int> cur;\n\nvoid rebuild(int l){\n\tint r = min(m, l + P);\n\tforn(i, n) p[i] = i, rk[i] = 1;\n\tmemset(used, 0, sizeof(used));\n\tmemset(state, 0, sizeof(state));\n\n\tforn(i, l) if (q[i].t == 1){\n\t\tint e = (ans[i] ? q[i].e1 : q[i].e0);\n\t\tused[e] = true;\n\t\tstate[e] ^= 1;\n\t}\n\t\n\tfor (int i = l; i < r; ++i) if (q[i].t == 1)\n\t\tused[q[i].e0] = used[q[i].e1] = false;\n\t\n\tcur.clear();\n\tcnt = 0;\n\tforn(i, l) if (q[i].t == 1){\n\t\tint e = (ans[i] ? q[i].e1 : q[i].e0);\n\t\tif (used[e] && state[e]){\n\t\t\tstate[e] = false;\n\t\t\tuniteFast(edges[e].v, edges[e].u);\n\t\t}\n\t\telse if (!used[e] && state[e]){\n\t\t\tstate[e] = false;\n\t\t\tcur.push_back(e);\n\t\t}\n\t}\n}\n\nint get_edge(edge e){\n\tif (!rev.count(e)){\n\t\tint k = rev.size();\n\t\tedges[k] = e;\n\t\trev[e] = k;\n\t}\n\treturn rev[e];\n}\n\nint main(){\n\tscanf(\"%d%d\", &n, &m);\n\tforn(i, m){\n\t\tscanf(\"%d%d%d\", &q[i].t, &q[i].x, &q[i].y);\n\t\t--q[i].x, --q[i].y;\n\t\tif (q[i].t == 1){\n\t\t\tedge e({q[i].x, q[i].y});\n\t\t\tif (e.v > e.u) swap(e.v, e.u);\n\t\t\tq[i].e0 = get_edge(e);\n\t\t\te.v = (e.v + 1) % n, e.u = (e.u + 1) % n;\n\t\t\tif (e.v > e.u) swap(e.v, e.u);\n\t\t\tq[i].e1 = get_edge(e);\n\t\t}\n\t}\n\t\n\tstring res = \"\";\n\tans[0] = 0;\n\tforn(i, m){\n\t\tif (i % P == 0)\n\t\t\trebuild(i);\n\t\t\n\t\tint x = (q[i].x + ans[i]) % n;\n\t\tint y = (q[i].y + ans[i]) % n;\n\t\tif (x > y) swap(x, y);\n\t\t\n\t\tif (q[i].t == 1){\n\t\t\trollback();\n\t\t\tint e = get_edge({x, y});\n\t\t\tauto it = find(cur.begin(), cur.end(), e);\n\t\t\tif (it == cur.end())\n\t\t\t\tcur.push_back(e);\n\t\t\telse\n\t\t\t\tcur.erase(it);\n\t\t\tans[i + 1] = ans[i];\n\t\t}\n\t\telse{\n\t\t\tfor (auto e : cur)\n\t\t\t\tunite(edges[e].v, edges[e].u);\n\t\t\tbool rc = (getp(x) == getp(y));\n\t\t\tans[i + 1] = rc;\n\t\t\tres += ('0' + rc);\n\t\t}\n\t}\n\t\n\tputs(res.c_str());\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}