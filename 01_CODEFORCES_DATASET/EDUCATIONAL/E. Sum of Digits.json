{"link": "https://codeforces.com//contest/1373/problem/E", "problemId": "657374", "shortId": "1373E", "contest_number": "1373", "name": "E. Sum of Digits", "statement": "Let  be the sum of digits of a decimal number .Find the smallest non-negative integer  such that .", "input": "The first line contains one integer  () \u2014 the number of test cases. Each test case consists of one line containing two integers  and  (, ). ", "output": "For each test case, print one integer without leading zeroes. If there is no such  that , print ; otherwise, print the minimum  meeting that constraint.", "tutorial": "There are many ways to solve this problem (including precalculating all answers), but the model solution is based on the following:In most cases, . It is not true only when the last digit of  is  (and if we know the number of -digits at the end of , we can easily derive the formula for ). And since , there will be at most one number with last digit equal to  in .Let's iterate on the last digit of  and the number of -digits before it. Suppose the fixed  has no other digits other than the last one and several -digits before it. Let's calculate .Here goes the trick. If we prepend  with several digits such that the last of them is not , and the sum of those digits is , then . So we can easily derive the value of  we need and construct the smallest number with sum of digits equal to  (don't forget that the last digit should not be ).", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint n, k;\n\nbool decimalLess(const string& s, const string& t)\n{\n\tif(s.size() != t.size())\n\t\treturn s.size() < t.size();\n\tfor(int i = 0; i < s.size(); i++)\n\t\tif(s[i] != t[i])\n\t\t\treturn s[i] < t[i];\n\treturn false;\n}\n\nvoid upd(string& ans, const string& cur)\n{\n\tif(ans == \"-1\" || decimalLess(cur, ans))\n\t\tans = cur;\n}\n\nvoid read()\n{\n\tcin >> n >> k;\n}\n\nvoid solve()\n{\n\tstring ans = \"-1\";\n\tfor(int i = 0; i <= 9; i++)\n\t{\n\t\tint cnt9 = n / 9;\n\t\tif(i + k < 10)\n\t\t\tcnt9 = 0;\n\t\tfor(int j = 0; j <= cnt9; j++)\n\t\t{\n\t\t    if(i + k >= 10 && j == 0)\n\t\t        continue;\n\t\t\tint curSum = (i + (i + k)) * (k + 1) / 2;\n\t\t\tif(j != 0)\n\t\t\t{\n\t\t\t\tint cntBefore = 10 - i;\n\t\t\t\tint cntAfter = k + 1 - cntBefore;\n\t\t\t\tcurSum = (i + 9) * cntBefore / 2 + cntBefore * 9 * (j - 1) + (1 + cntAfter) * cntAfter / 2;\n\t\t\t}\n\t\t\tcurSum = n - curSum;\n\t\t\tif(curSum < 0 || curSum % (k + 1) != 0)\n\t\t\t\tcontinue;\n\t\t\tstring curNum = {char('0' + i)};\n\t\t\tfor(int z = 0; z < j - 1; z++)\n\t\t\t\tcurNum += \"9\";\n\t\t\tint maxNum = 9;\n\t\t\tif(i + k >= 10)\n\t\t\t\tmaxNum = 8;\n\t\t\tcurSum /= (k + 1);\n\t\t\twhile(curSum != 0)\n\t\t\t{\n\t\t\t\tint d = min(curSum, maxNum);\n\t\t\t\tmaxNum = 9;\n\t\t\t\tcurSum -= d;\n\t\t\t\tcurNum.push_back(char('0' + d));\n\t\t\t}\n\t\t\treverse(curNum.begin(), curNum.end());\n\t\t\tupd(ans, curNum);\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n\nint main()\n{\n\tint t;\n\tcin >> t;\n\tfor(int i = 0; i < t; i++)\n\t{\n\t\tread();\n\t\tsolve();\n\t}\n}", "interactive": false, "noSolution": false, "noTutorial": false}