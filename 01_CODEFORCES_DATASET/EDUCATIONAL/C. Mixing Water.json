{"link": "https://codeforces.com//contest/1359/problem/C", "problemId": "634674", "shortId": "1359C", "contest_number": "1359", "name": "C. Mixing Water", "statement": "There are two infinite sources of water:  hot water of temperature ;  cold water of temperature  (). You perform the following procedure of alternating moves:  take  cup of the  water and pour it into an infinitely deep barrel;  take  cup of the  water and pour it into an infinitely deep barrel;  take  cup of the  water   and so on  .The barrel is initially empty. You have to pour  into the barrel. The water temperature in the barrel is an average of the temperatures of the poured cups.You want to achieve a temperature as close as possible to . So if the temperature in the barrel is , then the  of  and  () should be as small as possible.How many cups should you pour into the barrel, so that the temperature in it is as close as possible to ? If there are multiple answers with the minimum absolute difference, then print the smallest of them.", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of testcases. Each of the next  lines contains three integers ,  and  (; )\u00a0\u2014 the temperature of the hot water, the temperature of the cold water and the desired temperature in the barrel.", "output": "For each testcase print a single positive integer\u00a0\u2014 the minimum number of cups required to be poured into the barrel to achieve the closest temperature to .", "tutorial": "Alice wants to choose such a segment  that  is maximum possible. There is a well-known problem where you have to find a segment with maximum . That problem is solved with Kadane algorithm. Let's learn how to reduce our problem to that one.Notice that the values in the array are unusually small. Let's iterate over the maximum value on segment. Let  be the current value. If we make all  such that  equal to , then it will never be optimal to take them in a segment. Find the maximum sum subarray in that modified array and update the answer with its .Notice that you can ignore the fact if there is a value exactly equal to  on the maximum sum segment. If there isn't then you'll update the answer with a smaller value than the actual one. Let the actual maximum on the maximum sum segment be some . You can see that for any value between  and  the maximum sum segment will always be that chosen one. Thus, when you reach , you'll update the answer with the correct value.Overall complexity: .", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\n\nint main() {\n\tint tc;\n\tscanf(\"%d\", &tc);\n\tforn(_, tc){\n\t\tint h, c, t;\n\t\tscanf(\"%d%d%d\", &h, &c, &t);\n\t\tif (h + c - 2 * t >= 0)\n\t\t\tputs(\"2\");\n\t\telse{\n\t\t\tint a = h - t;\n\t\t\tint b = 2 * t - c - h;\n\t\t\tint k = 2 * (a / b) + 1;\n\t\t\tlong long val1 = abs(k / 2 * 1ll * c + (k + 1) / 2 * 1ll * h - t * 1ll * k);\n\t\t\tlong long val2 = abs((k + 2) / 2 * 1ll * c + (k + 3) / 2 * 1ll * h - t * 1ll * (k + 2));\n\t\t\tprintf(\"%d\\n\", val1 * (k + 2) <= val2 * k ? k : k + 2);\n\t\t}\n\t}\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}