{"link": "https://codeforces.com//contest/1278/problem/F", "problemId": "498935", "shortId": "1278F", "contest_number": "1278", "name": "F. Cards", "statement": "Consider the following experiment. You have a deck of  cards, and exactly one card is a joker.  times, you do the following: shuffle the deck, take the top card of the deck, look at it and return it into the deck.Let  be the number of times you have taken the joker out of the deck during this experiment. Assuming that every time you shuffle the deck, all  possible permutations of cards are equiprobable, what is the expected value of ? Print the answer modulo .", "input": "The only line contains three integers ,  and  (, ).", "output": "Print one integer \u2014 the expected value of , taken modulo  (the answer can always be represented as an irreducible fraction , where ; you have to print ).", "tutorial": "1278F - CardsFirst of all, I would like to thank Errichto for his awesome lecture on expected value: part 1, part 2. This problem was invented after I learned the concept of estimating the square of expected value from that lecture \u2014 and the editorial uses some ideas that were introduced there.Okay, now for the editorial itself. We call a number  as good if , and the -th shuffle of the deck resulted in a joker on top.  from our problem is the number of such good numbers . We can represent  as the number of pairs  such that every element of the pair is a good number,  as the number of triples, and so on \u2014  is the number of -tuples  such that each element of a tuple is a good number.So we can rewrite the expected value of  as the expected number of such tuples, or the sum of  over all tuples , where  is the probability that  consists of good numbers. How to calculate the probability that  is a good tuple? Since all shuffles of the deck result in a joker with probability ,  should be equal to  \u2014 but that is true only if all elements in  are unique. How to deal with tuples with repeating elements? Since all occurences of the same element are either good or bad (with probability  of being good), the correct formula for  is , where  is the number of distinct elements in the tuple.Okay, then for each  we have to calculate the number of -tuples with exactly  distinct elements. To do that, we use dynamic programming: let  be the number of -tuples with exactly  distinct elements. Each transition in this dynamic programming solution models adding an element to the tuple; if we want to compute the transitions leading from , we either add a new element to the tuple (there are  ways to choose it, and we enter the state ), or we add an already existing element (there are  ways to choose it, and we enter the state ).Overall complexity is  or , depending on your implementation.", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int MOD = 998244353;\nconst int N = 5043;\n\nint add(int x, int y)\n{\n\tx += y;\n\twhile(x >= MOD) x -= MOD;\n\twhile(x < 0) x += MOD;\n\treturn x;\n}\n\nint mul(int x, int y)\n{\n\treturn (x * 1ll * y) % MOD;\n}\n\nint binpow(int x, int y)\n{\n\tint z = 1;\n\twhile(y > 0)\n\t{\n\t\tif(y % 2 == 1)\n\t\t\tz = mul(z, x);\n\t\tx = mul(x, x);\n\t\ty /= 2;\n\t}\n\treturn z;\n}\n\nint inv(int x)\n{\n\treturn binpow(x, MOD - 2);\n}\n\nint n, m, k;\n\nint dp[N][N];\n\nint main()\n{\n\tcin >> n >> m >> k;\n\tdp[0][0] = 1;\n\tfor(int i = 0; i < k; i++)\n\t\tfor(int j = 0; j < k; j++)\n\t\t{\n\t\t\tdp[i + 1][j] = add(dp[i + 1][j], mul(dp[i][j], j));\n\t\t\tdp[i + 1][j + 1] = add(dp[i + 1][j + 1], mul(dp[i][j], n - j));\n\t\t}\n\tint ans = 0;\n\tfor(int i = 1; i <= k; i++)\n\t\tans = add(ans, mul(dp[k][i], binpow(inv(m), i)));\n\tcout << ans << endl;\n}", "interactive": false, "noSolution": false, "noTutorial": false}