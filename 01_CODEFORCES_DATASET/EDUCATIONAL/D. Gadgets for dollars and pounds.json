{"link": "https://codeforces.com//contest/609/problem/D", "problemId": "43547", "shortId": "609D", "contest_number": "609", "name": "D. Gadgets for dollars and pounds", "statement": "Nura wants to buy  gadgets. She has only  burles for that. She can buy each gadget for dollars or for pounds. So each gadget is selling only for some type of currency. The type of currency and the cost in that currency are not changing.Nura can buy gadgets for  days. For each day you know the exchange rates of dollar and pound, so you know the cost of conversion burles to dollars or to pounds.Each day (from  to ) Nura can buy some gadgets by current exchange rate. Each day she can buy any gadgets she wants, but each gadget can be bought no more than once during  days.Help Nura to find the minimum day index when she will have  gadgets. Nura always pays with burles, which are converted according to the exchange rate of the purchase day. Nura can't buy dollars or pounds, she always stores only burles. Gadgets are numbered with integers from  to  in order of their appearing in input.", "input": "First line contains four integers  () \u2014 number of days, total number and required number of gadgets, number of burles Nura has. Second line contains  integers  () \u2014 the cost of one dollar in burles on -th day. Third line contains  integers  () \u2014 the cost of one pound in burles on -th day. Each of the next  lines contains two integers  () \u2014 type of the gadget and it's cost. For the gadgets of the first type cost is specified in dollars. For the gadgets of the second type cost is specified in pounds.", "output": "If Nura can't buy  gadgets print the only line with the number . Otherwise the first line should contain integer  \u2014 the minimum day index, when Nura will have  gadgets. On each of the next  lines print two integers  \u2014 the number of gadget and the day gadget should be bought. All values  should be different, but the values  can coincide (so Nura can buy several gadgets at one day). The days are numbered from  to . In case there are multiple possible solutions, print any of them.", "tutorial": "If Nura can buy k gadgets in x days then she can do that in x\u2009+\u20091 days. So the function of answer is monotonic. So we can find the minimal day with binary search. Denote lf\u2009=\u20090 \u2014 the left bound of binary search and rg\u2009=\u2009n\u2009+\u20091 \u2014 the right one. We will maintain the invariant that in left bound we can't buy k gadgets and in right bound we can do that. Denote function f(d) equals to 1 if we can buy k gadgets in d days and 0 otherwise. As usual in binary search we will choose . If f(d)\u2009=\u20091 then we should move the right bound rg\u2009=\u2009d and the left bound lf\u2009=\u2009d in other case. If binary search found the value lf\u2009=\u2009n\u2009+\u20091 then the answer is \u2009-\u20091, otherwise the answer is lf. Before binary search we can create two arrays of gadgets which are selling for dollars and pounds, and sort them. Easy to see that we should buy gadgets for dollars on day i\u2009\u2264\u2009d when dollar costs as small as possible and j\u2009\u2264\u2009d when pounds costs as small as possible. Let now we want to buy x gadgets for dollars and k\u2009-\u2009x gadgets for pounds. Of course we will buy the least cheap of them (we already sort the arrays for that). Let's iterate over x from 0 to k and maintain the sum of gadgets for dollars s1 and the sum of gadgets for pounds s2. For x\u2009=\u20090 we can calculate the sums in O(k). For other x's we can recalculate the sums in O(1) time from the sums for x\u2009-\u20091 by adding gadget for dollars and removing gadget for pounds.\nComplexity: O(klogn).\n", "solution": "/*\nThe basement incinerator\nIs where they'll put the head\nHose the floor and clean the room\nAnywhere they bled\n\nInto boxes go the bags\nFill the space with rocks\nIn the dark of night\nHe throws them off the docks\n\nRotting in the river\nNever to be found\nUnder tons of concrete\nDeep beneath the ground\n\nFrom behind, he grabs his mouth\nThe blade goes to his neck\nBulging veins pumping blood\nHe struggles to protect\n\nIf you don't cut open the stomach\nThe corpse will rise and float\nThe victim is discovered dead\nRotting organs bloat\n\nThe killer chops the body\nWith a scalpel and an axe\nThe parts are then drained\nAnd put into the sacks\n\nGrab the neck, slit the throat, take the life\nHang the corpse, prepare to drain the blood\nBone saw, meat cleaver, filleting knife\nCarve the corpse, dissect him in the tub\n\nSmash the teeth, slice off scars, crush the bones\nWith a crowbar scrape off all tattoos\n\nIf you don't cut open the stomach\nThe corpse will rise and float\nThe victim is discovered dead\nRotting organs bloat\n\nThe killer chops the body\nWith a scalpel and an axe\nThe parts are then drained\nAnd put into the sacks\n\nChunks of a skull\nSawn in half bones\nBody is found\nKiller unknown\n*/\n\n//#pragma comment(linker, \"/STACK:16777216\")\n#define _CRT_SECURE_NO_WARNINGS\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <complex>\n#include <math.h>\n#include <set>\n#include <vector>\n#include <map>  \n#include <queue>\n#include <stdio.h>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <ctime>\n#include <memory.h>\n#include <ctime> \n#include <assert.h>\n\n#define y0 sdkfaslhagaklsldk\n#define y1 aasdfasdfasdf\n#define yn askfhwqriuperikldjk\n#define j1 assdgsdgasghsf\n#define tm sdfjahlfasfh\n#define lr asgasgash\n\n#define eps 1e-8\n#define M_PI 3.141592653589793\n#define bs 1234567891\n#define bsize 512\n\nconst int N = 210000;\n\nusing namespace std;\n\nvector < pair<long long, pair<int, int> > >v;\nint l, r;\nint cheap1, cheap2;\nint a[N], b[N];\nint tp[N];\nint c[N];\nint n, m, k, s;\n\nbool good(int l)\n{\n\tv.clear();\n\n\tcheap1 = 1;\n\tcheap2 = 1;\n\tfor (int i = 1; i <= l; i++)\n\t{\n\t\tif (a[i] < a[cheap1])\n\t\t\tcheap1 = i;\n\t\tif (b[i] < b[cheap2])\n\t\t\tcheap2 = i;\n\t}\n\n\tfor (int i = 1; i <= m; i++)\n\t{\n\t\tif (tp[i] == 1)\n\t\t{\n\t\t\tv.push_back(make_pair(1ll * a[cheap1] * c[i], make_pair(i, cheap1)));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tv.push_back(make_pair(1ll * b[cheap2] * c[i], make_pair(i, cheap2)));\n\t\t}\n\t}\n\tsort(v.begin(), v.end());\n\tlong long need = 0;\n\tfor (int i = 0; i < k; i++)\n\t\tneed += v[i].first;\n\treturn (need <= s);\n}\n\nint main(){\n\t//freopen(\"beavers.in\",\"r\",stdin);\n\t//freopen(\"beavers.out\",\"w\",stdout);\n\t//freopen(\"F:/in.txt\",\"r\",stdin);\n\t//freopen(\"F:/output.txt\",\"w\",stdout);\n\t//ios_base::sync_with_stdio(0);\n\t//cin.tie(0);\n\n\tcin >> n >> m >> k >> s;\n\n\tfor (int i = 1; i <= n; i++)\n\t\tcin >> a[i];\n\tfor (int i = 1; i <= n; i++)\n\t\tcin >> b[i];\n\n\tfor (int i = 1; i <= m; i++)\n\t{\n\t\tcin >> tp[i] >> c[i];\n\t}\n\n\tl = 1;\n\tr = n + 1;\n\twhile (l < r)\n\t{\n\t\tint mid = l + r;\n\t\tmid /= 2;\n\t\tif (good(mid))\n\t\t\tr = mid;\n\t\telse\n\t\t\tl = mid+1;\n\t}\n\n\tif (l == n + 1)\n\t{\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\n\tcout << l << endl;\n\n\tgood(l);\n\tfor (int i = 0; i < k; i++)\n\t{\n\t\tcout << v[i].second.first << \" \" << v[i].second.second << \"\\n\";\n\t}\n\n\tcin.get();\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}