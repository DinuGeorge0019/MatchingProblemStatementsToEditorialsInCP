{"link": "https://codeforces.com//contest/911/problem/E", "problemId": "142499", "shortId": "911E", "contest_number": "911", "name": "E. Stack Sorting", "statement": "Let's suppose you have an array , a stack  (initially empty) and an array  (also initially empty).You may perform the following operations until both  and  are empty:  Take the first element of , push it into  and remove it from  (if  is not empty);  Take the top element from , append it to the end of array  and remove it from  (if  is not empty). You can perform these operations in arbitrary order.If there exists a way to perform the operations such that array  is sorted in non-descending order in the end, then array  is called .For example,  is , because  will be sorted if we perform the following operations:  Remove  from  and push it into ;  Remove  from  and push it into ;  Remove  from  and append it to the end of ;  Remove  from  and push it into ;  Remove  from  and append it to the end of ;  Remove  from  and append it to the end of . After all these operations , so  is .  is not .You are given  first elements of some permutation  of size  (recall that a permutation of size  is an array of size  where each integer from  to  occurs exactly once). You have to restore the remaining  elements of this permutation so it is . If there are multiple answers, choose the answer such that  is lexicographically maximal (an array  is lexicographically greater than an array  iff there exists some integer  such that for every  , and ). .Print the lexicographically maximal permutation  you can obtain.If there exists no answer then output .", "input": "The first line contains two integers  and  (, ) \u2014 the size of a desired permutation, and the number of elements you are given, respectively. The second line contains  integers , , ...,  () \u2014 the first  elements of . These integers are pairwise distinct.", "output": "If it is possible to restore a  permutation  of size  such that the first  elements of  are equal to elements given in the input, print lexicographically maximal such permutation. Otherwise print .", "tutorial": "Let's denote  as some stack-sortable array which contains all integers from  to  (inclusive).We can see that if the first element of  is , then , where by  we mean concatenation of arrays. It's easy to prove this fact: if the first element is , then we have to store it in the stack until we have processed all elements less than , so in  no element that is greater than  can precede any element less than .This way we can represent the prefix we are given. For example, if ,  and prefix is , then we can rewrite the permutation we have to obtain as:.So the unknown suffix is a contatenation of some stack-sortable arrays. It's easy to see that if an array is sorted in non-increasing order, then it is stack-sortable. So we can replace each block  with an array .If during rewriting the given prefix we obtain some impossible situation (for example, when  and given prefix is , we have  and  can't be the beginning of ), then answer is .", "solution": "#include <bits/stdc++.h>\n#ifndef ONLINE_JUDGE\n# include <sys/time.h>\n# include <sys/resource.h>\n#endif\n\n/*** TEMPLATE CODE STARTS HERE ***/\n\n#ifndef M_PI\n#define M_PI 3.1415926535897932384626433832795028841971693993751\n#endif\n\nusing namespace std;\n\ntypedef vector<string> vs;\ntypedef long long ll;\ntypedef complex<double> pnt;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n#define RA(x) begin(x), end(x)\n#define FE(i, x) for (auto i = begin(x); i != end(x); ++i)\n#define SZ(x) ((ll) (x).size())\n\ntemplate<class T>\nvoid splitstr(const string &s, vector<T> &out)\n{\n    istringstream in(s);\n    out.clear();\n    copy(istream_iterator<T>(in), istream_iterator<T>(), back_inserter(out));\n}\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\n\nstatic void redirect(int argc, const char **argv)\n{\n#ifndef ONLINE_JUDGE\n    struct rlimit rlim;\n    getrlimit(RLIMIT_STACK, &rlim);\n    rlim.rlim_cur = 256 * 1024 * 1024;\n    setrlimit(RLIMIT_STACK, &rlim);\n#ifndef __SANITIZE_ADDRESS__\n    getrlimit(RLIMIT_DATA, &rlim);\n    rlim.rlim_cur = 256 * 1024 * 1024;\n    setrlimit(RLIMIT_DATA, &rlim);\n#endif\n#endif\n\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n    if (argc > 1)\n    {\n        static filebuf f;\n        f.open(argv[1], ios::in);\n        cin.rdbuf(&f);\n        if (!cin)\n        {\n            cerr << \"Failed to open '\" << argv[1] << \"'\" << endl;\n            exit(1);\n        }\n    }\n\n    if (argc > 2)\n    {\n        static filebuf f;\n        f.open(argv[2], ios::out | ios::trunc);\n        cout.rdbuf(&f);\n        if (!cout)\n        {\n            cerr << \"Failed to open '\" << argv[2] << \"'\" << endl;\n        }\n    }\n}\n\n/*** TEMPLATE CODE ENDS HERE */\n\nstatic void no()\n{\n    cout << \"-1\\n\";\n    exit(0);\n}\n\nint main(int argc, const char **argv)\n{\n    redirect(argc, argv);\n    int N, K;\n    cin >> N >> K;\n    vi a(N);\n    int out = 0;\n    set<int> miss;\n    for (int i = 0; i < N; i++)\n        miss.insert(i);\n    for (int i = 0; i < K; i++)\n    {\n        cin >> a[i];\n        a[i]--;\n        miss.erase(a[i]);\n    }\n    stack<int> s;\n    for (int i = 0; i < K; i++)\n    {\n        while (!s.empty() && s.top() < a[i])\n        {\n            if (s.top() != out)\n                no();\n            s.pop();\n            out++;\n        }\n        s.push(a[i]);\n    }\n\n    for (int i = K; i < N; i++)\n    {\n        while (!s.empty() && s.top() == out)\n        {\n            s.pop();\n            out++;\n        }\n        int limit = s.empty() ? INT_MAX / 2 : s.top();\n        auto it = prev(miss.lower_bound(limit));\n        s.push(*it);\n        a[i] = *it;\n        miss.erase(it);\n    }\n\n    for (int i = 0; i < N; i++)\n        cout << a[i] + 1 << ' ';\n    cout << '\\n';\n\n    return 0;\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}