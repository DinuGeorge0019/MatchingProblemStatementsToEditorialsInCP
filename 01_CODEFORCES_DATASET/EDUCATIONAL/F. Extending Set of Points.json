{"link": "https://codeforces.com//contest/1140/problem/F", "problemId": "317589", "shortId": "1140F", "contest_number": "1140", "name": "F. Extending Set of Points", "statement": "For a given set of two-dimensional points , let's denote its extension  as the result of the following algorithm:Create another set of two-dimensional points , which is initially equal to . Then, while there exist four numbers , ,  and  such that , ,  and , add  to . When it is impossible to find such four integers, let  be the result of the algorithm.Now for the problem itself. You are given a set of two-dimensional points , which is initially empty. You have to process two types of queries: add some point to , or remove some point from it. After each query you have to compute the size of .", "input": "The first line contains one integer  () \u2014 the number of queries. Then  lines follow, each containing two integers ,  (), denoting -th query as follows: if , erase it from , otherwise insert  into .", "output": "Print  integers. -th integer should be equal to the size of  after processing first  queries.", "tutorial": "Let's try to analyze how the size of  can be calculated. Let's connect points having same -coordinates to each other, and do the same for points having same -coordinates. Then we can solve the problem for each component separatedly: after the algorithm is run, the component will contain the points  such that at least one point in the component has -coordinate equal to , and at least one point in the component (maybe same, maybe another one) has -coordinate equal to . So the answer for each component is the product of the number of distinct -coordinates and the number of distinct -coordinates in the component. Now we can process insertion queries: there are many ways to do it, but, in my opinion, the easiest way to handle them is to create a separate vertex for every -coordinate and -coordinate, and process each point as an edge connecting vertices corresponding to its coordinates (edges can be easily added by using DSU with rank heuristics).To handle removals, we will get rid of them completely. Transform the input into a set of  events \"some point exists from query  to query \". Then build a segment tree over queries, and break each event into  segments with this segment tree. Then we can initialize a DSU, and run DFS on the vertices of the segment tree to get answers for all queries. When we enter some node, we add all edges that exist on the corresponding segment into DSU. If we are in a leaf node, we may compute the  for the corresponding query. And when we leave a vertex, we can rollback all changes we made when we entered it. One important moment is that using path compression in DSU here is meaningless since it doesn't work with rollbacks well.This solution works in .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long li;\n\n#define x first\n#define y second\n\nconst int N = 300043;\nconst int K = 300000;\n\nint p[2 * N];\nint s1[2 * N];\nint s2[2 * N];\nli ans = 0;\n\nint* where[80 * N];\nint val[80 * N];\nint cur = 0;\n\nvoid change(int& x, int y)\n{\n\twhere[cur] = &x;\n\tval[cur] = x;\n\tx = y;\n\tcur++;\n}\n\nvoid rollback()\n{\n\tcur--;\n\t(*where[cur]) = val[cur];\n}\n\nint get(int x)\n{\n\tif(p[x] == x)\n\t\treturn x;\n\treturn get(p[x]);\n}\n\nvoid merge(int x, int y)\n{\n\tx = get(x);\n\ty = get(y);\n\tif(x == y) return;\n\tans -= s1[x] * 1ll * s2[x];\n\tans -= s1[y] * 1ll * s2[y];\n\tif(s1[x] + s2[x] < s1[y] + s2[y])\n\t\tswap(x, y);\n\tchange(p[y], x);\n\tchange(s1[x], s1[x] + s1[y]);\n\tchange(s2[x], s2[x] + s2[y]);\n\tans += s1[x] * 1ll * s2[x];\n}\n\nvoid init()\n{\n\tfor(int i = 0; i < K; i++)\n\t{\n\t\tp[i] = i;\n\t\tp[i + K] = i + K;\n\t\ts1[i] = 1;\n\t\ts2[i + K] = 1;\n\t}\n}\n\nvector<pair<int, int> > T[4 * N];\n\nvoid add(int v, int l, int r, int L, int R, pair<int, int> val)\n{\n\tif(L >= R) return;\n\tif(L == l && R == r)\n\t\tT[v].push_back(val);\n\telse\n\t{\n\t\tint m = (l + r) / 2;\n\t\tadd(v * 2 + 1, l, m, L, min(R, m), val);\n\t\tadd(v * 2 + 2, m, r, max(m, L), R, val);\n\t}\n}\n\nli res[N];\n\nvoid dfs(int v, int l, int r)\n{\n\tli last_ans = ans;\n\tint state = cur;\n\tfor(auto x : T[v])\n\t\tmerge(x.x, x.y + K);\n\tif(l == r - 1)\n\t\tres[l] = ans;\n\telse\n\t{\n\t\tint m = (l + r) / 2;\n\t\tdfs(v * 2 + 1, l, m);\n\t\tdfs(v * 2 + 2, m, r);\n\t}\n\twhile(cur != state) rollback();\n\tans = last_ans;\n}\n\nint main()\n{\n\tint q;\n\tscanf(\"%d\", &q);\n\tmap<pair<int, int>, int> last;\n\tfor(int i = 0; i < q; i++)\n\t{\n\t\tint x, y;\n\t\tscanf(\"%d %d\", &x, &y);\n\t\t--x;\n\t\t--y;\n\t\tpair<int, int> p = make_pair(x, y);\n\t\tif(last.count(p))\n\t\t{\n\t\t\tadd(0, 0, q, last[p], i, p);\n\t\t\tlast.erase(p);\n\t\t}\n\t\telse\n\t\t\tlast[p] = i;\n\t}\n\tfor(auto x : last)\n\t\tadd(0, 0, q, x.y, q, x.x);\n\tinit();\n\tdfs(0, 0, q);\n\tfor(int i = 0; i < q; i++)\n\t\tprintf(\"%I64d \", res[i]);\n}", "interactive": false, "noSolution": false, "noTutorial": false}