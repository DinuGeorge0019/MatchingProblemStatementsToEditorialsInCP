{"link": "https://codeforces.com//contest/1278/problem/E", "problemId": "498934", "shortId": "1278E", "contest_number": "1278", "name": "E. Tests for problem D", "statement": "We had a really tough time generating tests for problem D. In order to prepare strong tests, we had to solve the following problem.Given an undirected labeled tree consisting of  vertices, find a set of segments such that:  both endpoints of each segment are integers from  to , and each integer from  to  should appear as an endpoint of exactly one segment;  all segments are non-degenerate;  for each pair  such that ,  and , the vertices  and  are connected with an edge if and only if the segments  and  intersect, but neither segment  is fully contained in segment , nor segment  is fully contained in segment . Can you solve this problem too?", "input": "The first line contains one integer  () \u2014 the number of vertices in the tree. Then  lines follow, each containing two integers  and  (, ) denoting the endpoints of the -th edge. It is guaranteed that the given graph is a tree.", "output": "Print  pairs of integers, the -th pair should contain two integers  and  () \u2014 the endpoints of the -th segment. All  integers you print should be unique. It is guaranteed that the answer always exists.", "tutorial": "For each vertex, we will build the following structure for its children: the segment for the second child is nested in the segment for the first child, the nested for the third child is nested in the segment for the second child, and so on; and the children of different vertices do not intersect at all.Let's solve the problem recursively: for each of the children, create a set of segments with endpoints from  to , where  is the size of the subtree. After that, combine them. To do this, you can use small-to-large technique and change the coordinates of the segments or use the necessary offset in the function call for the next child.After that, it remains to cross children's segments with the segment of the vertex itself. To do this, you can move the right ends of all segments of the children by  to the right, and add a segment that starts before the first one and ends immediately after the last one.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n#define pb push_back\n#define mp make_pair\n#define all(a) (a).begin(), (a).end()\n#define sz(a) int((a).size())\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\ntypedef pair<int, int> pt;\n\nconst int N = 500 * 1000 + 13;\n\nint n;\nvector<int> g[N], vs[N];\npt segs[N];\n\nvoid dfs(int v, int p = -1) {\n\tint sum = 0;\n\tint bst = -1;\n\tfor (auto to : g[v]) if (to != p) {\n\t\tdfs(to, v);\n\t\tsum += 2 * sz(vs[to]);\n\t\tif (bst == -1 || sz(vs[to]) > sz(vs[bst]))\n\t\t\tbst = to;\n\t}\n\t\n\tif (bst == -1) {\n\t\tvs[v].pb(v);\n\t\tsegs[v] = mp(1, 2);\n\t\treturn;\n\t}\n\t\n\tswap(vs[v], vs[bst]);\n\tint lst = segs[bst].y;\n\t\n\tsum -= 2 * sz(vs[v]);\n\tsum += 1;\n\tsegs[bst].y += sum;\n\t\n\tfor (auto to : g[v]) if (to != p && to != bst) {\n\t\tint add = lst - 1;\n\t\tfor (auto u : vs[to]) {\n\t\t\tsegs[u].x += add;\n\t\t\tsegs[u].y += add;\n\t\t\tvs[v].pb(u);\n\t\t}\n\t\tlst = segs[to].y;\n\t\tsum -= 2 * sz(vs[to]);\n\t\tsegs[to].y += sum;\n\t\tvs[to].clear();\n\t}\n\t\n\tvs[v].pb(v);\n\tsegs[v] = mp(lst, segs[bst].y + 1);\n}\t\n\nint main() {\n\tscanf(\"%d\", &n);\n\tforn(i, n - 1) {\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\t--x; --y;\n\t\tg[x].pb(y);\n\t\tg[y].pb(x);\n\t}\n\t\n\tdfs(0);\n\t\n\tfor (int i = 0; i < n; i++)\n\t\tprintf(\"%d %d\\n\", segs[i].x, segs[i].y);\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}