{"link": "https://codeforces.com//contest/1795/problem/F", "problemId": "1785702", "shortId": "1795F", "contest_number": "1795", "name": "F. Blocking Chips", "statement": "You are given a tree, consisting of  vertices. There are  chips, placed in vertices . All  are distinct. Vertices  are colored black initially. The remaining vertices are white.You are going to play a game where you perform some moves (possibly, zero). On the -th move (-indexed) you are going to move the -st chip from its current vertex to an adjacent  vertex and color that vertex . So, if , you move chip  on move , chip  on move , chip  on move , chip  on move , chip  on move  and so on. If there is no adjacent white vertex, then the game ends.What's the maximum number of moves you can perform?", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of testcases. The first line of each testcase contains a single integer  ()\u00a0\u2014 the number of vertices of the tree. Each of the next  lines contains two integers  and  ()\u00a0\u2014 the descriptions of the edges. The given edges form a tree. The next line contains a single integer  ()\u00a0\u2014 the number of chips. The next line contains  integers  ()\u00a0\u2014 the vertices with the chips. All  are distinct. The sum of  over all testcases doesn't exceed .", "output": "For each testcase, print a single integer\u00a0\u2014 the maximum number of moves you can perform.", "tutorial": "The constraints tell us that the solution should be linear or pretty close to it. Well, in particular, that implies that the solution almost certainly isn't dynamic programming, since we have both  and  to care about. Thus, we'll think about something greedy.When we know the number of move the game will last, we can tell how many steps each chip should make. Well, since the more moves the game last, the more steps each ship makes, the answer is a monotonic function. Let's apply binary search and think if we can check if each chip can make some known number of steps.A common idea in the problems where you have to do something greedily on a tree is to root the tree arbitrarily and process everything bottom up.Consider the bottommost chip. If it can move its number of moves downwards, it's always optimal to do that. Since it's the bottommost chip, it can only make things worse for chips above it. And any of them can't pass through the initial vertex of this chip anyway.If it can't, it has to move to its parent vertex. Let's move it there and deal with this chip later\u00a0\u2014 when it becomes the bottommost again.If it can't move to its parent, it can't move at all. Thus, the game can't last for this many steps.Since we only apply either the move which is guaranteed to not interrupt any other moves or the move which is forced, the greedy strategy is correct.As for implementation details, it's not too tricky. Basically, for each vertex, we should maintain these values:   if this vertex has been visited;  the number of steps the chip in this vertex still has to make (if any chip is in this vertex);  the longest path downwards from this vertex via non-visited vertices. The second value can be initialized beforehand and pushed to the parent when needed. The rest of them are easily maintained with a single dfs.Overall complexity:  per testcase.", "solution": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define forn(i, n) for(int i = 0; i < int(n); i++) \n\nvector<vector<int>> g;\nvector<int> req;\nvector<char> used;\n\nvector<int> d;\n\nbool dfs(int v, int p = -1){\n    d[v] = 0;\n    for (int u : g[v]) if (u != p){\n        if (!dfs(u, v)) return false;\n        if (!used[u]) d[v] = max(d[v], d[u] + 1);\n    }\n    if (req[v] == 0 || d[v] >= req[v]) return true;\n    if (p == -1 || used[p]) return false;\n    used[p] = true;\n    req[p] = req[v] - 1;\n    return true;\n}\n\nint main(){\n    int t;\n    scanf(\"%d\", &t);\n    while (t--){\n        int n;\n        scanf(\"%d\", &n);\n        g.assign(n, {});\n        d.resize(n);\n        forn(i, n - 1){\n            int v, u;\n            scanf(\"%d%d\", &v, &u);\n            --v, --u;\n            g[v].push_back(u);\n            g[u].push_back(v);\n        }\n        int k;\n        scanf(\"%d\", &k);\n        vector<int> a(k);\n        forn(i, k){\n            scanf(\"%d\", &a[i]);\n            --a[i];\n        }\n        int l = 1, r = n;\n        int res = 0;\n        while (l <= r){\n            int m = (l + r) / 2;\n            used.assign(n, 0);\n            req.assign(n, 0);\n            forn(i, k){\n                used[a[i]] = true;\n                req[a[i]] = m / k + (i < m % k);\n            }\n            if (dfs(0)){\n                res = m;\n                l = m + 1;\n            }\n            else{\n                r = m - 1;\n            }\n        }\n        printf(\"%d\\n\", res);\n    }\n}", "interactive": false, "noSolution": false, "noTutorial": false}