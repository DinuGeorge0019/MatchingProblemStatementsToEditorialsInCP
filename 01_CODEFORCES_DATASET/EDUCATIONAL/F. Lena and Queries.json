{"link": "https://codeforces.com//contest/678/problem/F", "problemId": "62344", "shortId": "678F", "contest_number": "678", "name": "F. Lena and Queries", "statement": "Lena is a programmer. She got a task to solve at work.There is an empty set of pairs of integers and  queries to process. Each query is one of three types:  Add a pair  to the set.  Remove a pair added in the query number . All queries are numbered with integers from  to .  For a given integer  find the maximal value  over all pairs  from the set. Help Lena to process the queries.", "input": "The first line of input contains integer  () \u2014 the number of queries. Each of the next  lines starts with integer  () \u2014 the type of the query. A pair of integers  and  () follows in the query of the first type. An integer  () follows in the query of the second type. It is guaranteed that  is less than the number of the query, the query number  has the first type and the pair from the -th query is not already removed. An integer  () follows in the query of the third type.", "output": "For the queries of the third type print on a separate line the desired maximal value of . If there are no pairs in the set print \"\".", "tutorial": "Let's interpret the problem geometrically: the pairs from the set are the lines and the problem to find to topmost intersection of the vertical line with the lines from the set.\nLet's split the queries to  blocks. Consider the lines added before the current block and that will not deleted in the current block. Let's build the lower envelope by that lines. Now to calculate the answer to the query we should get maximum over the lines from the envelope and the lines from the block before the current query that is not deleted yet. There are no more than  lines from the block, so we can iterate over them. Let's find the answers from the envelope for all queries of the third type from the block at once: we should sort them and iterate over envelope using two pointers technique.\n", "solution": "const int N = 300300;\n\nint n;\nint t[N], a[N], b[N], id[N], q[N];\n\nbool read() {\n\tif (!(cin >> n)) return false;\n\tforn(i, n) {\n\t\tassert(scanf(\"%d\", &t[i]) == 1);\n\t\tif (t[i] == 1) {\n\t\t\tassert(scanf(\"%d%d\", &a[i], &b[i]) == 2);\n\t\t} else if (t[i] == 2) {\n\t\t\tassert(scanf(\"%d\", &id[i]) == 1);\n\t\t\tid[i]--;\n\t\t} else if (t[i] == 3) {\n\t\t\tassert(scanf(\"%d\", &q[i]) == 1);\n\t\t} else throw;\n\t}\n\treturn true;\n}\n\nbool in_set[N], deleted[N];\nvector<pair<pti, int>> lines;\nvector<pti> envelope;\n\nvoid build_envelope() {\n\tenvelope.clear();\n\tenvelope.reserve(n);\n\n\tforn(ii, sz(lines)) {\n\t\tint i = lines[ii].y;\n\t\tif (in_set[i] && !deleted[i]) {\n\t\t\tassert(t[i] == 1);\n\t\t\tpti c(a[i], b[i]);\n\t\t\twhile (!envelope.empty()) {\n\t\t\t\tpti b = envelope.back();\n\t\t\t\tif (b.x == c.x) {\n\t\t\t\t\tenvelope.pop_back();\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (sz(envelope) > 1) {\n\t\t\t\t\tpti a = envelope[sz(envelope) - 2];\n\n\t\t\t\t\tld xc = ld(c.y - a.y) / (a.x - c.x);\n\t\t\t\t\tld xb = ld(b.y - a.y) / (a.x - b.x);\n\n\t\t\t\t\tif (xc < xb) {\n\t\t\t\t\t\tenvelope.pop_back();\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tenvelope.pb(c);\n\t\t}\n\t}\n}\n\nli ans[N];\nvector<pti> qs;\n\nvoid process_qs() {\n\tsort(all(qs));\n\n\tint p = 0;\n\tforn(i, sz(qs)) {\n\t\tli q = qs[i].x;\n\t\tint id = qs[i].y;\n\n\t\twhile (p + 1 < sz(envelope)) {\n\t\t\tli cval = envelope[p].x * q + envelope[p].y;\n\t\t\tli nval = envelope[p + 1].x * q + envelope[p + 1].y;\n\t\t\tif (cval > nval) break;\n\t\t\tp++;\n\t\t}\n\n\t\tif (p < sz(envelope)) {\n\t\t\tans[id] = envelope[p].x * q + envelope[p].y;\n\t\t}\n\t}\n}\n\nvoid solve() {\n\tlines.clear();\n\tlines.reserve(n);\n\tforn(i, n) if (t[i] == 1) lines.pb(mp(mp(a[i], b[i]), i));\n\tsort(all(lines));\n\n\tmemset(in_set, false, sizeof(in_set));\n\tmemset(deleted, false, sizeof(deleted));\n\tforn(i, n) ans[i] = LLONG_MIN;\n\n\tint blen = int(sqrtl(n));\n\tblen = 2500;\n\tfor (int l = 0; l < n; l += blen) {\n\t\tint r = min(n, l + blen);\n\n\t\tmemset(deleted, false, sizeof(deleted));\n\t\tfore(i, l, r) if (t[i] == 2) deleted[id[i]] = true;\n\t\tbuild_envelope();\n\n\t\tqs.clear();\n\t\tqs.reserve(r - l);\n\t\tfore(i, l, r) if (t[i] == 3) qs.pb(mp(q[i], i));\n\t\tprocess_qs();\n\n\t\tfore(i, l, r) {\n\t\t\tif (t[i] == 1) in_set[i] = true;\n\t\t\telse if (t[i] == 2) in_set[id[i]] = false;\n\t\t\telse {\n\t\t\t\tfore(j, l, r) {\n\t\t\t\t\tif (t[j] == 1 && in_set[j])\n\t\t\t\t\t\tans[i] = max(ans[i], li(a[j]) * q[i] + b[j]);\n\t\t\t\t\telse if (t[j] == 2 && in_set[id[j]])\n\t\t\t\t\t\tans[i] = max(ans[i], li(a[id[j]]) * q[i] + b[id[j]]);\n\t\t\t\t}\n\t\t\t\tif (ans[i] != LLONG_MIN) printf(\"%lldn\", ans[i]);\n\t\t\t\telse puts(\"EMPTY SET\");\n\t\t\t}\n\t\t}\n\t}\n}", "interactive": false, "noSolution": false, "noTutorial": false}