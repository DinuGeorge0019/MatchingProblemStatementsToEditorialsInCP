{"link": "https://codeforces.com//contest/1680/problem/E", "problemId": "1398259", "shortId": "1680E", "contest_number": "1680", "name": "E. Moving Chips", "statement": "You are given a board of size  ( rows,  columns). Some cells of the board contain chips. The chip is represented as '', and an empty space is represented as ''. It is guaranteed that there is at least one chip on the board.In one move, you can choose  chip and move it to any adjacent (by side) cell of the board (if this cell is inside the board). It means that if the chip is in the first row, you can move it left, right or down (but it shouldn't leave the board). Same, if the chip is in the second row, you can move it left, right or up.If the chip moves to the cell with another chip, the chip in the destination cell disappears (i.\u2009e. our chip captures it).Your task is to calculate the  number of moves required to leave  one chip on the board.You have to answer  independent test cases.", "input": "The first line of the input contains one integer  () \u2014 the number of test cases. Then  test cases follow. The first line of the test case contains one integer  () \u2014 the length of the board. The second line of the test case contains the string  consisting of  characters '' (chip) and/or '' (empty cell). The third line of the test case contains the string  consisting of  characters '' (chip) and/or '' (empty cell). Additional constraints on the input:   in each test case, there is at least one chip on a board;  the sum of  over all test cases does not exceed  (). ", "output": "For each test case, print one integer \u2014 the  number of moves required to leave  one chip on the board.", "tutorial": "Firstly, I want to say a few words about the difficulty of this problem. Till the last moment, we didn't know easy to prove (and easy to write) solutions, so we decided that this is a good problem E. But now we realized it is a lot easier than we expected.Now, let's talk about the solution. At the beginning, let's remove redundant columns from the beginning and from the end (i.\u2009e. columns without chips) and change the value  correspondingly. Now, let  be  if  is '', and  otherwise. This array needed to make the implementation easier.Let's calculate the dynamic programming , where  is the index of the last processed column and  is the number of the row where our chip is standing. This seems a bit suspicious why we can calculate such a dynamic programming, so let's explain some things about it.  It can be shown that in the optimal answer there will be some column where the last move happens. And if the number of this column is  then all chips to the left of  will move only to the right and all chips to the right of  will move only to the left.  Actually, we can always consider that  is the last column. Consider paths of two chips that will survive till the last move. The first chip is to the left of  and will move only to the right, and the second one is to the right of  and will move only to the left. Then we can replicate the path of the second chip in the reverse order using the first chip. So the second chip can stay still until the last move.  In the optimal answer, it is always better to have exactly one chip in the current column, because moving two chips to the right is always worse than just eat one of them and move the remaining one. Initial states of  are  except the values of the first column. For the first column,  and . The answer will be .Okay, how to make transitions from ? For all  from  to , let's consider four cases:   \u2014 here we need one move to go to the next column and, probably, one more move to delete the figure in the second row in the column . So the transition seems like ;   \u2014 same as the previous transition, ;   \u2014 because the cost of this transition is always  (the distance between these cells is ), we just go firstly to the right and then down (to ensure that we eat the figure in the first row). So the transition is ;   \u2014 same as the previous transition, . Time complexity: .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1e9;\n\nint main() {\n#ifdef _DEBUG\n    freopen(\"input.txt\", \"r\", stdin);\n//  freopen(\"output.txt\", \"w\", stdout);\n#endif\n    \n    int tc;\n    cin >> tc;\n    while (tc--) {\n        int n;\n        string s[2];\n        cin >> n >> s[0] >> s[1];\n        \n        for (int it = 0; it < 2; ++it) {\n            while (s[0].back() == '.' && s[1].back() == '.') {\n                s[0].pop_back();\n                s[1].pop_back();\n            }\n            reverse(s[0].begin(), s[0].end());\n            reverse(s[1].begin(), s[1].end());\n        }\n        n = s[0].size();\n        \n        vector<vector<int>> cost(n, vector<int>(2));\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < 2; ++j) {\n                cost[i][j] = (s[j][i] == '*');\n            }\n        }\n        \n        vector<vector<int>> dp(n, vector<int>(2, INF));\n        dp[0][0] = cost[0][1];\n        dp[0][1] = cost[0][0];\n        for (int i = 0; i + 1 < n; ++i) {\n            dp[i + 1][0] = min(dp[i + 1][0], dp[i][0] + 1 + cost[i + 1][1]);\n            dp[i + 1][0] = min(dp[i + 1][0], dp[i][1] + 2);\n            dp[i + 1][1] = min(dp[i + 1][1], dp[i][1] + 1 + cost[i + 1][0]);\n            dp[i + 1][1] = min(dp[i + 1][1], dp[i][0] + 2);\n        }\n        \n        cout << min(dp[n - 1][0], dp[n - 1][1]) << endl;\n    }\n        \n    return 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}