{"link": "https://codeforces.com//contest/1076/problem/E", "problemId": "253929", "shortId": "1076E", "contest_number": "1076", "name": "E. Vasya and a Tree", "statement": "Vasya has a tree consisting of  vertices with root in vertex . At first all vertices has  written on it.Let  be the distance between vertices  and , i.e. number of edges in the shortest path from  to . Also, let's denote -subtree of vertex  \u2014 set of vertices  such that next two conditions are met:    is the ancestor of  (each vertex is the ancestor of itself);  . Vasya needs you to process  queries. The -th query is a triple ,  and . For each query Vasya adds value  to each vertex from -subtree of .Report to Vasya all values, written on vertices of the tree after processing all queries.", "input": "The first line contains single integer  () \u2014 number of vertices in the tree. Each of next  lines contains two integers  and  () \u2014 edge between vertices  and . It is guarantied that given graph is a tree. Next line contains single integer  () \u2014 number of queries. Each of next  lines contains three integers , ,  (, , ) \u2014 description of the -th query.", "output": "Print  integers. The -th integers is the value, written in the -th vertex after processing all queries.", "tutorial": "To solve this problem we can use a data structure which allows to add some value on segment and get a value from some point (Fenwick tree, segment tree or anything you are familliar with).Let's run DFS from the root while maintaining current depth. When entering a vertex  on depth , let's consider all queries having , and for each such query add  on segment . Then for current vertex  the answer is the value in point .When leaving vertex  we need to rollback everything we have done: for all queries having  subtract  on segment .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(3e5) + 9;\n\nint n, m;\t\nvector <int> g[N];\nvector <pair<int, int> > q[N];\nlong long add[N];\nlong long res[N];\n\nvoid dfs(int v, int pr, int h, long long sum){\n\tfor(auto p : q[v]){\n\t\tint l = h, r = h + p.first;\n\t\tadd[l] += p.second;\n\t\tif(r + 1 < N) add[r + 1] -= p.second;\n\t}\n\tsum += add[h];\n\tres[v] = sum;\t\n\tfor(auto to : g[v])\n\t\tif(to != pr)\n\t\t\tdfs(to, v, h + 1, sum);\n\t\t\t\n\tfor(auto p : q[v]){\n\t\tint l = h, r = h + p.first;\n\t\tadd[l] -= p.second;\n\t\tif(r + 1 < N) add[r + 1] += p.second;\n\t}\n}\n\nint main() {\t\n//\tfreopen(\"input.txt\", \"r\", stdin);\n\t\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n - 1; ++i){\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\t\t--u, --v;\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\t\n\tscanf(\"%d\", &m);\n\tfor(int i = 0; i < m; ++i){\n\t\tint v, h, d;\n\t\tscanf(\"%d %d %d\", &v, &h, &d);\n\t\t--v;\n\t\tq[v].push_back(make_pair(h, d));\n\t}\n\t\n\tdfs(0, 0, 0, 0);\n\tfor(int i = 0; i < n; ++i)\n\t\tprintf(\"%lld \", res[i]);\n\tputs(\"\");\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}