{"link": "https://codeforces.com//contest/1555/problem/E", "problemId": "1062144", "shortId": "1555E", "contest_number": "1555", "name": "E. Boring Segments", "statement": "You are given  segments on a number line, numbered from  to . The -th segments covers all integer points from  to  and has a value .You are asked to select a subset of these segments (possibly, all of them). Once the subset is selected, it's possible to travel between two integer points if there exists a selected segment that covers both of them. A subset is good if it's possible to reach point  starting from point  in arbitrary number of moves.The cost of the subset is the difference between the maximum and the minimum values of segments in it. Find the minimum cost of a good subset.In every test there exists at least one good subset.", "input": "The first line contains two integers  and  (; )\u00a0\u2014 the number of segments and the number of integer points. Each of the next  lines contains three integers ,  and  (; )\u00a0\u2014 the description of the -th segment. In every test there exists at least one good subset.", "output": "Print a single integer\u00a0\u2014 the minimum cost of a good subset.", "tutorial": "Take a look at the condition for a good subset.The major implication it makes is that every point (even non-integer) of the segment $$$[1; m]$$$ should be covered by at least one segment. If some point isn't, then there is no way to jump across the gap it produces.At the same time, this condition is enough to have a path, since for every half-integer point ($$$0.5$$$, $$$1.5$$$ and so on) there exists a segment that covers it. So you can take that segment to go from $$$1$$$ to $$$2$$$, then from $$$2$$$ to $$$3$$$ and so on.Thus, we are asked to select a subset of segments that covers the entire segment $$$[1; m]$$$ in its union.The main prerequisite to the following solution is knowing the way to maintain the union of segments. For now, I can tell you that there is a data structure that allows you to add a segment, remove a segment and query the length of the current union.Let's continue with making some observations on the cost function. If you fix the minimum and the maximum value, you are free to select all segments that have their value in-between.That allows us to transition from selecting a subset of segment to an interval, if you sort the segments by their weight.If you fix only minimum, then the required maximum should be as small as possible. However, if some value suffices as a maximum, then any value greater than it also suffices (since it only adds extra segments to the subset). This makes the function on the maximum monotonous.So the binary search applicable. You could iterate over the minimum and binary search the maximum. However, it's not too clear how to make a check function. You would need to find a union of some interval of segments quickly. I don't really know a way to do that, so let's try something different.Instead, let's forget about binary search and try to reach a two pointers solution. Let $$$f(x)$$$ be the smallest possible maximum, given the fixed minimum is $$$x$$$. We want $$$f(x + 1)$$$ to be greater than or equal than $$$f(x)$$$ for two pointers to be applicable.That condition indeed holds. Imagine if $$$f(x + 1)$$$ is smaller than $$$f(x)$$$. So there exists some optimal subset for $$$x + 1$$$. Add all segments with weight $$$x$$$ to that subset. That brings the minimum to $$$x$$$. However, it doesn't change the maximum, so $$$f(x)$$$ is at least equal to $$$f(x + 1)$$$, what contradicts the assumption.Finally, the solution comes up to the following. Iterate over the minimum value $$$x$$$, while maintaining $$$f(x)$$$. When going from $$$x$$$ to $$$x + 1$$$, keep increasing the value of $$$f$$$ until the union of the segments is exactly $$$m$$$.Going from $$$x$$$ to $$$x+1$$$ and increasing the value of $$$f$$$ is actually removing some segments and adding some segments to the data structure.The data structure that helps us with that is a segment tree. The $$$i$$$-th leaf of the tree holds the number of segments that cover the interval $$$(i; i + 1)$$$. Add/remove segment makes it add/subtract on a range. The union is full if the there are no intervals that are covered by zero segments. Thus, let's store the minimum of the subtree in every intermediate node. If the minimum on the tree is above zero, then the current subset is good.Instead of applying two pointers on the values of the segments, let's apply them on the sorted segments themselves. That makes moving the pointer exactly one update to the segtree.Overall complexity: $$$O(n \\log n + n \\log m)$$$.", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int INF = 1e9;\n\nvector<int> t, ps;\n\nvoid push(int v){\n\tif (v * 2 + 1 < int(ps.size())){\n\t\tps[v * 2] += ps[v];\n\t\tps[v * 2 + 1] += ps[v];\n\t}\n\tt[v] += ps[v];\n\tps[v] = 0;\n}\n\nvoid upd(int v, int l, int r, int L, int R, int val){\n\tpush(v);\n\tif (L >= R)\n\t\treturn;\n\tif (l == L && r == R){\n\t\tps[v] += val;\n\t\tpush(v);\n\t\treturn;\n\t}\n\tint m = (l + r) / 2;\n\tupd(v * 2, l, m, L, min(m, R), val);\n\tupd(v * 2 + 1, m, r, max(m, L), R, val);\n\tt[v] = min(t[v * 2], t[v * 2 + 1]);\n}\n\nint get(){\n\treturn t[1] + ps[1];\n}\n\nstruct seg{\n\tint l, r, w;\n};\n\nint main() {\n\tint n, m;\n\tscanf(\"%d%d\", &n, &m);\n\tvector<seg> a(n);\n\tforn(i, n){\n\t\tscanf(\"%d%d%d\", &a[i].l, &a[i].r, &a[i].w);\n\t\t--a[i].l, --a[i].r;\n\t}\n\t--m;\n\tsort(a.begin(), a.end(), [](const seg &a, const seg &b){\n\t\treturn a.w < b.w;\n\t});\n\tt.resize(4 * m);\n\tps.resize(4 * m);\n\tint ans = INF;\n\tint j = 0;\n\tforn(i, n){\n\t\twhile (j < n && get() == 0){\n\t\t\tupd(1, 0, m, a[j].l, a[j].r, 1);\n\t\t\t++j;\n\t\t}\n\t\tif (get() == 0){\n\t\t\tbreak;\n\t\t}\n\t\tans = min(ans, a[j - 1].w - a[i].w);\n\t\tupd(1, 0, m, a[i].l, a[i].r, -1);\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}