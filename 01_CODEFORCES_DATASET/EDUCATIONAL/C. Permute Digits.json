{"link": "https://codeforces.com//contest/915/problem/C", "problemId": "146470", "shortId": "915C", "contest_number": "915", "name": "C. Permute Digits", "statement": "You are given two positive integer numbers  and . Permute (change order) of the digits of  to construct maximal number not exceeding . No number in input and/or output can start with the digit .It is allowed to leave  as it is.", "input": "The first line contains integer  (). The second line contains integer  (). Numbers don't have leading zeroes. It is guaranteed that answer exists.", "output": "Print the maximum possible number that is a permutation of digits of  and is not greater than . The answer can't have any leading zeroes. It is guaranteed that the answer exists. The number in the output should have exactly the same length as number . It should be a permutation of digits of .", "tutorial": "Let's construct the answer digit by digit starting from the leftmost. Obviously, we are asked to build lexicographically maximal answer so in this order we should choose the greatest digit on each step.Precalc  \u2014 number of digits  in number . Iterate over all possible digits starting from the greatest. For each digit check if it's possible to put it in this position. For this you construct minimal suffix (greedily put the lowest digit) and compare the resulting number with number . If it became less or equal then proceed to the next digit.Overall complexity: , where  is digits from  to .", "solution": "#define _CRT_SECURE_NO_DEPRECATE\n#pragma comment(linker, \"/STACK:167772160000\")\n#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <stdio.h>\n#include <cstdlib>\n#include <stdlib.h>\n#include <string>\n#include <list>\n#include <fstream>\n#include <algorithm>\n#include <cmath>\n#include <map>\n#include <vector>\n#include <iomanip>\n#include <queue>\n#include <deque>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <assert.h>\n#include <functional>\n#include <climits>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\n//typedef uint64_t ull;\n//typedef std::pair<long double,long double> pdd;\n#define for8(i) for( i = 1; i<=8; i++)\n#define fori(N)          for(int i = 0; i<(N); i++)\n#define forj(N)         for(int j = 0; j<(N); j++)\n#define fork(N)         for(int k = 0; k<(N); k++)\n#define forl(N)         for(int l = 0; l<(N); l++)\n#define ford(N)         for(int d = 0; d<(N); d++)\n#define fori1(N)          for(int i = 1; i<=(N); i++)\n#define forj1(N)         for(int j = 1; j<=(N); j++)\n#define fork1(N)         for(int k = 1; k<=(N); k++)\n#define ford1(N)         for(int d = 1; d<=(N); d++)\n#define PI (2*asin(1))\n#define read(n) scanf(\"%d\", &n);\n#define read2(n, m) scanf(\"%d%d\", &n, &m);\n#define readll(n) scanf(\"%I64d\", &n);\n#define mp make_pair\n\nmap<int, int>haveInt;\nvector<int>need;\nvector<int>answer;\n\nvoid prnt() {\n\tfor (auto x : answer)cout << x;\n\texit(0);\n}\n\nvoid formAll() {\n\twhile (!haveInt.empty()) {\n\t\tmap<int, int>::iterator it = haveInt.end();\n\t\tit--;\n\t\tanswer.push_back(it->first);\n\t\tit->second -= 1;\n\t\tif (it->second == 0)\n\t\t\thaveInt.erase(it);\n\t}\n\tprnt();\n}\n\nvoid tryNum(int a) {\n\tif (haveInt.size()==0)\n\t\tprnt();\n\tmap<int, int>::iterator it = haveInt.lower_bound(need[a]);\n\tif (it != haveInt.end() && it->first == need[a]) {\n\t\tint x = it->first;\n\t\tit->second--;\n\t\tif (it->second == 0)\n\t\t\thaveInt.erase(it);\n\t\tanswer.push_back(x);\n\t\ttryNum(a + 1);\n\t\thaveInt[x]++;\n\t\tanswer.pop_back();\n\t}\n\tit = haveInt.lower_bound(need[a]);\n\tif (it == haveInt.begin())return;\n\tit--;\n\tanswer.push_back(it->first);\n\tit->second--;\n\tif (it->second == 0)\n\t\thaveInt.erase(it);\n\tformAll();\n}\n\n\nint main()\n{\n\tios::sync_with_stdio(false); cin.tie(0);\n#if defined(_DEBUG) || defined(_RELEASE)\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\tstring s1, s2;\n\tcin >> s1 >> s2;\n\tswap(s1, s2);\n\tfor (auto x : s2)\n\t\thaveInt[x - '0']++;\n\tif (s2.length() < s1.length())\n\t\tformAll();\n\tfor (auto x : s1)\n\t\tneed.push_back(x - '0');\n\ttryNum(0);\n\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}