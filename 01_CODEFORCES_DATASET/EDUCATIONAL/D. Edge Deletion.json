{"link": "https://codeforces.com//contest/1076/problem/D", "problemId": "253928", "shortId": "1076D", "contest_number": "1076", "name": "D. Edge Deletion", "statement": "You are given an undirected connected weighted graph consisting of  vertices and  edges. Let's denote the length of the shortest path from vertex  to vertex  as . You have to erase some edges of the graph so that at most  edges remain. Let's call a vertex   if there still exists a path from  to  with length  after erasing the edges.Your goal is to erase the edges in such a way that the number of  vertices is maximized.", "input": "The first line contains three integers ,  and  (, , , ) \u2014 the number of vertices and edges in the graph, and the maximum number of edges that can be retained in the graph, respectively. Then  lines follow, each containing three integers , ,  (, , ), denoting an edge connecting vertices  and  and having weight . The given graph is connected (any vertex can be reached from any other vertex) and simple (there are no self-loops, and for each unordered pair of vertices there exists at most one edge connecting these vertices).", "output": "In the first line print  \u2014 the number of edges that should remain in the graph (). In the second line print   integers from  to  \u2014 the indices of edges that should remain in the graph. Edges are numbered in the same order they are given in the input. The number of  vertices should be as large as possible.", "tutorial": "Let's understand how many good vertices we may get if only  edges remain. This value is not greater than , since an edge an add only one good vertex, and for  we have a good vertex with index . This is an upper bound; let's try to find a solution getting exactly  good vertices (or, if , all vertices of the graph will be good). Let's run Dijkstra's algorithm from vertex  and stop it as soon as we know the shortest paths to  vertices (including vertex ). The answer should contain the edges belonging to the shortest path tree built on these  vertices. ", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector<pair<int, pair<int, int> > > g[300043];\n\nint main()\n{\n\tint n, m, k;\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\tfor(int i = 0; i < m; i++)\n\t{\n\t\tint x, y, w;\n\t\tscanf(\"%d %d %d\", &x, &y, &w);\n\t\t--x;\n\t\t--y;\n\t\tg[x].push_back(make_pair(y, make_pair(w, i)));\n\t\tg[y].push_back(make_pair(x, make_pair(w, i)));\n\t}\n\tset<pair<long long, int> > q;\n\tvector<long long> d(n, (long long)(1e18));\n\td[0] = 0;\n\tq.insert(make_pair(0, 0));\n\tvector<int> last(n, -1);\n\tint cnt = 0;\n\tvector<int> ans;\n\twhile(!q.empty() && cnt < k)\n\t{\n\t\tauto z = *q.begin();\n\t\tq.erase(q.begin());\n\t\tint k = z.second;\n\t\tif(last[k] != -1)\n\t\t{\n\t\t\tcnt++;\n\t\t\tans.push_back(last[k]);\n\t\t}\n\t\tfor(auto y : g[k])\n\t\t{\n\t\t\tint to = y.first;\n\t\t\tint w = y.second.first;\n\t\t\tint idx = y.second.second;\n\t\t\tif(d[to] > d[k] + w)\n\t\t\t{\n\t\t\t\tq.erase(make_pair(d[to], to));\n\t\t\t\td[to] = d[k] + w;\n\t\t\t\tlast[to] = idx;\n\t\t\t\tq.insert(make_pair(d[to], to));\n\t\t\t}\n\t\t}\n\t}\t\t\n\tprintf(\"%d\\n\", ans.size());\n\tfor(auto x : ans) printf(\"%d \", x + 1);\n}\t", "interactive": false, "noSolution": false, "noTutorial": false}