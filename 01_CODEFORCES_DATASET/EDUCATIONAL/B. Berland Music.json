{"link": "https://codeforces.com//contest/1622/problem/B", "problemId": "1242578", "shortId": "1622B", "contest_number": "1622", "name": "B. Berland Music", "statement": "Berland Music is a music streaming service built specifically to support Berland local artist. Its developers are currently working on a song recommendation module.So imagine Monocarp got recommended  songs, numbered from  to . The -th song had its predicted rating equal to , where  and every integer from  to  appears exactly once. In other words,  is a permutation.After listening to each of them, Monocarp pressed either a like or a dislike button. Let his vote sequence be represented with a string , such that  means that he disliked the -th song, and  means that he liked it.Now the service has to re-evaluate the song ratings in such a way that:  the new ratings  still form a permutation (; each integer from  to  appears exactly once);  every song that Monocarp liked should have a greater rating than every song that Monocarp disliked (formally, for all  such that  and ,  should hold). Among all valid permutations  find the one that has the smallest value of , where  is an absolute value of .Print the permutation . If there are multiple answers, you can print any of them.", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of testcases. The first line of each testcase contains a single integer  ()\u00a0\u2014 the number of songs. The second line of each testcase contains  integers  ()\u00a0\u2014 the permutation of the predicted ratings. The third line contains a single string , consisting of  characters. Each character is either a  or a .  means that Monocarp disliked the song, and  means that he liked it. The sum of  over all testcases doesn't exceed .", "output": "For each testcase, print a permutation \u00a0\u2014 the re-evaluated ratings of the songs. If there are multiple answers such that  is minimum possible, you can print any of them.", "tutorial": "Since we know that every disliked song should have lower rating than every liked song, we actually know which new ratings should belong to disliked songs and which should belong to the liked ones.The disliked songs take ratings from  to the number of zeros in . The liked songs take ratings from the number of zeros in  plus  to . Thus, we have two independent tasks to solve.Let the disliked songs have ratings . Their new ratings should be . We can show that if we sort the array , then  will be the lowest possible. The general way to prove it is to show that if the order has any inversions, we can always fix the leftmost of them (swap two adjacent values), and the cost doesn't increase.So the solution can be to sort triples  and restore  from the order of  in these.Overall complexity:  per testcase.", "solution": "for _ in range(int(input())):\n\tn = int(input())\n\tp = [int(x) for x in input().split()]\n\ts = input()\n\tl = sorted([[s[i], p[i], i] for i in range(n)])\n\tq = [-1 for i in range(n)]\n\tfor i in range(n):\n\t\tq[l[i][2]] = i + 1\n\tprint(*q)", "interactive": false, "noSolution": false, "noTutorial": false}