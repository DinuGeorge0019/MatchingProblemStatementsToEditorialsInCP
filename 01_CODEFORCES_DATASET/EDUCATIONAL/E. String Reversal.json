{"link": "https://codeforces.com//contest/1430/problem/E", "problemId": "755157", "shortId": "1430E", "contest_number": "1430", "name": "E. String Reversal", "statement": "You are given a string . You have to reverse it \u2014 that is, the first letter should become equal to the last letter before the reversal, the second letter should become equal to the second-to-last letter before the reversal \u2014 and so on. For example, if your goal is to reverse the string \"\", you should get the string \"\". To accomplish your goal, you can swap the . Your task is to calculate the minimum number of swaps you have to perform to reverse the given string.", "input": "The first line contains one integer  () \u2014 the length of . The second line contains  \u2014 a string consisting of  lowercase Latin letters.", "output": "Print one integer \u2014 the minimum number of swaps of neighboring elements you have to perform to reverse the string.", "tutorial": "First of all, let's find the resulting position for each character of the string. It's easy to see that we don't need to swap equal adjacent characters (it changes nothing), so the first character  in the original string is the first character  in the resulting string, the second character  in the original string is the second character  in the resulting string, and so on.Now, let's build a permutation  of  elements, where  is the resulting position of the element that was on position  in the original string. For example, for the string  this permutation will be . In one operation, we may swap two elements in this permutation, and our goal is to sort it (since each character of the string has its own required position, and when for every  the condition  holds, each character is on the position it should be). The required number of swaps of adjacent elements to sort a permutation is exactly the number of inversions in it (since each swap changes the number of inversions by ), and this number can be calculated using many different techniques, for example, mergesort tree or Fenwick tree.", "solution": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <cassert>\n#include <iomanip>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <ctime>\n#include <cmath>\n\n#define forn(i, n) for(int i=0;i<n;++i)\n#define fore(i, l, r) for(int i = int(l); i <= int(r); ++i)\n#define sz(v) int(v.size())\n#define all(v) v.begin(), v.end()\n#define pb push_back\n#define mp make_pair\n#define x first\n#define y1 ________y1\n#define y second\n#define ft first\n#define sc second\n#define pt pair<int, int>\n\ntemplate<typename X> inline X abs(const X& a) { return a < 0? -a: a; }\ntemplate<typename X> inline X sqr(const X& a) { return a * a; }\n\ntypedef long long li;\ntypedef long double ld;\n\nusing namespace std;\n\nconst int INF = 1000 * 1000 * 1000;\nconst ld EPS = 1e-9;\nconst ld PI = acos(-1.0);\nconst int N = 200 * 1000 + 13;\n\nint n;\nstring s;\nstring revS;\nvector<int> posS[30];\nvector<int> posT[30];\nint cnt[30];\nint t[N];\n\ninline int sum (int r) {\n\tint result = 0;\n\tfor (; r >= 0; r = (r & (r+1)) - 1)\n\t\tresult += t[r];\n\treturn result;\n}\n\ninline void inc (int i, int d) {\n\tfor (; i < n; i = (i | (i+1)))\n\t\tt[i] += d;\n}\n\nint sum (int l, int r) {\n\treturn sum (r) - sum (l-1);\n}\n     \ninline void read() {\t\n\tcin >> n >> s;\n}\n\ninline void solve() {\n\trevS = s;\n\treverse(all(revS));\n\tfor (int i = 0; i < sz(s); i++) {\n\t\tposS[s[i] - 'a'].pb(i);\n\t\tposT[revS[i] - 'a'].pb(i);\n\t}\n\tli ans = 0;\n\tfor (int i = 0; i < sz(revS); i++) {\n\t\tint let = revS[i] - 'a';\n\t\tint cur = posS[let][cnt[let]];\n\t\tint oldC = cur;\n\t\tcur += sum(cur, n - 1);\n\t\tint need = i;\n\t\tans += cur - need;\n\t\tinc(oldC, 1);\n\t\tcnt[let]++;\n\t}\n\tcout << ans << endl;\n}\n\nint main () {\n#ifdef fcspartakm\n    freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n#endif\n    srand(time(NULL));\n    cerr << setprecision(10) << fixed;\n    \n    read();\n    solve();\n \n    //cerr << \"TIME: \" << clock() << endl;\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}