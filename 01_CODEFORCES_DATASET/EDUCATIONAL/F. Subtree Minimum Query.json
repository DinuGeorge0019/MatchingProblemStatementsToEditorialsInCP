{"link": "https://codeforces.com//contest/893/problem/F", "problemId": "135516", "shortId": "893F", "contest_number": "893", "name": "F. Subtree Minimum Query", "statement": "You are given a rooted tree consisting of  vertices. Each vertex has a number written on it; number  is written on vertex .Let's denote  as the distance between vertices  and  in the tree (that is, the number of edges in the shortest path from  to ). Also let's denote the  of vertex  as the set of vertices  such that both these conditions are met:   is an ancestor of  (every vertex is an ancestor of itself);  . You are given  queries to the tree. -th query is represented by two numbers  and , and the answer to this query is the minimum value of  among such vertices  such that  belongs to -blocked subtree of .Write a program that would process these queries quickly!.", "input": "The first line contains two integers  and  () \u2014 the number of vertices in the tree and the index of the root, respectively. The second line contains  integers  () \u2014 the numbers written on the vertices. Then  lines follow, each containing two integers  and  () and representing an edge between vertices  and . It is guaranteed that these edges form a tree. Next line contains one integer  () \u2014 the number of queries to process. Then  lines follow, -th line containing two numbers  and , which can be used to restore -th query (). -th query can be restored as follows: Let  be the answer for previous query (or  if ). Then , and .", "output": "Print  integers. -th of them has to be equal to the answer to -th query.", "tutorial": "The main idea is to use a two-dimensional data structure: one dimension is depth of vertices, and other dimension is the time we entered a vertex during DFS.Model solution uses sparse table for these purposes. First of all, let's renumerate the vertices so we can handle them easier. We run DFS from the root and then sort the vertices by their depth (and if depths are equal, by time we entered them in DFS). Then we renumerate vertices in this sorted order.We need to denote some functions in order to continue:   \u2014 depth of vertex  in the tree;   \u2014 the time we entered  during DFS;   \u2014 the time we left  during DFS. For each depth we can store a sorted array of vertices belonging do this depth. This will allow us to build an auxiliary sparse table , where  is such vertex  that:  ;  ;   is minimal among all vertices that meet first two conditions. We also need a second sparse table , where  is  iff:  ;  ;   is minimal among all vertices that meet first two conditions. These sparse tables can be built using binary search in arrays we created for depths.Okay, why do we need them? To create a third sparse table that will process the queries themselves: \u2014 the minimum value of  among vertices  such that  belongs to -blocked subtree of some vertex with index included in . This table can be built backwards with the help of auxiliary tables.So, how do we answer the queries? We need to look at the binary representation of  and do something like binary lifting (but descending the tree instead of ascending) and maintain the leftmost and the rightmost vertices on current depth which belong to the subtree we are interested in (and make queries to  on the segment between these two vertices).This solution works in , but, unfortunately (or fortunately to some participants), we made the time limit too high so the structures that require  time to process each query, such as two-dimensional segment trees, might also get AC.", "solution": "#include <bits/stdc++.h>\n\n#define itn int\n#define all(x) (x).begin(), (x).end()\n#define make_unique(x) sort(all((x))); (x).resize(unique(all((x))) - (x).begin())\n\n#ifdef ONLINE_JUDGE\n\tinline int pidorand() {\n\t\treturn ((rand() & 32767) << 15) | (rand() & 32767);\n\t}\n\t#define rand pidorand\n#endif\t// ONLINE_JUDGE\n\n#ifdef OLBOEB\n\t#define return std::cerr << __FUNCTION__ << \"\\n\"; return\n#endif  // OLBOEB\n\nusing namespace std;\n\ninline int nxt() {\n\tint x;\n\tscanf(\"%d\", &x);\n\treturn x;\n}\n\nstruct Vertex {\n\tint level;\n\tint val;\n\n\tVertex() {}\n\tVertex(int l, int v): level(l), val(v) {}\n\n\tbool operator <(const Vertex& ot) const {\n\t\treturn level < ot.level;\n\t}\n};\n\nconst int INF = 1e9 + 10;\n\nstruct SegTree {\n\tint n;\n\tvector<vector<Vertex>> a;\n\tvector<vector<int>> res;\n\n\tSegTree(const vector<int>& level, const vector<int>& vals) {\n\t\tn = 1;\n\t\twhile (n < (int)level.size()) {\n\t\t\tn *= 2;\n\t\t}\n\t\ta.resize(n + n);\n\t\tres.resize(n + n);\n\t\tfor (int i = 0; i < (int)level.size(); ++i) {\n\t\t\ta[n + i] = {{level[i], vals[i]}};\n\t\t\tres[n + i] = {INF, vals[i]};\n\t\t}\n\t\tfor (int i = n - 1; i > 0; --i) {\n\t\t\ta[i].resize(a[i + i].size() + a[i + i + 1].size());\n\t\t\tmerge(all(a[i + i]), all(a[i + i + 1]), a[i].begin());\n\t\t\tres[i].resize(a[i].size() + 1, INF);\n\t\t\tfor (int j = 0; j < (int)a[i].size(); ++j) {\n\t\t\t\tres[i][j + 1] = min(res[i][j], a[i][j].val);\n\t\t\t}\n\t\t}\n\t}\n\n\tint _get(int v, int l1, int r1, int l, int r, int maxk) {\n\t\tif (l >= r1 || l1 >= r) {\n\t\t\treturn INF;\n\t\t}\n\t\tif (l <= l1 && r >= r1) {\n\t\t\tint idx = lower_bound(all(a[v]), Vertex(maxk + 1, 0)) - a[v].begin();\n\t\t\treturn res[v][idx];\n\t\t}\n\t\tint mid = (l1 + r1) / 2;\n\t\treturn min(_get(v + v, l1, mid, l, r, maxk),\n\t\t\t\t   _get(v + v + 1, mid, r1, l, r, maxk));\n\t}\n\n\tint get(int l, int r, int maxk) {\n\t\treturn _get(1, 0, n, l, r, maxk);\n\t}\n};\n\nconst int N = 111111;\nint tin[N], tout[N], level[N];\nint timer = 0;\nvector<int> a[N];\nint val[N];\nvector<int> levels, vals;\n\nvoid dfs(int v, int p = -1) {\n\ttin[v] = timer++;\n\tlevels.push_back(level[v]);\n\tvals.push_back(val[v]);\n\tfor (int x : a[v]) {\n\t\tif (x == p) {\n\t\t\tcontinue;\n\t\t}\n\t\tlevel[x] = level[v] + 1;\n\t\tdfs(x, v);\n\t}\n\ttout[v] = timer;\n}\n\nint main() {\n\tint n = nxt(), root = nxt() - 1;\n\tfor (int i = 0; i < n; ++i) {\n\t\tval[i] = nxt();\n\t}\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tint u = nxt() - 1, v = nxt() - 1;\n\t\ta[u].push_back(v);\n\t\ta[v].push_back(u);\n\t}\n\n\tdfs(root);\n\n\tSegTree tree(levels, vals);\n\tint q = nxt();\n\tint last = 0;\n\twhile (q--) {\n\t\tint p1 = nxt(), p2 = nxt();\n\t\tint x = (p1 + last) % n;\n\t\tint k = (p2 + last) % n;\n\n\t\tlast = tree.get(tin[x], tout[x], level[x] + k);\n\t\tprintf(\"%d\\n\", last);\n\t}\n\n\treturn 0;\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}