{"link": "https://codeforces.com//contest/1327/problem/D", "problemId": "571327", "shortId": "1327D", "contest_number": "1327", "name": "D. Infinite Path", "statement": "You are given a colored permutation . The -th element of the permutation has color .Let's define an  as infinite sequence  where all elements have  ().We can also define a multiplication of permutations  and  as permutation  where . Moreover, we can define a power  of permutation  as .Find the minimum  such that  has at least one infinite path (i.e. there is a position  in  such that the sequence starting from  is an infinite path).It can be proved that the answer always exists.", "input": "The first line contains single integer  () \u2014 the number of test cases. Next  lines contain test cases \u2014 one per three lines. The first line contains single integer  () \u2014 the size of the permutation. The second line contains  integers  (,  for ) \u2014 the permutation . The third line contains  integers  () \u2014 the colors of elements of the permutation. It is guaranteed that the total sum of  doesn't exceed .", "output": "Print  integers \u2014 one per test case. For each test case print minimum  such that  has at least one infinite path.", "tutorial": "Let's look at the permutation as at a graph with  vertices and edges . It's not hard to prove that the graph consists of several cycles (self-loops are also considered as cycles). So, the sequence  is just a walking on the corresponding cycle.Let's consider one cycle . In permutation  we have . But since  or , so  and in general case, .Now, walking with step  we can note, that the initial cycle  split up on  cycles of length . Looking at the definition of infinite path we can understand that all we need to do is to check that at least one of  cycles have all vertices of the same color. We can check it in  time for the cycle  and fixed .The final observation is next: for  and  such that  the produced cycles will have the same sets of vertices and differ only in the order of walking, so we can check only one representative for each , i.e. we can take only such  which divide .We can handle each cycle of  separately. So, using the approximation that the number of divisors of  is , we get  time complexity.", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) int((a).size())\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef pair<int, int> pt;\n\nconst int INF = int(1e9);\nconst li INF64 = li(1e18);\n\nint n;\nvector<int> p, c;\n\ninline bool read() {\n    if(!(cin >> n))\n        return false;\n    p.resize(n);\n    c.resize(n);\n    \n    fore(i, 0, n) {\n        cin >> p[i];\n        p[i]--;\n    }\n    fore(i, 0, n)\n        cin >> c[i];\n    return true;\n}\n\ninline void solve() {\n    vector<int> used(n, 0);\n    \n    int ans = INF;\n    fore(st, 0, n) {\n        if(used[st])\n            continue;\n        \n        vector<int> cycle;\n        int v = st;\n        while(!used[v]) {\n            used[v] = 1;\n            cycle.push_back(v);\n            v = p[v];\n        }\n        \n        fore(step, 1, sz(cycle) + 1) {\n            if(sz(cycle) % step != 0)\n                continue;\n            \n            fore(s, 0, step) {\n                bool eq = true;\n                for(int pos = s; pos + step < sz(cycle); pos += step) {\n                    if(c[cycle[pos]] != c[cycle[pos + step]])\n                        eq = false;\n                }\n                if(eq) {\n                    ans = min(ans, step);\n                    break;\n                }\n            }\n        }\n    }\n    cout << ans << endl;\n}\n\nint main() {\n#ifdef _DEBUG\n    freopen(\"input.txt\", \"r\", stdin);\n    int tt = clock();\n#endif\n    ios_base::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n    cout << fixed << setprecision(15);\n    \n    int tc; cin >> tc;\n    \n    while(tc--) {\n        read();\n        solve();\n        \n#ifdef _DEBUG\n        cerr << \"TIME = \" << clock() - tt << endl;\n        tt = clock();\n#endif\n    }\n    return 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}