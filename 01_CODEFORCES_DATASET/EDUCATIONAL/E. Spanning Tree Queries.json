{"link": "https://codeforces.com//contest/1633/problem/E", "problemId": "1280037", "shortId": "1633E", "contest_number": "1633", "name": "E. Spanning Tree Queries", "statement": "You are given a connected weighted undirected graph, consisting of  vertices and  edges.You are asked  queries about it. Each query consists of a single integer . For each query, you select a spanning tree in the graph. Let the weights of its edges be . The cost of a spanning tree is  (the sum of absolute differences between the weights and ). The answer to a query is the lowest cost of a spanning tree.The queries are given in a compressed format. The first   queries  are provided explicitly. For queries from  to , .Print the xor of answers to all queries.", "input": "The first line contains two integers  and  (; )\u00a0\u2014 the number of vertices and the number of edges in the graph. Each of the next  lines contains a description of an undirected edge: three integers ,  and  (; ; )\u00a0\u2014 the vertices the edge connects and its weight. Note that there might be multiple edges between a pair of vertices. The edges form a connected graph. The next line contains five integers  and  (; ; ; )\u00a0\u2014 the number of queries provided explicitly, the total number of queries and parameters to generate the queries. The next line contains  integers  ()\u00a0\u2014 the first  queries.", "output": "Print a single integer\u00a0\u2014 the xor of answers to all queries.", "tutorial": "Consider a naive solution using Kruskal's algorithm for finding MST. Given some , you arrange the edges in the increasing order of  and process them one by one. Look closely at the arrangements. At  the edges are sorted by . How does the arrangement change when  increases? Well, some edges swap places.Consider a pair of edges with different weights  and  (). Edge  will go before edge  in the arrangement as long as  is closer to  than . So for all  up to , edge  goes before edge . And for all  from  onwards, edge  goes before edge .This tells us that every pair of edge with different weights will swap exactly once. So there will be at most  swaps. Which is at most  different arrangements. Each of them corresponds to some range of 's.We can extract the ranges of 's for all arrangements and calculate MST at the start of each range. We can also find the arrangement that corresponds to some  from a query with a binary search.However, only knowing the weight of the MST at the start of the range is not enough. The weights of edges change later in the range, and we can't predict how. Some edges have their weight increasing, some decreasing.First, let's add more ranges. We want each edge to behave the same way on the entire range: either increase all the way or decrease all the way. If we also add  for all  into the MST calculation, this will hold.Second, let's store another value for each range: the number of edges that have their weight increasing on it. With that, we can easily recalculate the change in the cost of the spanning tree.The TL should be free enough for you to sort the edges for each MST calculation, resulting in  solution. You can also optimize the first part to .", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nstruct edge{\n\tint v, u, w;\n};\n\nvector<int> pr, rk;\n\nint getp(int a){\n\treturn a == pr[a] ? a : pr[a] = getp(pr[a]);\n}\n\nbool unite(int a, int b){\n\ta = getp(a), b = getp(b);\n\tif (a == b) return false;\n\tif (rk[a] < rk[b]) swap(a, b);\n\trk[a] += rk[b];\n\tpr[b] = a;\n\treturn true;\n}\n\nint main() {\n\tint n, m;\n\tscanf(\"%d%d\", &n, &m);\n\tpr.resize(n);\n\trk.resize(n);\n\tvector<edge> es(m);\n\tforn(i, m){\n\t\tscanf(\"%d%d%d\", &es[i].v, &es[i].u, &es[i].w);\n\t\t--es[i].v, --es[i].u;\n\t\tes[i].w *= 2;\n\t}\n\tvector<int> ev(1, 0);\n\tforn(i, m) forn(j, i + 1) ev.push_back((es[i].w + es[j].w) / 2);\n\tsort(ev.begin(), ev.end());\n\tev.resize(unique(ev.begin(), ev.end()) - ev.begin());\n\tvector<long long> base;\n\tvector<int> cnt;\n\tfor (int x : ev){\n\t\tsort(es.begin(), es.end(), [&x](const edge &a, const edge &b){\n\t\t\tint wa = abs(a.w - x);\n\t\t\tint wb = abs(b.w - x);\n\t\t\tif (wa != wb) return wa < wb;\n\t\t\treturn a.w > b.w;\n\t\t});\n\t\tforn(i, n) pr[i] = i, rk[i] = 1;\n\t\tlong long cur_base = 0;\n\t\tint cur_cnt = 0;\n\t\tfor (const auto &e : es) if (unite(e.v, e.u)){\n\t\t\tcur_base += abs(e.w - x);\n\t\t\tcur_cnt += x < e.w;\n\t\t}\n\t\tbase.push_back(cur_base);\n\t\tcnt.push_back(cur_cnt);\n\t}\n\tint p, k, a, b, c;\n\tscanf(\"%d%d%d%d%d\", &p, &k, &a, &b, &c);\n\tint x = 0;\n\tlong long ans = 0;\n\tforn(q, k){\n\t\tif (q < p) scanf(\"%d\", &x);\n\t\telse x = (x * 1ll * a + b) % c;\n\t\tint y = upper_bound(ev.begin(), ev.end(), 2 * x) - ev.begin() - 1;\n\t\tans ^= (base[y] + (n - 1 - 2 * cnt[y]) * 1ll * (2 * x - ev[y])) / 2;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}