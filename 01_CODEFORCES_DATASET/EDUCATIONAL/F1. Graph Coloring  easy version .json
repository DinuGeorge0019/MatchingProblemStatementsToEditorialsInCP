{"link": "https://codeforces.com//contest/1792/problem/F1", "problemId": "1749564", "shortId": "1792F1", "contest_number": "1792", "name": "F1. Graph Coloring  easy version ", "statement": "You are given an undirected complete graph on  vertices. A complete graph is a graph where each pair of vertices is connected by an edge. You have to paint the edges of the graph into two colors, red and blue (each edge will have one color).A set of vertices  is  if, for every pair of vertices  such that  and , there exists a path from  to  that goes only through red edges and vertices from . Similarly, a set of vertices  is  if, for every pair of vertices  such that  and , there exists a path from  to  that goes only through blue edges and vertices from .You have to paint the graph in such a way that:  there is at least one red edge;  there is at least one blue edge;  for each set of vertices  such that ,  is either red-connected or blue-connected, but . Calculate the number of ways to paint the graph, and print it modulo .", "input": "The first (and only) line contains one integer  ().", "output": "Print one integer \u2014 the number of ways to paint the graph, taken modulo .", "tutorial": " if an undirected graph is disconnected, then its complement is connected. Similarly, if its complement is disconnected, then the graph itself is connected. suppose a graph is disconnected. Pick two vertices  and  from different components. Every vertex outside of 's component is connected to  in the complement, and every vertex outside of 's component is connected to  in the complement; the complement also contains the edge from  to , so all vertices in the complement graph belong to the single component.Why do we need this lemma at all? We can treat the graph formed by blue edges as the complement to the graph formed by red edges. So, if the \"red\" graph is disconnected, then the \"blue\" graph is connected, so we don't need to consider the case when some set of vertices is connected by neither color. We only need to make sure that no set of vertices is connected by both colors.Let  be the answer for . Every graph counted in  is either red-disconnected or blue-disconnected; since there is a bijection between red-disconnected and blue-disconnected graphs (you can flip the colors of all edges to transform one type into the other), we will count only red-disconnected graphs and multiply it by .Let  be the number of blue-connected graphs with  vertices meeting the properties of the problem statement. It's easy to see that  if , otherwise  (the case  is special because a graph on one vertex is both red-connected and blue-connected). To calculate , let's iterate on  \u2014 the number of vertices which are in the same \"red\" component as . This component must be a red-connected graph which meets the problem statement, so the number of ways to build the graph on these  vertices is ; there are  ways to choose the vertices in the same component as , and the remaining graph can be either red-connected or blue-connected, so the number of ways to build the remaining graph is .Thus, we get the following two relations:We can calculate all values with dynamic programming using these formulas in .", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int MOD = 998244353;\n\nint add(int x, int y)\n{\n    x += y;\n    while(x >= MOD) x -= MOD;\n    while(x < 0) x += MOD;\n    return x;\n}\n\nint mul(int x, int y)\n{\n    return (x * 1ll * y) % MOD;\n}\n\nint varMul(int x)\n{\n    return x;\n}\n\ntemplate<typename... Args>\nint varMul(int x, Args... args)\n{\n    return mul(x, varMul(args...));\n}\n\nint binpow(int x, int y)\n{\n    int z = 1;\n    while(y)\n    {\n        if(y & 1) z = mul(z, x);\n        x = mul(x, x);\n        y /= 2;\n    }\n    return z;\n}\n\nvector<int> fact, rfact;\nvector<int> dp;\nint n;\n\nvoid precalc()\n{\n    fact.resize(n + 1);\n    rfact.resize(n + 1);\n    fact[0] = 1;\n    for(int i = 1; i <= n; i++)\n        fact[i] = mul(i, fact[i - 1]);\n    for(int i = 0; i <= n; i++)\n        rfact[i] = binpow(fact[i], MOD - 2);\n    dp.resize(n + 1, -1);\n}\n\nint C(int n, int k)\n{\n    if(n < 0 || n < k || k < 0) return 0;\n    return varMul(fact[n], rfact[k], rfact[n - k]);\n}\n\nint calc(int x)\n{\n    if(dp[x] != -1) return dp[x];\n    if(x == 1) return dp[x] = 1;\n    if(x == 2) return dp[x] = 1;\n    dp[x] = 0;\n    int& d = dp[x];\n    for(int i = 1; i < x; i++)\n    {\n        d = add(d, varMul(calc(i), (i == x - 1 ? (MOD + 1) / 2 : calc(x - i)), 2, C(x - 1, i - 1)));\n    }   \n    return d;\n}\n\nint main()\n{\n    cin >> n;\n    precalc();\n    cout << add(mul(calc(n), 2), -2) << endl;\n}", "interactive": false, "noSolution": false, "noTutorial": false}