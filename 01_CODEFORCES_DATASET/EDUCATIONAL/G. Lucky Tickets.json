{"link": "https://codeforces.com//contest/1096/problem/G", "problemId": "275414", "shortId": "1096G", "contest_number": "1096", "name": "G. Lucky Tickets", "statement": "All bus tickets in Berland have their numbers. A number consists of  digits ( is even). Only  decimal digits  can be used to form ticket numbers. If  is among these digits, then numbers may have leading zeroes. For example, if  and only digits  and  can be used, then , ,  are valid ticket numbers, and , ,  are not.A ticket is lucky if the sum of first  digits is equal to the sum of remaining  digits. Calculate the number of different lucky tickets in Berland. Since the answer may be big, print it modulo .", "input": "The first line contains two integers  and   \u2014 the number of digits in each ticket number, and the number of different decimal digits that may be used.  is even. The second line contains a sequence of  integers   \u2014 the digits that may be used in ticket numbers. The digits are given in arbitrary order.", "output": "Print the number of lucky ticket numbers, taken modulo .", "tutorial": "The naive solution would be  \u2014 the number of sequences of allowed digits with length  and sum . We compute it for  and for every possible , and the answer is .Let's speed this up. Let's denote the following polynomial: , where  if  is an allowed digit, otherwise .It's easy to see that the coefficients of  are equal to the values of . Using mathematical induction we may prove that the coefficients of  are equal to .So now we need to compute . There are two possible ways to do this that result in  complexity. The first option is to apply binary exponentiation with NTT polynomial multiplication. The second option is to use the fact that if we apply NTT to a polynomial, we get a set of its values in some points. So, if we exponentiate these values, we get a set of values of exponentiated polynomial in the same points. So we may apply NTT to  treating it as a polynomial of degree , raise each resulting value to the power of  and apply inverse transformation.", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define forn(i, n) fore(i, 0, n)\n\n#define sz(a) int((a).size())\n#define all(a) (a).begin(), (a).end()\n\n#define mp make_pair\n#define pb push_back\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef long double ld;\ntypedef pair<int, int> pt;\n\ntemplate<class A, class B> ostream& operator <<(ostream& out, const pair<A, B> &p) {\n\treturn out << \"(\" << p.x << \", \" << p.y << \")\";\n}\n\ntemplate<class A> ostream& operator <<(ostream& out, const vector<A> &v) {\n\tout << \"[\";\n\tforn(i, sz(v)) {\n\t\tif(i) out << \", \";\n\t\tout << v[i];\n\t}\n\treturn out << \"]\";\n}\n\nconst int INF = int(1e9);\nconst li INF64 = li(1e18);\nconst ld EPS = 1e-9;\n\nconst int N = 2500 * 1000 + 555;\nconst int LOGN = 22;\n\nconst int MOD = 998244353;\nint g = 3;\n\ninline int mul(int a, int b){\n\treturn int(a * 1ll * b % MOD);\n}\n\ninline int norm(int a) {\n\tif(a >= MOD)\n\t\ta -= MOD;\n\tif(a < 0)\n\t\ta += MOD;\n\treturn a;\n}\n\ninline int binPow(int a, int k) {\n\tint ans = 1;\n\twhile(k > 0) {\n\t\tif(k & 1)\n\t\t\tans = mul(ans, a);\n\t\ta = mul(a, a);\n\t\tk >>= 1;\n\t}\n\treturn ans;\n}\n\ninline int inv(int a) {\n\treturn binPow(a, MOD - 2);\n}\n\nvector<int> w[LOGN];\nvector<int> rv[LOGN];\n\nvoid precalc() {\n    int wb = binPow(g, (MOD - 1) / (1 << LOGN));\n\n    for(int st = 0; st < LOGN - 1; st++) {\n        w[st].assign(1 << st, 1);\n\n        int bw = binPow(wb, 1 << (LOGN - st - 1));\n        int cw = 1;\n\n        for (int k = 0; k < (1 << st); k++) {\n            w[st][k] = cw;\n            cw = mul(cw, bw);\n        }\n    }\n    for(int st = 0; st < LOGN; st++) {\n        rv[st].assign(1 << st, 0);\n\n        if(st == 0) {\n            rv[st][0] = 0;\n            continue;\n        }\n        int h = (1 << (st - 1));\n        for(int k = 0; k < (1 << st); k++)\n            rv[st][k] = (rv[st - 1][k & (h - 1)] << 1) | (k >= h);\n    }\n}\n\ninline void fft(int a[N], int n, bool inverse) {\n    int ln = 0;\n    while((1 << ln) < n)\n        ln++;\n\n    assert((1 << ln) < N);\n    n = (1 << ln);\n\n    forn(i, n) {\n        int ni = rv[ln][i];\n        if(i < ni)\n            swap(a[i], a[ni]);\n    }\n\n    for(int st = 0; (1 << st) < n; st++) {\n        int len = (1 << st);\n        for(int k = 0; k < n; k += (len << 1)) {\n            for(int pos = k; pos < k + len; pos++) {\n                int l = a[pos];\n                int r = mul(a[pos + len], w[st][pos - k]);\n\n                a[pos] = norm(l + r);\n                a[pos + len] = norm(l - r);\n            }\n        }\n    }\n\n    if(inverse) {\n        int in = inv(n);\n        forn(i, n)\n            a[i] = mul(a[i], in);\n        reverse(a + 1, a + n);\n    }\n}\n\nint aa[N], bb[N], cc[N];\n\ninline vector<int> multiply(const vector<int> a, const vector<int> b) {\n\tint ln = 1;\n\twhile(ln < (sz(a) + sz(b)))\n\t\tln <<= 1;\n\t\t\n\tforn(i, ln)\n\t\taa[i] = (i < sz(a) ? a[i] : 0);\n\t\t\n\tforn(i, ln)\n\t\tbb[i] = (i < sz(b) ? b[i] : 0);\n\t\t\n\tfft(aa, ln, false);\n\tfft(bb, ln, false);\n\t\n\tforn(i, ln)\n\t\tcc[i] = mul(aa[i], bb[i]);\n\t\t\n\tfft(cc, ln, true);\n\t\n\tvector<int> c(ln, 0);\n\tforn(i, sz(c))\n\t\tc[i] = cc[i];\n\t\n\twhile(sz(c) > 1 && c.back() == 0)\n\t\tc.pop_back();\n\treturn c;\n}\n\nint n, k, a[11];\n\ninline bool read() {\n\tif(!(cin >> n >> k))\n\t\treturn false;\n\tforn(i, k)\n\t\tcin >> a[i];\n\treturn true;\n}\n\ninline void solve() {\n\tsort(a, a + k);\n\t\n\tvector<int> ans(1, 1);\n\tvector<int> f(10, 0);\n\tforn(i, k)\n\t\tf[a[i]] = 1;\n\n\tprecalc();\n\t\t\n\tint pw = n / 2;\n\twhile(pw > 0) {\n\t\tif(pw & 1)\n\t\t\tans = multiply(ans, f);\n\t\tf = multiply(f, f);\n\t\tpw >>= 1;\n\t}\n\t\n\tint res = 0;\n\tforn(i, sz(ans))\n\t\tres = norm(res + mul(ans[i], ans[i]));\n\tcout << res << endl;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint tt = clock();\n#endif\n\tcout << fixed << setprecision(15);\n\t\n\tif(read()) {\n\t\tsolve();\n\t\t\n#ifdef _DEBUG\n\t\tcerr << \"TIME = \" << clock() - tt << endl;\n\t\ttt = clock();\n#endif\n\t}\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}