{"link": "https://codeforces.com//contest/1455/problem/B", "problemId": "815715", "shortId": "1455B", "contest_number": "1455", "name": "B. Jumps", "statement": "You are standing on the -axis at point  and you want to move to an integer point .You can make several jumps. Suppose you're currently at point  ( may be negative) and jump for the -th time. You can:   either jump to the point   or jump to the point . What is the minimum number of jumps you need to reach the point ?", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of test cases. The first and only line of each test case contains the single integer  ()\u00a0\u2014 the destination point.", "output": "For each test case, print the single integer\u00a0\u2014 the minimum number of jumps to reach . It can be proved that we can reach any integer point .", "tutorial": "At first, let's jump with  while  is still greater than the current position. Now we finished in some position . Note that  otherwise, we wouldn't make the last step.If  then we are lucky to finish right in point . Otherwise, let's look at what happens if we replace one  with . Basically, we'll finish in . And since  then .We know that  so if  then we can choose the corresponding  and replace  with  and get straight to the point . But if  then we need one extra operation .To calculate  fast we can note we need at least  since  and then we can increase  while .", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n\tint t; cin >> t;\n\twhile (t--) {\n\t\tint x; cin >> x;\n\t\t\n\t\tint steps = 0;\n\t\twhile (steps * (steps + 1) < 2 * x)\n\t\t\tsteps++;\n\t\t\n\t\tif (steps * (steps + 1) / 2 == x + 1)\n\t\t\tsteps++;\n\t\tcout << steps << endl;\n\t}\n}", "interactive": false, "noSolution": false, "noTutorial": false}