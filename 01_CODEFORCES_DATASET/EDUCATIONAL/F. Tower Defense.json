{"link": "https://codeforces.com//contest/1651/problem/F", "problemId": "1324101", "shortId": "1651F", "contest_number": "1651", "name": "F. Tower Defense", "statement": "Monocarp is playing a tower defense game. A level in the game can be represented as an OX axis, where each lattice point from  to  contains a tower in it.The tower in the -th point has  mana capacity and  mana regeneration rate. In the beginning, before the -th second, each tower has full mana. If, at the end of some second, the -th tower has  mana, then it becomes  mana for the next second.There are  monsters spawning on a level. The -th monster spawns at point  at the beginning of -th second, and it has  health. Every monster is moving  point per second in the direction of increasing coordinate.When a monster passes the tower, the tower deals  damage to it, where  is the current health of the monster and  is the current mana amount of the tower. This amount gets subtracted from both monster's health and tower's mana.Unfortunately, sometimes some monsters can pass all  towers and remain alive. Monocarp wants to know what will be the total health of the monsters after they pass all towers.", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of towers. The -th of the next  lines contains two integers  and  ()\u00a0\u2014 the mana capacity and the mana regeneration rate of the -th tower. The next line contains a single integer  ()\u00a0\u2014 the number of monsters. The -th of the next  lines contains two integers  and  (; )\u00a0\u2014 the time the -th monster spawns and its health. The monsters are listed in the increasing order of their spawn time, so  for all .", "output": "Print a single integer\u00a0\u2014 the total health of all monsters after they pass all towers.", "tutorial": "Let's start thinking about the problem from the easy cases.How to solve the problem fast if all towers have full mana? We can store prefix sums of their capacities and find the first tower that doesn't get drained completely with a binary search.Let's try the opposite. How to solve the problem fast if all towers were drained completely in the previous second? It's the same but the prefix sums are calculated over regeneration rates.What if all towers were drained at the same second, earlier than the previous second, and no tower is fully restored yet? It's also the same but the regeneration rates are multiplied by the time passed since the drain.What if we drop the condition about the towers not being fully restored? How would a data structure that can answer prefix sum queries work? It should store the total mana capacity of all towers that are full. Then mana regeneration rates for all towers that aren't. If these are kept separately, then it's easy to obtain the prefix sum by providing the time passed. This will be total capacity plus total regeneration rate, multiplied by the time passed.How to determine if the tower is fully restored since the drain or not? That's easy. For each tower, we can calculate the number of seconds it takes it to get restored from zero. That is . Thus, all towers that have this value smaller than the time passed won't get restored. All the rest will.Unfortunately, in the actual problem, not all towers were last drained at the same time. However, it's possible to reduce the problem to that. Store the segments of towers that were drained at same time. There are also towers that weren't drained completely, but they can be stored as segments of length  too. When a monster comes, it drains some prefix of the towers completely and possibly one more tower partially. In terms of segments, it removes some prefix of the them and possibly cuts one. Then it creates a segment that covers the prefix and possibly a segment of length  (with a partially drained tower). So each monster creates  segments and removes no more segments than were created. Thus, if we were to process each creation and removal in some , then the complexity will be .All towers on each segment have the same time passed since the drain. We want to query the sum on the entire segment. If it is greater than the remaining health of the monster, we want to find the largest prefix of this segment that has a smaller or equal sum than the monster health.Given time passed, let's learn to query the range sum. If we knew the queries beforehand, it would be easy. Initialize a segment tree as if all towers are completely restored. Then make events of two kinds: a tower with restore time  and a query with time . Sort them in the decreasing order and start processing one by one. When a tower event happens, update a single position in the segment tree from capacity to regeneration rate. When a query event happens, find the sum.Since the queries are not known beforehand, make that segment tree persistent and ask specific versions of it. If a segment of towers was last drained at time , and the query is at time , then you should query the segment tree in version . Obviously, you can store not all versions but only ones that have some tower change. Moreover, it's more convenient to make one version responsible for one tower update. Then you can lower_bound the array of sorted  to find the version you want to ask at.To determine the largest prefix of this segment that has a smaller or equal sum than the monster health, you can either binary search for  or traverse the segment tree for . The time limit might be a little tight for the first approach, but it can still pass.Overall complexity: .", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nstruct node{\n\tnode *l, *r;\n\tlong long sumc, sumr;\n\tnode() : l(NULL), r(NULL), sumc(0), sumr(0) {}\n\tnode(node* l, node* r, long long sumc, long long sumr) : l(l), r(r), sumc(sumc), sumr(sumr) {}\n};\n\nnode* build(int l, int r, vector<int> &c){\n\tif (l == r - 1)\n\t\treturn new node(NULL, NULL, c[l], 0);\n\tint m = (l + r) / 2;\n\tnode* nw = new node();\n\tnw->l = build(l, m, c);\n\tnw->r = build(m, r, c);\n\tnw->sumc = nw->l->sumc + nw->r->sumc;\n\treturn nw;\n}\n\nnode* upd(node* v, int l, int r, int pos, int val){\n\tif (l == r - 1)\n\t\treturn new node(NULL, NULL, 0, val);\n\tint m = (l + r) / 2;\n\tnode* nw = new node(v->l, v->r, 0, 0);\n\tif (pos < m)\n\t\tnw->l = upd(v->l, l, m, pos, val);\n\telse\n\t\tnw->r = upd(v->r, m, r, pos, val);\n\tnw->sumc = nw->l->sumc + nw->r->sumc;\n\tnw->sumr = nw->l->sumr + nw->r->sumr;\n\treturn nw;\n}\n\nlong long getsum(node *v, int mult){\n\treturn v->sumc + v->sumr * mult;\n}\n\nint trav(node *v, int l, int r, int L, int R, long long &lft, int mult){\n\tif (L >= R){\n\t\treturn 0;\n\t}\n\tif (l == L && r == R && lft - getsum(v, mult) >= 0){\n\t\tlft -= getsum(v, mult);\n\t\treturn r - l;\n\t}\n\tif (l == r - 1){\n\t\treturn 0;\n\t}\n\tint m = (l + r) / 2;\n\tint cnt = trav(v->l, l, m, L, min(m, R), lft, mult);\n\tif (cnt == max(0, min(m, R) - L))\n\t\tcnt += trav(v->r, m, r, max(m, L), R, lft, mult);\n\treturn cnt;\n}\n\nstruct seg{\n\tint l, r, lst, cur;\n};\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tvector<int> c(n), r(n);\n\tforn(i, n) scanf(\"%d%d\", &c[i], &r[i]);\n\t\n\tvector<int> ord(n);\n\tiota(ord.begin(), ord.end(), 0);\n\tsort(ord.begin(), ord.end(), [&](int x, int y){\n\t\treturn c[x] / r[x] > c[y] / r[y];\n\t});\n\tvector<int> vals;\n\tfor (int i : ord) vals.push_back(c[i] / r[i]);\n\t\n\tvector<node*> root(1, build(0, n, c));\n\tfor (int i : ord)\n\t\troot.push_back(upd(root.back(), 0, n, i, r[i]));\n\t\n\tvector<seg> st;\n\tfor (int i = n - 1; i >= 0; --i)\n\t\tst.push_back({i, i + 1, 0, c[i]});\n\t\n\tlong long ans = 0;\n\tint q;\n\tscanf(\"%d\", &q);\n\tforn(_, q){\n\t\tint t;\n\t\tlong long h;\n\t\tscanf(\"%d%lld\", &t, &h);\n\t\twhile (!st.empty()){\n\t\t\tauto it = st.back();\n\t\t\tst.pop_back();\n\t\t\tif (it.r - it.l == 1){\n\t\t\t\tit.cur = min((long long)c[it.l], it.cur + (t - it.lst) * 1ll * r[it.l]);\n\t\t\t\tif (it.cur <= h){\n\t\t\t\t\th -= it.cur;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tst.push_back({it.l, it.r, t, int(it.cur - h)});\n\t\t\t\t\th = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint mx = vals.rend() - lower_bound(vals.rbegin(), vals.rend(), t - it.lst);\n\t\t\t\tint res = it.l + trav(root[mx], 0, n, it.l, it.r, h, t - it.lst);\n\t\t\t\tassert(res <= it.r);\n\t\t\t\tif (res != it.r){\n\t\t\t\t\tif (it.r - res > 1)\n\t\t\t\t\t\tst.push_back({res + 1, it.r, it.lst, 0});\n\t\t\t\t\tint nw = min((long long)c[res], r[res] * 1ll * (t - it.lst));\n\t\t\t\t\tassert(nw - h > 0);\n\t\t\t\t\tst.push_back({res, res + 1, t, int(nw - h)});\n\t\t\t\t\th = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (h == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (st.empty()){\n\t\t\tst.push_back({0, n, t, 0});\n\t\t}\n\t\telse if (st.back().l != 0){\n\t\t\tst.push_back({0, st.back().l, t, 0});\n\t\t}\n\t\tans += h;\n\t}\n\t\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}