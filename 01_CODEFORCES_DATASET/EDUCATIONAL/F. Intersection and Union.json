{"link": "https://codeforces.com//contest/1743/problem/F", "problemId": "1590321", "shortId": "1743F", "contest_number": "1743", "name": "F. Intersection and Union", "statement": "You are given  segments on the coordinate axis. The -th segment is . Let's denote the set of all integer points belonging to the -th segment as .Let  be the union of two sets  and ,  be the intersection of two sets  and , and  be the symmetric difference of  and  (a set which contains all elements of  and all elements of , except for the ones that belong to both sets).Let  be an array where each element is either , , or . Over all  ways to choose this array, calculate the sum of the following values:In this expression,  denotes the size of the set .", "input": "The first line contains one integer  (). Then,  lines follow. The -th of them contains two integers  and  ().", "output": "Print one integer \u2014 the sum of  over all possible ways to choose . Since the answer can be huge, print it modulo .", "tutorial": "We will use the Contribution to the Sum technique to solve this problem: for every integer from  to , let's calculate the number of ways to choose the operators so it belongs to the result, and add all of the results.For a fixed integer , the number of ways to choose the operators so that  belongs to the result can be done as follows: let  be the number of ways to choose the first  operators so that, after applying them, the resulting set contains  if , and does not contain  if . The transitions from  to  depend on whether the number  belongs to the segment .Obviously, this is too slow if we compute the dynamic programming from scratch for every integer . Instead, we can notice that the transitions from  to  are linear combinations: both  and  are linear combinations of  and  with coefficients depending on whether the element  belongs to the set or not. So, transitioning from  to  can be written in terms of multiplying by a  matrix.Let's build a segment tree where each vertex stores a transition matrix, and operations are \"calculate the product of matrices on a segment\" and \"replace a matrix at some index\". We can build a sequence of these transition matrices for  and store them in the segment tree; for , this sequence of transition matrices will change only in positions  such that either  belongs to  and  does not belong to it, or vice versa. So, we can go from  to  by replacing these transition matrices in the segment tree. For , the only changes from  are in positions  such that either  belongs to  and  does not belong to it, or vice versa \u2014 and we can replace the matrices in these positions as well. In total, there will be only  such replacements; so, we solve the problem in , where  is the constraint on the numbers belonging to the sets. ", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 300043;\n\ntypedef array<int, 2> vec;\ntypedef array<vec, 2> mat;\n\nconst int MOD = 998244353;\n\nmat operator*(const mat& a, const mat& b)\n{\n    mat c;\n    for(int i = 0; i < 2; i++)\n        for(int j = 0; j < 2; j++)\n            c[i][j] = 0;\n    for(int i = 0; i < 2; i++)\n        for(int j = 0; j < 2; j++)\n            for(int k = 0; k < 2; k++)\n                c[i][k] = (a[i][j] * 1ll * b[j][k] + c[i][k]) % MOD;\n    return c;\n}\n\nmat ZERO = {vec({3, 0}), vec({1, 2})};\nmat ONE = {vec({1, 2}), vec({1, 2})};\n\nmat t[4 * N];\n\nvoid recalc(int v)\n{\n    t[v] = t[v * 2 + 1] * t[v * 2 + 2];    \n}\n\nvoid build(int v, int l, int r)\n{\n    if(l == r - 1)\n    {            \n        t[v] = ZERO;                       \n    }\n    else\n    {\n        int m = (l + r) / 2;\n        build(v * 2 + 1, l, m);\n        build(v * 2 + 2, m, r);\n        recalc(v);               \n    }\n}\n\nvoid upd(int v, int l, int r, int pos, int val)\n{\n    if(l == r - 1)\n    {\n        if(val == 0) t[v] = ZERO;\n        else t[v] = ONE;\n    }\n    else\n    {\n        int m = (l + r) / 2;\n        if(pos < m) upd(v * 2 + 1, l, m, pos, val);\n        else upd(v * 2 + 2, m, r, pos, val);\n        recalc(v);\n    }\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    int n;\n    cin >> n;\n    vector<vector<pair<int, int>>> v(N);\n    for(int i = 0; i < n; i++)\n    {\n        int l, r;\n        cin >> l >> r;\n        v[l].push_back(make_pair(1, i));\n        v[r + 1].push_back(make_pair(0, i));\n    }    \n    build(0, 0, n - 1);\n    int cur = 0;\n    int ans = 0;\n    for(int i = 0; i <= 300000; i++)\n    {\n        for(auto x : v[i])\n        {\n            if(x.second == 0) cur = x.first;\n            else upd(0, 0, n - 1, x.second - 1, x.first);\n        }\n        ans = (ans + t[0][cur][1]) % MOD;\n    }\n    cout << ans << endl;\n}", "interactive": false, "noSolution": false, "noTutorial": false}