{"link": "https://codeforces.com//contest/915/problem/F", "problemId": "146473", "shortId": "915F", "contest_number": "915", "name": "F. Imbalance Value of a Tree", "statement": "You are given a tree  consisting of  vertices. A number is written on each vertex; the number written on vertex  is . Let's denote the function  as the difference between maximum and minimum value of  on a simple path connecting vertices  and .Your task is to calculate .", "input": "The first line contains one integer number  () \u2014 the number of vertices in the tree. The second line contains  integer numbers , , ...,  () \u2014 the numbers written on the vertices. Then  lines follow. Each line contains two integers  and  denoting an edge connecting vertex  and vertex  (, ). It is guaranteed that these edges denote a tree.", "output": "Print one number equal to .", "tutorial": "Let's calculate the answer as the difference between sum of maxima and sum of minima over all paths. These sums can be found by the following approach:Consider the sum of maxima. Let's sort all vertices in ascending order of values of  (if two vertices have equal values, their order doesn't matter). This order has an important property that we can use: for every path, the maximum on this path is written on the vertex that has the greatest position in sorted order. This allows us to do the following:Let's denote as  a tree, rooted at vertex , that is formed by the set of such vertices  that are directly connected to  or some other vertex from the set, and have . Consider the vertices that are connected to  in this tree. Let's denote them as , , ...,  (the order doesn't matter), and denote by  the size of the subtree of  in the tree . Let's try to calculate the number of paths going through  in this tree:   paths that have  as its endpoint;   paths (connecting a vertex from subtree of  to a vertex from subtree of ). So vertex  adds the sum of these values, multiplied by , to the sum of maxima. To calculate these sums, we will use the following algorithm:Initialize a DSU (disjoint set union), making a set for each vertex. Process the vertices in sorted order. When we process some vertex , find all its already processed neighbours (they will be , , ...,  in ). For every neighbour , denote the size of its set in DSU as . Then calculate the number of paths going through  using aforementioned formulas (to do it in linear time, use partial sums). Add this number, multiplied by , to the sum of maxima, and merge  with , , ...,  in DSU.To calculate the sum of minima, you can do the same while processing vertices in reversed order.Time complexity of this solution is .", "solution": "#define _CRT_SECURE_NO_DEPRECATE\n#pragma comment(linker, \"/STACK:167772160000\")\n#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <stdio.h>\n#include <cstdlib>\n#include <stdlib.h>\n#include <string>\n#include <list>\n#include <fstream>\n#include <algorithm>\n#include <cmath>\n#include <map>\n#include <vector>\n#include <iomanip>\n#include <queue>\n#include <deque>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <assert.h>\n#include <functional>\n#include <climits>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\n//typedef uint64_t ull;\n//typedef std::pair<long double,long double> pdd;\n#define for8(i) for( i = 1; i<=8; i++)\n#define fori(N)          for(int i = 0; i<(N); i++)\n#define forj(N)         for(int j = 0; j<(N); j++)\n#define fork(N)         for(int k = 0; k<(N); k++)\n#define forl(N)         for(int l = 0; l<(N); l++)\n#define ford(N)         for(int d = 0; d<(N); d++)\n#define fori1(N)          for(int i = 1; i<=(N); i++)\n#define forj1(N)         for(int j = 1; j<=(N); j++)\n#define fork1(N)         for(int k = 1; k<=(N); k++)\n#define ford1(N)         for(int d = 1; d<=(N); d++)\n#define PI (2*asin(1))\n#define read(n) scanf(\"%d\", &n);\n#define read2(n, m) scanf(\"%d%d\", &n, &m);\n#define readll(n) scanf(\"%I64d\", &n);\n#define mp make_pair\nint n;\nvector<int>edges[1100000];\nint par[1100000];\nint siz[1100000];\nint find(int a) {\n\tif (par[a] == a)return a;\n\tpar[a] = find(par[a]);\n\treturn par[a];\n}\nvoid unite(int a, int b) {\n\ta = find(a);\n\tb = find(b);\n\tif (a == b)return;\n\tsiz[a] += siz[b];\n\tpar[b] = a;\n}\nll w[1100000];\npll p[1100000];\nbool vis[1100000];\nll solve() {\n\tfori1(n) {\n\t\tvis[i] = false;\n\t\tpar[i] = i;\n\t\tsiz[i] = 1;\n\t}\n\tll answer = 0;\n\tfori1(n) {\n\t\tp[i] = mp(w[i], i);\n\t}\n\tsort(p + 1, p + 1 + n);\n\n\tfork1(n) {\n\t\tint a = p[k].second;\n\t\tanswer += w[a];\n\t\tll have = 1;\n\t\tfor (auto x : edges[a]) {\n\t\t\tif (!vis[x])continue;\n\t\t\tanswer += have*siz[find(x)] * w[a];\n\t\t\thave += siz[find(x)];\n\t\t\tunite(a, x);\n\t\t}\n\t\tvis[a] = true;\n\t}\n\treturn answer;\n}\n\n\nint main()\n{\n\tios::sync_with_stdio(false); cin.tie(0);\n#if defined(_DEBUG) || defined(_RELEASE)\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\tcin >> n;\n\tfori1(n)cin >> w[i];\n\tfori(n - 1) {\n\t\tint a, b; cin >> a >> b;\n\t\tedges[a].push_back(b);\n\t\tedges[b].push_back(a);\n\t}\n\tll ans = solve();\n\tfori1(n)w[i] = -w[i];\n\tans += solve();\n\tcout << ans;\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}