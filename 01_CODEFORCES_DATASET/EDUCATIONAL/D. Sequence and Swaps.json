{"link": "https://codeforces.com//contest/1455/problem/D", "problemId": "815717", "shortId": "1455D", "contest_number": "1455", "name": "D. Sequence and Swaps", "statement": "You are given a sequence  consisting of  integers , and an integer . Your task is to make the sequence  sorted (it is considered sorted if the condition  holds).To make the sequence sorted, you may perform the following operation any number of times you want (possibly zero): choose an integer  such that  and , and swap the values of  and .For example, if , , the following sequence of operations is possible:  choose  (it is possible since ), then , ;  choose  (it is possible since ), then , ;  choose  (it is possible since ), then , . Calculate the minimum number of operations you have to perform so that  becomes sorted, or report that it is impossible.", "input": "The first line contains one integer  () \u2014 the number of test cases. Each test case consists of two lines. The first line contains two integers  and  (, ) \u2014 the number of elements in the sequence and the initial value of . The second line contains  integers , , ...,  (). The sum of values of  over all test cases in the input does not exceed .", "output": "For each test case, print one integer \u2014 the minimum number of operations you have to perform to make  sorted, or , if it is impossible.", "tutorial": "The main fact that allows us to solve this problem is that the value of  always increases after swaps, and since the resulting sequence should be sorted, the indices of elements we swap with  also increase.This observation is actually enough for us to implement a dynamic programming solution of the form \"dp_{i, j} is the minimum number of actions we have to perform to reach the following situation: the last integer we swapped with  was , and the current value of  is \". Depending on your implementation, it works either in  or in .But there exists a much simpler to code greedy solution: scan the array from left to right until it is sorted, and find the first element such that we can apply the operation to it (and apply that operation to it). Implementing it in  or even in  is easy, but proving it is a bit harder. The key fact that is required to prove it is that if we can apply an operation to some position, but don't do it and instead apply this operation to some position to the right of that one, the elements on these two positions are no longer sorted (if we can apply the operation to some position , then , but if we apply the operation to position  instead, then after it ). Since we can't go backward, the resulting array cannot be sorted by any means \u2014 that's why we can't skip elements in this greedy solution.", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    int t;\n    cin >> t;\n    for(int i = 0; i < t; i++)\n    {\n        int n, x;\n        cin >> n >> x;\n        vector<int> a(n);\n        for(int i = 0; i < n; i++)\n            cin >> a[i];\n        if(is_sorted(a.begin(), a.end()))\n        {\n            cout << 0 << endl;\n            continue;\n        }\n        vector<vector<int>> dp(n, vector<int>(501, int(1e9)));\n        for(int i = 0; i < n; i++)\n        {\n            if(a[i] > x && (i == 0 || a[i - 1] <= x))\n                dp[i][x] = 1;\n            if(i < n - 1 && a[i] > a[i + 1])\n                break;\n        }\n        int ans = int(1e9);\n        for(int i = 0; i < n; i++)\n            for(int j = 0; j <= 500; j++)\n            {\n                if(dp[i][j] == int(1e9))\n                    continue;\n                if(i == n || (j <= a[i + 1] && is_sorted(a.begin() + i + 1, a.end())))\n                    ans = min(ans, dp[i][j]);\n                bool good = true;\n                for(int k = i + 1; k < n; k++)\n                {\n                    int pr = k == i + 1 ? j : a[k - 1];\n                    if(good && a[i] >= pr && a[i] < a[k])\n                        dp[k][a[i]] = min(dp[k][a[i]], dp[i][j] + 1);\n                    good &= a[k] >= pr;\n                }\n            }\n        if(ans == int(1e9))\n            ans = -1;\n        cout << ans << endl;\n        \n    }   \n}", "interactive": false, "noSolution": false, "noTutorial": false}