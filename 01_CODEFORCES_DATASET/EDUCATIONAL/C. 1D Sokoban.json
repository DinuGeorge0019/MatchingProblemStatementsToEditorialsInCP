{"link": "https://codeforces.com//contest/1494/problem/C", "problemId": "913252", "shortId": "1494C", "contest_number": "1494", "name": "C. 1D Sokoban", "statement": "You are playing a game similar to Sokoban on an infinite number line. The game is discrete, so you only consider integer positions on the line.You start on a position . There are  boxes, the -th box is on a position . All positions of the boxes are distinct. There are also  special positions, the -th position is . All the special positions are also distinct.In one move you can go one position to the left or to the right. If there is a box in the direction of your move, then you push the box to the next position in that direction. If the next position is taken by another box, then that box is also pushed to the next position, and so on. . .You are allowed to perform any number of moves (possibly, zero). Your goal is to place as many boxes on special positions as possible. Note that some boxes can be initially placed on special positions.", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of testcases. Then descriptions of  testcases follow. The first line of each testcase contains two integers  and  ()\u00a0\u2014 the number of boxes and the number of special positions, respectively. The second line of each testcase contains  distinct integers in the increasing order  (; )\u00a0\u2014 the initial positions of the boxes. The third line of each testcase contains  distinct integers in the increasing order  (; )\u00a0\u2014 the special positions. The sum of  over all testcases doesn't exceed . The sum of  over all testcases doesn't exceed .", "output": "For each testcase print a single integer\u00a0\u2014 the maximum number of boxes that can be placed on special positions.", "tutorial": "Since you can only push boxes, you can't bring boxes from negative positions to positive ones and vice versa. Thus, negative boxes/special positions and positive boxes/special positions are two separate tasks. You can solve them independently with the same algorithm and add up the answers.So, we will only consider the positive boxes/special positions case. Notice that it never makes sense to move left. Thus, the only thing that determines the answer is the maximum position to the right you reach.For a naive algorithm, we could iterate over that position, push all boxes that we have encountered on our way ahead of us and calculate the number of boxes that are on special positions. That works in , where  is maximum coordinate.To improve that solution we can notice that the positions that are the most optimal are actually the ones such that the first box is pushed to some special position.Consider the case the first box isn't on a special position, and there is a special position somewhere to the right of it. There are two types of boxes: the ones that are in the pile you would push if you move right and the remaining suffix.What happens if you move one step to the right? The number of boxes from the suffix on special positions doesn't change. The number of boxes from the pile on special positions doesn't decrease. This number changes depending on if there is a special position immediately to the right of the pile and underneath the first box. Since we considered the case where there is no special position underneath the first box, the number can't decrease.So we managed to improve the solution to . Still slow. Let's now learn to maintain the answer while moving the boxes. Precalculate \u00a0\u2014 the number of boxes from the -th to the last one that are already on special positions. That can be done with two pointers. Now iterate over the special position under the first box in the increasing order. Maintain the size of the pile and the number of special positions under the pile. The first value is just the index of the first box not in a pile. The second value is easier to obtain if you keep the index of the first special position after the pile (or  if there are none). Also achievable with two pointers. The answer is the number of special positions under the pile plus the suffix answer for the boxes after the pile. Take the maximum of all options.The constraints are pretty free, so you could replace two pointers with binary searches if you wanted to.Overall complexity:  per testcase.", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nint calc(const vector<int> &a, const vector<int> &b){\n    int n = a.size();\n    int m = b.size();\n    vector<int> su(n + 1);\n    int r = m - 1;\n    for (int i = n - 1; i >= 0; --i){\n        su[i] = su[i + 1];\n        while (r >= 0 && b[r] > a[i]) --r;\n        if (r >= 0 && b[r] == a[i]) ++su[i];\n    }\n    int ans = 0;\n    int j = 0;\n    r = 0;\n    forn(l, m){\n        while (j < n && a[j] <= b[l] + j) ++j;\n        while (r < m && b[r] - b[l] < j) ++r;\n        ans = max(ans, r - l + su[j]);\n    }\n    return ans;\n}\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n    forn(_, t){\n        int n, m;\n        scanf(\"%d%d\", &n, &m);\n        vector<int> a(n), b(m);\n        forn(i, n) scanf(\"%d\", &a[i]);\n        forn(i, m) scanf(\"%d\", &b[i]);\n        vector<int> al, bl, ar, br;\n        forn(i, n){\n            if (a[i] < 0) al.push_back(-a[i]);\n            else ar.push_back(a[i]);\n        }\n        forn(i, m){\n            if (b[i] < 0) bl.push_back(-b[i]);\n            else br.push_back(b[i]);\n        }\n        reverse(al.begin(), al.end());\n        reverse(bl.begin(), bl.end());\n        printf(\"%d\\n\", calc(al, bl) + calc(ar, br));\n    }\n    return 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}