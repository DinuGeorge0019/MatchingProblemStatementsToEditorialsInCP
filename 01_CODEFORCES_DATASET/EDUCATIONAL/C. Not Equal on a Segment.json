{"link": "https://codeforces.com//contest/622/problem/C", "problemId": "47917", "shortId": "622C", "contest_number": "622", "name": "C. Not Equal on a Segment", "statement": "You are given array  with  integers and  queries. The -th query is given with three integers .For the -th query find any position  () so that .", "input": "The first line contains two integers  () \u2014 the number of elements in  and the number of queries. The second line contains  integers  () \u2014 the elements of the array . Each of the next  lines contains three integers  () \u2014 the parameters of the -th query.", "output": "Print  lines. On the -th line print integer  \u2014 the position of any number not equal to  in segment  or the value  if there is no such number.", "tutorial": "This problem can be solved differently. For example you can use some data structures or sqrt-decomposition technique. But it is not required. We expected the following simple solution from the participants. Let's preprocess the following values  \u2014 the position of the first element to the left from the -th element such that . Now to answer to the query we should check if  then we have the answer. Otherwise we should check the position .\n", "solution": "\n            #include <bits/stdc++.h>\n\u00a0\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n#define ford(i, n) for (int i = int(n) - 1; i >= 0; i--)\n#define fore(i, l, r) for (int i = int(l); i < int(r); i++)\n#define correct(x, y, n, m) (0 <= (x) && (x) < (n) && 0 <= (y) && (y) < (m))\n#define all(a) (a).begin(), (a).end()\n#define sz(a) int((a).size())\n#define pb(a) push_back(a)\n#define mp(x, y) make_pair((x), (y))\n#define x first\n#define y second\n\u00a0\nusing namespace std;\n\u00a0\ntypedef long long li;\ntypedef long double ld;\ntypedef pair<int, int> pt;\n\u00a0\ntemplate<typename X> inline X abs(const X& a) { return a < 0? -a: a; }\ntemplate<typename X> inline X sqr(const X& a) { return a * a; }\n\u00a0\nconst int INF = int(1e9);\nconst li INF64 = li(1e18);\nconst ld EPS = 1e-9, PI = 3.1415926535897932384626433832795;\n\u00a0\nconst int N = 200200;\n\u00a0\nint n, m;\nint a[N];\nint l[N], r[N], x[N];\n\u00a0\ninline bool read() {\n\u00a0 \u00a0 if (!(cin >> n >> m)) return false;\n\u00a0 \u00a0 forn(i, n) assert(scanf(\"%d\", &a[i]) == 1);\n\u00a0 \u00a0 forn(i, m) {\n\u00a0 \u00a0 \u00a0 \u00a0 assert(scanf(\"%d%d%d\", &l[i], &r[i], &x[i]) == 3);\n\u00a0 \u00a0 \u00a0 \u00a0 l[i]--, r[i]--;\n\u00a0 \u00a0 }\n\u00a0 \u00a0 return true;\n}\n\u00a0\nint z[N];\n\u00a0\ninline void solve() {\n\u00a0 \u00a0 z[0] = -1;\n\u00a0 \u00a0 fore(i, 1, n) {\n\u00a0 \u00a0 \u00a0 \u00a0 if (a[i - 1] != a[i]) z[i] = i - 1;\n\u00a0 \u00a0 \u00a0 \u00a0 else z[i] = z[i - 1];\n\u00a0 \u00a0 }\n\u00a0\n\u00a0 \u00a0 forn(i, m) {\n\u00a0 \u00a0 \u00a0 \u00a0 if (a[r[i]] != x[i]) printf(\"%d\\n\", r[i] + 1);\n\u00a0 \u00a0 \u00a0 \u00a0 else if (z[r[i]] >= l[i]) printf(\"%d\\n\", z[r[i]] + 1);\n\u00a0 \u00a0 \u00a0 \u00a0 else puts(\"-1\");\n\u00a0 \u00a0 }\n}\n\u00a0\nint main() {\n#ifdef SU1\n\u00a0 \u00a0 assert(freopen(\"input.txt\", \"rt\", stdin));\n\u00a0 \u00a0 //assert(freopen(\"output.txt\", \"wt\", stdout));\n#endif\n\u00a0 \u00a0 \n\u00a0 \u00a0 cout << setprecision(10) << fixed;\n\u00a0 \u00a0 cerr << setprecision(5) << fixed;\n\u00a0\n\u00a0 \u00a0 while (read()) {\n\u00a0 \u00a0 \u00a0 \u00a0 solve();\n\u00a0 \u00a0 \u00a0 \u00a0 //break;\n\u00a0 \u00a0 }\n\u00a0 \u00a0 \n\u00a0 \u00a0 return 0;\n}\n        ", "interactive": false, "noSolution": false, "noTutorial": false}