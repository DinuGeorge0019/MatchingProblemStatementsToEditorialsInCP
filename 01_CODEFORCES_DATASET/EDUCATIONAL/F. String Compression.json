{"link": "https://codeforces.com//contest/825/problem/F", "problemId": "114549", "shortId": "825F", "contest_number": "825", "name": "F. String Compression", "statement": "Ivan wants to write a letter to his friend. The letter is a string  consisting of lowercase Latin letters.Unfortunately, when Ivan started writing the letter, he realised that it is very long and writing the whole letter may take extremely long time. So he wants to write the  of string  instead of the string itself.The  of string  is a sequence of strings , where  is the decimal representation of number  (without any leading zeroes) and  is some string consisting of lowercase Latin letters. If Ivan writes string  exactly  times, then string  exactly  times, and so on, the result will be string .The length of a  is . Among all  Ivan wants to choose a version such that its length is minimum possible. Help Ivan to determine minimum possible length.", "input": "The only line of input contains one string  consisting of lowercase Latin letters ().", "output": "Output one integer number \u2014 the minimum possible length of a  of .", "tutorial": "Let  be the answer for the prefix of  consisting of  first characters.How can we update  from  ()? Suppose that we try to represent the substring from index  to index  (-indexed) by writing it as some other string  times. Then this string has to be the smallest period of the substring, and , where  is the length of the smallest period.The smallest period of some string  can be calculated as follows: compute prefix-function for , and if  is divisible by  ( is the last value of prefix-function), then the length of the smallest period is  (if not, then the length of the smallest period is ).This allows us to write a solution with complexity . To improve it to , we can use the fact that when we compute prefix-function for some string, we compute it for every prefix of this string. So to obtain all values of  we need in our solution, we only need to compute prefix-functions for every suffix of .", "solution": "#ifdef __GNUC__\n#pragma GCC target(\"sse4,avx\")\n#endif\n#include <immintrin.h>\n#include <algorithm>\n#include <string>\n#include <iostream>\n#include <vector>\n#include <cstdint>\n#include <numeric>\n\nstd::vector<int> getSelfPi(const std::string& s, int pos) {\n    size_t n = s.length() - pos;\n    std::vector<int> res(n);\n    size_t cur = 0;\n    for (size_t i = 1; i < n; i++) {\n        while (s[i + pos] != s[cur + pos] && cur > 0) {\n            cur = res[cur - 1];\n        }\n        if (s[i + pos] == s[cur + pos]) cur++;\n        res[i] = cur;\n    }\n    return res;\n}\n\nstruct Solution {\n  std::string s;\n  std::vector<std::vector<int>> pis;\n  void buildPi() {\n      pis.resize(s.length());\n      for (int i = 0; i < s.length(); i++) {\n          pis[i] = getSelfPi(s, i);\n      }\n  }\n  int log10(int diff) {\n      int res = 0;\n      while (diff > 0) {\n          res++;\n          diff /= 10;\n      }\n      return res;\n  }\n\n  void run(std::istream& in, std::ostream& out) {\n      in >> s;\n      buildPi();\n      std::vector<int> dyn(s.length() + 1, 1000000);\n      dyn[0] = 0;\n      for (int i = 0; i < s.length(); i++) {\n          int init = dyn[i];\n          for (int j = i + 1; j <= s.length(); j++) {\n              dyn[j] = std::min(dyn[j], init + j - i + 1);\n              int len = pis[i][j - i - 1];\n              int diff = j - i - len;\n              if ((j - i) % diff == 0) {\n                  dyn[j] = std::min(dyn[j], init + diff + log10((j - i) / diff));\n              }\n\n          }\n      }\n      out << dyn[s.length()] << std::endl;\n  }\n};\n\nint main() {\n    std::cin.sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    Solution().run(std::cin, std::cout);\n    return 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}