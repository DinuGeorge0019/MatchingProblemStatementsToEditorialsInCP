{"link": "https://codeforces.com//contest/1796/problem/A", "problemId": "1802545", "shortId": "1796A", "contest_number": "1796", "name": "A. Typical Interview Problem", "statement": "The FB-string is formed as follows. Initially, it is empty. We go through all positive integers, starting from , in ascending order, and do the following for each integer:  if the current integer is divisible by , append  to the end of the FB-string;  if the current integer is divisible by , append  to the end of the FB-string. Note that if an integer is divisible by both  and , we append , and then , not in the opposite order.The first  characters of the FB-string are : the first  comes from the integer , the next character () comes from , the next  comes from the integer , and so on. It's easy to see that this string is infinitely long. Let  be the -th character of FB-string; so,  is ,  is ,  is ,  is , and so on.You are given a string , consisting of characters  and/or . You have to determine whether it is a substring (contiguous subsequence) of the FB-string. In other words, determine if it is possible to choose two integers  and  () so that the string  is exactly .For example:   is a substring of the FB-string: if we pick  and , the string  is exactly ;   is a substring of the FB-string: if we pick  and , the string  is exactly ;   is not a substring of the FB-string. ", "input": "The first line contains one integer  () \u2014 the number of test cases. Each test case consists of two lines. The first line contains one integer  () \u2014 the number of characters in . The second line contains , which is a string of exactly  characters. Each character of  is either  or .", "output": "For each test case, print  if  is a substring of the FB-string, or  otherwise. You may print each letter in any case (, ,  will all be recognized as positive answer, ,  and  will all be recognized as negative answer).", "tutorial": "It's easy to see that the FB-string repeats every  characters: after processing every  numbers, we will get the same remainders modulo  and  as  numbers ago, and when we process  consecutive numbers, we get  characters. So, .This means that if we want to find a substring no longer than  characters in the FB-string, we don't need to consider more than  first characters of the FB-string: the substring of length  starting with the -th character ends with the -th character, and we don't need to consider substrings starting on positions greater than .So, the solution is to generate at least  first characters of the FB-string, and then check if the substring occurs in the generated string using a standard function like .", "solution": "#include <bits/stdc++.h>\n \nusing namespace std;\n\nint main()\n{\n    string fb;\n    int cur = 1;\n    while(fb.size() < 100)\n    {\n        if(cur % 3 == 0) fb += \"F\";\n        if(cur % 5 == 0) fb += \"B\";\n        cur++;\n    }\n    int t;\n    cin >> t;\n    for(int i = 0; i < t; i++)\n    {\n        int k;\n        cin >> k;\n        string s;\n        cin >> s;\n        cout << (fb.find(s) != string::npos ? \"YES\" : \"NO\") << endl;\n    }\n}", "interactive": false, "noSolution": false, "noTutorial": false}