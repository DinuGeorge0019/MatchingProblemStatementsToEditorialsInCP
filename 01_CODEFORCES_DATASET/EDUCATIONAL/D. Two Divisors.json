{"link": "https://codeforces.com//contest/1366/problem/D", "problemId": "646802", "shortId": "1366D", "contest_number": "1366", "name": "D. Two Divisors", "statement": "You are given  integers .For each  find its   and  such that  (where  is the greatest common divisor of  and ) or say that there is no such pair.", "input": "The first line contains single integer  ()\u00a0\u2014 the size of the array . The second line contains  integers  ()\u00a0\u2014 the array .", "output": "To speed up the output, print two lines with  integers in each line. The -th integers in the first and second lines should be corresponding divisors  and  such that  or  and  if there is no such pair. If there are multiple answers, print any of them.", "tutorial": "Firstly, for the fast factorization of given , let's use Sieve of Eratosthenes: let's for each value  calculate its minimum prime divisor  in the same manner as the sieve do. Now we can factorize each  in  time by separating its prime divisors one by one using precalculated array .Suppose, we have a factorization . If  then any divisor of  is divisible by  so do the sum of divisors. Obviously, the answer is  .Otherwise, we can divide all prime divisors  into two non-empty groups  and  and take  and . Any division is valid (proof is below), so, for example, we can take  and .Let's prove that if  and  then . Let's look at any . We can assume that  and (without loss of generality) . But it means that , then . In other words, there are no prime divisor of  which divides , so the .Time complexity is  for the sieve and finding answers ().", "solution": "fun main() {\n    val n = readLine()!!.toInt()\n    val a = readLine()!!.split(' ').map { it.toInt() }\n\n    val minDiv = IntArray(1e7.toInt() + 2) { it }\n    for (i in 2 until minDiv.size) {\n        if (minDiv[i] != i)\n            continue\n        for (j in i until minDiv.size step i)\n            minDiv[j] = minOf(minDiv[j], i)\n    }\n\n    fun getPrimeDivisors(v: Int): ArrayList<Int> {\n        val ans = ArrayList<Int>()\n        var curVal = v\n        while (curVal != 1) {\n            if (ans.isEmpty() || ans.last() != minDiv[curVal])\n                ans.add(minDiv[curVal])\n            curVal /= minDiv[curVal]\n        }\n        return ans\n    }\n\n    val d1 = IntArray(n)\n    val d2 = IntArray(n)\n    for (id in a.indices) {\n        val list = getPrimeDivisors(a[id])\n        if (list.size < 2) {\n            d1[id] = -1\n            d2[id] = -1\n        } else {\n            d1[id] = list[0]\n            list.removeAt(0)\n            d2[id] = list.reduce { s, t -> s * t }\n        }\n    }\n    println(d1.joinToString(\" \"))\n    println(d2.joinToString(\" \"))\n}", "interactive": false, "noSolution": false, "noTutorial": false}