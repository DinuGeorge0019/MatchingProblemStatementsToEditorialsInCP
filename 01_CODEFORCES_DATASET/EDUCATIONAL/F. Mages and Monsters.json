{"link": "https://codeforces.com//contest/792/problem/F", "problemId": "100429", "shortId": "792F", "contest_number": "792", "name": "F. Mages and Monsters", "statement": "Vova plays a computer game known as Mages and Monsters. Vova's character is a mage. Though as he has just started, his character knows no spells.Vova's character can learn new spells during the game. Every spell is characterized by two values  and  \u2014 damage per second and mana cost per second, respectively. Vova doesn't have to use a spell for an integer amount of seconds. More formally, if he uses a spell with damage  and mana cost  for  seconds, then he will deal  damage and spend  mana (no rounding). If there is no mana left (mana amount is set in the start of the game and it remains the same at the beginning of every fight), then character won't be able to use any spells. It is prohibited to use multiple spells simultaneously.Also Vova can fight monsters. Every monster is characterized by two values  and  \u2014 monster kills Vova's character in  seconds and has  health points. Mana refills after every fight (or Vova's character revives with full mana reserve), so previous fights have no influence on further ones.Vova's character kills a monster, if he deals  damage to it in no more than  seconds using his spells (it is allowed to use more than one spell in a fight) and spending no more mana than he had at the beginning of the fight. .You have to write a program which can answer two types of queries:     \u2014 Vova's character learns new spell which deals  damage per second and costs  mana per second.     \u2014 Vova fights the monster which kills his character in  seconds and has  health points. For every query of second type you have to determine if Vova is able to win the fight with corresponding monster.", "input": "The first line contains two integer numbers  and   \u2014 the number of queries and the amount of mana at the beginning of every fight. -th of each next  lines contains three numbers ,  and  .  Using them you can restore queries this way: let  be the index of the last query of second type with positive answer ( if there were none of these).    If , then character learns spell with   ,   .  If , then you have to determine if Vova is able to win the fight against monster with   ,   . ", "output": "For every query of second type print  if Vova is able to win the fight with corresponding monster and  otherwise.", "tutorial": "Let's represent spells as points on cartesian plane. If we consider three spells ,  and  such that  and  is above  on the cartesian plane or belongs to it, then we don't need to use spell  because we can replace it with a linear combination of spells  and  without any additional mana cost.We can maintain the lower boundary of the convex hull of all points from -type queries and the point . Then to process -type query we have to find the intersection of aforementioned lower boundary and the line  (our average damage in this fight has to be at least this value). If there is no intersection, then the answer is  because even with infinite mana Vova's character can't deal that much damage before dying. If there is an intersection, we have to check that it is not higher than the line  to ensure that we have enough mana to kill the monster in given time. Model solution uses only integral calculations, but it seems that  precision is enough.Time complexity:  .", "solution": "#include <iostream>\n#include <fstream>\n#include <set>\n#include <map>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <queue>\n\n#define mp make_pair\n#define pb push_back\n\n\ntypedef long long ll;\ntypedef long double ld;\n\nusing namespace std;\n\n#ifndef LOCAL\n#define cerr _cer\nstruct _cert\n{\n    template <typename T> _cert& operator << (T) { return *this; }\n};\n_cert _cer;\n#endif\n\ntemplate <typename T> void dprint(T begin, T end) {\n    for (auto i = begin; i != end; i++) {\n\t\tcerr << (*i) << \" \";\n    }\n    cerr << \"\\n\";\n}\n\nset<pair<ll, ll> > ss;\nint q;\nll m;\n\nint bd(pair<ll, ll> a, pair<ll, ll> b, pair<ll, ll> c) {\n\tb.first -= a.first;\n\tb.second -= a.second;\n\tc.first -= a.first;\n\tc.second -= a.second;\n\treturn ((ld)b.first * (ld)c.second - (ld)b.second * (ld)c.first) <= 0;\n}\n\nint main() {\n\tscanf(\"%d%lld\", &q, &m);\n\tint ij = 0;\n\tss.insert(make_pair(0, 0));\n\tfor (int i = 0; i < q; ++i) {\n\t\tint k, t, h;\n\t\tll x, y, a, b;\n\t\tscanf(\"%d%d%d\", &k, &t, &h);\n\t\tif (k == 1) {\n\t\t\tx = (t + ij) % 1000000 + 1;\n\t\t\ty = (h + ij) % 1000000 + 1;\n\t\t\tauto it = ss.lower_bound(make_pair(x, 0));\n\t\t\tif (it != ss.end() && it->second <= y)\n\t\t\t\tcontinue;\n\t\t\tauto it2 = prev(it);\n\t\t\tif (it != ss.end() && bd(*it2, make_pair(x, y), *it))\n\t\t\t\tcontinue;\n\t\t\tit = ss.insert(make_pair(x, y)).first;\n\t\t\twhile (next(it) != ss.end() && next(it)->first == x)\n\t\t\t\tss.erase(next(it));\n\t\t\twhile (prev(it) != ss.begin() && bd(*prev(prev(it)), *prev(it), *it))\n\t\t\t\tss.erase(prev(it));\n\t\t}\n\t\telse {\n\t\t\tb = (t + ij) % 1000000 + 1;\n\t\t\ta = (h + ij) % 1000000 + 1;\n\t\t\tauto it = ss.lower_bound(make_pair((a + b - 1) / b, 0));\n\t\t\tint fl = 0;\n\t\t\tif (it != ss.end()) {\n\t\t\t\tif (it->second * b <= m)\n\t\t\t\t\tfl = 1;\n\t\t\t\telse {\n\t\t\t\t\tauto it2 = prev(it);\n\t\t\t\t\tif (bd(make_pair(it2->first * b, it2->second * b), make_pair(a, m), make_pair(it->first * b, it->second * b)))\n\t\t\t\t\t\tfl = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (fl) {\n\t\t\t\tprintf(\"YES\\n\");\n\t\t\t\tij = i + 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tprintf(\"NO\\n\");\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n\n", "interactive": false, "noSolution": false, "noTutorial": false}