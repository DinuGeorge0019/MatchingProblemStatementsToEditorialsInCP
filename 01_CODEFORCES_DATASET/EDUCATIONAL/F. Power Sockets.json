{"link": "https://codeforces.com//contest/1469/problem/F", "problemId": "847531", "shortId": "1469F", "contest_number": "1469", "name": "F. Power Sockets", "statement": "// Define a chain:   a chain of length  is a single vertex;  a chain of length  is a chain of length  with a new vertex connected to the end of it with a single edge. You are given  chains of lengths . You plan to build a tree using some of them.  Each vertex of the tree is either white or black.  The tree initially only has a white root vertex.  All chains initially consist only of white vertices.  You can take one of the chains and connect any of its vertices to any white vertex of the tree with an edge. The chain becomes part of the tree. Both endpoints of this edge become black.  Each chain can be used no more than once.  Some chains can be left unused. The distance between two vertices of the tree is the number of edges on the shortest path between them.If there is at least  white vertices in the resulting tree, then the value of the tree is the distance between the root and the -th closest white vertex.What's the minimum value of the tree you can obtain? If there is no way to build a tree with at least  white vertices, then print .", "input": "The first line contains two integers  and  (, )\u00a0\u2014 the number of chains and the minimum number of white vertices a tree should have to have a value. The second line contains  integers  ()\u00a0\u2014 the lengths of the chains.", "output": "Print a single integer. If there is no way to build a tree with at least  white vertices, then print . Otherwise, print the minimum value the tree can have.", "tutorial": "At first, let's realize that the tree structure doesn't matter that much. What we actually need is the array  such that it stores the number of white vertices on depth .Initially,  and all other are zero. If you take a chain and attach it to some vertex on depth , then the number of vertices on depth  decreases by . Also, the added vertices update some other counts.So far, it's extremely unclear what to begin with. Let's start by introducing some greedy ideas.For each  let's find the most optimal tree using exactly  chains and update the answer with each of them.First, it's always optimal to attach a chain with its middle vertex. Just consider the changes in the white vertices counts.Second, for each  it's always optimal to take the longest  chains to use. If not the longest  are used, then you can replace any of them and there will be more white vertices.It would be nice if we were able to just add another chain to the tree for  to get the tree for . However, that's not always the case. But we can still attempt it and show that the optimal answer was achieved somewhere in the process.Let's show that it's always optimal to attach a new chain to the closest white vertex.So there are basically two cases: there is not enough white vertices yet and there is enough. What happens if there is not enough vertices, and we pick the closest one to attach a chain to? If there are still not enough vertices, then we'll just continue. Otherwise, we'll have to show that the answer can't get any smaller by rearranging something.Consider what the answer actually is. Build a prefix sum array over , then the answer is the shortest prefix such that its prefix sum is greater or equal to .So we put the -th chain to the closest white vertex at depth . It decreases  by  and increases  and further by  or . Every chain we have put to this point was attached to a vertex at depth less or equal to the answer (otherwise, we could've rearranged it and obtain the answer before). The optimal answer can be neither , nor  (also because we could've rearranged). Thus, the answer is at least  and every single chain we have put was packed as tightly as possible below that depth.The second case works similarly. We could've obtained the optimal answer before . So the answer is below  and we can do nothing about that. Or the optimal answer is ahead of us, so putting the chain at  can decrease it as much or stronger as any other choice.Thus, updating the answer on every iteration will give us the optimal result.Now we are done with the greedy, time to implement it. I chose the most straightforward way. We basically have to maintain a data structure that can add on range, get the value of a cell and find the shortest prefix with sum at least . That can be easily done with segtree.Overall complexity: .", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int INF = 1e9;\n\nint n, k, nn;\n\nvector<long long> t, ps;\n\nvoid push(int v, int l, int r){\n\tif (l < r - 1){\n\t\tps[v * 2] += ps[v];\n\t\tps[v * 2 + 1] += ps[v];\n\t}\n\tt[v] += ps[v] * (r - l);\n\tps[v] = 0;\n}\n\nvoid upd(int v, int l, int r, int L, int R, int val){\n\tpush(v, l, r);\n\tif (L >= R)\n\t\treturn;\n\tif (l == L && r == R){\n\t\tps[v] = val;\n\t\tpush(v, l, r);\n\t\treturn;\n\t}\n\tint m = (l + r) / 2;\n\tupd(v * 2, l, m, L, min(m, R), val);\n\tupd(v * 2 + 1, m, r, max(m, L), R, val);\n\tt[v] = t[v * 2] + t[v * 2 + 1];\n}\n\nlong long get(int v, int l, int r, int L, int R){\n\tpush(v, l, r);\n\tif (L >= R)\n\t\treturn 0;\n\tif (l == L && r == R)\n\t\treturn t[v];\n\tint m = (l + r) / 2;\n\tlong long res = get(v * 2, l, m, L, min(m, R)) + get(v * 2 + 1, m, r, max(m, L), R);\n\tt[v] = t[v * 2] + t[v * 2 + 1];\n\treturn res;\n}\n\nint trav(int v, int l, int r, int cnt){\n\tpush(v, l, r);\n\tif (l == r - 1)\n\t\treturn l;\n\tint m = (l + r) / 2;\n\tpush(v * 2, l, m);\n\tpush(v * 2 + 1, m, r);\n\tint res = INF;\n\tif (t[v * 2] >= cnt)\n\t\tres = trav(v * 2, l, m, cnt);\n\telse if (t[v * 2 + 1] >= cnt - t[v * 2])\n\t\tres = trav(v * 2 + 1, m, r, cnt - t[v * 2]);\n\tt[v] = t[v * 2] + t[v * 2 + 1];\n\treturn res;\n}\n\nint main() {\n\tscanf(\"%d%d\", &n, &k);\n\tvector<int> a(n);\n\tforn(i, n) scanf(\"%d\", &a[i]);\n\tsort(a.begin(), a.end(), greater<int>());\n\tnn = a[0] + 500;\n\tt.resize(4 * nn);\n\tps.resize(4 * nn);\n\tupd(1, 0, nn, 0, 1, 1);\n\tint fst = 0;\n\tint ans = INF;\n\tforn(i, n){\n\t\twhile (get(1, 0, nn, 0, fst + 1) == 0) ++fst;\n\t\tupd(1, 0, nn, fst, fst + 1, -1);\n\t\tupd(1, 0, nn, fst + 2, fst + 2 + (a[i] - 1) / 2, 1);\n\t\tupd(1, 0, nn, fst + 2, fst + 2 + a[i] / 2, 1);\n\t\tans = min(ans, trav(1, 0, nn, k));\n\t}\n\tprintf(\"%d\\n\", ans == INF ? -1 : ans);\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}