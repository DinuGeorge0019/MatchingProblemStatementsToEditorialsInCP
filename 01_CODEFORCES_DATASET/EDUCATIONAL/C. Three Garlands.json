{"link": "https://codeforces.com//contest/911/problem/C", "problemId": "142497", "shortId": "911C", "contest_number": "911", "name": "C. Three Garlands", "statement": "Mishka is decorating the Christmas tree. He has got three garlands, and all of them will be put on the tree. After that Mishka will switch these garlands on.When a garland is switched on, it periodically changes its state \u2014 sometimes it is lit, sometimes not. Formally, if -th garland is switched on during -th second, then it is lit only during seconds , , ,  and so on.Mishka wants to switch on the garlands in such a way that during each second after switching the garlands on there would be at least one lit garland. Formally, Mishka wants to choose three integers ,  and  (not necessarily distinct) so that he will switch on the first garland during -th second, the second one \u2014 during -th second, and the third one \u2014 during -th second, respectively, and during each second starting from  at least one garland will be lit.Help Mishka by telling him if it is possible to do this!", "input": "The first line contains three integers ,  and  () \u2014 time intervals of the garlands.", "output": "If Mishka can choose moments of time to switch on the garlands in such a way that each second after switching the garlands on at least one garland will be lit, print . Otherwise, print .", "tutorial": "There are pretty few cases to have :  One of  is equal to ;  At least two of  are equal to ;  All  equal ;  . It's easy to notice that having minimum of  equal to  produce the only case, greater numbers will always miss some seconds. Let's consider minimum of , let it cover all odd seconds. Now you should cover all even seconds and  and  are the only possible solutions.Overall complexity: .", "solution": "#include <bits/stdc++.h>\n#ifndef ONLINE_JUDGE\n# include <sys/time.h>\n# include <sys/resource.h>\n#endif\n\n/*** TEMPLATE CODE STARTS HERE ***/\n\n#ifndef M_PI\n#define M_PI 3.1415926535897932384626433832795028841971693993751\n#endif\n\nusing namespace std;\n\ntypedef vector<string> vs;\ntypedef long long ll;\ntypedef complex<double> pnt;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n#define RA(x) begin(x), end(x)\n#define FE(i, x) for (auto i = begin(x); i != end(x); ++i)\n#define SZ(x) ((ll) (x).size())\n\ntemplate<class T>\nvoid splitstr(const string &s, vector<T> &out)\n{\n    istringstream in(s);\n    out.clear();\n    copy(istream_iterator<T>(in), istream_iterator<T>(), back_inserter(out));\n}\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\n\nstatic void redirect(int argc, const char **argv)\n{\n#ifndef ONLINE_JUDGE\n    struct rlimit rlim;\n    getrlimit(RLIMIT_STACK, &rlim);\n    rlim.rlim_cur = 256 * 1024 * 1024;\n    setrlimit(RLIMIT_STACK, &rlim);\n#ifndef __SANITIZE_ADDRESS__\n    getrlimit(RLIMIT_DATA, &rlim);\n    rlim.rlim_cur = 256 * 1024 * 1024;\n    setrlimit(RLIMIT_DATA, &rlim);\n#endif\n#endif\n\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n    if (argc > 1)\n    {\n        static filebuf f;\n        f.open(argv[1], ios::in);\n        cin.rdbuf(&f);\n        if (!cin)\n        {\n            cerr << \"Failed to open '\" << argv[1] << \"'\" << endl;\n            exit(1);\n        }\n    }\n\n    if (argc > 2)\n    {\n        static filebuf f;\n        f.open(argv[2], ios::out | ios::trunc);\n        cout.rdbuf(&f);\n        if (!cout)\n        {\n            cerr << \"Failed to open '\" << argv[2] << \"'\" << endl;\n        }\n    }\n}\n\n/*** TEMPLATE CODE ENDS HERE */\n\nint main(int argc, const char **argv)\n{\n    redirect(argc, argv);\n    int K[3];\n    cin >> K[0] >> K[1] >> K[2];\n    sort(RA(K));\n    bool good = (K[0] == 1)\n        || (K[0] == 2 && K[1] == 2)\n        || (K[0] == 2 && K[1] == 4 && K[2] == 4)\n        || (K[0] == 3 && K[1] == 3 && K[2] == 3);\n    cout << (good ? \"YES\\n\" : \"NO\\n\");\n\n    return 0;\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}