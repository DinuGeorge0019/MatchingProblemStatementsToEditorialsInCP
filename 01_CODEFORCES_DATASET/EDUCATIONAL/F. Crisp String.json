{"link": "https://codeforces.com//contest/1117/problem/F", "problemId": "300046", "shortId": "1117F", "contest_number": "1117", "name": "F. Crisp String", "statement": "You are given a string of length . Each character is one of the first  lowercase Latin letters.You are also given a matrix  with binary values of size . This matrix is symmetric ().  means that the string can have the -th and -th letters of Latin alphabet adjacent.Let's call the string  if  in it can be adjacent (have 1 in the corresponding cell of matrix ).You are allowed to do the following move. Choose any letter, remove  and join the remaining parts of the string without changing their order. For example, removing letter 'a' from \"abacaba\" will yield \"bcb\".The string you are given is . The string should remain  .You are allowed to do arbitrary number of moves (possible zero). What is the shortest resulting string you can obtain?", "input": "The first line contains two integers  and  (, ) \u2014 the length of the initial string and the length of the allowed prefix of Latin alphabet. The second line contains the initial string. It is guaranteed that it contains only first  lowercase Latin letters and that is it . Some of these  first Latin letters might not be present in the string. Each of the next  lines contains  integer numbers \u2014 the matrix  (, ).  means that the string can have the -th and -th letters of Latin alphabet adjacent.", "output": "Print a single integer \u2014 the length of the shortest string after you make arbitrary number of moves (possible zero).", "tutorial": "Each state of the string can be denoted as the set of characters we deleted from it, and each such set can be represented as a -bit binary mask, where -th bit is equal to  if -th character of the alphabet is already deleted, and  otherwise.Let's call a mask  if the string formed by this mask is not crisp. Let's also say that a pair of characters  forbids mask  if  is a pair of characters that should not be adjacent, but they are adjacent in the string formed by mask .If we somehow find all bad masks, then the solution would be writing simple bitmask dp to find the best mask that is not bad and reachable from the initial mask (the one having all bits set to ). So let's focus on finding all bad masks. Obviously, if some pair of characters forbids a mask, then it's bad, and vice versa.Let's pick some pair of characters  and find all masks forbidden by it (we will do the same for every pair of characters that cannot be adjacent). Let's check every occurence of  in the initial string. For each occurence, we will find the closest occurence of  to the right of it. If there's no any, or if there's another  between them, let's ignore the occurence of  we have chosen and move to the next one. Otherwise, let's find all characters that occur at least once between the fixed occurences of  and . If all those characters are deleted, then these occurences of  and  will be adjacent \u2014 so pair  forbids any mask that has bits representing  and  set to , bits representing every character occuring in between to , and all other bits to any values. Let's mark all these masks as forbidden as follows: we will write a recursive function  that marks mask  and every its submask that has bits  and  set to  as forbidden. This function should check if  is not forbidden; if not, then mark it as forbidden, iterate on the bit  we may remove from , and call  recursively (but only if  is set to  in mask , and if  and ). If we implement it in such a way, then for each pair , it will take  operations to mark all masks forbidden by this pair of characters, so overall complexity will be  or , depending on your implementation. ", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int N = 100 * 1000 + 13;\nconst int P = 17;\n\nint n, p;\nstring s;\nint A[P][P];\nvector<int> pos[P];\nint pr[P][N];\nbitset<(1 << P)> legal, cur, dp;\nint cnt[P];\n\nint main() {\n\tscanf(\"%d%d\", &n, &p);\n\tchar buf[N];\n\tscanf(\"%s\", buf);\n\ts = buf;\n\tforn(i, p) forn(j, p)\n\t\tscanf(\"%d\", &A[i][j]);\n\t\n\tforn(i, n){\n\t\tpos[s[i] - 'a'].push_back(i);\n\t\tforn(j, p)\n\t\t\tpr[j][i + 1] = pr[j][i] + (s[i] == 'a' + j);\n\t}\n\t\n\tlegal.reset();\n\tlegal.flip();\n\t\n\tint fl = (1 << p) - 1;\n\tforn(c, p) forn(d, c + 1){\n\t\tif (A[c][d]) continue;\n\t\tcur.reset();\n\t\tcur.flip();\n\t\tint i = 0, j = 0;\n\t\twhile (i < pos[c].size() && j < pos[d].size()){\n\t\t\tif (c == d && i == j){\n\t\t\t\t++j;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint mask = 0;\n\t\t\tif (pos[c][i] < pos[d][j]){\n\t\t\t\tforn(e, p) if ((pr[e][pos[d][j]] - pr[e][pos[c][i] + 1]) != 0)\n\t\t\t\t\tmask |= (1 << e);\n\t\t\t\t++i;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tforn(e, p) if ((pr[e][pos[c][i]] - pr[e][pos[d][j] + 1]) != 0)\n\t\t\t\t\tmask |= (1 << e);\n\t\t\t\t++j;\n\t\t\t}\n\t\t\tif ((mask >> c) & 1) continue;\n\t\t\tif ((mask >> d) & 1) continue;\n\t\t\tcur[mask ^ fl] = 0;\n\t\t}\n\t\tfor (int mask = fl; mask > 0; --mask){\n\t\t\tif (cur[mask]) continue;\n\t\t\tforn(e, p) if (c != e && d != e && ((mask >> e) & 1))\n\t\t\t\tcur[mask ^ (1 << e)] = 0;\n\t\t}\n\t\tlegal &= cur;\n\t}\n\t\n\tdp[fl] = 1;\n\tfor (int mask = fl; mask > 0; --mask){\n\t\tif (!dp[mask]) continue;\n\t\tforn(i, p) if ((mask >> i) & 1){\n\t\t\tint nmask = mask ^ (1 << i);\n\t\t\tif (dp[nmask]) continue;\n\t\t\tdp[nmask] = legal[nmask];\n\t\t}\n\t}\n\t\n\tforn(i, n)\n\t\t++cnt[s[i] - 'a'];\n\t\n\tint ans = n;\n\tforn(mask, 1 << p) if (dp[mask]){\n\t\tint cur = 0;\n\t\tforn(i, p) if ((mask >> i) & 1)\n\t\t\tcur += cnt[i];\n\t\tans = min(ans, cur);\n\t}\n\t\n\tprintf(\"%d\\n\", ans);\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}