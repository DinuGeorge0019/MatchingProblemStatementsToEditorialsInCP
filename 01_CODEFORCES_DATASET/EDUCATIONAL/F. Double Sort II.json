{"link": "https://codeforces.com//contest/1783/problem/F", "problemId": "1728815", "shortId": "1783F", "contest_number": "1783", "name": "F. Double Sort II", "statement": "You are given two permutations  and , both of size . A permutation of size  is an array of  elements, where each integer from  to  appears exactly once. The elements in each permutation are indexed from  to .You can perform the following operation any number of times:  choose an integer  from  to ;  let  be the integer such that . Swap  with ;  let  be the integer such that . Swap  with . Your goal is to make both permutations  (i.\u2009e. the conditions  and  must be satisfied) using . Note that both permutations must be sorted after you perform the sequence of operations you have chosen.", "input": "The first line contains one integer  (). The second line contains  integers  (; all  are distinct). The third line contains  integers  (; all  are distinct).", "output": "First, print one integer  () \u2014 the minimum number of operations required to sort both permutations. Note that it can be shown that  operations are always enough. Then, print  integers  (), where  is the value of  you choose during the -th operation. If there are multiple answers, print any of them.", "tutorial": "The solution to this problem uses cyclic decomposition of permutations. A cyclic decomposition of a permutation is formulated as follows: you treat a permutation as a directed graph on  vertices, where each vertex  has an outgoing arc . This graph consists of several cycles, and the properties of this graph can be helpful when solving permutation-based problems.First of all, how does the cyclic decomposition of a sorted permutation look? Every vertex belongs to its own cycle formed by a self-loop going from that vertex to itself. We will try to bring the cyclic decompositions of the given permutations to this form.What does an operation with integer  do to the cyclic decomposition of the permutation? If  is in its own separate cycle, the operation does nothing (, so we swap an element with itself). Otherwise, let's suppose that  is the element before  in the same cycle (), and  is the element after  in the same cycle (). Note that this can be the same element. When we apply an operation on , we swap  with , so after the operation, , and . So,  leaves the cycle and forms its separate cycle, and  becomes the next vertex in the cycle after . So, using the operation, we exclude the vertex  from the cycle.Suppose we want to sort one permutation. Then each cycle having length  must be broken down: for a cycle of length , we need to exclude  vertices from it to break it down. The vertex we don't touch can be any vertex from the cycle, and all other vertices from the cycle will be extracted using one operation directed at them. It's easy to see now that if we want to sort a permutation, we don't need to apply the same operation twice, and the order of operations does not matter.Okay, then what about sorting two permutations in parallel? Let's change the problem a bit: instead of calculating the minimum number of operations, we will try to maximize the number of integers  such that we don't perform operations with them. So, an integer  can be left untouched if it is the only untouched vertex in its cycles in both permutations... Can you see where this is going?Suppose we want to leave the vertex  untouched. It means that in its cycles in both permutations, every other vertex has to be extracted with an operation. So, if two cycles from different permutations have a vertex in common, we can leave this vertex untouched, as long as there are no other vertices left untouched in both of these cycles. Let's build a bipartite graph, where each vertex in the left part represents a cycle in the first permutation, and each vertex in the right part represents a cycle in the second permutation. We will treat each integer  as an edge between two respective vertices in the bipartite graph. If the edge corresponding to  is \"used\" ( is left untouched), we cannot \"use\" any edges incident to the same vertex in left or right part. So, maximizing the number of untouched numbers is actually the same as finding the maximum matching in this bipartite graph.After you find the maximum matching, restoring the actual answer is easy. Remember that the edges saturated by the matching correspond to the integers we don't touch with our operations, the order of operations does not matter, and each integer has to be used in an operation only once. So, the actual answer is the set of all integers without those which correspond to the edges from the matching.This solution runs in  even with a straightforward implementation of bipartite matching, since the bipartite graph has at most  vertices and  edges.", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 5043;\n\nvector<int> g[N];\nint mt[N];\nint u[N];\nvector<vector<int>> cycle[2];\nvector<int> a[2];\nint n;\nint vs[2];\nvector<vector<int>> inter;\n\nbool kuhn(int x)\n{\n    if(u[x]) return false;\n    u[x] = true;\n    for(auto y : g[x])\n    {\n        if(mt[y] == x) continue;\n        if(mt[y] == -1 || kuhn(mt[y]))\n        {\n            mt[y] = x;\n            return true;\n        }\n    }\n    return false;\n}\n\nint find_intersection(const vector<int>& x, const vector<int>& y)\n{\n    for(auto i : x)\n        for(auto j : y)\n            if(i == j)\n                return i;\n    return -1;\n}\n\nint main()\n{\n    scanf(\"%d\", &n);\n    for(int k = 0; k < 2; k++)\n    {\n        a[k].resize(n);\n        for(int j = 0; j < n; j++)\n        {\n            scanf(\"%d\", &a[k][j]);\n            a[k][j]--;\n        }    \n    }\n\n    for(int k = 0; k < 2; k++)\n    {\n        vector<bool> used(n);\n        for(int i = 0; i < n; i++)\n        {\n            if(used[i]) continue;\n            vector<int> cur;\n            int j = i;\n            while(!used[j])\n            {\n                cur.push_back(j);\n                used[j] = true;\n                j = a[k][j];            \n            }\n            cycle[k].push_back(cur);\n        }\n        vs[k] = cycle[k].size();\n    }\n\n    inter.resize(vs[0], vector<int>(vs[1]));\n\n    for(int i = 0; i < vs[0]; i++)\n        for(int j = 0; j < vs[1]; j++)\n        {\n            inter[i][j] = find_intersection(cycle[0][i], cycle[1][j]);\n            if(inter[i][j] != -1)\n                g[i].push_back(j);\n        }\n\n    for(int i = 0; i < vs[1]; i++)\n        mt[i] = -1;\n    for(int i = 0; i < vs[0]; i++)\n    {\n        for(int j = 0; j < vs[0]; j++)\n            u[j] = false;\n        kuhn(i);\n    }\n    \n    set<int> res;\n    for(int i = 0; i < n; i++) res.insert(i);\n    for(int i = 0; i < vs[1]; i++)\n        if(mt[i] != -1)\n            res.erase(inter[mt[i]][i]);\n\n    printf(\"%d\\n\", res.size());\n    for(auto x : res) printf(\"%d \", x + 1);\n    puts(\"\");\n}", "interactive": false, "noSolution": false, "noTutorial": false}