{"link": "https://codeforces.com//contest/1156/problem/C", "problemId": "338450", "shortId": "1156C", "contest_number": "1156", "name": "C. Match Points", "statement": "You are given a set of points , , ...,  on the number line.Two points  and  can be matched with each other if the following conditions hold:  neither  nor  is matched with any other point;  . What is the maximum number of pairs of points you can match with each other?", "input": "The first line contains two integers  and  (, ) \u2014 the number of points and the constraint on the distance between matched points, respectively. The second line contains  integers , , ...,  ().", "output": "Print one integer \u2014 the maximum number of pairs of points you can match with each other.", "tutorial": "Let's denote the points that have greater coordinates in their matched pairs as -points, and the points that have smaller coordinates as -points.Suppose we have an -point that has smaller coordinate than some -point. Then we can \"swap\" them, and the answer won't become worse. Also, if some -point has smaller coordinate than some point that doesn't belong to any pair, or some -point has greater coordinate than some point that doesn't belong to any pair, we can swap them too. So, if the answer is , we choose  leftmost points as -points, and  rightmost ones as -points.For a fixed value of , it's easy to see that we should match the leftmost -point with the leftmost -point, the second -point with the second -point, and so on, in order to maximize the minimum distance in a pair. This fact allows us to check whether it is possible to construct at least  pairs, and we can use binary search to compute the answer to the problem.", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 200043;\n\nint n, z;\nint a[N];\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tscanf(\"%d\", &z);\n\tfor(int i = 0; i < n; i++)\n\t\tscanf(\"%d\", &a[i]);\n\tsort(a, a + n);\n\tint l = 0;\n\tint r = n / 2 + 1;\n\twhile(r - l > 1)\n\t{\n\t\tint m = (l + r) / 2;\n\t\tbool good = true;\n\t\tfor(int i = 0; i < m; i++)\n\t\t\tgood &= (a[n - m + i] - a[i] >= z);\n\t\tif(good)\n\t\t\tl = m;\n\t\telse\n\t\t\tr = m;\n\t}\n\tcout << l << endl;\n}", "interactive": false, "noSolution": false, "noTutorial": false}