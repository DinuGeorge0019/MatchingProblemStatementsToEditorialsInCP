{"link": "https://codeforces.com//contest/1000/problem/G", "problemId": "193660", "shortId": "1000G", "contest_number": "1000", "name": "G. Two-Paths", "statement": "You are given a weighted tree (undirected connected graph with no cycles, loops or multiple edges) with  vertices. The edge  has weight . Also each vertex  has its own value  assigned to it.Let's call a path starting in vertex  and ending in vertex , where each edge can appear no more than twice (regardless of direction), a . Vertices can appear in the 2-path multiple times (even start and end vertices).For some 2-path  profit , where  is the number of times edge  appears in . That is, vertices are counted once, but edges are counted the number of times they appear in .You are about to answer  queries. Each query is a pair of vertices . For each query find 2-path  from  to  with maximal profit .", "input": "The first line contains two integers  and  (, ) \u2014 the number of vertices in the tree and the number of queries. The second line contains  space-separated integers   \u2014 the values of the vertices. Next  lines contain descriptions of edges: each line contains three space separated integers ,  and  (, , ) \u2014 there is edge  with weight  in the tree. Next  lines contain queries (one per line). Each query contains two integers  and   \u2014 endpoints of the 2-path you need to find.", "output": "For each query print one integer per line \u2014 maximal profit  of the some 2-path  with the corresponding endpoints.", "tutorial": "Let's solve this task in several steps.Step 1. Calculate  for each vertex.Let  be maximal profit of some 2-path starting at  and finishing at . If vertex  is a root of the tree, then  equivalent to , where  \u2014 maximal profit of 2-path , when we can go only in subtree of . The  can be calculated with next approach: .To calculate  we can use next technique. Let's manage next invariant: when processing vertex  all its neighbours (even parent) will hold  as if  its parent. Then . After that, we can proceed with each child  of , but before moving to it we must change value  since we must keep invariant true. To keep it true, it's enough to set . Also let's memorize value  as .Step 2. Processing queries.Let simple path  be . If  then answer is . Otherwise, each edge on this simple path must be used exactly once. But, while travelling from  to  using this simple path, at each vertex  we can go somewhere and return to  \u2014 the only condition is not use edges from simple path. And we can do it using precalculated values  and . So, if we want to find max profit of 2-path  with prohibited edges , , so we can use value .Finally, to process queries, let's find , divide it on two queries , . Now we can handle all queries offline, travelling on tree in dfs order. Let's manage some data structure on current path from current vertex to the root (this DS can be based on array of depths). Then, when we come to vertex , just add value  to DS in position  (and erase it before exit). Each query  becomes a query of sum to some subsegment in DS (don't forget carefully handle value in lca). And, before moving from  to , you need subtract  from current value of  (here you can at once subtract weight of edge ). Don't forget to return each change in DS, when it needed.As we can see, DS is just a BIT with sum on segment and change in position.Result complexity is . Fast IO are welcome.", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n\n#define sz(a) int((a).size())\n#define all(a) (a).begin(), (a).end()\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef long double ld;\ntypedef pair<int, int> pt;\n\ntemplate<class A, class B> ostream& operator <<(ostream& out, const pair<A, B> &p) {\n\treturn out << \"(\" << p.x << \", \" << p.y << \")\";\n}\n\ntemplate<class A> ostream& operator <<(ostream& out, const vector<A> &v) {\n\tout << \"[\";\n\tfore(i, 0, sz(v)) {\n\t\tif(i) out << \", \";\n\t\tout << v[i];\n\t}\n\treturn out << \"]\";\n}\n\nconst int M = 400 * 1000 + 555;\nconst int N = 300 * 1000 + 555;\nconst int LOGN = 19;\n\nint n, m, a[N];\nvector<pt> g[N];\n\ninline bool read() {\n\tif(!(cin >> n >> m))\n\t\treturn false;\n\tfore(i, 0, n)\n\t\tassert(scanf(\"%d\", &a[i]) == 1);\n\tfore(i, 0, n - 1) {\n\t\tint u, v, w;\n\t\tassert(scanf(\"%d%d%d\", &u, &v, &w) == 3);\n\t\tu--, v--;\n\t\t\n\t\tg[u].emplace_back(v, w);\n\t\tg[v].emplace_back(u, w);\n\t}\n\tfore(i, 0, n)\n\t\tsort(all(g[i]));\n\treturn true;\n}\n\nint tin[N], tout[N], T = 0;\nint p[N][LOGN];\n\nint h[N];\nli d1[N];\n\nvoid calc1(int v, int pr) {\n\ttin[v] = T++;\n\tp[v][0] = pr;\n\tfore(st, 1, LOGN)\n\t\tp[v][st] = p[p[v][st - 1]][st - 1];\n\t\n\td1[v] = a[v];\n\tfore(i, 0, sz(g[v])) {\n\t\tint to = g[v][i].x;\n\t\tint w = g[v][i].y;\n\t\t\n\t\tif(to == pr)\n\t\t\tcontinue;\n\n\t\th[to] = h[v] + 1;\n\t\tcalc1(to, v);\n\t\td1[v] += max(0ll, d1[to] - 2ll * w);\n\t}\n\ttout[v] = T++;\n}\n\nli dp[N];\nvector<li> dto[N];\n\nvoid calcRRT(int v) {\n\tdp[v] = a[v];\n\tdto[v].assign(sz(g[v]), 0ll);\n\t\n\tfore(i, 0, sz(g[v])) {\n\t\tint to = g[v][i].x;\n\t\tint w = g[v][i].y;\n\t\t\n\t\tli curVal = max(0ll, d1[to] - 2ll * w);\n\t\tdp[v] += curVal;\n\t\tdto[v][i] = curVal;\n\t}\n\t\n\tfore(i, 0, sz(g[v])) {\n\t\tint to = g[v][i].x;\n\t\tif(h[to] < h[v])\n\t\t\tcontinue;\n\t\t\n\t\tli tmp = d1[v];\n\t\td1[v] = dp[v] - dto[v][i];\n\t\tcalcRRT(to);\n\t\td1[v] = tmp;\n\t}\n}\n\ninline bool isP(int l, int v) {\n\treturn tin[l] <= tin[v] && tout[v] <= tout[l];\n}\n\nint lca(int u, int v) {\n\tif(isP(u, v)) return u;\n\tif(isP(v, u)) return v;\n\t\n\tfor(int st = LOGN - 1; st >= 0; st--)\n\t\tif(!isP(p[v][st], u))\n\t\t\tv = p[v][st];\n\treturn p[v][0];\n}\n\n\nli getDto(int v, int to) {\n\tint pos = int(lower_bound(all(g[v]), pt(to, -1)) - g[v].begin());\n\tif(pos >= sz(g[v]) || g[v][pos].x != to)\n\t\treturn 0;\n\treturn dto[v][pos];\n}\n\nli f[N];\n\ninline void inc(int pos, li val) {\n\tfor(; pos < N; pos |= pos + 1)\n\t\tf[pos] += val;\n}\n\ninline li sum(int pos) {\n\tli ans = 0;\n\tfor(; pos >= 0; pos = (pos & (pos + 1)) - 1)\n\t\tans += f[pos];\n\treturn ans;\n}\n\ninline li getSum(int l, int r) {\n\treturn sum(r) - sum(l);\n}\n\nli ans[M];\nvector<pt> qs[N];\n\nvoid calcAns(int v) {\n\tli vAdd = dp[v] - getDto(v, p[v][0]);\n\tinc(h[v], vAdd);\n\t\n\tfor(pt &q : qs[v]) {\n\t\tint up = q.x, id = q.y;\n\t\tans[id] += getSum(h[up] - 1, h[v]) + getDto(up, p[up][0]);\n\t}\n\t\n\tfore(i, 0, sz(g[v])) {\n\t\tint to = g[v][i].x;\n\t\tint w = g[v][i].y;\n\t\tif(h[to] < h[v])\n\t\t\tcontinue;\n\t\t\n\t\tli curSub = dto[v][i] + w;\n\t\tinc(h[v], -curSub);\n\t\t\n\t\tcalcAns(to);\n\t\tinc(h[v], +curSub);\n\t}\n\tinc(h[v], -vAdd);\n}\n\ninline void solve() {\n\tT = 0;\n\th[0] = 0;\n\tcalc1(0, 0);\n\tcalcRRT(0);\n\t\n\tfore(i, 0, m) {\n\t\tint u, v;\n\t\tassert(scanf(\"%d%d\", &u, &v) == 2);\n\t\tu--, v--;\n\t\t\n\t\tint l = lca(u, v);\t\t\n\t\tans[i] = -dp[l];\n\t\t\n\t\tqs[u].emplace_back(l, i);\n\t\tqs[v].emplace_back(l, i);\n\t}\n\t\n\tcalcAns(0);\n\tfore(i, 0, m)\n\t\tprintf(\"%lld\\n\", ans[i]);\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint tt = clock();\n#endif\n\tcout << fixed << setprecision(15);\n\t\n\tif(read()) {\n\t\tsolve();\n\t\t\n#ifdef _DEBUG\n\t\tcerr << \"TIME = \" << clock() - tt << endl;\n\t\ttt = clock();\n#endif\n\t}\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}