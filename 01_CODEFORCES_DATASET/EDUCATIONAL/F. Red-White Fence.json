{"link": "https://codeforces.com//contest/1251/problem/F", "problemId": "449550", "shortId": "1251F", "contest_number": "1251", "name": "F. Red-White Fence", "statement": "Polycarp wants to build a fence near his house. He has  white boards and  red boards he can use to build it. Each board is characterised by its length, which is an integer.A good fence should consist of  red board and several (possibly zero) white boards. The red board should be the longest one in the fence (every white board used in the fence should be strictly shorter), and the sequence of lengths of boards should be ascending before the red board and descending after it. Formally, if  boards are used, and their lengths are , , ...,  in the order they are placed in the fence, from left to right (let's call this array  ), the following conditions should hold:  there should be exactly one red board in the fence (let its index be );  for every  ;  for every  . When Polycarp will build his fence, he will place all boards from left to right on the same height of , without any gaps, so these boards compose a polygon:     Polycarp is interested in fences of some special perimeters. He has   integers he really likes (these integers are , , ..., ), and for every such integer , he wants to calculate the number of different fences with perimeter  he can build (two fences are considered different if their  are different). Can you help him calculate these values?", "input": "The first line contains two integers  and  (, ) \u2014 the number of white and red boards Polycarp has. The second line contains  integers , , ...,  () \u2014 the lengths of white boards Polycarp has. The third line contains  integers , , ...,  () \u2014 the lengths of red boards Polycarp has. . The fourth line contains one integer  () \u2014 the number of special integers. The fifth line contains  integers , , ...,  (, every  is even) \u2014 the special integers Polycarp likes.", "output": "For each , print one integer \u2014 the number of good fences with perimeter  Polycarp can build, taken modulo .", "tutorial": "Let's analyze how the perimeter of the fence can be calculated, if we know its array of lengths. Suppose there are  boards in the fence. The perimeter of the fence can be composed of the three following values:  the lower border of the fence (with length );   horizontal segments in the upper border of the fence (with total length );   vertical segment of the border. The total length of all vertical segments before the red board (including its left border) is . The total length of all vertical segments after the red board (including its right border) is  too. So, the perimeter of the fence is , where  is the number of boards used in constructing the fence, and  is the length of the red board.So, for example, if we want to create a fence that contains a red board with length  and has perimeter , it should contain exactly  white boards. Now let's solve the problem as follows: iterate on the length of the red board that will be used, and for each  calculate the number of ways to construct a fence with a red board of length  and exactly  white boards (which are shorter than ).Suppose all white boards shorter than  have distinct lengths. Then for each board, there are three options: not place it at all, place it in the left part (to the left of the red board) or place it in the right part. So, if there are  different white boards shorter than , the number of ways to build a fence with  white boards is  .Okay, now let's consider the opposite situation: there is no unique white board; that is, for each length, we have either  boards or at least  boards. Suppose the number of different lengths is . For each length, we can choose whether we place a board of such length in the left side and in the right side. So, the number of ways to build a fence with  white boards is .And now let's consider the general case. Divide all boards into two categories: \"unique\" and \"non-unique\". If we want to build a fence with exactly  white boards, there are     ways to do it. Since we should calculate these values for many different values of , we have to use FFT: we should form two polynomials    and   , and then multiply them. Since the modulo is special, it's better to use NTT.", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int LOGN = 20;\nconst int N = (1 << LOGN);\nconst int MOD = 998244353;\nconst int g = 3;\n\n#define forn(i, n) for(int i = 0; i < int(n); i++)\n\ninline int mul(int a, int b)\n{\n\treturn (a * 1ll * b) % MOD;\n}\n\ninline int norm(int a) \n{\n\twhile(a >= MOD)\n\t\ta -= MOD;\n\twhile(a < 0)\n\t\ta += MOD;\n\treturn a;\n}\n\ninline int binPow(int a, int k) \n{\n\tint ans = 1;\n\twhile(k > 0) \n\t{\n\t\tif(k & 1)\n\t\t\tans = mul(ans, a);\n\t\ta = mul(a, a);\n\t\tk >>= 1;\n\t}\n\treturn ans;\n}\n\ninline int inv(int a) \n{\n\treturn binPow(a, MOD - 2);\n}\n\nvector<int> w[LOGN];\nvector<int> iw[LOGN];\nvector<int> rv[LOGN];\n\nvoid precalc() \n{\n\tint wb = binPow(g, (MOD - 1) / (1 << LOGN));\n\t\n\tfor(int st = 0; st < LOGN; st++) \n\t{\n\t\tw[st].assign(1 << st, 1);\n\t\tiw[st].assign(1 << st, 1);\n\t\t\n\t\tint bw = binPow(wb, 1 << (LOGN - st - 1));\n\t\tint ibw = inv(bw);\n\t\t\n\t\tint cw = 1;\n\t\tint icw = 1;\n\t\t\n\t\tfor(int k = 0; k < (1 << st); k++) \n\t\t{\n\t\t\tw[st][k] = cw;\n\t\t\tiw[st][k] = icw;\n\t\t\t\n\t\t\tcw = mul(cw, bw);\n\t\t\ticw = mul(icw, ibw);\n\t\t}\n\t\t\n\t\trv[st].assign(1 << st, 0);\n\t\t\n\t\tif(st == 0) \n\t\t{\n\t\t\trv[st][0] = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tint h = (1 << (st - 1));\n\t\tfor(int k = 0; k < (1 << st); k++)\n\t\t\trv[st][k] = (rv[st - 1][k & (h - 1)] << 1) | (k >= h);\n\t}\n}\n\ninline void fft(int a[N], int n, int ln, bool inverse) \n{\t\n\tfor(int i = 0; i < n; i++) \n\t{\n\t\tint ni = rv[ln][i];\n\t\tif(i < ni)\n\t\t\tswap(a[i], a[ni]);\n\t}\n\t\n\tfor(int st = 0; (1 << st) < n; st++) \n\t{\n\t\tint len = (1 << st);\n\t\tfor(int k = 0; k < n; k += (len << 1)) \n\t\t{\n\t\t\tfor(int pos = k; pos < k + len; pos++) \n\t\t\t{\n\t\t\t\tint l = a[pos];\n\t\t\t\tint r = mul(a[pos + len], (inverse ? iw[st][pos - k] : w[st][pos - k]));\n\t\t\t\t\n\t\t\t\ta[pos] = norm(l + r);\n\t\t\t\ta[pos + len] = norm(l - r);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif(inverse) \n\t{\n\t\tint in = inv(n);\n\t\tfor(int i = 0; i < n; i++)\n\t\t\ta[i] = mul(a[i], in);\n\t}\n}\n\nint aa[N], bb[N], cc[N];\n\ninline void multiply(int a[N], int sza, int b[N], int szb, int c[N], int &szc) \n{\n\tint n = 1, ln = 0;\n\twhile(n < (sza + szb))\n\t\tn <<= 1, ln++;\n\tfor(int i = 0; i < n; i++)\n\t\taa[i] = (i < sza ? a[i] : 0);\n\tfor(int i = 0; i < n; i++)\n\t\tbb[i] = (i < szb ? b[i] : 0);\n\t\t\n\tfft(aa, n, ln, false);\n\tfft(bb, n, ln, false);\n\t\n\tfor(int i = 0; i < n; i++)\n\t\tcc[i] = mul(aa[i], bb[i]);\n\t\t\n\tfft(cc, n, ln, true);\n\t\n\tszc = n;\n\tfor(int i = 0; i < n; i++)\n\t\tc[i] = cc[i];\n}\n\nvector<int> T[N];\n\nint a[N];\nint b[N];\nint n, k;\nint ans[N];\nint Q[N];\nint fact[N];\nint rfact[N];\n\nint auxa[N];\nint auxb[N];\nint auxc[N];\n\nint C(int n, int k)\n{\n\tif(n < 0 || k < 0 || k > n) return 0;\n\treturn mul(fact[n], mul(rfact[k], rfact[n - k]));\n}\n\nvector<int> newtonExp(int a, int b, int p)\n{\n\tvector<int> res(p + 1);\n\tfor(int i = 0; i <= p; i++)\n\t\tres[i] = mul(C(p, i), mul(binPow(a, i), binPow(b, p - i)));\n\treturn res;\n}\n\nint main()\n{\n\tprecalc();\n\tfact[0] = 1;\n\tfor(int i = 1; i < N; i++) fact[i] = mul(fact[i - 1], i);\n\tfor(int i = 0; i < N; i++) rfact[i] = inv(fact[i]);\n\t\n\tscanf(\"%d %d\", &n, &k);\n\tfor(int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n\tfor(int i = 0; i < k; i++) scanf(\"%d\", &b[i]);\n\tint q;\n\tscanf(\"%d\", &q);\n\tfor(int i = 0; i < q; i++) scanf(\"%d\", &Q[i]);\n\t\n\tmap<int, int> cnt;\n\tfor(int i = 0; i < n; i++)\n\t\tcnt[a[i]]++;\n\t\n\tfor(int i = 0; i < k; i++)\n\t{\n\t\tint redL = b[i];\n\t\tint cnt1 = 0;\n\t\tint cnt2 = 0;\n\t\tfor(auto x : cnt)\n\t\t{\n\t\t\tif(x.first >= redL) \n\t\t\t\tbreak;\n\t\t\tif(x.second == 1)\n\t\t\t\tcnt1++;\n\t\t\telse\n\t\t\t\tcnt2++;\n\t\t}\n\t\tmemset(auxa, 0, sizeof auxa);\n\t\tmemset(auxb, 0, sizeof auxb);\n\t\tmemset(auxc, 0, sizeof auxc);\n\t\tvector<int> p1 = newtonExp(2, 1, cnt1);\n\t\tvector<int> p2 = newtonExp(1, 1, cnt2 * 2);\n\t\tint sa = p1.size();\n\t\tint sb = p2.size();\n\t\tint sc;\n\t\tfor(int j = 0; j < sa; j++)\n\t\t\tauxa[j] = p1[j];\n\t\tfor(int j = 0; j < sb; j++)\n\t\t\tauxb[j] = p2[j];\n\t\tmultiply(auxa, sa, auxb, sb, auxc, sc);\n\t\tfor(int j = 0; j < q; j++)\n\t\t{\n\t\t\tint cntW = Q[j] / 2 - redL - 1;\n\t\t\tif(cntW >= 0 && cntW < sc)\n\t\t\t\tans[j] = norm(ans[j] + auxc[cntW]);\n\t\t}\n\t}\n\t\n\tfor(int i = 0; i < q; i++)\n\t\tprintf(\"%d\\n\", ans[i]);\n}", "interactive": false, "noSolution": false, "noTutorial": false}