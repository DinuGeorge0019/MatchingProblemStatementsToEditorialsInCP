{"link": "https://codeforces.com//contest/845/problem/F", "problemId": "119176", "shortId": "845F", "contest_number": "845", "name": "F. Guards In The Storehouse", "statement": "Polycarp owns a shop in the capital of Berland. Recently the criminal activity in the capital increased, so Polycarp is thinking about establishing some better security in the storehouse of his shop.The storehouse can be represented as a matrix with  rows and  columns. Each element of the matrix is either  (an empty space) or  (a wall).Polycarp wants to hire some guards (possibly zero) to watch for the storehouse. Each guard will be in some cell of matrix and will protect every cell to the right of his own cell and every cell to the bottom of his own cell, until the nearest wall. More formally, if the guard is standing in the cell , then he protects cell  if all these conditions are met:   is an empty cell;  either  and , or  and ;  there are no walls between cells  and .  Guards can be placed only in empty cells (and can protect only empty cells). The  of placing the guards is some set of cells where guards will be placed (of course, two plans are different if there exists at least one cell that is included in the first plan, but not included in the second plan, or vice versa). Polycarp calls a plan  if there is  empty cell that is not protected.Polycarp wants to know the number of suitable plans. Since it can be very large, you have to output it modulo .", "input": "The first line contains two numbers  and  \u2014 the length and the width of the storehouse (, ). Then  lines follow, th line contains a string consisting of  characters \u2014 th row of the matrix representing the storehouse. Each character is either  or .", "output": "Output the number of suitable plans modulo .", "tutorial": "This problem can be solved using dynamic programming with broken profile. First of all, we have to make the number of rows not larger than ; if it is larger, then we can just rotate the given matrix.Let's fill the matrix from left to right, and in each column from top to bottom. Let  be the number of ways to achieve the following situation: we now want to fill cell with index ,  denotes the rows which are already protected in this column (so there is a wall in this row or there is a guard to the left),  is a flag that denotes if current cell is protected by some guard above, and  is a flag that denotes if there was a cell that was not protected.When advancing from one column to another, we have to change the mask so we update the rows that are currently protected. The rows such that in the previous column there was a wall in this row become un-protected, and the rows such that there is a wall in current column in this row become protected. And, of course,  becomes zero.When we place a guard, we set  to one and make the corresponding row protected. And when we are at the wall, we have to set  to zero, so the guard from above doesn't protect next cell.The answer is the sum of all  values.", "solution": "//package educational.round27;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class F {\n\tInputStream is;\n\tPrintWriter out;\n\tString INPUT = \"\";\n\t\n\tvoid solve()\n\t{\n\t\tint n = ni(), m = ni();\n\t\tchar[][] map = nm(n,m);\n\t\tif(n < m){\n\t\t\tmap = trans(map);\n\t\t\tint d = n; n = m;m  = d;\n\t\t}\n\t\t// m<=16\n\t\tint mod = 1000000007;\n\t\tlong[][][] dp = new long[2][2][1<<m]; // [space][horizontal ray pattern][vertical ray pattern (no rolling)]\n\t\tdp[0][0][0] = 1;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tfor(int j = 0;j < m;j++){\n\t\t\t\tlong[][][] ndp = new long[2][2][1<<m]; // [space][horizontal ray pattern][vertical ray pattern (no rolling)]\n\t\t\t\tif(map[i][j] == 'x'){\n\t\t\t\t\tfor(int s = 0;s < 2;s++){\n\t\t\t\t\t\tfor(int h = 0;h < 2;h++){\n\t\t\t\t\t\t\tfor(int k = 0;k < 1<<m;k++){\n\t\t\t\t\t\t\t\tint nk = k&~(1<<j);\n\t\t\t\t\t\t\t\tndp[s][0][nk] += dp[s][h][k];\n\t\t\t\t\t\t\t\tif (ndp[s][0][nk] >= mod)\n\t\t\t\t\t\t\t\t\tndp[s][0][nk] -= mod;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tfor(int s = 0;s < 2;s++){\n\t\t\t\t\t\tfor(int h = 0;h < 2;h++){\n\t\t\t\t\t\t\tfor(int k = 0;k < 1<<m;k++){\n\t\t\t\t\t\t\t\t// put\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tint nh = j == m-1 ? 0 : (h|1);\n\t\t\t\t\t\t\t\t\tint nk = k|1<<j;\n\t\t\t\t\t\t\t\t\tndp[s][nh][nk] += dp[s][h][k];\n\t\t\t\t\t\t\t\t\tif (ndp[s][nh][nk] >= mod)\n\t\t\t\t\t\t\t\t\t\tndp[s][nh][nk] -= mod;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// not put\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tint ns = h == 0 && k<<~j>=0 ? s+1 : s;\n\t\t\t\t\t\t\t\t\tint nh = j == m-1 ? 0 : h;\n\t\t\t\t\t\t\t\t\tif(ns < 2){\n\t\t\t\t\t\t\t\t\t\tndp[ns][nh][k] += dp[s][h][k];\n\t\t\t\t\t\t\t\t\t\tif (ndp[ns][nh][k] >= mod)\n\t\t\t\t\t\t\t\t\t\t\tndp[ns][nh][k] -= mod;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdp = ndp;\n\t\t\t}\n\t\t}\n\t\tlong ret = 0;\n\t\tfor(int i = 0;i < 2;i++){\n\t\t\tfor(int j = 0;j < 1<<m;j++){\n\t\t\t\tret += dp[0][i][j];\n\t\t\t\tret += dp[1][i][j];\n\t\t\t}\n\t\t}\n\t\tout.println(ret%mod);\n\t}\n\t\n\tpublic static char[][] trans(char[][] a)\n\t{\n\t\tif(a.length == 0)return new char[0][0];\n\t\tint n = a.length, m = a[0].length;\n\t\tchar[][] ret = new char[m][n];\n\t\tfor(int i = 0;i < m;i++){\n\t\t\tfor(int j = 0;j < n;j++){\n\t\t\t\tret[i][j] = a[j][i];\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\t\n\tvoid run() throws Exception\n\t{\n//\t\tint n = 15, m = 16;\n//\t\tRandom gen = new Random();\n//\t\tStringBuilder sb = new StringBuilder();\n//\t\tsb.append(n + \" \");\n//\t\tsb.append(m + \" \");\n//\t\tfor (int i = 0; i < n; i++) {\n//\t\t\tfor(int j = 0;j < m;j++){\n//\t\t\t\tsb.append(\"x\");\n//\t\t\t}\n//\t\t\tsb.append(\"\\n\");\n//\t\t}\n//\t\tINPUT = sb.toString();\n\n\t\t\n\t\tis = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tlong s = System.currentTimeMillis();\n\t\tsolve();\n\t\tout.flush();\n\t\ttr(System.currentTimeMillis()-s+\"ms\");\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception { new F().run(); }\n\t\n\tprivate byte[] inbuf = new byte[1024];\n\tpublic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n\tprivate int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate double nd() { return Double.parseDouble(ns()); }\n\tprivate char nc() { return (char)skip(); }\n\t\n\tprivate String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\tprivate void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}