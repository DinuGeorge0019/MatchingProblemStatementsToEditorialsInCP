{"link": "https://codeforces.com//contest/1613/problem/E", "problemId": "1209365", "shortId": "1613E", "contest_number": "1613", "name": "E. Crazy Robot", "statement": "There is a grid, consisting of  rows and  columns. Each cell of the grid is either free or blocked. One of the free cells contains a lab. All the cells beyond the borders of the grid are also blocked.A crazy robot has escaped from this lab. It is currently in some free cell of the grid. You can send one of the following commands to the robot: \"move right\", \"move down\", \"move left\" or \"move up\". Each command means moving to a neighbouring cell in the corresponding direction.However, as the robot is crazy, it will do anything except following the command. Upon receiving a command, it will choose a direction such that it differs from the one in command and the cell in that direction is not blocked. If there is such a direction, then it will move to a neighbouring cell in that direction. Otherwise, it will do nothing.We want to get the robot to the lab to get it fixed. For each free cell, determine if the robot can be forced to reach the lab starting in this cell. That is, after each step of the robot a command can be sent to a robot such that no matter what different directions the robot chooses, it will end up in a lab.", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of testcases. The first line of each testcase contains two integers  and  (; )\u00a0\u2014 the number of rows and the number of columns in the grid. The -th of the next  lines provides a description of the -th row of the grid. It consists of  elements of one of three types:    '.'\u00a0\u2014 the cell is free;  '#'\u00a0\u2014 the cell is blocked;  'L'\u00a0\u2014 the cell contains a lab.  The grid contains exactly one lab. The sum of  over all testcases doesn't exceed .", "output": "For each testcase find the free cells that the robot can be forced to reach the lab from. Given the grid, replace the free cells (marked with a dot) with a plus sign ('+') for the cells that the robot can be forced to reach the lab from. Print the resulting grid.", "tutorial": "One way to think about this problem is in game theory terms.Imagine a following game. Two players alternate moves. The first players chooses a direction. The second player chooses a different direction and moves a robot there. The game ends when the robot reaches the lab, and the first player wins. Otherwise, it's a draw. What's the outcome of the game if both players play optimally (as in the first player tries to win, the second player tries to draw)?Does it sound easier? Well, it sure does if you ever dealt with solving games on arbitrary graphs. You can skim through this article if that's unfamiliar to you. The state of the game is a pair . If a direction is not chosen (denote it with ), it's the first player's move. Otherwise, it's the second player's move.You can even implement it as is. Or you can adjust a part of this algorithm for this particular problem. Initially, all the states are drawing, only the state  is winning. What we basically need is a way to determine if a state is winning or not. From game theory, we can tell that the state is winning if there's a transition from it to a losing state. The state is losing if all the transitions from it lead to winning states. So  is winning if any of  are losing.Promote that one step further. The state is winning if there exists such a direction that all neighbouring free cells except in this direction are winning states. Rephrase it. The state is winning if it has at least one winning state neighbour and no more than one non-winning state neighbour.Let's store the number of non-winning neighbouring states for each cell. Initially, it's the number of neighbouring free cells. If some state becomes marked as winning, decrease the value for each of its neighbours by . If some state's value reaches  or  after this operation, mark it as winning.Since what this does is basically a traversal of a grid, this can be done with a DFS/BFS, starting from the lab.Overall complexity:  per testcase.", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nstruct cell{\n\tint x, y;\n};\n\nint dx[] = {-1, 0, 1, 0};\nint dy[] = {0, 1, 0, -1};\n\nint main() {\n\tint t;\n\tcin >> t;\n\twhile (t--){\n\t\tint n, m;\n\t\tcin >> n >> m;\n\t\tvector<string> s(n);\n\t\tint lx = -1, ly = -1;\n\t\tforn(i, n){\n\t\t\tcin >> s[i];\n\t\t\tforn(j, m) if (s[i][j] == 'L'){\n\t\t\t\tlx = i;\n\t\t\t\tly = j;\n\t\t\t}\n\t\t}\n\t\tauto in = [&](int x, int y){\n\t\t\treturn 0 <= x && x < n && 0 <= y && y < m;\n\t\t};\n\t\tvector<vector<int>> d(n, vector<int>(m, 0));\n\t\tforn(x, n) forn(y, m) if (s[x][y] == '.'){\n\t\t\tforn(i, 4){\n\t\t\t\tint nx = x + dx[i];\n\t\t\t\tint ny = y + dy[i];\n\t\t\t\td[x][y] += in(nx, ny) && s[nx][ny] != '#';\n\t\t\t}\n\t\t}\n\t\tqueue<cell> q;\n\t\tvector<vector<char>> used(n, vector<char>(m, 0));\n\t\tq.push({lx, ly});\n\t\tused[lx][ly] = true;\n\t\twhile (!q.empty()){\n\t\t\tint x = q.front().x;\n\t\t\tint y = q.front().y;\n\t\t\tq.pop();\n\t\t\tforn(i, 4){\n\t\t\t\tint nx = x + dx[i];\n\t\t\t\tint ny = y + dy[i];\n\t\t\t\tif (!in(nx, ny) || s[nx][ny] == '#' || used[nx][ny]) continue;\n\t\t\t\t--d[nx][ny];\n\t\t\t\tif (d[nx][ny] <= 1){\n\t\t\t\t\tused[nx][ny] = true;\n\t\t\t\t\tq.push({nx, ny});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tforn(i, n){\n\t\t\tforn(j, m) if (s[i][j] == '.' && used[i][j])\n\t\t\t\ts[i][j] = '+';\n\t\t\tcout << s[i] << \"\\n\";\n\t\t}\n\t}\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}