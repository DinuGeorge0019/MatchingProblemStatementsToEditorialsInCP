{"link": "https://codeforces.com//contest/1795/problem/A", "problemId": "1785697", "shortId": "1795A", "contest_number": "1795", "name": "A. Two Towers", "statement": "There are two towers consisting of blocks of two colors: red and blue. Both towers are represented by strings of characters  and/or  denoting the order of blocks in them , where  corresponds to a blue block, and  corresponds to a red block.   You can perform the following operation any number of times: choose a tower with , and move its  block to the  of the other tower.   The pair of towers is  if no pair of touching blocks has the same color; i.\u2009e. no red block stands on top of another red block, and no blue block stands on top of another blue block.You have to check if it is possible to perform any number of operations (possibly zero) to make the pair of towers beautiful.", "input": "The first line contains one integer  ()\u00a0\u2014 the number of test cases. Each test case consists of three lines:   the first line contains two integers  and  ()\u00a0\u2014 the number of blocks in the first tower and the number of blocks in the second tower, respectively;  the second line contains \u00a0\u2014 a string of exactly  characters  and/or , denoting the first tower;  the third line contains \u00a0\u2014 a string of exactly  characters  and/or , denoting the second tower. ", "output": "For each test case, print  if it is possible to perform several (possibly zero) operations in such a way that the pair of towers becomes beautiful; otherwise print . You may print each letter in any case (, ,  will all be recognized as positive answer, ,  and  will all be recognized as negative answer).", "tutorial": "Note that it does not make sense to move several blocks first from the left tower to the right, and then from the right to the left, since this is similar to canceling the last actions.Using the fact described above and small restrictions on the input data, one of the possible solutions is the following: choose which tower will be the one where we take blocks from (try both options), iterate over the number of operations, and then check that both towers are beautiful after that number of operations.There is a faster solution: move all the blocks to the left tower, and then check that there is no more than one pair of adjacent blocks of the same color. If there are no such pairs, then we can divide the tower into two in an arbitrary way, and if there is exactly one pair, then we need to make a \"cut\" exactly between two blocks of the same color. Otherwise, there will always be a pair of adjacent blocks of the same color in one of the towers.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  auto ok = [](string s) {\n    for (int i = 1; i < (int)s.size(); ++i)\n      if (s[i - 1] == s[i]) return false;\n    return true;    \n  };\n  \n  int t;\n  cin >> t;\n  while (t--) {\n    int n, m;\n    string s, t;\n    cin >> n >> m >> s >> t;\n    bool f = false;\n    for (int x = 0; x < 2; ++x) {\n      string cs = s, ct = t;\n      for (int i = 0; i < n; ++i) {\n        f |= ok(cs) && ok(ct);\n        ct.push_back(cs.back());\n        cs.pop_back();\n      }\n      swap(n, m);\n      swap(s, t);   \n    }\n    cout << (f ? \"YES\\n\" : \"NO\\n\");\n  }\n}", "interactive": false, "noSolution": false, "noTutorial": false}