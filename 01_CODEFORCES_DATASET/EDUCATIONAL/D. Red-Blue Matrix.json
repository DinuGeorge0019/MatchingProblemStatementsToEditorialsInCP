{"link": "https://codeforces.com//contest/1606/problem/D", "problemId": "1163615", "shortId": "1606D", "contest_number": "1606", "name": "D. Red-Blue Matrix", "statement": "You are given a matrix, consisting of  rows and  columns. The -th cell of the -th row contains an integer .First, you have to color each row of the matrix either red or blue in such a way that  and .Then, you have to choose an integer  () and cut the colored matrix in such a way that the first  columns become a separate matrix (the  matrix) and the last  columns become a separate matrix (the  matrix).The coloring and the cut are called  if two properties hold:   every red cell in the left matrix contains an integer greater than every blue cell in the left matrix;  every blue cell in the right matrix contains an integer greater than every red cell in the right matrix. Find any perfect coloring and cut, or report that there are none.", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of testcases. Then the descriptions of  testcases follow. The first line of each testcase contains two integers  and  (; )\u00a0\u2014 the number of rows and the number of columns in the matrix, respectively. The -th of the next  lines contains  integers  (). The sum of  over all testcases doesn't exceed .", "output": "For each testcase print an answer. If there are no perfect colorings and cuts in the matrix, then print \"\". Otherwise, first, print \"\". Then a string, consisting of  characters: the -th character should be '' if the -th row is colored red and '' if it's colored blue. The string should contain at least one '' and at least one ''. Finally, print an integer  ()\u00a0\u2014 the number of columns from the left that are cut.", "tutorial": "Imagine you fixed some cut and then colored one row red. Which rows can now be colored red or blue so that the condition on the left matrix is satisfied? If the row has at least one number greater or equal than the numbers in the red row, then the row must be red. Otherwise, it can be either red or blue.However, imagine a weaker condition. Let's look only at the first cell in each row. Sort the rows by the first cell in them. Similarly, if a row is colored red, all the rows that are further in the sorted order should also be red, because they already have a greater or equal number in them.It implies that after you sort the rows, the only possible colorings are: color some prefix of the rows in blue and the remaining suffix in red.So there are  possible colorings and  possible cuts. If we learn to check if they are perfect in , we can get the solution in .Turns out, the condition \"all numbers in the submatrix should be greater than all numbers in the other submatrix\" is the same as \"the minimum in the first submatrix should be greater than the maximum in the second submatrix\".Thus, you can first precalculate prefix and suffix minimums and maximums and check a coloring and a cut in .Overall complexity:  per testcase.", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int INF = 1e9;\n\nint main() {\n\tint tc;\n\tscanf(\"%d\", &tc);\n\twhile (tc--){\n\t\tint n, m;\n\t\tscanf(\"%d%d\", &n, &m);\n\t\tvector<vector<int>> a(n, vector<int>(m));\n\t\tforn(i, n) forn(j, m) scanf(\"%d\", &a[i][j]);\n\t\tvector<int> ord(n);\n\t\tiota(ord.begin(), ord.end(), 0);\n\t\tsort(ord.begin(), ord.end(), [&a](int x, int y){ return a[x][0] > a[y][0]; });\n\t\tvector<vector<int>> mxl(n, vector<int>(m, -INF));\n\t\tvector<vector<int>> mnr(n, vector<int>(m, INF));\n\t\tfor (int i = n - 1; i >= 0; --i) forn(j, m){\n\t\t\tmxl[i][j] = a[ord[i]][j];\n\t\t\tif (i < n - 1) mxl[i][j] = max(mxl[i][j], mxl[i + 1][j]);\n\t\t\tif (j > 0) mxl[i][j] = max(mxl[i][j], mxl[i][j - 1]);\n\t\t}\n\t\tfor (int i = n - 1; i >= 0; --i) for (int j = m - 1; j >= 0; --j){\n\t\t\tmnr[i][j] = a[ord[i]][j];\n\t\t\tif (i < n - 1) mnr[i][j] = min(mnr[i][j], mnr[i + 1][j]);\n\t\t\tif (j < m - 1) mnr[i][j] = min(mnr[i][j], mnr[i][j + 1]);\n\t\t}\n\t\tvector<int> mnl(m, INF), mxr(m, -INF);\n\t\tpair<int, int> ans(-1, -1);\n\t\tforn(i, n - 1){\n\t\t\tforn(j, m){\n\t\t\t\tmnl[j] = min(mnl[j], a[ord[i]][j]);\n\t\t\t\tif (j > 0) mnl[j] = min(mnl[j], mnl[j - 1]);\n\t\t\t}\n\t\t\tfor (int j = m - 1; j >= 0; --j){\n\t\t\t\tmxr[j] = max(mxr[j], a[ord[i]][j]);\n\t\t\t\tif (j < m - 1) mxr[j] = max(mxr[j], mxr[j + 1]);\n\t\t\t}\n\t\t\tforn(j, m - 1) if (mnl[j] > mxl[i + 1][j] && mxr[j + 1] < mnr[i + 1][j + 1]){\n\t\t\t\tans = {i, j};\n\t\t\t}\n\t\t}\n\t\tif (ans.first == -1){\n\t\t\tputs(\"NO\");\n\t\t\tcontinue;\n\t\t}\n\t\tputs(\"YES\");\n\t\tstring res(n, '.');\n\t\tforn(i, n) res[ord[i]] = i <= ans.first ? 'R' : 'B';\n\t\tprintf(\"%s %d\\n\", res.c_str(), ans.second + 1);\n\t}\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}