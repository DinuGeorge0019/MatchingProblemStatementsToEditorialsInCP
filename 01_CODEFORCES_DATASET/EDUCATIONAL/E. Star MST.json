{"link": "https://codeforces.com//contest/1657/problem/E", "problemId": "1339155", "shortId": "1657E", "contest_number": "1657", "name": "E. Star MST", "statement": "In this problem, we will consider  undirected graphs consisting of  vertices with weighted edges. The weight of each edge is an integer from  to .An undirected graph is considered  if the sum of weights of all edges incident to vertex  is equal to the weight of MST in the graph. MST is the minimum spanning tree\u00a0\u2014 a tree consisting of  edges of the graph, which connects all  vertices and has the minimum sum of weights among all such trees; the weight of MST is the sum of weights of all edges in it.Calculate the number of   graphs having exactly  vertices and the weights of edges from  to . Since the answer might be large, print it modulo .", "input": "The only line contains two integers  and  (; ).", "output": "Print one integer\u00a0\u2014 the number of   graphs having exactly  vertices and the weights of edges from  to . Since the answer might be large, print it modulo .", "tutorial": "Let the weight of the edge between the vertex  to the vertex  be .Suppose there exists a pair of vertices  and  (with indices greater than ) such that  or . Then, if we choose the spanning tree with all vertices connected to , it won't be an MST: we can remove either the edge  or the edge , add the edge  instead, and the cost of the spanning tree will decrease. So, we should have  for every pair .It can be shown that this condition is not only necessary, but sufficient as well: if for every pair  the condition  holds, the MST can't have the weight less than . We can prove this by induction (suppose that  for simplicity):  in the spanning tree, there should be at least one edge incident to vertex , and its weight is at least ;  there should be at least two edges incident to vertices  and , and their weights are at least ;  ...;  there should be at least  edges incident to vertices from  to , and their weights are at least . Okay, now let's show how to calculate the number of such graphs. We can run the following dynamic programming: let  be the number of graphs where we have already connected  vertices to the vertex , and the maximum weight we have used is . We start with , and for each transition from , we will iterate on the number of vertices we connect to the vertex  with edges with weight  (let the number of those vertices be ), choose them with a binomial coefficient , and also choose the weights for the edges that connect one of the chosen vertices with one of the vertices already connected to  (since for each of those edges, we know that their weights should be in ) \u2014 so, we need to multiply the value in transition by , where  is the number of such edges.Implementing this dynamic programming can be done in  or , both are sufficient.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n\nconst int MOD = 998244353;\n\nint add(int a, int b){\n\ta += b;\n\tif (a >= MOD)\n\t\ta -= MOD;\n\treturn a;\n}\n\nint mul(int a, int b){\n\treturn a * 1ll * b % MOD;\n}\n\nint binpow(int a, int b){\n\tint res = 1;\n\twhile (b){\n\t\tif (b & 1)\n\t\t\tres = mul(res, a);\n\t\ta = mul(a, a);\n\t\tb >>= 1;\n\t}\n\treturn res;\n}\n\nint main(){\n\tint n, k;\n\tscanf(\"%d%d\", &n, &k);\n\t--n;\n\tvector<vector<int>> dp(k + 1, vector<int>(n + 1, 0));\n\tvector<vector<int>> C(n + 1);\n\tforn(i, n + 1){\n\t\tC[i].resize(i + 1);\n\t\tC[i][0] = C[i][i] = 1;\n\t\tfor (int j = 1; j < i; ++j)\n\t\t\tC[i][j] = add(C[i - 1][j], C[i - 1][j - 1]);\n\t}\n\tdp[0][0] = 1;\n\tforn(i, k) forn(t, n + 1) {\n\t\tint pw = binpow(k - i, t * (t - 1) / 2);\n\t\tint step = binpow(k - i, t);\n\t\tforn(j, n - t + 1){\n\t\t\tdp[i + 1][j + t] = add(dp[i + 1][j + t], mul(dp[i][j], mul(C[n - j][t], pw)));\n\t\t\tpw = mul(pw, step);\n\t\t}\n\t}\n\tprintf(\"%d\\n\", dp[k][n]);\n}", "interactive": false, "noSolution": false, "noTutorial": false}