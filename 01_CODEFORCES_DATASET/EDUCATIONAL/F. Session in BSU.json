{"link": "https://codeforces.com//contest/1027/problem/F", "problemId": "209493", "shortId": "1027F", "contest_number": "1027", "name": "F. Session in BSU", "statement": "Polycarp studies in Berland State University. Soon he will have to take his exam. He has to pass exactly  exams.For the each exam  there are known two days:  \u2014 day of the first opportunity to pass the exam,  \u2014 day of the second opportunity to pass the exam (). Polycarp  during each day. For each exam Polycarp chooses by himself which day he will pass this exam. He has to pass all the  exams.Polycarp wants to pass all the exams as soon as possible. Print the minimum index of day by which Polycarp can pass all the  exams, or print  if he cannot pass all the exams at all.", "input": "The first line of the input contains one integer  () \u2014 the number of exams. The next  lines contain two integers each:  and  (), where  is the number of day of the first passing the -th exam and  is the number of day of the second passing the -th exam.", "output": "If Polycarp cannot pass all the  exams, print . Otherwise print the minimum index of day by which Polycarp can do that.", "tutorial": "This problem has many approaches (as Hall's theorem, Kuhn algorithm (???) and so on), I will explain one (or two) of them.Let's find the answer using binary search. It is obvious that if we can pass all the exams in  days we can also pass them in  days.For the fixed last day  let's do the following thing: firstly, if there exists some exam with the day of the first opportunity to pass it greater than , then the answer for the day  is false.Next, while there exist exams having only one possibility to pass them (because of the upper bound of the maximum possible day or constraints imposed by the other exams), we choose this day for this exam and continue (after choosing such day there can appear some new exams with the same property). Now there are no exams having only one day to pass them.Let's take a look on the graph where vertices represent days and edges represent exams (the edge between some vertices  and  () exists iff there is an exam with the first day to pass it equal to  and the second day to pass it equal to ). Let's remove all the exams for which we identified the answer. Now let's take a look on the connected components of this graph and analyze the problem which we have now. Our problem is to choose exactly one vertex incident to each edge of the connected component such that no vertex is chosen twice (and we have to do this for all the connected components we have).Let  be the number of vertices in the current connected component and  be the number of edges in the current connected component. The answer for the connected component is true iff , for obvious reasons. There is very easy constructive method to see how we can do this. If  then the current connected component is a tree. Let's remove some leaf of this tree and set it as the chosen vertex for the edge incident to this leaf (and remove this edge too). If  then let's remove all leaves as in the algorithm for the tree. For the remaining cycle let's choose any edge and any vertex incident to it, set this vertex as the chosen to this edge and remove them. Now we have a chain. Chain is a tree, so let's apply the algorithm for the tree to this chain.So, if for some connected component  holds  then the answer for the day  is false. Otherwise the answer is true.Overall complexity  because of numbers compressing or using logarithmic data structures to maintain the graph.Also there is another solution (which can be too slow, I don't know why it works). It is well-known fact that if we will apply Kuhn algorithm to the some bipartite graph in order of increasing indices of vertices of the left part, then the last vertex in the left part of this graph which is in the matching will be minimum possible. Oh, that's what we need! Let the left part of this graph consist of days and the right part consist of exams. The edge between some vertices  from the left part and  from the right part exists iff  is one of two days to pass the exam . Let's apply Kuhn algorithm to this graph, considering days in increasing order. The first day when matching becomes  (all exams are in the matching) will be the answer. I don't know its complexity, really. Maybe it works too fast because of the special properties of the graph... If someone can explain in which time it works I will very happy!", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n\nconst int N = 2 * 1000 * 1000 + 11;\nconst int INF = 1e9 + 1;\n\nint n;\nint a[N][2];\nvector<int> s;\nbool used[N];\nbool exam[N];\nvector<pair<int, int>> g[N];\n\nbool deny(int v) {\n    if (used[v]) return false;\n    used[v] = true;\n    for (auto it : g[v]) {\n        int to = it.first;\n        int ex = it.second;\n        if (exam[ex]) continue;\n        if (used[to])\n            return false;\n        exam[ex] = true;\n        if (!deny(to))\n            return false;\n    }\n    return true;\n}\n\nint cntv, cnte;\n\nvoid dfs(int v) {\n    ++cntv;\n    used[v] = true;\n    for (auto it : g[v]) {\n        int to = it.first;\n        int ex = it.second;\n        if (exam[ex]) continue;\n        exam[ex] = true;\n        ++cnte;\n        if (!used[to])\n            dfs(to);\n    }\n}\n\nbool check(int day) {\n    memset(used, false, sizeof(used));\n    memset(exam, false, sizeof(exam));\n    forn(i, s.size()) if (i > day) {\n        if (!deny(i)) {\n            return false;\n        }\n    }\n    \n    forn(i, s.size()) {\n        if (!used[i]) {\n            cntv = 0;\n            cnte = 0;\n            dfs(i);\n            if (cntv < cnte)\n                return false;\n        }\n    }\n    \n    return true;\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    forn(i, n) forn(j, 2) {\n        scanf(\"%d\", &a[i][j]);\n        s.push_back(a[i][j]);\n    }\n    \n    sort(s.begin(), s.end());\n    s.resize(unique(s.begin(), s.end()) - s.begin());\n    \n    forn(i, n) {\n        forn(j, 2) {\n            a[i][j] = lower_bound(s.begin(), s.end(), a[i][j]) - s.begin();\n        }\n        g[a[i][0]].push_back(make_pair(a[i][1], i));\n        g[a[i][1]].push_back(make_pair(a[i][0], i));\n    }\n        \n    int l = 0, r = int(s.size()) - 1;\n    while (r - l > 1) {\n        int mid = (l + r) >> 1;\n        if (check(mid))\n            r = mid;\n        else\n            l = mid;\n    }\n    for (int i = l; i <= r; ++i) {\n        if (check(i)) {\n            printf(\"%d\\n\", s[i]);\n            return 0;\n        }\n    }\n    puts(\"-1\");\n}", "interactive": false, "noSolution": false, "noTutorial": false}