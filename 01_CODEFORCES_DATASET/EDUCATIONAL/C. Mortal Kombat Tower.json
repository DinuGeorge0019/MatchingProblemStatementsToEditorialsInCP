{"link": "https://codeforces.com//contest/1418/problem/C", "problemId": "727425", "shortId": "1418C", "contest_number": "1418", "name": "C. Mortal Kombat Tower", "statement": "You and your friend are playing the game Mortal Kombat XI. You are trying to pass a challenge tower. There are  bosses in this tower, numbered from  to . The type of the -th boss is . If the -th boss is easy then its type is , otherwise this boss is hard and its type is .During one session, either you or your friend can kill  bosses (neither you nor your friend can skip the session, so the minimum number of bosses killed during one session is at least one). After your friend session, your session begins, then again your friend session begins, your session begins, and so on. .Your friend needs to get good because he can't actually kill hard bosses. To kill them, he uses skip points. One skip point can be used to kill one hard boss.Your task is to find the  number of skip points your friend needs to use so you and your friend kill all  bosses in the given order.For example: suppose , . Then the best course of action is the following:  your friend kills two first bosses, using one skip point for the first boss;  you kill the third and the fourth bosses;  your friend kills the fifth boss;  you kill the sixth and the seventh bosses;  your friend kills the last boss, using one skip point, so the tower is completed using two skip points. You have to answer  independent test cases.", "input": "The first line of the input contains one integer  () \u2014 the number of test cases. Then  test cases follow. The first line of the test case contains one integer  () \u2014 the number of bosses. The second line of the test case contains  integers  (), where  is the type of the -th boss. It is guaranteed that the sum of  does not exceed  ().", "output": "For each test case, print the answer: the  number of skip points your friend needs to use so you and your friend kill all  bosses in the given order.", "tutorial": "If  then our friend always needs one skip point because he always has to kill the first boss. Let's just remove this boss from our consideration and increase the answer if needed.What about other skip points? Firstly, let's understand that we can always do our moves in such a way that the first hard boss will always be killed by us (except the first one). So, if it's our friend turn now and there is only one easy boss before the hard, our friend just kills this easy boss. If there are two easy bosses, he kills both. If there are three, friend kills the first, we kill the second, and he kills the third. And so on. So we can always assume that each segment of hard bosses starts with our move.We can kill each such segment greedily: we kill two bosses and our friend kills one. If there are less than three bosses in the segment, we just kill remaining and proceed. So if the length of the current segment of hard bosses is  then we need  skip points. Summing up these values over all segments we get the answer (and don't forget that the first boss should be handled separately). Segments of ones can be extracted using two pointers.There are also dynamic programming solution but I found this one more clever.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n    freopen(\"input.txt\", \"r\", stdin);\n//  freopen(\"output.txt\", \"w\", stdout);\n#endif\n    \n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        vector<int> a(n);\n        for (auto &it : a) cin >> it;\n        int ans = 0;\n        ans += a[0] == 1;\n        for (int i = 1; i < n; ++i) {\n            if (a[i] == 0) {\n                continue;\n            }\n            int j = i;\n            while (j < n && a[j] == 1) {\n                ++j;\n            }\n            ans += (j - i) / 3;\n            i = j - 1;\n        }\n        cout << ans << endl;\n    }\n    \n    return 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}