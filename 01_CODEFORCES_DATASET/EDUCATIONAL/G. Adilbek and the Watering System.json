{"link": "https://codeforces.com//contest/1238/problem/G", "problemId": "434111", "shortId": "1238G", "contest_number": "1238", "name": "G. Adilbek and the Watering System", "statement": "Adilbek has to water his garden. He is going to do it with the help of a complex watering system: he only has to deliver water to it, and the mechanisms will do all the remaining job.The watering system consumes one liter of water per minute (if there is no water, it is not working). It can hold no more than  liters. Adilbek has already poured  liters of water into the system. He is going to start watering the garden right now and water it for  minutes, and the watering system should contain at least one liter of water at the beginning of the -th minute (for every  from  to ).Now Adilbek wonders what he will do if the watering system runs out of water. He called  his friends and asked them if they are going to bring some water. The -th friend answered that he can bring no more than  liters of water; he will arrive at the beginning of the -th minute and pour all the water he has into the system (if the system cannot hold such amount of water, the excess water is poured out); and then he will ask Adilbek to pay  dollars for each liter of water he has brought. You may assume that if a friend arrives at the beginning of the -th minute and the system runs out of water at the beginning of the same minute, the friend pours his water fast enough so that the system does not stop working.Of course, Adilbek does not want to pay his friends, but he has to water the garden. So he has to tell his friends how much water should they bring. Formally, Adilbek wants to choose  integers , , ...,  in such a way that:  if each friend  brings exactly  liters of water, then the watering system works during the whole time required to water the garden;  the sum  is minimum possible. Help Adilbek to determine the minimum amount he has to pay his friends or determine that Adilbek not able to water the garden for  minutes.You have to answer  independent queries.", "input": "The first line contains one integer  () \u2013 the number of queries. The first line of each query contains four integers  and  ()\u00a0\u2014 the number of friends, the number of minutes of watering, the capacity of the watering system and the number of liters poured by Adilbek. Each of the next  lines contains three integers  () \u2014 the -th friend's arrival time, the maximum amount of water -th friend can bring and the cost of  liter from -th friend. It is guaranteed that sum of all  over all queries does not exceed .", "output": "For each query print one integer\u00a0\u2014 the minimum amount Adilbek has to pay his friends, or  if Adilbek is not able to water the garden for  minutes.", "tutorial": "Despite the fact that statement sounds like some dp or flow, the actual solution is pretty greedy.Let's iterate over all minutes Adilbek has to water at and maintain the cheapest  liters he can obtain to this minute. Let this be some structure which stores data in form (price for 1 liter, total volume Adilbek can buy for this price). Pairs will be sorted by the price of a liter. The most convenient structure for that might be a C++ map, for example.When moving to the next minute, pop the cheapest liter out of this structure and add it to the answer.If that minute some friend comes, then push his water to the structure: if the total updated volume in the structure is greater than , then pop the most expensive left-overs out of it so that the structure holds no more than  liters total. That prevents out solution to fill the watering system over its capacity.The main idea for why this greedy strategy works is that it's never optimal to take not the cheapest liter because a liter of that price or cheaper will still be available in the future minutes.Note that between each pairs of adjacent coming friends basically nothing happens. Thus you can find the time between them and pop that number of cheapest liters right away instead of iterating minute by minute.Overall complexity:  per query.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n#define mp make_pair\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n\ntypedef long long li;\ntypedef pair<int, int> pt;\n\nconst int N = 500 * 1000 + 13;\n\nint n, m, c, c0;\npair<int, pt> a[N];\n\nli solve() {\n\tscanf(\"%d%d%d%d\", &n, &m, &c, &c0);\n\tforn(i, n) scanf(\"%d%d%d\", &a[i].x, &a[i].y.x, &a[i].y.y);\n\ta[n++] = mp(m, mp(0, 0));\n\tsort(a, a + n);\n\n\tint sum = c0;\n\tmap<int, int> q;\n\tq[0] = c0;\n\t\n\tli ans = 0;\n\tforn(i, n) {\n\t\tint x = a[i].x;\n\t\tint cnt = a[i].y.x;\n\t\tint cost = a[i].y.y;\n\t\n\t\tint dist = x - (i ? a[i - 1].x : 0);\n\t\twhile (!q.empty() && dist > 0) {\n\t\t\tint can = min(q.begin()->y, dist);\n\t\t\tans += q.begin()->x * 1ll * can;\n\t\t\tsum -= can;\n\t\t\tdist -= can;\n\t\t\tq.begin()->y -= can;\n\t\t\tif (q.begin()->y == 0) q.erase(q.begin());\n\t\t}\n\t\t\n\t\tif (dist > 0) \n\t\t\treturn -1;\n\t\t\n\t\tint add = min(c - sum, cnt);\n\t\tsum += add;\n\t\t\n\t\twhile (add < cnt && !q.empty() && q.rbegin()->x > cost) {\n\t\t\tif (cnt - add >= q.rbegin()->y) {\n\t\t\t\tadd += q.rbegin()->y;\n\t\t\t\tq.erase(--q.end());\n\t\t\t} else {\n\t\t\t\tq.rbegin()->y -= cnt - add;\n\t\t\t\tadd = cnt;\n\t\t\t}\n\t\t}\n\t\t\n\t\tq[cost] += add;\n\t}\n\t\n\treturn ans;\n}\n\nint main() {\n\tint q;\n\tscanf(\"%d\", &q);\n\tforn(i, q) printf(\"%lld\\n\", solve());\n}", "interactive": false, "noSolution": false, "noTutorial": false}