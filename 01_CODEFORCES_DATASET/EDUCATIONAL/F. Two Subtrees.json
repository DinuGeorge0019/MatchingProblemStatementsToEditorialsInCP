{"link": "https://codeforces.com//contest/1767/problem/F", "problemId": "1697005", "shortId": "1767F", "contest_number": "1767", "name": "F. Two Subtrees", "statement": "You are given a rooted tree consisting of  vertices. The vertex  is the root. Each vertex has an integer written on it; this integer is  for the vertex .You are given  queries to the tree. The -th query is represented by two vertices,  and . To answer the query, consider all vertices  that lie in the subtree of  or  . For all vertices in these two subtrees, list all integers written on them, and find the integer with the maximum number of occurrences. If there are multiple integers with maximum number of occurrences, the  among them is the answer.", "input": "The first line contains one integer  () \u2014 the number of vertices in the tree. The second line contains  integers  () \u2014 the numbers written on the vertices. Then  lines follow, each containing two integers  and  () representing an edge between vertices  and . These edges form a tree. The next line contains one integer  () \u2014 the number of queries to process. Then  lines follow. The -th of them containing two numbers  and  () \u2014 the roots of subtrees in the -th query.", "output": "For each query, print one integer \u2014 the number that has the maximum amount of occurrences in the corresponding pair of subtrees (if there are multiple such numbers, print the  one among them).", "tutorial": "First, let's solve the following problem: we need to maintain a multiset of numbers and process queries of $$$3$$$-th types: add a number to the multiset, remove one occurrence of a number from the multiset (it is guaranteed that it exists), calculate the mode on this multiset. To do this, we will maintain the array $$$cnt_i$$$ \u2014 the frequency of $$$i$$$ in the multiset. Now the mode is the position of the leftmost maximum in this array. There are many ways to search for this position, we will use the following: we will build a sqrt-decomposition on the array $$$cnt$$$: for a block we will maintain a maximum on this block and an array $$$c_i$$$ \u2014 the number of positions $$$j$$$ in this block, such that $$$cnt_j = i$$$. Since in each of the initial requests $$$cnt_i$$$ changes by no more than $$$1$$$, the maximum in the block also changes by no more than 1 and, using the $$$c$$$ array, it is easy to update it after each query. Now, to find the mode (the position of the leftmost maximum in the $$$cnt$$$ array), you first need to go through all the blocks to find the value of the maximum and the leftmost block in which this maximum occurs, then iterate over the desired position in this block. Thus, queries to add and remove an element run in $$$O(1)$$$, and a mode search query runs in $$$O(\\sqrt{A})$$$, where $$$A$$$ is the number of possible distinct values, in a given problem $$$A = 2 \\cdot 10 ^ 5$$$.Now let's get back to the problem itself. Let's build a Preorder traversal of our tree. Let $$$tin_v$$$ be the position in the $$$0$$$-indexing of the vertex $$$v$$$ in the Preorder traversal, $$$tout_v$$$ be the size of the Preorder traversal after leaving the vertex $$$v$$$. Then the half-interval $$$[tin_v, tout_v)$$$ of the Preorder traversal represents the set of vertices of the subtree of the vertex $$$v$$$. For the $$$i$$$-th query, we will consider $$$tin_{v_i} \\le tin_{u_i}$$$.Let $$$sz_v = tout_v - tin_v$$$ be the size of the subtree of $$$v$$$, $$$B$$$ be some integer, then $$$v$$$ will be called light if $$$sz_v < B$$$, and heavy otherwise. A query $$$i$$$ is called light (heavy) if $$$v_i$$$ is a light (heavy) vertex. We will solve the problem for light and heavy queries independently. Let's use the small-to-large technique and maintain the multiset described at the beginning of the solution. Let at the moment we have this multiset for the vertex $$$w$$$. Let's answer all light queries for which $$$u_i = w$$$. To do this, take all the vertices from the subtree of $$$v_i$$$ and add the numbers written on them, calculate the mode on the current multiset \u2014 this will be the answer to the query, and then delete the newly added vertices. In the standard implementation of small-to-large, you need to maintain several structures at the same time, which in this case is impossible due to the fact that each of them takes up $$$O(A\\sqrt{A})$$$ of memory. This problem can be avoided, for example, as follows: before constructing the Preorder traversal for each vertex $$$v$$$, put its heaviest son at the head of the adjacency list. Then it will be possible to iterate over the vertices in the order of the Preorder traversal, preserving the asymptotics. This part of the solution runs in $$$O(n\\log{n} + qB + q\\sqrt{A})$$$. Let's divide all heavy vertices into non-intersecting vertical paths, so that two vertices from the same path have subtrees that differ by no more than $$$B$$$ vertices, and the number of the paths themselves is $$$O(\\frac{n}{B})$$$. To do this, let's take the deepest of the unused heavy vertices and build one of the desired paths, going up to the parent, while the first of these conditions is met. Then we mark all the vertices in this path as used, and start over. We will continue to do this while there are still unused heavy vertices. It is easy to see that the resulting paths are vertical and the subtrees of two vertices from the same path differ by no more than $$$B$$$ by construction. Let's prove that there are not very many of these paths. To do this, we will understand in which cases the path breaks:   If the current path contains a root, then since the root has no parent, the path will terminate. Obviously, this path is only $$$1$$$.  If the parent of the last vertex of the path has only one heavy child (this last vertex itself). From the construction, a break means that the number of vertices in this path plus the number of children outside the heaviest son subtree of the parent of the last vertex and each vertex of the path, except for the initial one, is more than $$$B$$$ in total, but each of the counted vertices can be counted in only one of such cases, that is, the number of paths that terminate in this way does not exceed $$$\\frac{n}{B}$$$.  If the parent of the last node has more than one heavy child. Let's leave only heavy vertices in the tree (since the parent of a heavy vertex is a heavy vertex too, it will indeed be a tree (or an empty graph)). This tree contains at most $$$\\frac{n}{B}$$$ leafs. Calculating the total degree of the vertices of this tree, we can see that there are at most $$$\\frac{n}{B}$$$ additional sons (all sons of a vertex except one). This means that the number of paths terminating in this way is at most $$$\\frac{n}{B}$$$.  We got that the paths are $$$O(\\frac{n}{B})$$$.Let's divide the heavy queries according to the paths where the $$$v_i$$$ is situated. We will answer queries with vertices $$$v$$$ from the same path together. We will do it similarly to the case with light queries, with minor differences: at the very beginning, we add to the multiset all the vertices of the subtree of the initial vertex of the path and mentally remove these vertices from the subtrees of $$$v_i$$$ vertices. Everything else is preserved. Let's calculate how long it takes: add all vertices from one subtree: $$$O(n)$$$, small-to-large: $$$O(n\\log{n})$$$, to answer one query due to condition on vertices from one path we have to add at most $$$B$$$ vertices. Since there are only $$$O(\\frac{n}{B})$$$ paths, the whole solution will take $$$O(\\frac{n^2\\log{n}}{B} + qB + q\\sqrt{A })$$$. We take $$$B = \\sqrt{\\frac{n^2\\log{n}}{q}}$$$ and, counting $$$n \\approx q$$$, we get $$$B = \\sqrt{n\\log{n}}$$$ and total running time $$$O(n\\sqrt{n\\log{n}} + n\\sqrt{A})$$$. As already mentioned, a subtree corresponds to a segment of the Preorder traversal, so $$$2$$$ subtrees are $$$2$$$ segments. We will maintain the data structure described at the beginning on the sum of $$$2$$$ segments. By moving the boundaries of these segments, you can move from one query to another, as in Mo's algorithm. It remains only to sort the queries. Heavy queries are sorted first by path number of $$$v_i$$$, then by $$$tin_{u_i}$$$. Light queries are sorted only by $$$tin_{u_i}$$$, but here you can't just move the segment of the $$$v$$$ subtree, you need to rebuild it for each query. Solve this problem for two subtrees and a path connecting the roots of these subtrees.This solution partially intersects with the one described by the problem author. We will use the same data structure for maintaining the mode; and we will also use DFS order of the tree (but before constructing it, we will reorder the children of each vertex so that the heaviest child is the first one).Let $$$tin_v$$$ be the moment we enter the vertex $$$v$$$ in DFS, and $$$tout_v$$$ be the moment we leave the vertex. As usual, the segment $$$[tin_v, tout_v]$$$ represents the subtree of vertex $$$v$$$, and we can change the state of the structure from the subtree of the vertex $$$x$$$ to the subtree of the vertex $$$y$$$ in $$$|tin_x - tin_y| + |tout_x + tout_y|$$$ operations. Let this number of operations be $$$cost(x,y)$$$.Let $$$v_1, v_2, \\dots, v_n$$$ be the DFS order of the tree. We can prove that $$$cost(v_1, v_2) + cost(v_2, v_3) + \\dots + cost(v_{n-1}, v_n)$$$ is estimated as $$$O(n \\log n)$$$ if we order the children of each vertex in such a way that the first of them is the heaviest one.. Let's analyze how many times some vertex $$$v$$$ is added when we go in DFS order and maintain the current set of vertices. When some vertex is added to the current subtree, this means that the previous vertex in DFS order was not an ancestor of the current vertex, so the current vertex is not the first son of its parent. So, the size of the subtree of the parent is at least 2x the size of the current vertex. Since the path from $$$v$$$ to root can have at most $$$O(\\log n)$$$ such vertices, then the vertex $$$v$$$ is added at most $$$O(\\log n)$$$ times.Okay, how do we use it to process queries efficiently? Let's say that the vertex $$$v_i$$$ (the $$$i$$$-th vertex in DFS order) has coordinate equal to $$$cost(v_1, v_2) + cost(v_2, v_3) + \\dots + cost(v_{i-1}, v_i)$$$. Let this coordinate be $$$c_{v_i}$$$. Then, if we have the data structure for the query $$$(x_1, y_1)$$$ and we want to change it so it meets the query $$$(x_2, y_2)$$$, we can do it in at most $$$|c_{x_1} - c_{x_2}| + |c_{y_1} - c_{y_2}|$$$ operations, which can be treated as the Manhattan distance between points $$$(c_{x_1}, c_{y_1})$$$ and $$$(c_{x_2}, c_{y_2})$$$.Do you see where this is going? We can map each query $$$(x, y)$$$ to the point $$$(c_x, c_y)$$$, and then order them in such a way that the total distance we need to travel between them is not too large. We can use Mo's algorithm to do this. Since the coordinates are up to $$$O(n \\log n)$$$, but there are only $$$q$$$ points, some alternative sorting orders for Mo (like the one that uses Hilbert's curve) may work better than the usual one.", "solution": "#include <bits/stdc++.h>\n\n#define f first\n#define s second\n\nusing namespace std;\nusing li = long long;\nusing ld = long double;\nusing pii = pair<int, int>;\n\nconst int INF = 2e9 + 13;\nconst li INF64 = 2e18 + 13;\nconst int M = 998244353;\nconst int A = 2e5 + 13;\n\nconst int N = 2e5 + 13;\nconst int B = 2000;\nconst int SQRTA = 500;\nconst int K = N / B + 113;\n\nint val[N];\nvector<int> g[N];\nint sz[N];\nint gr[N];\nint leaf[N], group_root[N];\nint par[N];\nbool heavy[N];\n\nint tin[N], tout[N], T = 0, mid[N];\nint et[N];\nint valet[N];\n\n\nvoid dfs1(int v, int pr, int depth) {\n    par[v] = pr;\n    sz[v] = 1;\n\n    int mx = -1;\n    for(int i = 0; i < g[v].size(); i++) {\n        int u = g[v][i];\n        if(u != pr) {\n            dfs1(u, v, depth + 1);\n            sz[v] += sz[u];\n            if(mx == -1 || sz[g[v][mx]] < sz[u])\n                mx = i;\n        }\n    }\n\n    if(mx != -1)\n        swap(g[v][mx], g[v][0]);\n}\n\nvoid dfs2(int v) {\n    et[T] = v;\n    tin[v] = T++;\n\n    for(int u : g[v]) {\n        if(u != par[v])\n            dfs2(u);\n    }\n\n    tout[v] = T;\n}\n\nstruct Query {\n    int ind;\n    int v, u;\n    int lv, rv, lu, ru;\n    int b;\n\n    Query() {};\n};\n\nbool cmp(const Query& a, const Query& b) {\n    if(a.b != b.b)\n        return a.b < b.b;\n    else\n        return a.lu < b.lu;\n}\n\nint cnt[A];\nint block_index[A];\nint block_mx[A];\nint block_cnt_of_cnt[A / SQRTA + 13][A];\n\ninline void insert(int i) {\n    block_cnt_of_cnt[block_index[valet[i]]][cnt[valet[i]]]--;\n    cnt[valet[i]]++;\n    block_cnt_of_cnt[block_index[valet[i]]][cnt[valet[i]]]++;\n    if(cnt[valet[i]] > block_mx[block_index[valet[i]]])\n        block_mx[block_index[valet[i]]]++;\n}\n\ninline void erase(int i) {\n    if(cnt[valet[i]] == block_mx[block_index[valet[i]]] && block_cnt_of_cnt[block_index[valet[i]]][cnt[valet[i]]] == 1)\n        block_mx[block_index[valet[i]]]--;\n    block_cnt_of_cnt[block_index[valet[i]]][cnt[valet[i]]]--;\n    cnt[valet[i]]--;\n    block_cnt_of_cnt[block_index[valet[i]]][cnt[valet[i]]]++;\n}\n\nint get_mode() {\n    int mx = 0;\n    for(int i = 0; i < A / SQRTA + 1; i++)\n        mx = max(mx, block_mx[i]);\n    for(int i = 0; ; i++) {\n        if(block_mx[i] == mx) {\n            for(int j = i * SQRTA; ; j++) {\n                if(cnt[j] == mx)\n                    return j;\n            }\n        }\n    }\n}\n\nQuery queries[N];\nint ans[N];\n\nvoid solve() {\n    int n;\n    cin >> n;\n\n    for(int i = 0; i < n; i++)\n        cin >> val[i];\n\n    for(int i = 1; i < n; i++) {\n        int v, u;\n        cin >> v >> u;\n\n        v--;\n        u--;\n\n        g[v].push_back(u);\n        g[u].push_back(v);\n    }\n\n    dfs1(0, -1, 0);\n\n    vector<pii> ord(n);\n    for(int i = 0; i < n; i++) {\n        ord[i] = {sz[i], i};\n        gr[i] = -1;\n    }\n\n    sort(ord.begin(), ord.end());\n\n    for(int i = 0; i < n; i++) {\n        if(sz[i] >= B)\n            heavy[i] = true;\n    }\n\n    int cur = 0;\n    for(int i = 0; i < n; i++) {\n        int v = ord[i].s;\n        if(sz[v] < B || gr[v] != -1)\n            continue;\n\n        leaf[cur] = v;\n\n        int u = v;\n        while(gr[u] == -1 && sz[u] - sz[v] < B) {\n            gr[u] = cur;\n            group_root[cur] = u;\n            u = par[u];\n        }\n\n        cur++;\n    }\n\n    dfs2(0);\n\n    for(int i = 0; i < n; i++) {\n        if(sz[i] < B) {\n            gr[i] = cur + tin[i] / B;\n        }\n    }\n\n    for(int i = 0; i < n; i++)\n        valet[i] = val[et[i]];\n\n    for(int i = 0; i < A; i++) {\n        block_index[i] = i / SQRTA;\n    }\n\n    int q;\n    cin >> q;\n\n    for(int i = 0; i < q; i++) {\n        queries[i].ind = i;\n        cin >> queries[i].v >> queries[i].u;\n\n        queries[i].v--;\n        queries[i].u--;\n\n        queries[i].lv = tin[queries[i].v];\n        queries[i].rv = tout[queries[i].v];\n        queries[i].lu = tin[queries[i].u];\n        queries[i].ru = tout[queries[i].u];\n\n        if(queries[i].lv > queries[i].lu) {\n            swap(queries[i].v, queries[i].u);\n            swap(queries[i].lv, queries[i].lu);\n            swap(queries[i].rv, queries[i].ru);\n        }\n\n        queries[i].b = gr[queries[i].v];\n    }\n\n    sort(queries, queries + q, cmp);\n\n    int lv = 0, rv = 0, lu = 0, ru = 0;\n    li fir = 0, sec = 0;\n\n    int hs = 0;\n    for(int i = 0; i < q; i++) {\n        int qlv = queries[i].lv;\n        int qrv = queries[i].rv;\n        int qlu = queries[i].lu;\n        int qru = queries[i].ru;\n\n        fir += abs(lv - qlv) + abs(rv - qrv);\n        sec += abs(lu - qlu) + abs(ru - qru);\n\n        if(queries[i].b < cur) {\n            while(rv < qrv)\n                insert(rv++);\n            while(lv > qlv)\n                insert(--lv);\n            while(rv > qrv)\n                erase(--rv);\n            while(lv < qlv)\n                erase(lv++);\n        } else {\n            while(rv > lv)\n                erase(--rv);\n            lv = qlv;\n            rv = lv;\n            while(rv < qrv)\n                insert(rv++);\n        }\n\n        while(ru < qru)\n                insert(ru++);\n            while(lu > qlu)\n                insert(--lu);\n            while(ru > qru)\n                erase(--ru);\n            while(lu < qlu)\n                erase(lu++);\n\n        ans[queries[i].ind] = get_mode();\n    }\n\n    for(int i = 0; i < q; i++)\n        cout << ans[i] << endl;\n}\n\nmt19937 rnd(1);\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n//    freopen(\"input.txt\", \"r\", stdin);\n\n    solve();\n}", "interactive": false, "noSolution": false, "noTutorial": false}