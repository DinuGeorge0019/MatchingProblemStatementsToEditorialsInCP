{"link": "https://codeforces.com//contest/1809/problem/D", "problemId": "1839364", "shortId": "1809D", "contest_number": "1809", "name": "D. Binary String Sorting", "statement": "You are given a binary string  consisting of only characters  and/or .You can perform several operations on this string (possibly zero). There are two types of operations:   choose two consecutive elements and swap them. In order to perform this operation, you pay  coins;  choose any element from the string and remove it. In order to perform this operation, you pay  coins. Your task is to calculate the minimum number of coins required to sort the string  in non-decreasing order (i.\u2009e. transform  so that , where  is the length of the string after applying all operations). An empty string is also considered sorted in non-decreasing order.", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of test cases. The only line of each test case contains the string  (), consisting of only characters  and/or . The sum of lengths of all given strings doesn't exceed .", "output": "For each test case, print a single integer\u00a0\u2014 the minimum number of coins required to sort the string  in non-decreasing order.", "tutorial": "Note that the price of operations is much greater than the difference between them. Therefore, first of all, we have to minimize the number of operations, and then maximize the number of operations of the first type.Swapping two elements if at least one of them will be deleted later is not optimal. Therefore, first let's delete some elements of the string, and then sort the remaining elements using swaps. The number of swaps for sorting is equal to the number of inversions (i.\u2009e. the number of pairs such that  and ). From here we can notice that if the number of inversions is greater than , then there is an element that produces at least  inversions. So it is more profitable for us to remove it, to minimize the number of operations.From the above we get that the number of operations of the first type is at most . If all operations are only of the second type, then we need to find a subsequence of the maximum length of the form . To do this, we can iterate over the number of zeros that we include in the final string, and then add the number of ones from the remaining suffix of the string (that goes after the fixed number of zeros). If there is an operation of the first type, then it is enough to iterate over the pair that creates the inversion, to the left of it take all zeros, and to the right of it take all ones (you can notice that in fact it is enough to iterate over only a pair of neighboring elements of the string).", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst long long pw10 = 1e12;\n\nint main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  int tc;\n  cin >> tc;\n  while (tc--) {\n    string s;\n    cin >> s;\n    int n = s.size();\n    int cnt0 = 0, cnt1 = count(s.begin(), s.end(), '1');\n    long long ans = 1e18;\n    if (n == 1) ans = 0;\n    for (int i = 0; i < n - 1; ++i) {\n      cnt0 += s[i] == '0';\n      cnt1 -= s[i] == '1';\n      int k = cnt0 + cnt1 + (s[i] == '1') + (s[i + 1] == '0');\n      long long cur = (n - k) * (pw10 + 1);\n      if (s[i] > s[i + 1]) cur += pw10;\n      ans = min(ans, cur); \n    }\n    cout << ans << '\\n';\n  }\n}", "interactive": false, "noSolution": false, "noTutorial": false}