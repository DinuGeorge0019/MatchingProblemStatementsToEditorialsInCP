{"link": "https://codeforces.com//contest/1073/problem/D", "problemId": "243299", "shortId": "1073D", "contest_number": "1073", "name": "D. Berland Fair", "statement": "XXI Berland Annual Fair is coming really soon! Traditionally fair consists of  booths, arranged in a circle. The booths are numbered  through  clockwise with  being adjacent to . The -th booths sells some candies for the price of  burles per item. Each booth has an unlimited supply of candies.Polycarp has decided to spend at most  burles at the fair. However, he has some plan in mind for his path across the booths:  at first, he visits booth number ;  if he has enough burles to buy  candy from the current booth, then he buys it immediately;  then he proceeds to the next booth in the clockwise order (regardless of if he bought a candy or not). Polycarp's money is finite, thus the process will end once he can no longer buy candy at any booth.Calculate the number of candies Polycarp will buy.", "input": "The first line contains two integers  and  (, ) \u2014 the number of booths at the fair and the initial amount of burles Polycarp has. The second line contains  integers  () \u2014 the price of the single candy at booth number .", "output": "Print a single integer \u2014 the total number of candies Polycarp will buy.", "tutorial": "Let's code the following process. Go one circle across the booths, calculate the total cost  of sweets bought and the number  of sweets bought. Now you can decrease you money down to  and add  to answer. It represents that you went maximum number of such circles. The later circles will have smaller cost. Let's continue this process until  becomes smaller than the minimum priced sweet.The number of operations made is . Let  be the amount of money before some operation,  be the total cost of sweets bought on that operation and .  is actually smaller than  (that's how modulo works) and smaller than  (that's also how modulo works). And these inequalities imply that . That leads to about  steps to reach the minimal price.Overall complexity: .", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int N = 200 * 1000 + 13;\n\ntypedef long long li;\n\nint n;\nint a[N];\n\nvoid get(li T, li& pr, li& cnt){\n\tpr = 0, cnt = 0;\n\tforn(i, n){\n\t\tif (T >= a[i]){\n\t\t\tT -= a[i];\n\t\t\tpr += a[i];\n\t\t\t++cnt;\n\t\t}\n\t}\n}\n\nint main() {\n\tli T;\n\tscanf(\"%d%lld\", &n, &T);\n\tforn(i, n)\n\t\tscanf(\"%d\", &a[i]);\n\t\n\tint mn = *min_element(a, a + n);\n\tli ans = 0;\n\twhile (T >= mn){\n\t\tli pr, cnt;\n\t\tget(T, pr, cnt);\n\t\tans += cnt * (T / pr);\n\t\tT %= pr;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}