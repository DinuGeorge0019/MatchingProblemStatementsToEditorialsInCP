{"link": "https://codeforces.com//contest/1452/problem/B", "problemId": "802105", "shortId": "1452B", "contest_number": "1452", "name": "B. Toy Blocks", "statement": "You are asked to watch your nephew who likes to play with toy blocks in a strange way.He has  boxes and the -th box has  blocks. His game consists of two steps:   he chooses an arbitrary box ;  he tries to move  blocks from the -th box to other boxes.  If he can make the same number of blocks in each of  other boxes then he will be happy, otherwise, will be sad. Note that your nephew can only move the blocks from the chosen box to the other boxes; he cannot move blocks from the other boxes.You don't want to make your nephew sad, so you decided to put several extra blocks into some boxes in such a way that no matter which box  he chooses he won't be sad. What is the minimum number of extra blocks you need to put?", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of test cases. The first line of each test case contains the integer  ()\u00a0\u2014 the number of boxes. The second line of each test case contains  integers  ()\u00a0\u2014 the number of blocks in each box. It's guaranteed that the sum of  over test cases doesn't exceed .", "output": "For each test case, print a single integer\u00a0\u2014 the minimum number of blocks you need to put. It can be proved that the answer always exists, i.\u00a0e. the number of blocks is finite.", "tutorial": "Since nephew emptying the box  he's chosen and wants to make all other  box equal then it means that at least the  of all array  should be divisible by  and the number of blocks in each other box should be at least  (ceiling function).On the other side, since nephew chooses  (not you), then he can choose a box which is  a maximum , and since he makes empty the only box , then the final number in each other block should be at least .In total, the resulting number of blocks in each of  other boxes should be at least  and we need to add at least  elements to the initial array. We can always reach this lower bound if we will put each block in the box with the current minimum number of blocks.", "solution": "fun main() {\n    repeat(readLine()!!.toInt()) {\n        val n = readLine()!!.toInt()\n        val a = readLine()!!.split(' ').map { it.toLong() }\n\n        val k = maxOf(a.max()!!, (a.sum() + n - 2) / (n - 1))\n        println(k * (n - 1) - a.sum())\n    }\n}", "interactive": false, "noSolution": false, "noTutorial": false}