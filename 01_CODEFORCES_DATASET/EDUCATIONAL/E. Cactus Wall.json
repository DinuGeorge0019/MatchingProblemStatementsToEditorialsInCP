{"link": "https://codeforces.com//contest/1749/problem/E", "problemId": "1596426", "shortId": "1749E", "contest_number": "1749", "name": "E. Cactus Wall", "statement": "Monocarp is playing Minecraft and wants to build a wall of cacti. He wants to build it on a field of sand of the size of  cells. Initially, there are cacti in some cells of the field. . Monocarp can plant new cacti (they must also fulfil the aforementioned condition). He can't chop down any of the cacti that are already growing on the field \u2014 he doesn't have an axe, and the cacti are too prickly for his hands.Monocarp believes that the wall is complete if there is no path from the top row of the field to the bottom row, such that:   each two consecutive cells in the path are adjacent by side;  no cell belonging to the path contains a cactus. Your task is to plant the minimum number of cacti to build a wall (or to report that this is impossible).", "input": "The first line contains a single integer  ()\u00a0\u2014 number of test cases. The first line of each test case contains two integers  and  (; )\u00a0\u2014 the number of rows and columns, respectively. Then  rows follow, -th row contains a string  of length , where  is '', if a cactus grows at the intersection of the -th row and the -th column. Otherwise,  is ''. The sum of  over all test cases does not exceed .", "output": "For each test case, print  in the first line if it is impossible to build a cactus wall without breaking the rules. Otherwise, print  in the first line, then print  lines of  characters each\u00a0\u2014 the field itself, where the -th character of the -th line is equal to '', if there is a cactus on the intersection of the -th row and the -th column, otherwise it is ''. If there are multiple optimal answers, print any of them.", "tutorial": "In order to block any path from the top row to the bottom row, you have to build a path from the left side to the right side consisting of . Since two consecutive cacti in a path cannot be placed side by side, they should be placed diagonally (i.e  should be followed by  on the path). So we can rephrase the task as a shortest path problem. The edge weight is  if cactus is already in the cell that corresponds to the end of the edge, and  otherwise. Don't forget that some cells can't contain a cactus, thus be part of a path, because of the cacti initially placed. The shortest path can be found using Dijkstra's or 0-1 BFS algorithm.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1e9;\n\nint dx[] = {0, 1, 0, -1, 1, 1, -1, -1};\nint dy[] = {1, 0, -1, 0, -1, 1, -1, 1};\n\nint main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  int t;\n  cin >> t;\n  while (t--) {\n    int n, m;\n    cin >> n >> m;\n    vector<string> s(n);\n    for (auto &it : s) cin >> it;\n    \n    auto in = [&](int x, int y) {\n      return 0 <= x && x < n && 0 <= y && y < m;\n    };\n    \n    auto can = [&](int x, int y) {\n      if (!in(x, y)) return false;\n      for (int i = 0; i < 4; ++i) {\n        int nx = x + dx[i], ny = y + dy[i];\n        if (in(nx, ny) && s[nx][ny] == '#')\n          return false;\n      }\n      return true;\n    };\n    \n    vector<vector<int>> d(n, vector<int>(m, INF)), p(n, vector<int>(m));\n    deque<pair<int, int>> q;\n    for (int i = 0; i < n; ++i) {\n        if (s[i][0] == '#') {\n          d[i][0] = 0;\n          q.push_front({i, 0});\n        } else if (can(i, 0)) {\n          d[i][0] = 1;\n          q.push_back({i, 0});\n        }\n    }\n    \n    while (!q.empty()) {\n      auto [x, y] = q.front();\n      q.pop_front();\n      for (int i = 4; i < 8; ++i) {\n        int nx = x + dx[i], ny = y + dy[i];\n        if (!can(nx, ny)) continue;\n        int w = (s[nx][ny] != '#');\n        if (d[nx][ny] > d[x][y] + w) {\n          d[nx][ny] = d[x][y] + w;\n          p[nx][ny] = i;\n          if (w) q.push_back({nx, ny});\n          else q.push_front({nx, ny});\n        }\n      }\n    }\n    \n    int x = 0, y = m - 1;\n    for (int i = 0; i < n; ++i) if (d[x][y] > d[i][y])\n      x = i;\n    if (d[x][y] == INF) {\n      cout << \"NO\\n\";\n      continue;\n    }\n    while (true) {\n      s[x][y] = '#';\n      int i = p[x][y];\n      if (!i) break;\n      x -= dx[i];\n      y -= dy[i];\n    }\n    cout << \"YES\\n\";\n    for (auto it : s) cout << it << '\\n';\n  }\n}", "interactive": false, "noSolution": false, "noTutorial": false}