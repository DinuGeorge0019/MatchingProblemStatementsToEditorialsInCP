{"link": "https://codeforces.com//contest/1728/problem/C", "problemId": "1534224", "shortId": "1728C", "contest_number": "1728", "name": "C. Digital Logarithm", "statement": "Let's define  for a positive integer  as the length of the base-10 representation of  without leading zeros. I like to call it a digital logarithm. Similar to a digital root, if you are familiar with that.You are given two arrays  and , each containing  positive integers. In one operation, you do the following:   pick some integer  from  to ;  assign either  to  or  to . Two arrays are considered similar to each other if you can rearrange the elements in both of them, so that they are equal (e.\u2009g.  for all  from  to ).What's the smallest number of operations required to make  and  similar to each other?", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of testcases. The first line of the testcase contains a single integer  ()\u00a0\u2014 the number of elements in each of the arrays. The second line contains  integers  (). The third line contains  integers  (). The sum of  over all testcases doesn't exceed .", "output": "For each testcase, print the smallest number of operations required to make  and  similar to each other.", "tutorial": "First, why can you always make the arrays similar? Applying a digital logarithm to any number will eventually make it equal to . Thus, you can at least make all numbers into s in both arrays.Then notice the most improtant thing\u00a0\u2014 applying the digital logarithm to a number greater than  always makes this number smaller.Thus, if a number appears in only one of the arrays, you will have to do one of the followings two things:   decrease some greater number to make it equal to this one;  decrease this number. What if there is no greater number at all? This is the case for the largest number in both arrays altogether. If it appears in only one of the arrays, you must always decrease. If it appears in both, though, why decrease it further? Worst case, you will decrease it in one array, then you'll have to decrease it in the other array as well. This is never more optimal than just matching one occurrence in both arrays to each other and removing them from the arrays.So, the proposed solution is the following. Consider the largest element in each array. If they are equal, remove both. If not, apply digital logarithm to the larger of them. Continue until the arrays are empty.What's the estimated complexity of this algorithm? Each number in the first array will be considered at most the number of times you can decrease it with a digital logarithm operation plus one. That is at most \u00a0\u2014 a number greater than  always becomes a single digit and a single digit always becomes . Same goes for the second array. So the complexity is basically linear.To implement it efficiently, you will have to use some data structure that provides three operations:   peek at the maximum;  remove the maximum;  insert a new element. The perfect one is a heap\u00a0\u2014 priority_queue in C++.Overall complexity:  per testcase.", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nint main() {\n\tint t;\n\tscanf(\"%d\", &t);\n\tforn(_, t){\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\t\tvector<int> a(n), b(n);\n\t\tforn(i, n) scanf(\"%d\", &a[i]);\n\t\tforn(i, n) scanf(\"%d\", &b[i]);\n\t\tpriority_queue<int> qa(a.begin(), a.end());\n\t\tpriority_queue<int> qb(b.begin(), b.end());\n\t\tint ans = 0;\n\t\twhile (!qa.empty()){\n\t\t\tif (qa.top() == qb.top()){\n\t\t\t\tqa.pop();\n\t\t\t\tqb.pop();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t++ans;\n\t\t\tif (qa.top() > qb.top()){\n\t\t\t\tqa.push(to_string(qa.top()).size());\n\t\t\t\tqa.pop();\n\t\t\t}\n\t\t\telse{\n\t\t\t\tqb.push(to_string(qb.top()).size());\n\t\t\t\tqb.pop();\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}