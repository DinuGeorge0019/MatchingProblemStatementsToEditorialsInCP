{"link": "https://codeforces.com//contest/1107/problem/G", "problemId": "288740", "shortId": "1107G", "contest_number": "1107", "name": "G. Vasya and Maximum Profit", "statement": "Vasya got really tired of these credits (from problem F) and now wants to earn the money himself! He decided to make a contest to gain a profit.Vasya has  problems to choose from. They are numbered from  to . The difficulty of the -th problem is . Moreover, the problems are given in the increasing order by their difficulties. . In order to add the -th problem to the contest you need to pay  burles to its author. For each problem in the contest Vasya gets  burles..So the total earnings for the contest are calculated as follows:   if Vasya takes problem  to the contest, he needs to pay  to its author;  for each problem in the contest Vasya gets  burles;  let . If Vasya takes all the tasks with indices from  to  to the contest, he also needs to pay . If  then . Calculate the maximum profit that Vasya can earn by taking a consecutive segment of tasks.", "input": "The first line contains two integers  and  (, ) \u2014 the number of proposed tasks and the profit for a single problem, respectively. Each of the next  lines contains two integers  and  ().", "output": "Print one integer \u2014 maximum amount of burles Vasya can earn.", "tutorial": "We can first compute all values of . Since we only care about the maximum such value within our segment, we can use div-conquer to solve every segment. In particular, if we know the index of the maximum value in , we know that any segment crossing this index has this value as its maximum. We can thus solve all segments crossing this maximum and recurse on the left and right sides.\nTo find the best crossing segment, note that each problem contributes a value of . We can independently find the largest sum starting from our crossing index going left and the largest sum going right, and add these two together for the best overall crossing segment.\nUnfortunately, since we can't guarantee that the maximum indices will divide our interval nicely in half, this does not lead to the usual  runtime of div-conquer but is instead  in the worst case. To improve on this, we can precompute partial sums of  and use RMQ to find the minimum sum left of the crossing index and the maximum sum right of the crossing index. This reduces the crossing computation from  per index to  or , giving an overall runtime of . Code: 49036431\n", "solution": "#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\n\ntemplate<typename T>\nstruct RMQ {\n    int n = 0, levels = 0;\n    vector<T> values;\n    vector<vector<int>> range_high;\n\n    RMQ(const vector<T> &_values = {}) {\n        if (!_values.empty())\n            build(_values);\n    }\n\n    static int largest_bit(int x) {\n        return 31 - __builtin_clz(x);\n    }\n\n    int max_index(int a, int b) const {\n        return values[a] > values[b] ? a : b;\n    }\n\n    void build(const vector<T> &_values) {\n        values = _values;\n        n = values.size();\n        levels = largest_bit(n) + 1;\n        range_high.resize(levels);\n\n        for (int k = 0; k < levels; k++)\n            range_high[k].resize(n - (1 << k) + 1);\n\n        for (int i = 0; i < n; i++)\n            range_high[0][i] = i;\n\n        for (int k = 1; k < levels; k++)\n            for (int i = 0; i <= n - (1 << k); i++)\n                range_high[k][i] = max_index(range_high[k - 1][i], range_high[k - 1][i + (1 << (k - 1))]);\n    }\n\n    int rmq_index(int a, int b) const {\n        assert(a < b);\n        int level = largest_bit(b - a);\n        return max_index(range_high[level][a], range_high[level][b - (1 << level)]);\n    }\n\n    T rmq_value(int a, int b) const {\n        return values[rmq_index(a, b)];\n    }\n};\n\n\nint N;\nlong long A;\nvector<long long> D, C, diff, ac_sum;\nRMQ<long long> diff_rmq, ac_max_rmq, ac_min_rmq;\n\nlong long solve(int start, int end) {\n    if (end - start <= 0)\n        return 0;\n\n    if (end - start == 1)\n        return max(A - C[start], 0LL);\n\n    int mid = diff_rmq.rmq_index(start, end - 1);\n    long long answer = max(solve(start, mid + 1), solve(mid + 1, end));\n    long long ac = ac_max_rmq.rmq_value(mid + 1, end + 1) + ac_min_rmq.rmq_value(start, mid + 1);\n    answer = max(answer, ac - diff[mid]);\n    return answer;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    cin >> N >> A;\n    D.resize(N);\n    C.resize(N);\n\n    for (int i = 0; i < N; i++)\n        cin >> D[i] >> C[i];\n\n    diff.resize(N - 1);\n\n    for (int i = 0; i < N - 1; i++)\n        diff[i] = (D[i + 1] - D[i]) * (D[i + 1] - D[i]);\n\n    ac_sum.assign(N + 1, 0);\n\n    for (int i = 0; i < N; i++)\n        ac_sum[i + 1] = ac_sum[i] + A - C[i];\n\n    diff_rmq.build(diff);\n    ac_max_rmq.build(ac_sum);\n\n    for (int i = 0; i <= N; i++)\n        ac_sum[i] = -ac_sum[i];\n\n    ac_min_rmq.build(ac_sum);\n    cout << solve(0, N) << '\\n';\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}