{"link": "https://codeforces.com//contest/1476/problem/F", "problemId": "881707", "shortId": "1476F", "contest_number": "1476", "name": "F. Lanterns", "statement": "There are  lanterns in a row. The lantern  is placed in position  and has power equal to .Each lantern can be directed to illuminate either some lanterns to the left or some lanterns to the right. If the -th lantern is turned to the left, it illuminates all such lanterns  that . Similarly, if it is turned to the right, it illuminates all such lanterns  that .Your goal is to choose a direction for each lantern so each lantern is illuminated by at least one other lantern, or report that it is impossible.", "input": "The first line contains one integer  () \u2014 the number of test cases. Each test case consists of two lines. The first line contains one integer  () \u2014 the number of lanterns. The second line contains  integers  () \u2014 the power of the -th lantern. The sum of  over all test cases does not exceed .", "output": "For each test case, print the answer as follows: If it is possible to direct all lanterns so that each lantern is illuminated, print  in the first line and a string of  characters  and/or  (the -th character is  if the -th lantern is turned to the left, otherwise this character is ) in the second line. If there are multiple answers, you may print any of them. If there is no answer, simply print  for that test case.", "tutorial": "The main idea of the solution is to calculate the following dynamic programming:  is the maximum prefix we can fully cover with  first lanterns.Let's look at how can we solve it in  with this kind of dynamic programming. First of all, let's write it forward. Which transitions from  do we have?  iterate on the lantern facing left that will cover the lantern . Let this lantern be . It should cover all lanterns in , so all lanterns from  can be turned to the right (and we need a max query to determine the new covered prefix);  if  (lantern  is already covered), we can just extend the prefix by turning the -th lantern to the right. Note that turning it to the right when it is not covered yet will be modeled by the first transition. It is obviously , how can we optimize it? Let's write this dynamic programming backward. The second transition is changed to backward dp easily, what about the first one? Suppose we want to turn some lantern  to the left. Let's iterate on the prefix  that we will \"connect\" to it; for this prefix,  should be at least , and we update  with the maximum of  (since it is covered by lantern ) and the result of max query on .In fact, we need only one such prefix \u2014 the one with the minimum  among those which have . So, we build a minimum segment tree where each pair  is interpreted as the value of  in position , and with min query on the suffix from  we find this optimal prefix, from which we should update (and to update, we can use any DS that allows max queries on segment \u2014 in my solution, it's another segment tree).", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = int(1e9);\n\nstruct segTree\n{\n    int n;\n    bool mx;\n    vector<int> t;\n\n    void fix(int v)\n    {\n        t[v] = (mx ? max(t[v * 2 + 1], t[v * 2 + 2]) : min(t[v * 2 + 1], t[v * 2 + 2]));\n    }\n\n    void build(int v, int l, int r)\n    {\n        if(l == r - 1)\n            t[v] = (mx ? -INF : INF);\n        else\n        {\n            int m = (l + r) / 2;\n            build(v * 2 + 1, l, m);\n            build(v * 2 + 2, m, r);\n            fix(v);\n        }\n    }\n\n    void upd(int v, int l, int r, int pos, int val)\n    {\n        if(l == r - 1)\n            t[v] = (mx ? max(t[v], val) : min(t[v], val));\n        else\n        {\n            int m = (l + r) / 2;\n            if(pos < m)\n                upd(v * 2 + 1, l, m, pos, val);\n            else\n                upd(v * 2 + 2, m, r, pos, val);\n            fix(v);\n        }\n    }\n\n    int get(int v, int l, int r, int L, int R)\n    {\n        if(L >= R)\n            return (mx ? -INF : INF);\n        if(l == L && r == R)\n            return t[v];\n        int m = (l + r) / 2;\n        int lf = get(v * 2 + 1, l, m, L, min(R, m));\n        int rg = get(v * 2 + 2, m, r, max(m, L), R);\n        return (mx ? max(lf, rg) : min(lf, rg));\n    }\n\n    void upd(int pos, int val)\n    {\n        upd(0, 0, n, pos, val);\n    }\n\n    int get(int L, int R)\n    {\n        return get(0, 0, n, L, R);\n    }\n\n    void build()\n    {\n        return build(0, 0, n);\n    }\n\n    segTree() {};\n    segTree(int n, bool mx) : n(n), mx(mx)\n    {\n        t.resize(4 * n);\n    }\n};\n\nint main()\n{\n    int t;\n    scanf(\"%d\", &t);\n    for(int _ = 0; _ < t; _++)\n    {\n        int n;\n        scanf(\"%d\", &n);\n        vector<int> p(n);\n        for(int i = 0; i < n; i++)\n            scanf(\"%d\", &p[i]);\n        vector<int> dp(n + 1, -INF);\n        vector<int> par(n + 1, -2);\n        dp[0] = 0;\n        par[0] = -1;\n        vector<int> lf(n), rg(n);\n        for(int i = 0; i < n; i++)\n        {\n            lf[i] = max(1, i - p[i] + 1);\n            rg[i] = min(n, i + p[i] + 1);\n        }\n        segTree sn(n + 1, false);        \n        segTree sx(n, true);\n        sn.build();\n        sx.build();\n        for(int i = 0; i < n; i++)\n            sx.upd(i, rg[i]);\n        sn.upd(0, 0);\n        for(int i = 1; i <= n; i++)\n        {\n            int j = i - 1;\n            int k = lf[j] - 1;\n            \n            int m = sn.get(k, n + 1);                 \n            if(m != INF)\n            {\n                int nval = max(sx.get(m, i - 1), i - 1);\n                if(nval > dp[i])\n                {\n                    dp[i] = nval;\n                    par[i] = m;\n                }\n            }\n            if(dp[j] >= i && max(dp[j], rg[j]) > dp[i])\n            {\n                dp[i] = max(dp[j], rg[j]);\n                par[i] = -1;\n            }\n            if(dp[j] > dp[i])\n            {\n                dp[i] = dp[j];\n                par[i] = -1;\n            }\n            sn.upd(dp[i], i);                \n        }\n        if(dp[n] != n)\n            puts(\"NO\");\n        else\n        {\n            puts(\"YES\");\n            string ans;\n            int cur = n;\n            while(cur != 0)\n            {\n                if(par[cur] == -1)\n                {\n                    cur--;\n                    ans += \"R\";\n                }\n                else\n                {\n                    int pcur = par[cur];\n                    int diff = cur - pcur;\n                    ans += \"L\";\n                    for(int j = 0; j < diff - 1; j++)\n                        ans += \"R\";\n                    cur = pcur;    \n                }\n            }\n            reverse(ans.begin(), ans.end());\n            puts(ans.c_str());\n        }\n    }\n}", "interactive": false, "noSolution": false, "noTutorial": false}