{"link": "https://codeforces.com//contest/1027/problem/G", "problemId": "209494", "shortId": "1027G", "contest_number": "1027", "name": "G. X-mouse in the Campus", "statement": "The campus has  rooms numbered from  to . Also the -mouse lives in the campus. The -mouse is not just a mouse: each second -mouse moves from room  to the room  (in fact, it teleports from one room to another since it doesn't visit any intermediate room). Starting position of the -mouse is unknown.You are responsible to catch the -mouse in the campus, so you are guessing about minimum possible number of traps (one trap in one room) you need to place. You are sure that if the -mouse enters a trapped room, it immediately gets caught.And the only observation you made is .", "input": "The only line contains two integers  and  (, , ) \u2014 the number of rooms and the parameter of -mouse. ", "output": "Print the only integer \u2014 minimum number of traps you need to install to catch the -mouse.", "tutorial": "Some notes:At first, there is  since  (lets define  as ). That means that for each  there is exactly one  that . So if we look at this problem as the graph then it consists of cycles (consider loops as cycles of length one). So we need to know number of cycles in this graph.At second,  since ,  and  and . So all  can be divided in groups by its . And we can calculate number of cylces in each group independently.Let fix some  equal to . All numbers  such that  can be represented as  and . Number of such  equals to . Moreover . Here we can shift from ,  and  to ,  and .In result we need for each  calculate number of cycles created by  from numbers , that  and . Lets set .Next step is to find minimal  such that , let's name it order of  or . Then for each  if  then  and , so each cycle will have length equal to  and number of cycles will be equal to .Last step is calculate  for each . There is a fact that  so can try to iterate over all divisors  of  and check  by binary exponentiation (It seems as  but it's faster and author's version work around 2 seconds. It doesn't pass but somebody can write better). But we'll speed it up. Let . So we can independently for each  find its minimal power  such that . We can just iterate over all  and  since .Some words about finding  \u2014 its factorization differs from factorization of  just by lowering degrees of primes and adding factorizations of some . But we can manually find factorization of  with memorization (or even without it) since .So our steps are next: factorize , recursively iterate over all divisors of , find  and , and add to the answer .Result complexity is .And the last note is how to multiply  modulo . You can use binary multiplification which will give you extra  what is not critically in this task (in C++, of course). Or you can use multiplification from hashes, which will work with 64 bit double, since it's only .", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) int((a).size())\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef long double ld;\ntypedef pair<li, li> pt;\n\nconst int INF = int(1e9);\nconst li INF64 = li(1e18);\nconst ld EPS = 1e-9;\n\nli m, x;\n\ninline bool read() {\n    if(!(cin >> m >> x))\n        return false;\n    return true;\n}\n\nmap< li, vector<pt> > dFact;\nvector<pt> fact(li v) {\n    if(dFact.count(v))\n        return dFact[v];\n    \n    li oldv = v;\n    vector<pt> fs;\n    for(li d = 2; d * d <= v; d++) {\n        int cnt = 0;\n        while(v % d == 0)\n            v /= d, cnt++;\n        \n        if(cnt > 0)\n            fs.emplace_back(d, cnt);\n    }\n    if(v > 1)\n        fs.emplace_back(v, 1), v = 1;\n    return dFact[oldv] = fs;\n}\n\nvector<pt> merge(const vector<pt> &a, const vector<pt> &b) {\n    vector<pt> ans;\n    int u = 0, v = 0;\n    while(u < sz(a) && v < sz(b)) {\n        if(a[u].x < b[v].x)\n            ans.push_back(a[u++]);\n        else if(a[u].x > b[v].x)\n            ans.push_back(b[v++]);\n        else {\n            ans.emplace_back(a[u].x, a[u].y + b[v].y);\n            u++, v++;\n        }\n    }\n    while(u < sz(a))\n        ans.push_back(a[u++]);\n    while(v < sz(b))\n        ans.push_back(b[v++]);\n    return ans;\n}\n\nli getPw(li a, li b) {\n    li ans = 1;\n    fore(i, 0, b)\n        ans *= a;\n    return ans;\n}\n\nli mul(li a, li b, li mod) {\n    li m = li(ld(a) * b / mod);\n    li rem = a * b - m * mod;\n    while(rem < 0)\n        rem += mod;\n    while(rem >= mod)\n        rem -= mod;\n    return rem;\n}\n\nli binPow(li a, li k, li mod) {\n    li ans = 1 % mod;\n    while(k > 0) {\n        if(k & 1)\n            ans = mul(ans, a, mod);\n        a = mul(a, a, mod);\n        k >>= 1;\n    }\n    return ans;\n}\n\nli findOrder(li x, li mod, const vector<pt> &f) {\n    li phi = 1;\n    fore(i, 0, sz(f)) fore(k, 0, f[i].y)\n        phi *= f[i].x;\n        \n    if(phi == 1 || x == 0)\n        return 1;\n    \n    li ord = 1;\n    fore(i, 0, sz(f)) {\n        li basePw = phi;\n        fore(k, 0, f[i].y)\n            basePw /= f[i].x;\n        \n        li curV = binPow(x, basePw, mod);\n        \n        int curPw = -1;\n        fore(k, 0, f[i].y + 1) {\n            if(curV != 1)\n                curPw = k;\n            curV = binPow(curV, f[i].x, mod);\n        }\n        \n        ord *= getPw(f[i].x, curPw + 1);\n    }\n    return ord;\n}\n\nvector<pt> fm;\nvector<int> pw;\n\nli calc(int pos, li dv) {\n    if(pos >= sz(fm)) {\n        vector<pt> cf = fm;\n        fore(i, 0, sz(fm))\n            cf[i].y = max(pw[i] - 1, 0);\n        \n        li phi = dv;\n        fore(i, 0, sz(fm)) {\n            if(pw[i] > 0) {\n                cf = merge(cf, fact(fm[i].x - 1));\n                phi -= phi / fm[i].x;\n            }\n        }\n        li k = findOrder(x % dv, dv, cf);\n        return phi / k;\n    }\n    \n    li ans = 0;\n    fore(i, 0, fm[pos].y + 1) {\n        pw[pos] = i;\n        ans += calc(pos + 1, dv);\n        dv *= fm[pos].x;\n    }\n    return ans;\n}\n\ninline void solve() {\n    fm = fact(m);\n    \n    pw.assign(sz(fm), 0);\n    li ans = calc(0, 1);\n    \n    cout << ans << endl;\n}\n\nint main() {\n#ifdef _DEBUG\n    freopen(\"input.txt\", \"r\", stdin);\n    int tt = clock();\n#endif\n    cout << fixed << setprecision(15);\n    \n    if(read()) {\n        solve();\n        \n#ifdef _DEBUG\n        cerr << \"TIME = \" << clock() - tt << endl;\n        tt = clock();\n#endif\n    }\n    return 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}