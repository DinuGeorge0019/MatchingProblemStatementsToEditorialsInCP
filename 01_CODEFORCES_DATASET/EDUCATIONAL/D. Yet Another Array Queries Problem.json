{"link": "https://codeforces.com//contest/863/problem/D", "problemId": "123494", "shortId": "863D", "contest_number": "863", "name": "D. Yet Another Array Queries Problem", "statement": "You are given an array  of size , and  queries to it. There are queries of two types:      \u2014 perform a cyclic shift of the segment  to the right. That is, for every  such that  new value of  becomes equal to old value of , and new value of  becomes equal to old value of ;     \u2014 reverse the segment .  There are  important indices in the array , , ..., . For each  such that  you have to output the number that will have index  in the array after all queries are performed.", "input": "The first line contains three integer numbers ,  and  (, ).  The second line contains  integer numbers , , ...,  ().  Then  lines follow. -th of them contains three integer numbers , , , where  is the type of -th query, and  is the segment where this query is performed (, ).  The last line contains  integer numbers , , ...,  () \u2014 important indices of the array. ", "output": "Print  numbers, -th of which is equal to the number at index  after all queries are done.", "tutorial": "One can guess from the constraits that complexity of the algorithm should be either  or . And there is a solution with the second one.Let's try to solve the reversed problem \u2014 answer what position will some number be at after all the queries. Check the impact of some query on position . Let the query be on some segment . If  is outside this segment then you can skip it. Otherwise reverse will swap  and , shift will swap  and  (if  then it will be  instead of ).This task can be translated to the given one just by reversing the query list. Overall complexity: .Obviously, you can also solve it with Cartesian tree online in .", "solution": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))\n#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))\nstatic const int INF = 0x3f3f3f3f; static const long long INFL = 0x3f3f3f3f3f3f3f3fLL;\ntypedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;\ntemplate<typename T, typename U> static void amin(T &x, U y) { if (y < x) x = y; }\ntemplate<typename T, typename U> static void amax(T &x, U y) { if (x < y) x = y; }\n\nint main() {\n\tint n; int q;\n\twhile (~scanf(\"%d%d\", &n, &q)) {\n\t\tint m;\n\t\tscanf(\"%d\", &m);\n\t\tvector<int> a(n);\n\t\tfor (int i = 0; i < n; ++ i)\n\t\t\tscanf(\"%d\", &a[i]);\n\t\tstruct Query {\n\t\t\tint ty, l, r;\n\t\t};\n\t\tvector<Query> queries(q);\n\t\tfor (int ii = 0; ii < q; ++ ii) {\n\t\t\tint ty;\n\t\t\tscanf(\"%d\", &ty);\n\t\t\tint l; int r;\n\t\t\tscanf(\"%d%d\", &l, &r), -- l;\n\t\t\tqueries[ii] = { ty, l, r };\n\t\t}\n\t\tvector<int> b(m);\n\t\tfor (int i = 0; i < m; ++ i)\n\t\t\tscanf(\"%d\", &b[i]), -- b[i];\n\t\tvector<int> ans;\n\t\tfor (int i : b) {\n\t\t\tfor (int qi = q - 1; qi >= 0; -- qi) {\n\t\t\t\tconst auto &t = queries[qi];\n\t\t\t\tif (t.l <= i && i < t.r) {\n\t\t\t\t\tif (t.ty == 1) {\n\t\t\t\t\t\ti = i == t.l ? t.r - 1 : i - 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ti = t.r - 1 - i + t.l;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tans.push_back(a[i]);\n\t\t}\n\t\tfor (int i = 0; i < (int)ans.size(); ++ i) {\n\t\t\tif (i != 0) putchar(' ');\n\t\t\tprintf(\"%d\", ans[i]);\n\t\t}\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}