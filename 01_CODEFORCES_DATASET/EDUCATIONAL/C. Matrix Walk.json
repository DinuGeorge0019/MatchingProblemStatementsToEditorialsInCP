{"link": "https://codeforces.com//contest/954/problem/C", "problemId": "167340", "shortId": "954C", "contest_number": "954", "name": "C. Matrix Walk", "statement": "There is a matrix  of size  filled with integers. For every ,  . Obviously, every integer from  occurs exactly once in this matrix. You have traversed some path in this matrix. Your path can be described as a sequence of visited cells , , ...,  denoting that you started in the cell containing the number , then moved to the cell with the number , and so on.From the cell located in -th line and -th column (we denote this cell as ) you can move into one of the following cells:  \u2014 only if ;   \u2014 only if ;   \u2014 only if ;   \u2014 only if .Notice that making a move requires you to go to an adjacent cell. It is not allowed to stay in the same cell. You don't know  and  exactly, but you have to find any possible values for these numbers such that you could start in the cell containing the integer , then move to the cell containing  (in one step), then move to the cell containing  (also in one step) and so on. Can you choose  and  so that they don't contradict with your sequence of moves?", "input": "The first line contains one integer number  () \u2014 the number of cells you visited on your path (if some cell is visited twice, then it's listed twice). The second line contains  integers , , ...,  () \u2014 the integers in the cells on your path.", "output": "If all possible values of  and  such that  contradict with the information about your path, print . Otherwise, print  in the first line, and in the second line print the values  and  such that your path was possible with such number of lines and columns in the matrix. Remember that they must be positive integers not exceeding .", "tutorial": "You can notice that moves of kind  and  are changing value  to  and . Thus, you can determine  by checking adjacent nodes in the path. The answer is  if there are one or zero distinct values of differences not counting difference of .You can also set  to arbitrary big value, it doesn't really matter until you can fit all values.  will work just fine.Finally, knowing  and , simulate the process and check that all moves are valid.Overall complexity: .", "solution": "#include<bits/stdc++.h>\n#define MN 200005\nusing namespace std;\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\nint n,M,mx,a[MN];\nint main()\n{\n\tregister int i,x,y;\n\tn=read();\n\tfor (i=1;i<=n;++i) mx=max(mx,a[i]=read());\n\tfor (i=2;i<=n;++i)\n\t\tif ((y=abs(a[i]-a[i-1]))>1)\n\t\t\tif (M) {if (M!=y) return 0*printf(\"NO\");}\n\t\t\telse M=y;\n\t\telse if (y==0) return 0*printf(\"NO\");\n\tif (!M) return 0*printf(\"YES\\n1 %d\",mx);\n\tfor (i=2;i<=n;++i)\n\t\tif (abs(a[i]-a[i-1])==1)\n\t\t\tif (min(a[i],a[i-1])%M==0) return 0*printf(\"NO\");\n\tputs(\"YES\");\n\tprintf(\"%d %d\",(mx-1)/M+1,M);\n}", "interactive": false, "noSolution": false, "noTutorial": false}