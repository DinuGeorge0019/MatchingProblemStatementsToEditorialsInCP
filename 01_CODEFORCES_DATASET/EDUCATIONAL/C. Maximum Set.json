{"link": "https://codeforces.com//contest/1796/problem/C", "problemId": "1802547", "shortId": "1796C", "contest_number": "1796", "name": "C. Maximum Set", "statement": "A set of positive integers  is called beautiful if, for every two integers  and  from this set, either  divides  or  divides  (or both).You are given two integers  and . Consider all beautiful sets consisting of integers not less than  and not greater than . You have to print two numbers:  the maximum possible size of a beautiful set where all elements are from  to ;  the number of beautiful sets consisting of integers from  to  with the maximum possible size. Since the second number can be very large, print it modulo .", "input": "The first line contains one integer  () \u2014 the number of test cases. Each test case consists of one line containing two integers  and  ().", "output": "For each test case, print two integers \u2014 the maximum possible size of a beautiful set consisting of integers from  to , and the number of such sets with maximum possible size. Since the second number can be very large, print it modulo .", "tutorial": "Every beautiful set can be represented as a sequence of its elements in sorted order. Let these elements for some set be ; also, let . When the set is beautiful, every  is an integer greater than .It's easy to see that if  and  belong to , the whole set belongs to . Since , in order to maximize , we need to choose  and  as small as possible. So, why don't we choose  and every ? This will allow us to calculate the maximum possible size of a beautiful set (let  be this maximum possible size).Okay, what about counting those sets? The claims  and that every  are no longer true by default. However, there are some constraints on .Firstly, every . If we had some value of , we could replace it with two values of , and the size of the set would increase.Secondly, there is at most one . If there are two values , we could replace them with three , and the size of the set would increase as well.So, the sequence  contains at most one value , and the rest of the values are .We will divide the sets we want to count into two categories: the ones with all , and the ones with one value .To count the sets in the first category, we simply need to count the number of different minimum values in those sets. Those minimum values have to be such that multiplying them by  wouldn't make them greater than , so these are all integers from the segment . For every such integer, there exists exactly one set of the first category.To count the sets in the second category, we do a similar thing. The minimum value in the set should be from the segment ; but for every integer from this segment, there are  different sets of the second category since there are  ways to choose which  is equal to .", "solution": "#include <bits/stdc++.h>\n \nusing namespace std;\n\nint main()\n{\n    int t;\n    cin >> t;\n    for(int i = 0; i < t; i++)\n    {\n        int l, r;\n        cin >> l >> r;\n        int max_size = 1;\n        while((l << max_size) <= r)\n            max_size++;\n        int ans2 = (r / (1 << (max_size - 1)) - l + 1);\n        if(max_size > 1)\n            ans2 += (max_size - 1) * max(0, (r / (1 << (max_size - 2)) / 3 - l + 1));\n        cout << max_size << \" \" << ans2 << endl;\n    }\n}", "interactive": false, "noSolution": false, "noTutorial": false}