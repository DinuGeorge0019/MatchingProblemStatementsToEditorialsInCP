{"link": "https://codeforces.com//contest/1051/problem/F", "problemId": "222362", "shortId": "1051F", "contest_number": "1051", "name": "F. The Shortest Statement", "statement": "You are given a weighed undirected  graph, consisting of  vertices and  edges.You should answer  queries, the -th query is to find the shortest distance between vertices  and .", "input": "The first line contains two integers  and  \u2014 the number of vertices and edges in the graph. Next  lines contain the edges: the -th edge is a triple of integers . This triple means that there is an edge between vertices  and  of weight . It is guaranteed that graph contains no self-loops and multiple edges. The next line contains a single integer  \u2014 the number of queries. Each of the next  lines contains two integers  and  \u2014 descriptions of the queries. ", "output": "Print  lines. The -th line should contain the answer to the -th query \u2014 the shortest distance between vertices  and .", "tutorial": "Firstly let's find any spanning tree and root it at any vertex. For each vertex we calculate the distance to the root (let it be  for vertex ). There are no more than  edges that don't belong to the tree. For each of these edges, let's run Dijkstra's algorithm from some vertex incident to this edge.Suppose we are answering a query  . If the shortest path between these vertices passes only along the edges of the tree, then it can be calculated by the formula , where  is the lowest common ancestor of vertices  and . You may use any fast enough algorithm you know to calculate .Otherwise there exists at least one vertex such that we ran Dijkstra's algorithm from it, and it belongs to the shortest path. Just iterate on every vertex for which we ran Dijkstra and update the answer with the value of , where  is the shortest path to the vertex  from the fixed vertex.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 300 * 1000 + 9;\nconst int LOGN = 19;\nconst int M = 21;\nconst long long INF64 = 1e18;\n\nint n, m, q;\nvector <pair<int, int> > g[N];\nint p[LOGN][N];\nint tin[N], tout[N], T;\nlong long h[N];\nset <pair<int, int> > badEdges;\nlong long d[M + M][N];\nbool u[N];\n\nvoid dfs(int v, int pr){\n\ttin[v] = T++;\n\tp[0][v] = pr;\n\tu[v] = true;\n\tfor(int i = 1; i < LOGN; ++i)\n\t\tp[i][v] = p[i - 1][ p[i - 1][v] ];\n\t\t\n\tfor(auto e : g[v]){\n\t\tint to = e.first, len = e.second;\n\t\tif(!u[to]){\n\t\t\th[to] = h[v] + len;\n\t\t\tdfs(to, v);\n\t\t\t\n\t\t\tif(v < to)\n\t\t\t\tbadEdges.erase(make_pair(v, to));\n\t\t\telse\n\t\t\t\tbadEdges.erase(make_pair(to, v));\t\t\t\n\t\t}\n\t}\t\n\t\t\n\ttout[v] = T;\n}\n\nbool isAncestor(int a, int b){\n\treturn tin[a] <= tin[b] && tout[a] >= tout[b];\n}\n\nint getLCA(int a, int b){\n\tif(isAncestor(a, b)) return a;\n\tif(isAncestor(b, a)) return b;\n\t\n\tfor(int i = LOGN - 1; i >= 0; --i)\n\t\tif(!isAncestor(p[i][a], b))\n\t\t\ta = p[i][a];\n\t\n\treturn p[0][a];\n}\n\nvoid dij(int st, long long d[N]){\n\tset<pair<long long, int> > q;\n\tfor(int i = 0; i < n; ++i) d[i] = INF64;\n\td[st] = 0;\n\tq.insert(make_pair(d[st], st));\n\t\n\twhile(!q.empty()){\n\t\tint v = q.begin()->second;\n\t\tq.erase(q.begin());\n\t\t\n\t\tfor(auto e : g[v]){\n\t\t\tint to = e.first, len = e.second;\n\t\t\tif(d[to] > d[v] + len){\n\t\t\t\tq.erase(make_pair(d[to], to));\n\t\t\t\td[to] = d[v] + len;\n\t\t\t\tq.insert(make_pair(d[to], to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t\n\tscanf(\"%d %d\", &n, &m);\n    for(int i = 0; i < m; ++i){\n    \tint u, v, w;\n    \tscanf(\"%d %d %d\", &u, &v, &w);\n    \t--u, --v;\n    \tg[u].push_back(make_pair(v, w));\n       \tg[v].push_back(make_pair(u, w));\n    }\n\t\n    for(int v = 0; v < n; ++v)\n    \tfor(auto e : g[v])\n    \t\tif(v < e.first)\n    \t\t\tbadEdges.insert(make_pair(v, e.first));\n\n    dfs(0, 0);\n\n    int cpos = 0;\n    for(auto e : badEdges)\n    \tdij(e.first, d[cpos++]);\n    scanf(\"%d\", &q);\n    for(int tc = 0; tc < q; ++tc){\n    \tint u, v;\n    \tscanf(\"%d %d\", &u, &v);\n    \t--u, --v;\n    \tint lca = getLCA(u, v);\n    \tlong long ans = h[u] + h[v] - 2 * h[lca];\n    \tfor(int i = 0; i < badEdges.size(); ++i)\n    \t\tans = min(ans, d[i][u] + d[i][v]);\n    \t\t\n    \tprintf(\"%lld\\n\", ans);\n    }\t\n    return 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}