{"link": "https://codeforces.com//contest/1598/problem/A", "problemId": "1138070", "shortId": "1598A", "contest_number": "1598", "name": "A. Computer Game", "statement": "Monocarp is playing a computer game. Now he wants to complete the first level of this game.A level is a rectangular grid of  rows and  columns. Monocarp controls a character, which starts in cell \u00a0\u2014 at the intersection of the -st row and the -st column.Monocarp's character can move from one cell to another in one step if the cells are adjacent by side and/or corner. Formally, it is possible to move from cell  to cell  in one step if  and . Obviously, it is prohibited to go outside the grid.There are traps in some cells. If Monocarp's character finds himself in such a cell, he dies, and the game ends.To complete a level, Monocarp's character should reach cell \u00a0\u2014 at the intersection of row  and column .Help Monocarp determine if it is possible to complete the level.", "input": "The first line contains a single integer  () \u2014 the number of test cases. Then the test cases follow. Each test case consists of three lines. The first line contains a single integer  ()\u00a0\u2014 the number of columns. The next two lines describe the level. The -th of these lines describes the -th line of the level\u00a0\u2014 the line consists of the characters '' and ''. The character '' corresponds to a safe cell, the character '' corresponds to a trap cell. Additional constraint on the input: cells  and  are safe.", "output": "For each test case, output  if it is possible to complete the level, and  otherwise.", "tutorial": "At first glance, it seems like a graph problem. And indeed, this problem can be solved by explicitly building a graph considering cells as the vertices and checking that there is a safe path from start to finish via DFS/BFS/DSU/any other graph algorithm or data structure you know. But there's a much simpler solution.Since there are only two rows in a matrix, it's possible to move from any cell in the column  to any cell in column  (if they are both safe, of course). It means that as long as there is at least one safe cell in each column, it is possible to reach any column of the matrix (and the cell  as well).It's easy to see that if this condition is not met, there exists a column with two unsafe cells \u2014 and this also means that this column and columns to the right of it are unreachable. So, the problem is reduced to checking if there is a column without any unsafe cells. To implement this, you can read both rows of the matrix as strings (let these strings be  and ) and check that there is a position  such that both  and  are equal to .", "solution": "def solve():\n\tn = int(input())\n\ts1 = input()\n\ts2 = input()\n\tbad = False\n\tfor i in range(n):\n\t\tbad |= s1[i] == '1' and s2[i] == '1'\n\tif bad:\n\t\tprint('NO')\n\telse:\n\t\tprint('YES')\n\nt = int(input())\nfor i in range(t):\n\tsolve()", "interactive": false, "noSolution": false, "noTutorial": false}