{"link": "https://codeforces.com//contest/1009/problem/C", "problemId": "197474", "shortId": "1009C", "contest_number": "1009", "name": "C. Annoying Present", "statement": "Alice got an array of length  as a birthday present once again! This is the third year in a row! And what is more disappointing, it is overwhelmengly boring, filled entirely with zeros. Bob decided to apply some changes to the array to cheer up Alice.Bob has chosen  changes of the following form. For some integer numbers  and , he chooses an arbitrary position  () and for every  adds  to the value of the -th cell.  is the distance between positions  and  (i.e. , where  is an absolute value of ).For example, if Alice currently has an array  and Bob chooses position  for  and  then the array will become  = . Note that Bob can't choose position  outside of the array (that is, smaller than  or greater than ).Alice will be the happiest when the elements of the array are as big as possible. Bob claimed that the arithmetic mean value of the elements will work fine as a metric.What is the maximum arithmetic mean value Bob can achieve?", "input": "The first line contains two integers  and  () \u2014 the number of elements of the array and the number of changes. Each of the next  lines contains two integers  and  () \u2014 the parameters for the -th change.", "output": "Print the maximal average arithmetic mean of the elements Bob can achieve. Your answer is considered correct if its absolute or relative error doesn't exceed .", "tutorial": "Judging by constraints, you can guess that the greedy approach is the right one. Firstly, let's transition from maximizing the arithmetic mean to the sum, it's the same thing generally. Secondly, notice that each  is being added to each element regardless of the chosen position. Finally, take a look at a function  \u2014 total sum obtained by applying change with  to position  and notice that it is non-strictly convex. Its maximum or minimum values can always be found in one of these positions:  (method of rounding doesn't matter),  and .Thus, the solution will look like this: for positive  you apply the change to position  and for non-positive  \u2014 to position . The impact of the change can be calculated with the formula of the sum of arithmetic progression.Also, you should either do all of your calculations in long double (10-byte type) or maintain sum in long long (you can estimate it with , so it fits) and divide it by  in the end (then double will work).Overall complexity: .", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\ntypedef long long li;\n\nint main() {\n\tint n, m;\n\tscanf(\"%d%d\", &n, &m);\n\t\n\tli neg = ((n - 1) / 2) * li((n - 1) / 2 + 1);\n\tif (n % 2 == 0) neg += n / 2;\n\tli pos = n * li(n - 1) / 2;\n\t\n\tli ans = 0;\n\tforn(i, m){\n\t\tint x, d;\n\t\tscanf(\"%d%d\", &x, &d);\n\t\tans += x * li(n);\n\t\tif (d < 0)\n\t\t\tans += neg * d;\n\t\telse\n\t\t\tans += pos * d;\n\t}\n\t\n\tprintf(\"%.15f\\n\", double(ans) / n);\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}