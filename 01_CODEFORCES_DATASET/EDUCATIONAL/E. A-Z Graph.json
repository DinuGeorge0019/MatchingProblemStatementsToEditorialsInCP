{"link": "https://codeforces.com//contest/1494/problem/E", "problemId": "913254", "shortId": "1494E", "contest_number": "1494", "name": "E. A-Z Graph", "statement": "You are given a directed graph consisting of  vertices. Each directed edge (or arc) labeled with a single character. Initially, the graph is empty.You should process  queries with it. Each query is one of three types:   \"\"\u00a0\u2014 add arc from  to  with label . It's guaranteed that there is no arc  in the graph at this moment;  \"\"\u00a0\u2014 erase arc from  to . It's guaranteed that the graph contains arc  at this moment;  \"\"\u00a0\u2014 find the sequence of  vertices  such that there exist both routes  and  and if you write down characters along both routes you'll get the same string. You can visit the same vertices any number of times. ", "input": "The first line contains two integers  and  (; )\u00a0\u2014 the number of vertices in the graph and the number of queries. The next  lines contain queries\u00a0\u2014 one per line. Each query is one of three types:    \"\" (; ;  is a lowercase Latin letter);  \"\" (; );  \"\" ().  It's guaranteed that you don't add multiple edges and erase only existing edges. Also, there is at least one query of the third type.", "output": "For each query of the third type, print  if there exist the sequence  described above, or  otherwise.", "tutorial": "At first, if there should be both routes  and  then there are both arcs  and , i.\u00a0e. there should exist at least one pair  that both arcs  and  are present in the graph.Now, if  is odd, and we have at least one pair  then we can simply create sequence . This sequence is a palindrome so, obviously, both routes generate the same string.If  is even (or ), we can note that in the sequence  there is a middle arc  and it should have the same character as arc  (since it's a middle arc in reverse route ), i.\u00a0e. there should exist at least one pair  that both arcs  and  are present in the graph and have the same label.Now, if we have at least one such pair  then routes  and  generate the same one-letter strings.Since each arc  is a part of at most one pair , we can just maintain two sets with pairs : one for pairs with different labels and the other one for pairs with equal labels. If  is odd, we check that at least one of the sets is not empty. If  is even, we check that the second set is not empty.", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) int((a).size())\n\n#define x first\n#define y second\n\ntypedef pair<int, int> pt;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    \n    int n, m;\n    cin >> n >> m;\n    \n    map<pt, int> allEdges;\n    set<pt> difPairs, eqPairs;\n    \n    fore (q, 0, m) {\n        char tp; cin >> tp;\n        if (tp == '+') {\n            int u, v;\n            char c;\n            cin >> u >> v >> c;\n            \n            if (allEdges.count({v, u})) {\n                if (allEdges[{v, u}] == c)\n                    eqPairs.emplace(min(u, v), max(u, v));\n                else\n                    difPairs.emplace(min(u, v), max(u, v));\n            }\n            allEdges[{u, v}] = c;\n            \n        } else if (tp == '-') {\n            int u, v;\n            cin >> u >> v;\n            if (eqPairs.count({min(u, v), max(u, v)}))\n                eqPairs.erase({min(u, v), max(u, v)});\n            if (difPairs.count({min(u, v), max(u, v)}))\n                difPairs.erase({min(u, v), max(u, v)});\n            \n            allEdges.erase({u, v});\n        } else {\n            int k;\n            cin >> k;\n            \n            bool hasAns = !eqPairs.empty();\n            if (k & 1)\n                hasAns |= !difPairs.empty();\n            cout << (hasAns ? \"YES\" : \"NO\") << '\\n';\n        }\n    }\n    \n    return 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}