{"link": "https://codeforces.com//contest/954/problem/H", "problemId": "167345", "shortId": "954H", "contest_number": "954", "name": "H. Path Counting", "statement": "You are given a rooted tree. Let's denote  as depth of node : depth of the root is , depth of any other node  is , where  is a parent of .The tree has the following property: every node  with  has exactly  children. Maximum possible depth of a node is , and .We define  as the number of unordered pairs of vertices in the tree such that the number of edges on the simple path between them is equal to .Calculate  modulo  for every .", "input": "The first line of input contains an integer  () \u2014 the maximum depth of a node. The second line of input contains  integers  (), where  is the number of children of every node  such that . Since , it is not given in the input.", "output": "Print  numbers. The -th of these numbers must be equal to  modulo .", "tutorial": "At first when we read the problem, a simple solution comes to our mind, take a look at the LCA (Lowest Common Ancestor) of that starting and ending vertices of the path and then use combinatorics to calculate the number of the paths, but after trying to implement this or solve this on paper it doesn't seem to be easy at all and it may even be impossible to implement this. So lets try to solve this problem in a different way.For calculating the answer, we count the number of times each path starts or ends at every vertex, and then divide them by  to get the answer for each vertex.For calculating the answer to the above, it is easy to see that all vertices with the same height have the same number of paths going through them, so if we calculate the number of paths going through one of them and then multiply it by the number of the vertices in that height (let it be ) it gets equal to our answer.We can calculate the answer for a certain height. So to do that, we divide the paths into two types, paths that go only into the subtree of a vertex (let's call it ), and paths that go up (let's call it ).For the ones that are in the subtree, it is easy to see if there are at least  other vertices that go down, we can go all paths going down (let the number of them be ), and the answer for this part, equals to:For the ones that go up, we use dynamic-programming, and we define  the number of paths that start at a vertex with height  and have length  and do not use the leftmost edge exiting the vertex at height . To update this either we go down on one of the  paths and then we go through a path of length , or we go up and get a path of length  starting at a vertex from height , so the answer for this one equals to:Now .And the final complexity of the solution will be , but because of the large constant of the solution the time limit is higher.", "solution": "#include<bits/stdc++.h>\n#define MN 5000\n#define mod 1000000007\nusing namespace std;\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\nint n,a[MN+5],num[MN+5],res[MN+5][MN*2+5],ans[MN*2+5];\ninline int pow(int x,int k)\n{\n\tint sum=1;\n\tfor(;k;k>>=1,x=1LL*x*x%mod)\n\t\tif(k&1) sum=1LL*sum*x%mod;\n\treturn sum;\t\n}\nint main()\n{\n\tn=read();num[1]=1;\n\tfor(int i=1;i<n;++i) a[i]=read(),num[i+1]=1LL*num[i]*a[i]%mod;\n\tfor(int i=1;i<=n;++i) \n\t{\n\t\tint x=1,inv=pow(a[i],mod-2);\n\t\tfor(int j=1;j<=2*n-2;++j)\n\t\t{\t\n\t\t\tx=i+j>n?0:1LL*x*a[i+j-1]%mod;\n\t\t\tint sum=(res[i][j]+x)%mod;\n\t\t\tans[j]=(ans[j]+1LL*num[i]*sum)%mod;\n\t\t\tif(i<n) res[i+1][j+1]=(1LL*res[i+1][j+1]+res[i][j]+1LL*x*inv%mod*(a[i]-1))%mod;\n\t\t}\n\t\tif(i<n) res[i+1][1]=(res[i+1][1]+1)%mod;\n\t}\n\tfor(int i=1;i<=n*2-2;++i) printf(\"%d \",1LL*ans[i]*(mod+1)/2%mod);\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}