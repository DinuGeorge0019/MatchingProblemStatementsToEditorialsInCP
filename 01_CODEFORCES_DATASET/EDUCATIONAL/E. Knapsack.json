{"link": "https://codeforces.com//contest/1132/problem/E", "problemId": "307699", "shortId": "1132E", "contest_number": "1132", "name": "E. Knapsack", "statement": "You have a set of items, each having some integer weight not greater than . You denote that a subset of items is good if total weight of items in the subset does not exceed .You want to calculate the maximum possible weight of a good subset of items. Note that you have to consider the empty set and the original set when calculating the answer.", "input": "The first line contains one integer  () \u2014 the maximum total weight of a good subset. The second line denotes the set of items you have. It contains  integers , , ...,  (), where  is the number of items having weight  in the set.", "output": "Print one integer \u2014 the maximum possible weight of a good subset of items.", "tutorial": "Let's consider the optimal answer. Suppose we take  items of weight .Let  be the least common multiple of all weights (that is ). Then we may represent  as , where . Let's do the following trick: we will take  items of weight , and all the remaining items of this weight can be merged into some items of weight .Then we can write a brute force solution that picks less than  items of each weight, transforms the remaining ones into items of weight  as much as possible, and when we fix the whole subset, adds maximum possible number of items of weight  to the answer. This works in something like  operations, which is too much.How can we speed it up? Rewrite it using dynamic programming! When we have fixed the number of items we take from  first sets, the only two things that matter now are the current total weight of taken items and the number of items of weight  we can use; and it's obvious that the more items of weight  we can use, the better. So let's write the following dynamic programming solution:  \u2014 maximum number of items of weight  we can have, if we processed first  types of items, and current total weight is . Note that the second dimension should have size .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 9;\nconst int L = 840;\n\ntypedef long long li;\n\nli dp[N][L * N];\nli W;\nli cnt[N];\n\nint main()\n{\n\tcin >> W;\n\tfor(int i = 0; i < 8; i++)\n\t\tcin >> cnt[i];\n\tfor(int i = 0; i < N; i++) for(int j = 0; j < L * N; j++) dp[i][j] = -1;\n\tdp[0][0] = 0;\n\tfor(int i = 0; i < 8; i++)\n\t{\n\t\tfor(int j = 0; j < L * N; j++)\n\t\t{\n\t\t\tif(dp[i][j] == -1) continue;\n\t\t\tint b = L / (i + 1);\n\t\t\tif(cnt[i] < b)\n\t\t\t\tb = cnt[i];\n\t\t\tfor(int k = 0; k <= b; k++)\n\t\t\t{\n\t\t\t\tli& d = dp[i + 1][j + k * (i + 1)];\n\t\t\t\td = max(d, dp[i][j] + (cnt[i] - k) / (L / (i + 1)));\n\t\t\t}\n\t\t}\n\t}\n\tli ans = 0;\n\tfor(int j = 0; j < L * N; j++)\n\t{\n\t\tif(j > W || dp[8][j] == -1)\n\t\t\tcontinue;\n\t\tans = max(ans, j + L * (min(dp[8][j], (W - j) / L)));\n\t}\n\tcout << ans << endl;\n}", "interactive": false, "noSolution": false, "noTutorial": false}