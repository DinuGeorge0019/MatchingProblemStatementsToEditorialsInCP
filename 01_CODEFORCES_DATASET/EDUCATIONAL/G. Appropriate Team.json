{"link": "https://codeforces.com//contest/1016/problem/G", "problemId": "204442", "shortId": "1016G", "contest_number": "1016", "name": "G. Appropriate Team", "statement": "Since next season are coming, you'd like to form a team from two or three participants. There are  candidates, the -th candidate has rank . But you have weird requirements for your teammates: if you have rank  and have chosen the -th and -th candidate, then  and  must be met.You are very experienced, so you can change your rank to any non-negative integer but  and  are tied with your birthdate, so they are fixed.Now you want to know, how many are there pairs  such that there exists an integer  meeting the following constraints:  and . It's possible that  and you form a team of two. is the greatest common divisor of two number,  \u2014 the least common multiple.", "input": "First line contains three integers ,  and  (, ) \u2014 the number of candidates and corresponding constants. Second line contains  space separated integers  () \u2014 ranks of candidates.", "output": "Print the only integer \u2014 the number of pairs  such that there exists an integer  meeting the following constraints:  and . It's possible that .", "tutorial": "At first,  must be met (since  and ). Now let  and . From now on let's consider only  such that .Now let's look at :  must be met. Let . Since , if  then  must have  to the power of  in its factorization; otherwise power of  can be any non-negative integer . It leads us to the bitmask of restrictions  () with size equal to the number of different prime divisors of .In the same way let's process . Of course,  and if  then  must have  to the power of  in its factorization. This is another restriction bitmask  ().So, for any pair  there exists  if and only if . Since we look only at  where  then  can't have power of  equal to  and  at the same time. For any other  it is enough to have power of  in  equal to the power of  in  (even if it's equal to ).So, for each  we need to know the number of  such that  is a submask of . So we just need to calculate sum of submasks for each mask; it can be done with  or .Finally, how to factorize number  up to . Of course, Pollard algorithm helps, but there is another way, which works sometimes. Let's factorize  with primes up to . So after that if  there is only three cases: ,  or .  is easy to check ( helps). Otherwise, just check  with all ,  and : if you have found  and , then  and you have found . Otherwise you can assume that , because this probable mistake doesn't break anything in this task.Result complexity is  where  is the number of prime divisors of  .", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) int((a).size())\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef pair<li, li> pt;\n\nconst int INF = int(1e9);\nconst li INF64 = li(1e18);\n\nconst int N = 200 * 1000 + 555;\nint n; li x, y;\nli a[N];\n\ninline bool read() {\n\tif(!(cin >> n >> x >> y))\n\t\treturn false;\n\tfore(i, 0, n)\n\t\tassert(scanf(\"%lld\", &a[i]) == 1);\n\treturn true;\n}\n\nli gcd(li a, li b) {\n\twhile(a > 0) {\n\t\tb %= a;\n\t\tswap(a, b);\n\t}\n\treturn b;\n}\n\nvector<pt> factorize(li v) {\n\tvector<pt> f;\n\tfor(li x = 2; x <= 1'000'000 && x * x <= v; x++) {\n\t\tint cnt = 0;\n\t\twhile(v % x == 0)\n\t\t\tv /= x, cnt++;\n\t\tif(cnt > 0)\n\t\t\tf.emplace_back(x, cnt);\n\t}\n\tif(v > 1) {\n\t\tfor(li s = max(1ll, (li)sqrtl(v) - 2); s * s <= v; s++)\n\t\t\tif(s * s == v) {\n\t\t\t\tf.emplace_back(s, 2);\n\t\t\t\tv = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif(v > 1) {\n\t\t\tvector<li> cnd(a, a + n);\n\t\t\tcnd.push_back(x);\n\t\t\tcnd.push_back(y);\n\t\t\t\n\t\t\tfor(li c : cnd) {\n\t\t\t\tli g = gcd(v, c);\n\t\t\t\tif(g != 1 && g != v) {\n\t\t\t\t\tli a = g, b = v / g;\n\t\t\t\t\tif(a > b)\n\t\t\t\t\t\tswap(a, b);\n\t\t\t\t\t\t\n\t\t\t\t\tf.emplace_back(a, 1);\n\t\t\t\t\tf.emplace_back(b, 1);\n\t\t\t\t\tv = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(v > 1)\n\t\t\t\tf.emplace_back(v, 1), v = 1;\n\t\t}\n\t}\n\treturn f;\n}\n\nint d[(1 << 18) + 3];\n\ninline void solve() {\n\tif(y % x != 0) {\n\t\tputs(\"0\");\n\t\treturn;\n\t}\n\t\n\tvector<pt> fy = factorize(y);\n\tvector<pt> fx;\n\tli cx = x;\n\tfor(auto p : fy) {\n\t\tint cnt = 0;\n\t\twhile(cx % p.x == 0)\n\t\t\tcx /= p.x, cnt++;\n\t\tfx.emplace_back(p.x, cnt);\n\t}\n\t\n\tvector<li> ps;\n\tvector<pt> bb;\n\t\n\tfore(i, 0, sz(fy)) {\n\t\tif(fx[i].y < fy[i].y) {\n\t\t\tps.push_back(fy[i].x);\n\t\t\tbb.emplace_back(fx[i].y, fy[i].y);\n\t\t}\n\t}\n\t\n\tfore(i, 0, n) {\n\t\tif(a[i] % x != 0)\n\t\t\tcontinue;\n\t\t\n\t\tint mask = 0;\n\t\tli ca = a[i];\n\t\tfore(j, 0, sz(ps)) {\n\t\t\tint cnt = 0;\n\t\t\twhile(ca % ps[j] == 0)\n\t\t\t\tca /= ps[j], cnt++;\n\t\t\tassert(cnt >= bb[j].x);\n\t\t\t\n\t\t\tmask |= (cnt > bb[j].x) << j;\n\t\t}\n\t\td[mask]++;\n\t}\n\t\n\tfor(int i = 0; i < sz(ps); i++) {\n\t\tfore(mask, 0, 1 << sz(ps))\n\t\t\tif((mask >> i) & 1)\n\t\t\t\td[mask] += d[mask ^ (1 << i)];\n\t}\n\t\n\tli ans = 0;\n\tfore(i, 0, n) {\n\t\tif(y % a[i] != 0)\n\t\t\tcontinue;\n\t\t\n\t\tint mask = 0;\n\t\tli ca = a[i];\n\t\tfore(j, 0, sz(ps)) {\n\t\t\tint cnt = 0;\n\t\t\twhile(ca % ps[j] == 0)\n\t\t\t\tca /= ps[j], cnt++;\n\t\t\tassert(cnt <= bb[j].y);\n\t\t\t\n\t\t\tmask |= (cnt < bb[j].y) << j;\n\t\t}\n\t\tans += d[mask ^ ((1 << sz(ps)) - 1)];\n\t}\n\tcout << ans << endl;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint tt = clock();\n#endif\n\tcout << fixed << setprecision(15);\n\t\n\tif(read()) {\n\t\tsolve();\n\t\t\n#ifdef _DEBUG\n\t\tcerr << \"TIME = \" << clock() - tt << endl;\n\t\ttt = clock();\n#endif\n\t}\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}