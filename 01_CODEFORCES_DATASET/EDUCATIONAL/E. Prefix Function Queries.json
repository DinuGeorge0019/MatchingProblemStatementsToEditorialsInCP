{"link": "https://codeforces.com//contest/1721/problem/E", "problemId": "1521728", "shortId": "1721E", "contest_number": "1721", "name": "E. Prefix Function Queries", "statement": "You are given a string , consisting of lowercase Latin letters.You are asked  queries about it: given another string , consisting of lowercase Latin letters, perform the following steps:  concatenate  and ;  calculate the prefix function of the resulting string ;  print the values of the prefix function on positions  ( and  denote the lengths of strings  and , respectively);  revert the string back to . The prefix function of a string  is a sequence , where  is the maximum value of  such that  and  ( denotes a contiguous substring of a string  from a position  to a position , inclusive). In other words, it's the longest proper prefix of the string  that is equal to its suffix of the same length.", "input": "The first line contains a non-empty string  (), consisting of lowercase Latin letters. The second line contains a single integer  ()\u00a0\u2014 the number of queries. Each of the next  lines contains a query: a non-empty string  (), consisting of lowercase Latin letters.", "output": "For each query, print the values of the prefix function of a string  on positions .", "tutorial": "What's the issue with calculating the prefix function on the string  and then appending the string  with an extra  recalculations? Calculating prefix function is linear anyway. Well, it's linear, but it's also amortized. So while it will make  operations for a string in total, it can take up to  on every particular letter. These particular letters can appear in string , making the algorithm work in .Let's analyze the classic way to calculate the prefix function. To append a character to the string and calculate the new value of the prefix function, you have to do the following:   take the longest proper prefix of a string before appending the letter, which is also a suffix;  if the letter right after it is the same as the new one, then the new value is length of it plus one;  if it's empty, then the new value is ;  otherwise, take its longest proper prefix and return to step . Basically, from having the value of the prefix function of the string and the new letter, you can determine the new value of the prefix function.If  was always equal to , then you would only want to try all options for the next letter after a string.That should remind you of a structure known as prefix function automaton. Its states are the values of the prefix function, and the transitions are appending a letter to a string with a certain value of the prefix function.So you can append a letter in  if you have an automaton built on the string . However, you can't just append more letters after one\u00a0\u2014 you don't have the automaton built this far.You can follow two paths.The first one is to jump with a regular way of calculating the prefix function until you reach the state of the automaton which exists.The second one is to continue building the automaton onto the string , calculating the prefix function along the way. Appending a layer to the automaton takes  non-amortized. After you calculated everything you needed, pop the states back to the original.Overall complexity:  or .", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int AL = 26;\n\nvector<int> prefix_function(const string &s){\n\tint n = s.size();\n\tvector<int> p(n);\n\tfor (int i = 1; i < n; ++i){\n\t\tint k = p[i - 1];\n\t\twhile (k > 0 && s[i] != s[k])\n\t\t\tk = p[k - 1];\n\t\tk += (s[i] == s[k]);\n\t\tp[i] = k;\n\t}\n\treturn p;\n}\n\nint main() {\n\tcin.tie(0);\n\tiostream::sync_with_stdio(false);\n\tstring s;\n\tcin >> s;\n\tint n = s.size();\n\tauto p = prefix_function(s);\n\tvector<vector<int>> A(n, vector<int>(AL));\n\tforn(i, n) forn(j, AL){\n\t\tif (i > 0 && j != s[i] - 'a')\n\t\t\tA[i][j] = A[p[i - 1]][j];\n\t\telse\n\t\t\tA[i][j] = i + (j == s[i] - 'a');\n\t}\n\tint q;\n\tcin >> q;\n\tvector<vector<int>> ans(q);\n\tforn(z, q){\n\t\tstring t;\n\t\tcin >> t;\n\t\tint m = t.size();\n\t\ts += t;\n\t\tfor (int i = n; i < n + m; ++i){\n\t\t    A.push_back(vector<int>(AL));\n\t\t\tforn(j, AL){\n\t\t\t\tif (j != s[i] - 'a')\n\t\t\t\t\tA[i][j] = A[p[i - 1]][j];\n\t\t\t\telse\n\t\t\t\t\tA[i][j] = i + (j == s[i] - 'a');\n\t\t\t}\n\t\t\tp.push_back(A[p[i - 1]][s[i] - 'a']);\n\t\t\tans[z].push_back(p[i]);\n\t\t}\n\t\tforn(_, m){\n\t\t\tp.pop_back();\n\t\t\ts.pop_back();\n\t\t\tA.pop_back();\n\t\t}\n\t}\n\tfor (auto &it : ans){\n\t\tfor (int x : it)\n\t\t\tcout << x << ' ';\n\t\tcout << '\\n';\n\t}\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}