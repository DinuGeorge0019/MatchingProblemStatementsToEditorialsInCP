{"link": "https://codeforces.com//contest/1207/problem/C", "problemId": "393973", "shortId": "1207C", "contest_number": "1207", "name": "C. Gas Pipeline", "statement": "You are responsible for installing a gas pipeline along a road. Let's consider the road (for simplicity) as a segment  on  axis. The road can have several crossroads, but for simplicity, we'll denote each crossroad as an interval  with integer . So we can represent the road as a binary string consisting of  characters, where character  means that current interval doesn't contain a crossroad, and  means that there is a crossroad.Usually, we can install the pipeline along the road on height of  unit with supporting pillars in each integer point (so, if we are responsible for  road, we must install  pillars). But on crossroads we should lift the pipeline up to the height , so the pipeline won't obstruct the way for cars.We can do so inserting several zig-zag-like lines. Each zig-zag can be represented as a segment  with integer  consisting of three parts:  units of horizontal pipe +  unit of vertical pipe +  of horizontal. Note that if pipeline is currently on height , the pillars that support it should also have length equal to  units.  Each unit of gas pipeline costs us  bourles, and each unit of pillar \u2014  bourles. So, it's not always optimal to make the whole pipeline on the height . Find the shape of the pipeline with minimum possible cost and calculate that cost.Note that you  start and finish the pipeline on height  and, also, it's guaranteed that the first and last characters of the input string are equal to .", "input": "The fist line contains one integer  () \u2014 the number of queries. Next  lines contain independent queries \u2014 one query per two lines. The first line contains three integers , ,  (, , ) \u2014 the length of the road, the cost of one unit of the pipeline and the cost of one unit of the pillar, respectively. The second line contains binary string  (, , ) \u2014 the description of the road. It's guaranteed that the total length of all strings  doesn't exceed .", "output": "Print  integers \u2014 one per query. For each query print the minimum possible cost of the constructed pipeline.", "tutorial": "This task was designed as a simple dynamic programming problem, but it also can be solved greedily.The dp solution is following: when we have already built some prefix of the pipeline all we need to know is the length of the prefix the height of the pipeline's endpoint ( or ). So we can calculate the following dynamic programming:  is the minimal answer for prefix of length  with pipeline at height . Transitions are quite straightforward: if  then we can either leave the pipeline on the same level, or change it. If  then we have to stay on the height . Look at the source code for the formal transitions. The answer is .The greedy solution is based on the following fact: let's look at some subsegment consisting of 's. It's always optimal either to leave this subsegment on height  or raise it to height . We can calculate the amount we have to pay in both cases and choose the optimal one.", "solution": "const val INF64 = 1e18.toLong()\n\nfun main(args: Array<String>) {\n    val tc = readLine()!!.toInt()\n    for (t in 1..tc) {\n        val (n, a, b) = readLine()!!.split(' ').map { it.toInt() }\n        val s = readLine()!!\n\n        val d = Array(n + 1) { arrayOf(INF64, INF64) }\n        d[0][0] = b.toLong()\n\n        for (pos in 0 until n) {\n            if (s[pos] == '0') {\n                d[pos + 1][0] = minOf(d[pos + 1][0], d[pos][0] + a + b)\n                d[pos + 1][1] = minOf(d[pos + 1][1], d[pos][0] + 2 * (a + b))\n\n                d[pos + 1][1] = minOf(d[pos + 1][1], d[pos][1] + a + 2 * b)\n                d[pos + 1][0] = minOf(d[pos + 1][0], d[pos][1] + 2 * a + b)\n            } else {\n                d[pos + 1][1] = minOf(d[pos + 1][1], d[pos][1] + a + 2 * b)\n            }\n        }\n        println(d[n][0])\n    }\n}", "interactive": false, "noSolution": false, "noTutorial": false}