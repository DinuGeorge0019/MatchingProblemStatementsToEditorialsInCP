{"link": "https://codeforces.com//contest/620/problem/E", "problemId": "45931", "shortId": "620E", "contest_number": "620", "name": "E. New Year Tree", "statement": "The New Year holidays are over, but Resha doesn't want to throw away the New Year tree. He invited his best friends Kerim and Gural to help him to redecorate the New Year tree.The New Year tree is an undirected tree with  vertices and root in the vertex .You should process the queries of the two types:  Change the colours of all vertices in the subtree of the vertex  to the colour .  Find the number of different colours in the subtree of the vertex . ", "input": "The first line contains two integers  () \u2014 the number of vertices in the tree and the number of the queries. The second line contains  integers  () \u2014 the colour of the -th vertex. Each of the next  lines contains two integers  () \u2014 the vertices of the -th edge. It is guaranteed that you are given correct undirected tree. The last  lines contains the description of the queries. Each description starts with the integer  () \u2014 the type of the -th query. For the queries of the first type then follows two integers  () \u2014 the number of the vertex whose subtree will be recoloured with the colour . For the queries of the second type then follows integer  () \u2014 the number of the vertex for which subtree you should find the number of different colours.", "output": "For each query of the second type print the integer  \u2014 the number of different colours in the subtree of the vertex given in the query. Each of the numbers should be printed on a separate line in order of query appearing in the input.", "tutorial": "Let's run dfs on the tree and write out the vertices in order of their visisiting by dfs (that permutation is called Euler walk). Easy to see that subtree of any vertex is a subsegment of that permutation. Note that the number of different colours is , so we can store the set of colours just as mask of binary bits in -bit type (*long long* in C++, long in Java). Let's build the segment tree over the permutation which supports two operations: paint subsegment by some colour and find the mask of colours of some segment.\n", "solution": "\n            #include <bits/stdc++.h>\n\u00a0\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n#define ford(i, n) for (int i = int(n) - 1; i >= 0; i--)\n#define fore(i, l, r) for (int i = int(l); i < int(r); i++)\n#define correct(x, y, n, m) (0 <= (x) && (x) < (n) && 0 <= (y) && (y) < (m))\n#define all(a) (a).begin(), (a).end()\n#define sz(a) int((a).size())\n#define pb(a) push_back(a)\n#define mp(x, y) make_pair((x), (y))\n#define x first\n#define y second\n\u00a0\nusing namespace std;\n\u00a0\ntypedef long long li;\ntypedef long double ld;\ntypedef pair<int, int> pt;\n\u00a0\ntemplate<typename X> inline X abs(const X& a) { return a < 0? -a: a; }\ntemplate<typename X> inline X sqr(const X& a) { return a * a; }\n\u00a0\nconst int INF = int(1e9);\nconst li INF64 = li(1e18);\nconst ld EPS = 1e-9, PI = 3.1415926535897932384626433832795;\n\u00a0\nconst int N = 1200300;\n\u00a0\nint n, m;\nint c[N];\nvector<int> g[N];\npair<int, pt> q[N];\n\u00a0\ninline bool read() {\n\u00a0 \u00a0 if (!(cin >> n >> m)) return false;\n\u00a0 \u00a0 forn(i, n) assert(scanf(\"%d\", &c[i]) == 1);\n\u00a0 \u00a0 forn(i, n) g[i].clear();\n\u00a0 \u00a0 forn(i, n - 1) {\n\u00a0 \u00a0 \u00a0 \u00a0 int x, y;\n\u00a0 \u00a0 \u00a0 \u00a0 assert(scanf(\"%d%d\", &x, &y) == 2);\n\u00a0 \u00a0 \u00a0 \u00a0 x--, y--;\n\u00a0 \u00a0 \u00a0 \u00a0 g[x].pb(y), g[y].pb(x);\n\u00a0 \u00a0 }\n\u00a0 \u00a0 forn(i, m) {\n\u00a0 \u00a0 \u00a0 \u00a0 assert(scanf(\"%d%d\", &q[i].x, &q[i].y.x) == 2);\n\u00a0 \u00a0 \u00a0 \u00a0 q[i].y.x--;\n\u00a0 \u00a0 \u00a0 \u00a0 if (q[i].x == 1) {\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 assert(scanf(\"%d\", &q[i].y.y) == 1);\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 //q[i].y.y--;\n\u00a0 \u00a0 \u00a0 \u00a0 }\n\u00a0 \u00a0 }\n\u00a0 \u00a0 return true;\n}\n\u00a0\nint tt, tin[N], tout[N], vs[N];\n\u00a0\nvoid dfs(int v, int p) {\n\u00a0 \u00a0 vs[tt] = v;\n\u00a0 \u00a0 tin[v] = tt++;\n\u00a0 \u00a0 forn(i, sz(g[v])) if (g[v][i] != p) dfs(g[v][i], v);\n\u00a0 \u00a0 tout[v] = tt;\n}\n\u00a0\nli t[4 * N], add[4 * N];\n\u00a0\nvoid build(int v, int l, int r) {\n\u00a0 \u00a0 add[v] = -1;\n\u00a0 \u00a0 if (l + 1 == r) t[v] = 1ll << c[vs[l]];\n\u00a0 \u00a0 else {\n\u00a0 \u00a0 \u00a0 \u00a0 int md = (l + r) >> 1;\n\u00a0 \u00a0 \u00a0 \u00a0 build(2 * v + 1, l, md);\n\u00a0 \u00a0 \u00a0 \u00a0 build(2 * v + 2, md, r);\n\u00a0 \u00a0 \u00a0 \u00a0 t[v] = t[2 * v + 1] | t[2 * v + 2];\n\u00a0 \u00a0 }\n}\n\u00a0\ninline void push(int v) {\n\u00a0 \u00a0 if (add[v] == -1) return;\n\u00a0 \u00a0 fore(i, 1, 3)\n\u00a0 \u00a0 \u00a0 \u00a0 t[2 * v + i] = add[2 * v + i] = add[v];\n\u00a0 \u00a0 add[v] = -1;\n}\n\u00a0\nvoid paint(int v, int l, int r, int lf, int rg, int c) {\n\u00a0 \u00a0 if (lf >= rg) return;\n\u00a0 \u00a0 if (l == lf && r == rg) {\n\u00a0 \u00a0 \u00a0 \u00a0 t[v] = 1ll << c;\n\u00a0 \u00a0 \u00a0 \u00a0 add[v] = 1ll << c;\n\u00a0 \u00a0 } else {\n\u00a0 \u00a0 \u00a0 \u00a0 push(v);\n\u00a0 \u00a0 \u00a0 \u00a0 int md = (l + r) >> 1;\n\u00a0 \u00a0 \u00a0 \u00a0 paint(2 * v + 1, l, md, lf, min(md, rg), c);\n\u00a0 \u00a0 \u00a0 \u00a0 paint(2 * v + 2, md, r, max(lf, md), rg, c);\n\u00a0 \u00a0 \u00a0 \u00a0 t[v] = t[2 * v + 1] | t[2 * v + 2];\n\u00a0 \u00a0 }\n}\n\u00a0\nli get(int v, int l, int r, int lf, int rg) {\n\u00a0 \u00a0 if (lf >= rg) return 0;\n\u00a0 \u00a0 if (l == lf && r == rg) return t[v];\n\u00a0 \u00a0 push(v);\n\u00a0 \u00a0 int md = (l + r) >> 1;\n\u00a0 \u00a0 li ans = 0;\n\u00a0 \u00a0 ans |= get(2 * v + 1, l, md, lf, min(md, rg));\n\u00a0 \u00a0 ans |= get(2 * v + 2, md, r, max(lf, md), rg);\n\u00a0 \u00a0 return ans;\n}\n\u00a0\ninline void solve() {\n\u00a0 \u00a0 tt = 0;\n\u00a0 \u00a0 dfs(0, -1);\n\u00a0 \u00a0 assert(tt == n);\n\u00a0 \u00a0 build(0, 0, n);\n\u00a0\n\u00a0 \u00a0 forn(i, m) {\n\u00a0 \u00a0 \u00a0 \u00a0 int tp = q[i].x, v = q[i].y.x;\n\u00a0 \u00a0 \u00a0 \u00a0 if (tp == 1) {\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 int c = q[i].y.y;\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 paint(0, 0, n, tin[v], tout[v], c);\n\u00a0 \u00a0 \u00a0 \u00a0 } else {\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 li mask = get(0, 0, n, tin[v], tout[v]);\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 /*cerr << mask << endl;\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 cerr << v << ' ' << tin[v] << ' ' << tout[v] << endl;\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 fore(i, tin[v], tout[v]) cerr << get(0, 0, n, i, i + 1) << ' '; cerr << endl;*/\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 int ans = 0;\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 forn(j, 61) ans += int((mask >> j) & 1);\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 printf(\"%d\\n\", ans);\n\u00a0 \u00a0 \u00a0 \u00a0 }\n\u00a0 \u00a0 }\n}\n\u00a0\nint main() {\n#ifdef SU1\n\u00a0 \u00a0 assert(freopen(\"input.txt\", \"rt\", stdin));\n\u00a0 \u00a0 //assert(freopen(\"output.txt\", \"wt\", stdout));\n#endif\n\u00a0 \u00a0 \n\u00a0 \u00a0 cout << setprecision(10) << fixed;\n\u00a0 \u00a0 cerr << setprecision(5) << fixed;\n\u00a0\n\u00a0 \u00a0 while (read()) {\n\u00a0 \u00a0 \u00a0 \u00a0 solve();\n\u00a0 \u00a0 \u00a0 \u00a0 //break;\n\u00a0 \u00a0 }\n\u00a0 \u00a0 \n\u00a0 \u00a0 return 0;\n}\n        ", "interactive": false, "noSolution": false, "noTutorial": false}