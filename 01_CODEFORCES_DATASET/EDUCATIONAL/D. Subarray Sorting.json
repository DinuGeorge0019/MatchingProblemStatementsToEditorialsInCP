{"link": "https://codeforces.com//contest/1187/problem/D", "problemId": "365120", "shortId": "1187D", "contest_number": "1187", "name": "D. Subarray Sorting", "statement": "You are given an array  and an array .For one operation you can sort in non-decreasing order any subarray  of the array .For example, if  and you choose subbarray , then the array turns into . You are asked to determine whether it is possible to obtain the array  by applying this operation any number of times (possibly zero) to the array .", "input": "The first line contains one integer  () \u2014 the number of queries. The first line of each query contains one integer  (). The second line of each query contains  integers  (). The third line of each query contains  integers  (). It is guaranteed that  over all queries in a test.", "output": "For each query print  (in any letter case) if it is possible to obtain an array  and  (in any letter case) otherwise.", "tutorial": "Let's reformulate this problem in next form: we can sort only subarray of length 2 (swap two consecutive elements  and  if ). It is simular tasks because we can sort any array by sorting subbarray of length 2 (for example bubble sort does exactly that). Now lets look at elements  and . If  then we will solve this task for arrays  and . Otherwise lets look at minimum position  such that  (if there is no such position then answer to the problem is ). We can move element  to the beginning of array only if all elements  greater then . In other words any index  such that  must be greater then . And if this condition holds, then we just delete element  and solve task for arrays  and .But instead of deleting this element  we will change information about minimum index  such that . This index will be the minimum index  such that  and .For do this we will maintain  stacks  such that for any element  of stack  condition  holds and moreover all elements in stacks are sorted in ascending order (the top element of stack is minimal). For example if , then , , , . For finding minimum element on top of stacks  we can use some data structure (for example segment tree).", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(3e5) + 99;\nconst int INF = int(1e9) + 99;\n\nint t, n;\nint a[N], b[N];\nvector <int> p[N];\nint st[4 * N + 55];\n\nint getMin(int v, int l, int r, int L, int R){\n\tif(L >= R) return INF;\n\tif(l == L && r == R)\n\t\treturn st[v];\n\n\tint mid = (l + r) / 2;\n\treturn min(getMin(v * 2 + 1, l, mid, L, min(R, mid)),\n\t\tgetMin(v * 2 + 2, mid, r, max(mid, L), R));\t\n}\n\nvoid upd(int v, int l, int r, int pos, int x){\n\tif(r - l == 1){\n\t\tst[v] = x;\n\t\treturn;\n\t}\n\n\tint mid = (l + r) / 2;\n\tif(pos < mid) upd(v * 2 + 1, l, mid, pos, x);\n\telse upd(v * 2 + 2, mid, r, pos, x);\n\t\t\n\tst[v] = min(st[v * 2 + 1], st[v * 2 + 2]);\n}\n\nint main() {\n\tscanf(\"%d\", &t);\n\tfor(int tc = 0; tc < t; ++tc){\n\t\tscanf(\"%d\", &n);\n\t\tfor(int i = 0; i < n; ++i)\n\t\t\tp[i].clear();\t\t\t\t\t\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tscanf(\"%d\", a + i);\n\t\t\t--a[i];\n\t\t\tp[a[i]].push_back(i);\t\n\t\t}\t\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tscanf(\"%d\", b + i);\t\n\t\t\t--b[i];\t\t\n\t\t}\n\n\t\tfor(int i = 0; i < 4 * n; ++i) st[i] = INF;\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\treverse(p[i].begin(), p[i].end());\n\t\t\tif(!p[i].empty()) upd(0, 0, n, i, p[i].back());\n\t\t}\n\n\t\tbool ok = true;\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tif(p[b[i]].empty()){\n\t\t\t\tok = false;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint pos = p[b[i]].back();\n\t\t\tif(getMin(0, 0, n, 0, b[i]) < pos){\n\t\t\t\tok = false;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tp[b[i]].pop_back();\n\t\t\tupd(0, 0, n, b[i], p[b[i]].empty()? INF : p[b[i]].back());\t\t\t\n\t\t}\n\n\t\tif(ok) puts(\"YES\");\n\t\telse puts(\"NO\");\n\t}\t\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}