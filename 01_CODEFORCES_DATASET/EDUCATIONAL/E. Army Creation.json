{"link": "https://codeforces.com//contest/813/problem/E", "problemId": "108592", "shortId": "813E", "contest_number": "813", "name": "E. Army Creation", "statement": "As you might remember from our previous rounds, Vova really likes computer games. Now he is playing a strategy game known as Rage of Empires.In the game Vova can hire  different warriors; th warrior has the type . Vova wants to create a  army hiring some subset of warriors. An army is called  if for each type of warrior present in the game there are not more than  warriors of this type in the army. Of course, Vova wants his army to be as large as possible.To make things more complicated, Vova has to consider  different plans of creating his army. th plan allows him to hire only warriors whose numbers are not less than  and not greater than .Help Vova to determine the largest size of a  army for each plan.", "input": "The first line contains two integers  and  (). The second line contains  integers , , ...  (). The third line contains one integer  (). Then  lines follow. th line contains two numbers  and  which represent th plan (). You have to keep track of the answer to the last plan (let's call it ). In the beginning . Then to restore values of  and  for the th plan, you have to do the following:   ;  ;  If , swap  and . ", "output": "Print  numbers. th number must be equal to the maximum size of a  army when considering th plan.", "tutorial": "Every time we process a plan, let's count only the first  warriors of some type.When will the warrior on position  be counted? Of course, he has to be present in the plan, so . But also he has to be among  first warriors of his type in this plan.Let's denote a function :   is the position of previous warrior of the same type before warrior  (that is, the greatest  such that  and ). If there's no any, then ;   if . It is easy to prove that the warrior  will be among  first warriors in some plan iff  and .So we can make a new array : . Then we build a segment tree on this array. The node of the segment tree will store all values of  from the segment corresponding to this node (in sorted order). Then to get answer to the plan, we have to count the number of elements on segment  that are less than .Complexity is , or  if you use fractional cascading technique.", "solution": "// eddy1021\n#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef double D;\ntypedef long double LD;\ntypedef long long LL;\ntypedef pair<int,int> PII;\ntypedef pair<LL,LL> PLL;\n#define mod9 1000000009LL\n#define mod7 1000000007LL\n#define INF  1023456789LL\n#define INF16 10000000000000000LL\n#define eps 1e-9\n#define SZ(x) (int)(x).size()\n#define ALL(x) (x).begin(), (x).end()\n#define IOS ios_base::sync_with_stdio(0); cin.tie(0)\n#ifndef ONLINE_JUDGE\n#define debug(...) printf(__VA_ARGS__)\n#else \n#define debug(...)\n#endif\ninline LL getint(){\n  LL _x=0,_tmp=1; char _tc=getchar();    \n  while( (_tc<'0'||_tc>'9')&&_tc!='-' ) _tc=getchar();\n  if( _tc == '-' ) _tc=getchar() , _tmp = -1;\n  while(_tc>='0'&&_tc<='9') _x*=10,_x+=(_tc-'0'),_tc=getchar();\n  return _x*_tmp;\n}\ninline LL add( LL _x , LL _y , LL _mod = mod7 ){\n  _x += _y;\n  return _x >= _mod ? _x - _mod : _x;\n}\ninline LL sub( LL _x , LL _y , LL _mod = mod7 ){\n  _x -= _y;\n  return _x < 0 ? _x + _mod : _x;\n}\ninline LL mul( LL _x , LL _y , LL _mod = mod7 ){\n  _x *= _y;\n  return _x >= _mod ? _x % _mod : _x;\n}\nLL mypow( LL _a , LL _x , LL _mod ){\n  if( _x == 0 ) return 1LL;\n  LL _ret = mypow( mul( _a , _a , _mod ) , _x >> 1 , _mod );\n  if( _x & 1 ) _ret = mul( _ret , _a , _mod );\n  return _ret;\n}\nLL mymul( LL _a , LL _x , LL _mod ){\n  if( _x == 0 ) return 0LL;\n  LL _ret = mymul( add( _a , _a , _mod ) , _x >> 1 , _mod );\n  if( _x & 1 ) _ret = add( _ret , _a , _mod );\n  return _ret;\n}\ninline bool equal( D _x ,  D _y ){\n  return _x > _y - eps && _x < _y + eps;\n}\n#define Bye exit(0)\nint __ = 1 , _cs;\n/*********default*********/\nstruct Nd{\n  Nd *tl , *tr;\n  int sum;\n  Nd(){\n    tl = tr = NULL;\n    sum = 0;\n  }\n};\nNd* copy( Nd* t ){\n  Nd* ret = new Nd();\n  if( t ){\n    ret->tl = t->tl;\n    ret->tr = t->tr;\n    ret->sum = t->sum;\n  }\n  return ret;\n}\nint Sum( Nd* t ){\n  return t ? t->sum : 0;\n}\n#define mid ((l+r)>>1)\nvoid modify( Nd* t , int l , int r , int p , int dlt ){\n  if( l == r ){\n    t->sum += dlt;\n    return;\n  }\n  if( p <= mid ){\n    t->tl = copy( t->tl );\n    modify( t->tl , l , mid , p , dlt );\n  }else{\n    t->tr = copy( t->tr );\n    modify( t->tr , mid + 1 , r , p , dlt );\n  }\n  t->sum = Sum( t->tl ) + Sum( t->tr );\n}\nint query( Nd* t , int l , int r , int ql , int qr ){\n  if( !t or r < ql or l > qr ) return 0;\n  if( ql <= l and r <= qr ) return t->sum;\n  return query( t->tl , l , mid , ql , qr ) +\n         query( t->tr , mid + 1 , r , ql , qr );\n}\nvoid build(){\n\n}\n#define N 101021\nint n , k;\nqueue<int> q[ N ];\nNd* root[ N ];\nvoid init(){\n  n = getint();\n  k = getint();\n  for( int i = 1 ; i <= n ; i ++ ){\n    int ai = getint();\n    root[ i ] = copy( root[ i - 1 ] );\n    modify( root[ i ] , 1 , n , i , +1 );\n    q[ ai ].push( i );\n    if( (int)q[ ai ].size() > k ){\n      modify( root[ i ] , 1 , n , q[ ai ].front() , -1 );\n      q[ ai ].pop();\n    }\n  }\n}\nvoid solve(){\n  int last = 0;\n  int qq = getint(); while( qq -- ){\n    int ql = ( getint() + last ) % n + 1;\n    int qr = ( getint() + last ) % n + 1;\n    if( ql > qr ) swap( ql , qr );\n    last = query( root[ qr ] , 1 , n , ql , qr );\n    printf( \"%d\\n\" , last );\n  }\n}\nint main(){\n  build();\n  //__ = getint(); \n  while( __ -- ){\n    init();\n    solve();\n  }\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}