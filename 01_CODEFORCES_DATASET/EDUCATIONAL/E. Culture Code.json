{"link": "https://codeforces.com//contest/1197/problem/E", "problemId": "376706", "shortId": "1197E", "contest_number": "1197", "name": "E. Culture Code", "statement": "There are famous Russian nesting dolls named matryoshkas sold in one of the souvenir stores nearby, and you'd like to buy several of them. The store has  different matryoshkas. Any matryoshka is a figure of volume  with an empty space inside of volume  (of course, ).You don't have much free space inside your bag, but, fortunately, you know that matryoshkas can be nested one inside another. Formally, let's call a set of matryoshkas  if we can rearrange dolls in such a way, that the first doll can be nested inside the second one, the second doll \u2014 inside the third one and so on. Matryoshka  can be nested inside matryoshka  if . So only the last doll will take space inside your bag.Let's call  of a nested set of dolls as a total volume of empty space inside this structure. Obviously, it's equal to , where , , ...,  are the indices of the chosen dolls in the order they are nested in each other.Finally, let's call a nested subset of the given sequence as  if there isn't any doll from the sequence that can be added to the nested subset without breaking its nested property.You want to buy many matryoshkas, so you should choose a  nested subset to buy it. But you will be disappointed if too much space in your bag will be wasted, so you want to choose a big enough subset so that its  is minimum possible among all big enough subsets. Now you wonder, how many different nested subsets meet these conditions (they are big enough, and there is no big enough subset such that its extra space is less than the extra space of the chosen subset). Two subsets are considered different if there exists at least one index  such that one of the subsets contains the -th doll, and another subset doesn't.Since the answer can be large, print it modulo .", "input": "The first line contains a single integer  () \u2014 the number of matryoshkas. The next  lines contain a description of each doll: two integers  and  () \u2014 the outer and inners volumes of the -th matryoshka.", "output": "Print one integer \u2014 the number of big enough nested subsets such that extra space of each of these subsets is minimum possible. Since the answer can be large, print it modulo .", "tutorial": "Let's, at first, sort all matryoshkas by increasing its inner volume $$$in_i$$$. Then each nested subset will appear as subsequence in its \"canonical\" order. Now we'll write the DP with $$$d[i] = (x, y)$$$ \u2014 the minimum extra space $$$x$$$ and number of such subsequences $$$y$$$ among all nested subsets, where the $$$i$$$-th doll is . Why minimal (not maximal, for example)? It's just easier transitions (and easier proof). There are two main cases. If there isn't $$$j$$$, such that $$$out_i \\le in_j$$$ then we can't put the $$$i$$$-th doll inside any other. So, $$$d[i] = (in_i, 1)$$$.Otherwise, we must put the $$$i$$$-th doll inside other doll (otherwise, the subset won't be a big enough). If we put the $$$i$$$-th doll inside the $$$j$$$-th doll then we extra space of such subset is equal to $$$d[j].first - (out_i - in_i)$$$. Since we minimize the extra space, then $$$$$$d[i].first = \\min\\limits_{out_i \\le in_j}{(d[j].first - (out_i - in_i))} = \\min\\limits_{out_i \\le in_j}{(d[j].first)} - (out_i - in_i).$$$$$$Since we sorted all matryoshkas, so there is a position $$$pos$$$ such that $$$\\forall j \\ge pos : out_i \\le in_j$$$ and $$$d[i].first = \\min\\limits_{j = pos}^{n}{(d[j].first)} - (out_i - in_i)$$$. The $$$d[i].second$$$ is just a sum from all minimums.As you can see: we can store $$$d[i]$$$ in Segment Tree with minimum + number of minimums. Why in the second transition we will build only  subsets? It's because not big enough subsets are not optimal in terms of minimality of extra space.The result complexity is $$$O(n \\log(n))$$$.", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) int((a).size())\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef long double ld;\ntypedef pair<int, int> pt;\n\nconst int INF = int(1e9) + 555;\nconst li INF64 = li(1e18);\nconst ld EPS = 1e-9;\n\nconst int MOD = int(1e9) + 7;\n\nint norm(int a) {\n\tif(a >= MOD) a -= MOD;\n\tif(a < 0) a += MOD;\n\treturn a;\n}\n\npt combine(const pt &a, const pt &b) {\n\tif(a.x < b.x)\n\t\treturn a;\n\tif(a.x > b.x)\n\t\treturn b;\n\treturn {a.x, norm(a.y + b.y)};\n}\n\nint n;\nvector<pt> p;\n\ninline bool read() {\n\tif(!(cin >> n))\n\t\treturn false;\n\tp.resize(n);\n\tfore(i, 0, n)\n\t\tcin >> p[i].x >> p[i].y;\n\t\n\treturn true;\n}\n\nvector<pt> T;\n\nvoid setVal(int pos, const pt &val) {\n\tT[pos += n] = val;\n\tfor(pos >>= 1; pos > 0; pos >>= 1)\n\t\tT[pos] = combine(T[2 * pos], T[2 * pos + 1]);\n}\n\npt getMin(int l, int r) {\n\tpt ans = {INF, 0};\n\tfor(l += n, r += n; l < r; l >>= 1, r >>= 1) {\n\t\tif(l & 1)\n\t\t\tans = combine(T[l++], ans);\n\t\tif(r & 1)\n\t\t\tans = combine(T[--r], ans);\n\t}\n\treturn ans;\n}\n\ninline void solve() {\n\tauto comp = [](const pt &a, const pt &b) {\n\t\tif(a.y != b.y)\n\t\t\treturn a.y < b.y;\n\t\treturn a.x < b.x;\n\t};\n\t\n\tsort(p.begin(), p.end(), comp);\n\t\n\tT.assign(2 * n, {INF, 0});\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tint pos = int(lower_bound(p.begin(), p.end(), pt(0, p[i].x), comp) - p.begin());\n\t\t\n\t\tif(pos >= n) {\n\t\t\tsetVal(i, {p[i].y, 1});\n\t\t\tcontinue;\n\t\t}\n\t\tpt bst = getMin(pos, n);\n\t\tsetVal(i, {bst.x - (p[i].x - p[i].y), bst.y});\n\t}\n\t\n\tcout << getMin(0, n).y << endl;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint tt = clock();\n#endif\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0), cout.tie(0);\n\tcout << fixed << setprecision(15);\n\t\n\tif(read()) {\n\t\tsolve();\n\t\t\n#ifdef _DEBUG\n\t\tcerr << \"TIME = \" << clock() - tt << endl;\n\t\ttt = clock();\n#endif\n\t}\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}