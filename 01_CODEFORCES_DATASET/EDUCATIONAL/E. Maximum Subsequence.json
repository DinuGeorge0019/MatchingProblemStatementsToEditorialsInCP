{"link": "https://codeforces.com//contest/888/problem/E", "problemId": "133218", "shortId": "888E", "contest_number": "888", "name": "E. Maximum Subsequence", "statement": "You are given an array  consisting of  integers, and additionally an integer . You have to choose some sequence of indices  () in such a way that the value of  is maximized. Chosen sequence can be empty.Print the maximum possible value of .", "input": "The first line contains two integers  and  (, ). The second line contains  integers , , ...,  ().", "output": "Print the maximum possible value of .", "tutorial": "Let's consider the naive solution in  or . Iterate over all subsets of original set, calculate sums and take maximum of them modulo .Now we can use meet-in-the-middle technique to optimize it to . Preprocess the first  elements naively and push sums modulo  to some array. After this process the second half with following algorithm. Take sum of the set and find the greatest total sum of current and some sum in the array. As any sum of two numbers less than  can go no greater than , we can consider just two values: the greatest number in array and the greatest number less than  in the array. This can be found by binary search over sorted array.Overall complexity: .", "solution": "// eddy1021\n#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef double D;\ntypedef long double LD;\ntypedef long long LL;\ntypedef pair<int,int> PII;\ntypedef pair<LL,LL> PLL;\n#define mod9 1000000009LL\n#define mod7 1000000007LL\n#define INF  1023456789LL\n#define INF16 10000000000000000LL\n#define eps 1e-9\n#define SZ(x) (int)(x).size()\n#define ALL(x) (x).begin(), (x).end()\n#define IOS ios_base::sync_with_stdio(0); cin.tie(0)\n#ifndef ONLINE_JUDGE\n#define debug(...) printf(__VA_ARGS__)\n#else \n#define debug(...)\n#endif\ninline LL getint(){\n  LL _x=0,_tmp=1; char _tc=getchar();    \n  while( (_tc<'0'||_tc>'9')&&_tc!='-' ) _tc=getchar();\n  if( _tc == '-' ) _tc=getchar() , _tmp = -1;\n  while(_tc>='0'&&_tc<='9') _x*=10,_x+=(_tc-'0'),_tc=getchar();\n  return _x*_tmp;\n}\ninline LL add( LL _x , LL _y , LL _mod = mod7 ){\n  _x += _y;\n  return _x >= _mod ? _x - _mod : _x;\n}\ninline LL sub( LL _x , LL _y , LL _mod = mod7 ){\n  _x -= _y;\n  return _x < 0 ? _x + _mod : _x;\n}\ninline LL mul( LL _x , LL _y , LL _mod = mod7 ){\n  _x *= _y;\n  return _x >= _mod ? _x % _mod : _x;\n}\nLL mypow( LL _a , LL _x , LL _mod ){\n  if( _x == 0 ) return 1LL;\n  LL _ret = mypow( mul( _a , _a , _mod ) , _x >> 1 , _mod );\n  if( _x & 1 ) _ret = mul( _ret , _a , _mod );\n  return _ret;\n}\nLL mymul( LL _a , LL _x , LL _mod ){\n  if( _x == 0 ) return 0LL;\n  LL _ret = mymul( add( _a , _a , _mod ) , _x >> 1 , _mod );\n  if( _x & 1 ) _ret = add( _ret , _a , _mod );\n  return _ret;\n}\ninline bool equal( D _x ,  D _y ){\n  return _x > _y - eps && _x < _y + eps;\n}\nvoid sleep( double sec = 1021 ){\n  clock_t s = clock();\n  while( clock() - s < CLOCKS_PER_SEC * sec );\n}\n#define Bye exit(0)\nint __ = 1 , _cs;\n/*********default*********/\nvoid build(){\n\n}\n#define N 35\nLL n , m , a[ N ] , ans;\nvoid init(){\n  n = getint();\n  m = getint();\n  for( int i = 0 ; i < n ; i ++ )\n    a[ i ] = getint();\n}\nset<LL> v;\nvoid solve(){\n  int hf = n / 2 , nhf = n - hf;\n  for( int i = 0 ; i < (1 << hf) ; i ++ ){\n    LL s = 0;\n    for( int j = 0 ; j < hf ; j ++ )\n      if( (i >> j) & 1 )\n        s += a[ j ];\n    v.insert( s % m );\n  }\n  for( int i = 0 ; i < (1 << nhf) ; i ++ ){\n    LL s = 0;\n    for( int j = 0 ; j < nhf ; j ++ )\n      if( (i >> j) & 1 )\n        s += a[ hf + j ];\n    s %= m;\n    if( v.empty() ) ans = max( ans , s );\n    else{\n      auto it = v.upper_bound( m - 1 - s );\n      if( it == v.begin() ) it = --v.end();\n      else it --;\n      ans = max( ans , s + *it );\n    }\n  }\n  cout << ans << endl;\n}\nint main(){\n  build();\n  //__ = getint();\n  while( __ -- ){\n    init();\n    solve();\n  }\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}