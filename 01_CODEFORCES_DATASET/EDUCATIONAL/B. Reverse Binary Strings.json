{"link": "https://codeforces.com//contest/1437/problem/B", "problemId": "775840", "shortId": "1437B", "contest_number": "1437", "name": "B. Reverse Binary Strings", "statement": "You are given a string  of even length . String  is binary, in other words, consists only of 's and 's.String  has exactly  zeroes and  ones ( is even).In one operation you can reverse any substring of . A substring of a string is a contiguous subsequence of that string.What is the minimum number of operations you need to make string  ? A string is alternating if  for all . There are two types of alternating strings in general:  or ", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of test cases. The first line of each test case contains a single integer  (;  is even)\u00a0\u2014 the length of string . The second line of each test case contains a binary string  of length  ( {, }). String  has exactly  zeroes and  ones. It's guaranteed that the total sum of  over test cases doesn't exceed .", "output": "For each test case, print the minimum number of operations to make  alternating.", "tutorial": "We need to make our string alternating, i. e. . When we reverse substring , we change no more than two pairs  and . Moreover, one pair should be a consecutive pair  and other\u00a0\u2014 . So, we can find lower bound to our answer as maximum between number of pairs of  and number of pairs of . And we can always reach this lower bound, by pairing  with  or with left/right border of . Another way to count the answer is next: suppose we want to make string , then let's transform  to  +  + . For example, if  , we will get . We claim that after this transformation, we will have equal number of  and , so the answer is the number of consecutive pairs of the same character divided by two. The answer is the minimum between answers for  +  +  and  +  + .", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) int((a).size())\n\nconst int INF = int(1e9);\n\nint n;\nstring s;\n\ninline bool read() {\n\tif(!(cin >> n >> s))\n\t\treturn false;\n\treturn true;\n}\n\nint cntSame(const string &s) {\n\tint ans = 0;\n\tfore (i, 1, sz(s))\n\t\tans += (s[i - 1] == s[i]);\n\tassert(ans % 2 == 0);\n\treturn ans / 2;\n}\n\ninline void solve() {\n\tint ans = INF;\n\tfore (k, 0, 2) {\n\t\tans = min(ans, cntSame(string(1, '0' + k) + s + string(1, '1' - k)));\n\t}\n\tcout << ans << endl;\n}\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0), cout.tie(0);\n\tcout << fixed << setprecision(15);\n\t\n\tint tc; cin >> tc;\n\twhile(tc--) {\n\t\tassert(read());\n\t\tsolve();\n\t}\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}