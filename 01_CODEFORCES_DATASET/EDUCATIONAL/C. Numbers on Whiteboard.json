{"link": "https://codeforces.com//contest/1430/problem/C", "problemId": "755155", "shortId": "1430C", "contest_number": "1430", "name": "C. Numbers on Whiteboard", "statement": "Numbers  (each integer from  to  once) are written on a board. In one operation you can erase any two numbers  and  from the board and write one integer   instead.You should perform the given operation  times and make the resulting number that will be left on the board as small as possible. For example, if , the following course of action is optimal:  choose  and , so the new number is , and the whiteboard contains ;  choose  and , so the new number is , and the whiteboard contains ;  choose  and , so the new number is , and the whiteboard contains . It's easy to see that after  operations, there will be left only one number. Your goal is to minimize it.", "input": "The first line contains one integer  ()\u00a0\u2014 the number of test cases. The only line of each test case contains one integer  ()\u00a0\u2014 the number of integers written on the board initially. It's guaranteed that the total sum of  over test cases doesn't exceed .", "output": "For each test case, in the first line, print the minimum possible number left on the board after  operations. Each of the next  lines should contain two integers\u00a0\u2014 numbers  and  chosen and erased in each operation.", "tutorial": "It's easy to see that we can't get the result less than , because, if we merge two positive numbers, and at least one of them is  or greater, the new number is always greater than . So we can't get rid of all numbers greater than .To always achieve , we can use a greedy algorithm: always merge two maximum numbers. During the first step, we merge  and , get ; then we merge  and , get ; then we merge  and , get ; and it's easy to see that the last operation is merging  and , so the result is .", "solution": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <cassert>\n#include <iomanip>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <ctime>\n#include <cmath>\n\n#define forn(i, n) for(int i=0;i<n;++i)\n#define fore(i, l, r) for(int i = int(l); i <= int(r); ++i)\n#define sz(v) int(v.size())\n#define all(v) v.begin(), v.end()\n#define pb push_back\n#define mp make_pair\n#define x first\n#define y1 ________y1\n#define y second\n#define ft first\n#define sc second\n#define pt pair<int, int>\n\ntemplate<typename X> inline X abs(const X& a) { return a < 0? -a: a; }\ntemplate<typename X> inline X sqr(const X& a) { return a * a; }\n\ntypedef long long li;\ntypedef long double ld;\n\nusing namespace std;\n\nconst int INF = 1000 * 1000 * 1000;\nconst ld EPS = 1e-9;\nconst ld PI = acos(-1.0);\n\nint n;\n\ninline void read() {\t\n\tcin >> n;\n}\n\ninline void solve() {\n\tmultiset<int> was;\n\tfor (int i = 1; i <= n; i++) {\n\t\twas.insert(i);\n\t}\n\tvector<pair<int, int> > ans;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tauto it = was.end();\n\t\tit--;\n\t\tint a = *it;\n\t\twas.erase(it);\n\t\tit = was.end();\n\t\tit--;\n\t\tint b = *it;\n\t\twas.erase(it);\n\t\twas.insert((a + b + 1) / 2);\n\t\tans.pb(mp(a, b));\n\t}\n\tcout << *was.begin() << endl;\n\tfor (int i = 0; i < sz(ans); i++) {\n\t\tcout << ans[i].ft << ' ' << ans[i].sc << endl;\n\t}\t\n}\n\nint main () {\n#ifdef fcspartakm\n    freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n#endif\n    cerr << setprecision(10) << fixed;\n    \n    int t; cin >> t;\n    while(t--) {\n    \tread();\n    \tsolve();\n    }\n    //cerr << \"TIME: \" << clock() << endl;\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}