{"link": "https://codeforces.com//contest/1312/problem/E", "problemId": "557981", "shortId": "1312E", "contest_number": "1312", "name": "E. Array Shrinking", "statement": "You are given an array . You can perform the following operation any number of times:  Choose a pair of two neighboring equal elements  (if there is at least one such pair).  Replace them by one element with value . After each such operation, the length of the array will decrease by one (and elements are renumerated accordingly). What is the minimum possible length of the array  you can get?", "input": "The first line contains the single integer  () \u2014 the initial length of the array . The second line contains  integers  () \u2014 the initial array .", "output": "Print the only integer \u2014 the minimum possible length you can get after performing the operation described above any number of times.", "tutorial": "Let's look at the answer: by construction, each element in the final answer was the result of replace series of elements on the corresponding segment. So all we need to find is the minimal (by size) partition of the array  on segments where each segment can be transformed in one element by series of replaces.We can calculate it using standard prefix dynamic programming, or  is the size of such minimal partition of a prefix of length . The transitions are standard: let's check all segments  and if it can be replaced by one element let's relax .Now we need to check for all segments of  \u2014 can it be replaced by one element. Let's calculate another  using the following fact: if there is a way to replace all segment as one element so the segment either has the length  or it can be divided into two parts where the prefix can be replaced by one element, the suffix also can be replaced by one element and these elements are equal. It's exactly the transitions we need to check to calculate .The resulting complexity is .", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) int((a).size())\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef long double ld;\ntypedef pair<int, int> pt;\n\ntemplate<class A, class B> ostream& operator <<(ostream& out, const pair<A, B> &p) {\n    return out << \"(\" << p.x << \", \" << p.y << \")\";\n}\ntemplate<class A> ostream& operator <<(ostream& out, const vector<A> &v) {\n    out << \"[\";\n    fore(i, 0, sz(v)) {\n        if(i) out << \", \";\n        out << v[i];\n    }\n    return out << \"]\";\n}\n\nconst int INF = int(1e9);\nconst li INF64 = li(1e18);\nconst ld EPS = 1e-9;\n\nconst int N = 555;\nint n, a[N];\n\ninline bool read() {\n    if(!(cin >> n))\n        return false;\n    fore(i, 0, n)\n        cin >> a[i];\n    return true;\n}\n\nint dp[N][N];\n\nint calcDP(int l, int r) {\n    assert(l < r);\n    if(l + 1 == r)\n        return dp[l][r] = a[l];\n    if(dp[l][r] != 0)\n        return dp[l][r];\n    \n    dp[l][r] = -1;\n    fore(mid, l + 1, r) {\n        int lf = calcDP(l, mid);\n        int rg = calcDP(mid, r);\n        if(lf > 0 && lf == rg)\n            return dp[l][r] = lf + 1;\n    }\n    return dp[l][r];\n}\n\nint dp2[N];\n\ninline void solve() {\n    fore(i, 0, N)\n        dp2[i] = INF;\n    \n    dp2[0] = 0;\n    fore(i, 0, n) {\n        fore(j, i + 1, n + 1) {\n            if(calcDP(i, j) > 0)\n                dp2[j] = min(dp2[j], dp2[i] + 1);\n        }\n    }\n    cout << dp2[n] << endl;\n}\n\nint main() {\n#ifdef _DEBUG\n    freopen(\"input.txt\", \"r\", stdin);\n    int tt = clock();\n#endif\n    ios_base::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n    cout << fixed << setprecision(15);\n    \n    if(read()) {\n        solve();\n        \n#ifdef _DEBUG\n        cerr << \"TIME = \" << clock() - tt << endl;\n        tt = clock();\n#endif\n    }\n    return 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}