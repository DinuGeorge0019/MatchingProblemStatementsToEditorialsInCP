{"link": "https://codeforces.com//contest/920/problem/D", "problemId": "152864", "shortId": "920D", "contest_number": "920", "name": "D. Tanks", "statement": "Petya sometimes has to water his field. To water the field, Petya needs a tank with exactly  ml of water.Petya has got  tanks, -th of them initially containing  ml of water. The tanks are really large, any of them can contain any amount of water (no matter how large this amount is).Also Petya has got a scoop that can contain up to  ml of water (initially the scoop is empty). This scoop can be used to get some water from some tank, and after that pour it all into some tank (it is impossible to get water from multiple tanks without pouring it, or leave some water in the scoop when pouring it). When Petya tries to get some water from a tank, he gets  water, where  is the current volume of water in the tank.Is it possible to obtain a tank with exactly  ml of water using these operations? If it is possible, print a sequence of operations that allows to do it. If there are multiple ways to obtain needed amount of water in some tank, print any of them.", "input": "The first line contains  integers:  ,  , and   \u2014 the number of tanks, the maximum volume of water the scoop can contain, and the required amount of water in some tank, respectively. The second line contains  integers  , where  is initial volume of water in -th tank.", "output": "If it is impossible to obtain a tank with exactly  ml of water, print .  Otherwise print  in the first line, and beginning from the second line, print the sequence of operations in the following format:  Each line has to contain  numbers denoting a compressed operation: \"  \" , where  is the index of the tank where we get water,  is the index of the tank where we pour water, and  is the number of times we transfer water from tank  to tank .  The number of these lines .", "tutorial": "Eliminate the obvious corner case when we don't have enough water (). Now we don't consider it in editorial.Let's fix some set of tanks , and let  be  (the total amount of water in the set). If  ( and  have the same remainders modulo ), then we can transfer all water from  to one tank , transfer all water from  to another tank , and then using some number of operations transfer required amount of water from  to  (or from  to ). So we have a solution when we have some set of tanks  such that .What if we don't have such set? In this case it is impossible to solve the problem since we cannot obtain a tank with  water such that  (and, obviously, we cannot obtain a tank with exactly  water).To find this set , we may use some sort of knapsack dynamic programming.", "solution": "#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, \"/STACK:336777216\")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 17;\nll MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define Se second\n#define Fi first\n\nbool dp[5050][5050];\nbool prv[5050][5050];\nint in[5050];\nint main() {\n\tint N, K, V, i, j;\n\tscanf(\"%d %d %d\", &N, &K, &V);\n\tfor (i = 1; i <= N; i++) scanf(\"%d\", &in[i]);\n\n\tint s = 0;\n\tfor (i = 1; i <= N; i++) s += in[i];\n\tif (s < V) return !printf(\"NO\\n\");\n\n\tdp[0][0] = true;\n\tfor (i = 1; i <= N; i++) {\n\t\tint x = in[i] % K;\n\t\tfor (j = 0; j < K; j++) {\n\t\t\tif (!dp[i - 1][j]) continue;\n\t\t\tdp[i][j] = true;\n\t\t\tprv[i][j] = false;\n\n\t\t\tdp[i][(j + x) % K] = true;\n\t\t\tprv[i][(j + x) % K] = true;\n\t\t}\n\t}\n\n\tif (!dp[N][V%K]) return !printf(\"NO\\n\");\n\n\tvector <int> Vl[2];\n\tint v = V%K;\n\tfor (i = N; i >= 1; i--) {\n\t\tint x = in[i] % K;\n\t\tif (prv[i][v]) {\n\t\t\tVl[1].push_back(i);\n\t\t\tv = (v - x + K) % K;\n\t\t}\n\t\telse Vl[0].push_back(i);\n\t}\n\tsort(all(Vl[0]));\n\tsort(all(Vl[1]));\n\n\tprintf(\"YES\\n\");\n\tif (!Vl[0].empty()) {\n\t\tfor (i = 1; i < Vl[0].size(); i++) printf(\"%d %d %d\\n\", 100000, Vl[0][i], Vl[0][0]);\n\t}\n\tif (!Vl[1].empty()) {\n\t\tfor (i = 1; i < Vl[1].size(); i++) printf(\"%d %d %d\\n\", 100000, Vl[1][i], Vl[1][0]);\n\t}\n\n\ts = 0;\n\tfor (auto it : Vl[1]) s += in[it];\n\n\tint p0, p1;\n\tif (Vl[0].empty()) p0 = Vl[1][1], p1 = Vl[1][0];\n\telse if (Vl[1].empty()) p0 = Vl[0][0], p1 = Vl[0][1];\n\telse p0 = Vl[0][0], p1 = Vl[1][0];\n\n\tif (s > V) printf(\"%d %d %d\\n\", (s - V) / K, p1, p0);\n\tif (s < V) printf(\"%d %d %d\\n\", (V - s) / K, p0, p1);\n\treturn 0;\n}\n//*/", "interactive": false, "noSolution": false, "noTutorial": false}