{"link": "https://codeforces.com//contest/903/problem/E", "problemId": "138454", "shortId": "903E", "contest_number": "903", "name": "E. Swapping Characters", "statement": "We had a string  consisting of  lowercase Latin letters. We made  copies of this string, thus obtaining  identical strings . After that, in each of these strings we swapped exactly two characters (the characters we swapped could be identical, but they had different indices in the string).You are given  strings , and you have to restore any string  so that it is possible to obtain these strings by performing aforementioned operations. Note that the total length of the strings you are given doesn't exceed 5000 (that is, ).", "input": "The first line contains two integers  and  () \u2014 the number of strings we obtained, and the length of each of these strings. Next  lines contain the strings , each consisting of exactly  lowercase Latin letters.", "output": "Print  suitable string , or  if such string doesn't exist.", "tutorial": "If we don't have two distinct strings then we just have to swap any pair of characters in any of the given strings and print it. Otherwise we have to find two indices  and  such that . Then let's store all positions  such that  in array . If the number of those positions will exceed 4 then the answer will be \u00ab-1\u00bb. Otherwise we need to iterate over all positions  in array , try to swap  with any other character of  and check that current string can be the answer. We also should try the same thing with string .It is clear how we can check string  to be the answer. Let's iterate over all strings  and for each string  count the number of positions  such that . Let's call it . If for any given string  is not equal to 0 or 2 then string  can't be the answer. Otherwise if for any given string  is equal to 0 and all characters in string  are distinct then  can't be the answer.If there is no string that satisfies all aforementioned conditions then the answer will be \u00ab-1\u00bb.", "solution": "#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, \"/STACK:336777216\")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 20;\nconst ll MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-9;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define Se second\n#define Fi first\n\nstring in[5550];\nvector <int> Vl[5550];\nchar u[5550];\n\nint cnt[26];\nint cnt2[26];\nint main() {\n\tint K, N, i, j, k, l;\n\tscanf(\"%d %d\", &K, &N);\n\tfor (i = 0; i < K; i++) {\n\t\tscanf(\"%s\", u);\n\t\tin[i] = string(u);\n\t}\n\tfor (i = 0; i < N; i++) cnt[in[0][i] - 'a']++;\n\tfor (i = 1; i < K; i++) {\n\t\tfor (j = 0; j < 26; j++) cnt2[j] = 0;\n\t\tfor (j = 0; j < N; j++) cnt2[in[i][j] - 'a']++;\n\t\tfor (j = 0; j < 26; j++) if (cnt[j] != cnt2[j]) return !printf(\"-1\\n\");\n\t}\n\n\tbool chk2 = false;\n\tfor (i = 0; i < 26; i++) if (cnt[i] >= 2) chk2 = true;\n\n\tfor (i = 1; i < K; i++) {\n\t\tfor (j = 0; j < N; j++) if (in[0][j] != in[i][j]) Vl[i].push_back(j);\n\t\tif (Vl[i].size() > 4) return !printf(\"-1\\n\");\n\t}\n\n\tfor (i = 0; i < N; i++) {\n\t\tfor (j = i + 1; j < N; j++) {\n\t\t\tswap(in[0][i], in[0][j]);\n\t\t\tfor (k = 1; k < K; k++) {\n\t\t\t\tint c = 0;\n\t\t\t\tif (in[0][i] != in[k][i]) c++;\n\t\t\t\tif (in[0][j] != in[k][j]) c++;\n\t\t\t\tfor (auto it : Vl[k]) if (it != i && it != j && in[0][it] != in[k][it]) c++;\n\t\t\t\tif (c > 2) break;\n\t\t\t\tif (c == 0 && !chk2) break;\n\t\t\t}\n\t\t\tif (k >= K) return !printf(\"%s\\n\", in[0].c_str());\n\t\t\tswap(in[0][i], in[0][j]);\n\t\t}\n\t}\n\treturn !printf(\"-1\\n\");\n}", "interactive": false, "noSolution": false, "noTutorial": false}