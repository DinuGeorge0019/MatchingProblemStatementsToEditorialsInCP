{"link": "https://codeforces.com//contest/1499/problem/G", "problemId": "928255", "shortId": "1499G", "contest_number": "1499", "name": "G. Graph Coloring", "statement": "You are given a bipartite graph consisting of  vertices in the first part,  vertices in the second part, and  edges, numbered from  to . You have to color each edge into one of two colors, red and blue. You have to minimize the following value: , where  is the set of vertices of the graph,  is the number of red edges incident to , and  is the number of blue edges incident to .Sounds classical and easy, right? Well, you have to process  queries of the following format:     \u2014 add a new edge connecting the vertex  of the first part with the vertex  of the second part. This edge gets a new index as follows: the first added edge gets the index , the second \u2014 , and so on. After adding the edge, you have to print the  of the current optimal coloring (if there are multiple optimal colorings, print the  of any of them). ;   \u2014 print the optimal coloring of the graph with the same  you printed while processing the previous query. The query of this type will only be asked after a query of type , and there will be at most  queries of this type. If there are multiple optimal colorings corresponding to this , print any of them. Note that if an edge was red or blue in some coloring, it may change its color in next colorings.The  of the coloring is calculated as follows: let  be the set of indices of red edges, then the  is .Note that you should solve the problem in  mode. It means that you can't read the whole input at once. You can read each query only after writing the answer for the last query. Use functions  in  and  in  languages after each writing in your program.", "input": "The first line contains three integers ,  and  (). Then  lines follow, the -th of them contains two integers  and  (; ) meaning that the -th edge connects the vertex  from the first part and the vertex  from the second part. The next line contains one integer  ()\u00a0\u2014 the number of queries you have to process. The next  lines contain the queries in the format introduced in the statement. Additional constraints on the input:   at any moment, the graph won't contain any multiple edges;  the queries of type  are only asked if the previous query had type ;  there are at most  queries of type . ", "output": "To answer a query of type , print one integer\u00a0\u2014 the  of the optimal coloring. To answer a query of type , print one line. It should begin with the integer \u00a0\u2014 the number of red edges. Then,   integer should follow\u00a0\u2014 the indices of  edges in your coloring, in any order. Each index should correspond to an existing edge, and the  of the coloring you produce should be equal to the  you printed as the answer to the previous query. If there are multiple answers to a query, you may print any of them.", "tutorial": "Let's split all edges of the graph into several paths and cycles (each edge will belong to exactly one path or cycle). Each path and each cycle will be colored in an alternating way: the first edge will be red, the second \u2014 blue, the third \u2014 red, and so on (or vice versa). Since the graph is bipartite, each cycle can be colored in an alternating way. The main idea of the solution is to add the edges one by one, maintain the structure of cycles and paths, and make sure that for each vertex, at most one path starts/ends in it. If we are able to maintain this invariant, then the value of  for every vertex will be minimum possible \u2014 each cycle going through a vertex covers an even number of edges incident to it (half of them will be red, half of them will be blue); so, if the degree of a vertex is odd, one path will have this vertex as an endpoint, and ; otherwise, it won't be an endpoint of any path, so .Okay, how do we maintain this structure? Let's add edges one by one (even the original edges of the graph) and rebuild the structure in online mode. For each vertex, we will maintain the indices of the paths that have this vertex as an endpoint. If some vertex has  or more paths as its endpoints, we can choose two of them and link them together. Whenever we add an edge from  to , we just create a new path and check if we can link together some paths that have  or  as their endpoints.How do we link the paths together? If we try to link a path with itself, it means that we try to close a cycle \u2014 and when we do it, we just forget about the resulting cycle, its structure won't change in future queries. When we link a path with some other path, we might need to reverse and/or repaint the paths before merging them into one. There are (at least) two possible data structures we can use to do this:  either an implicit-key treap that supports reversing and repainting;  or a deque with small-to-large merging: whenever we try to link two paths together, we repaint and/or reverse the smaller one. Both of those methods give a solution in  or , depending on your implementation. The model solution uses deques and small-to-large merging.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MOD = 998244353;\nconst int N = 1000043;\n\nint add(int x, int y)\n{\n    x += y;\n    while(x >= MOD) x -= MOD;\n    while(x < 0) x += MOD;\n    return x;\n}\n\nint sub(int x, int y)\n{\n    return add(x, -y);\n}\n\nint mul(int x, int y)\n{\n    return (x * 1ll * y) % MOD;\n}                               \n\nint binpow(int x, int y)\n{\n    int z = 1;\n    while(y > 0)\n    {\n        if(y % 2 == 1)\n            z = mul(z, x);\n        x = mul(x, x);\n        y /= 2;\n    }\n    return z;\n}\n\nint global_hash = 0;\n\nvoid reverse(deque<pair<int, int>>& d)\n{\n    stack<pair<int, int>> s;\n    while(!d.empty())\n    {\n        s.push(d.back());\n        d.pop_back();\n    }\n    while(!s.empty())\n    {\n        d.push_front(s.top());\n        s.pop();\n    }\n}\n\nvoid safe_push_front(deque<pair<int, int>>& d, int c, int& res)\n{\n    int z = d.front().first ^ 1;\n    res = add(res, mul(binpow(2, c), z));\n    d.push_front(make_pair(z, c));\n}\n\nvoid safe_push_back(deque<pair<int, int>>& d, int c, int& res)\n{\n    int z = d.back().first ^ 1;\n    res = add(res, mul(binpow(2, c), z));\n    d.push_back(make_pair(z, c));\n}\n\ndeque<pair<int, int>> ds[N];\n\nstruct path\n{\n    int s;\n    int t;\n    int d;\n    int c;\n\n    path() {};\n    path(int s, int t, int d, int c) : s(s), t(t), d(d), c(c) {};\n\n    void push_front(int i)\n    {\n        safe_push_front(ds[d], i, c);\n    }\n\n    void push_back(int i)\n    {\n        safe_push_back(ds[d], i, c);\n    }\n\n    void pop_front()\n    {\n        ds[d].pop_front();\n    }\n\n    void pop_back()\n    {\n        ds[d].pop_back();\n    }\n\n    int front()\n    {\n        return ds[d].front().second;\n    }\n\n    int back()\n    {\n        return ds[d].back().second;\n    }\n\n    void reverse()\n    {\n        ::reverse(ds[d]);\n        swap(s, t);\n    }\n\n    int size()\n    {\n        return ds[d].size();\n    }\n};\n\npath link_to_left(path x, path y)\n{\n    path z = x;\n    while(y.size() > 0)\n    {\n        z.push_back(y.front());\n        y.pop_front();\n    }\n    z.t = y.t;\n    return z;\n}\n\npath link_to_right(path x, path y)\n{\n    path z = y;\n    while(x.size() > 0)\n    {\n        z.push_front(x.back());\n        x.pop_back();\n    }\n    z.s = x.s;\n    return z;\n}\n\nint cur = 0;\n\npath make(int x, int y, int i)\n{\n    int cost = i;\n    ds[cur].push_back(make_pair(0, cost));\n    return path(x, y, cur++, 0);    \n}\n\nset<int> paths;\nvector<int> paths_v[N];\npath ps[N];\n\npath merge(path x, path y, int v)\n{\n    if(x.size() > y.size())\n        swap(x, y);\n    if(y.s == v)\n    {\n        if(x.t != v)\n            x.reverse();\n        return link_to_right(x, y);    \n    }\n    else\n    {\n        if(x.s != v)\n            x.reverse();\n        return link_to_left(y, x);\n    }    \n}\n\nint cur2 = 0;       \n\nvoid modify(vector<int>& v, int x, int y)\n{\n    for(int i = 0; i < v.size(); i++)\n        if(v[i] == x)\n            v[i] = y;\n}   \n\nvoid reassign(path p, int x, int y)\n{\n    modify(paths_v[p.s], x, y);\n    modify(paths_v[p.t], x, y);    \n}\n\nvoid merge_paths(int x, int y, int v)\n{\n    if(x == y)\n    {                         \n\n    }\n    else\n    {\n        global_hash = sub(global_hash, ps[x].c);\n        global_hash = sub(global_hash, ps[y].c);\n        ps[cur2++] = merge(ps[x], ps[y], v);\n        paths.erase(x);\n        paths.erase(y);\n        paths.insert(cur2 - 1);\n        reassign(ps[x], x, cur2 - 1);\n        reassign(ps[y], y, cur2 - 1);\n        global_hash = add(global_hash, ps[cur2 - 1].c);   \n    }\n}\n\nvoid relax(int v)\n{\n    while(paths_v[v].size() >= 2)\n    {\n        int x = paths_v[v].back();\n        paths_v[v].pop_back();\n        int y = paths_v[v].back();\n        paths_v[v].pop_back();\n        merge_paths(x, y, v);\n    }\n}\n\nvoid add_edge(int x, int y, int i)\n{\n    //cerr << x << \" \" << y << \" \" << i << endl;\n    int c = cur2;\n    ps[cur2++] = make(x, y, i);\n    paths_v[x].push_back(c);\n    paths_v[y].push_back(c);\n    paths.insert(c);\n    relax(x);\n    relax(y);\n}\n\nvoid print_coloring()\n{\n    vector<int> ans;\n    for(auto x : paths)\n    {\n        for(auto y : ds[ps[x].d])\n        {\n            if(y.first == 1)\n                ans.push_back(y.second);\n        }\n    }\n    printf(\"%d\", int(ans.size()));\n    for(auto x : ans)\n        printf(\" %d\", x);\n    puts(\"\");\n    fflush(stdout);\n}\n\nint e = 0;\n\nvoid process_query()\n{\n    int t;\n    scanf(\"%d\", &t);\n    if(t == 1)\n    {\n        int x, y;\n        scanf(\"%d %d\", &x, &y);\n        y += 200001;\n        add_edge(x, y, ++e);\n        printf(\"%d\\n\", global_hash);\n        fflush(stdout);\n    }\n    else\n        print_coloring();\n}\n\nvoid print_info()\n{\n    cerr << \"Paths\\n\";\n    for(auto x : paths)\n        cerr << x << \" start: \" << ps[x].s << \" \" << \" end: \" << ps[x].t << endl;\n    cerr << \"Vertices\\n\";\n    for(int i = 0; i < N; i++)\n        if(!paths_v[i].empty())\n        {\n            cerr << i << \": \";\n            for(auto x : paths_v[i])\n                cerr << x << \" \";\n            cerr << endl;\n        }\n\n}\n        \nint main()\n{\n    int n1, n2, m;\n    scanf(\"%d %d %d\", &n1, &n2, &m);\n    for(int i = 0; i < m; i++)\n    {\n        int x, y;\n        scanf(\"%d %d\", &x, &y);\n        y += 200001;\n        add_edge(x, y, ++e);\n    }\n    int q;\n    scanf(\"%d\", &q);\n    for(int i = 0; i < q; i++)\n    {\n        //print_info();\n        process_query();\n    }\n}", "interactive": false, "noSolution": false, "noTutorial": false}