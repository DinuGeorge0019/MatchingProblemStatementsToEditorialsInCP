{"link": "https://codeforces.com//contest/1469/problem/C", "problemId": "847528", "shortId": "1469C", "contest_number": "1469", "name": "C. Building a Fence", "statement": "You want to build a fence that will consist of  equal sections. All sections have a width equal to  and height equal to . You will place all sections in one line side by side.Unfortunately, the ground beneath the fence is not flat. For simplicity, you can think that the ground level under the -th section is equal to . You should follow several rules to build the fence:   the consecutive sections should have a common side of length at least ;  the first and the last sections should stand on the corresponding ground levels;  the sections between may be either on the ground level or higher, but not higher than  from the ground level  (the height should be an integer);    Is it possible to build a fence that meets all rules?", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of test cases. The first line of each test case contains two integers  and  (; )\u00a0\u2014 the number of sections in the fence and the height of each section. The second line of each test case contains  integers  (), where  is the ground level beneath the -th section. It's guaranteed that the sum of  over test cases doesn't exceed .", "output": "For each test case print  if it's possible to build the fence that meets all rules. Otherwise, print . You may print each letter in any case (for example, , , ,  will all be recognized as positive answer).", "tutorial": "Let's set sections from left to right. Note that for the -th section all valid heights  (heights for which it's possible to choose heights for all sections  meeting all rules and finishing with the height of  equal to ) form a segment.It's not hard to prove by induction. For the first section, the valid segment is . The step of induction: if the valid segment for  is  then valid -s for  is the segment , since for each  you can find at least one  in  which don't break the first rule.If for any  the correct segment is empty or if we can't fulfill the third rule () then there is no answer, otherwise at least one answer is always exist.As a result, to solve the problem, you should just maintain the segment of valid  (using the formula above) while iterating . Complexity is .", "solution": "fun main() {\n    repeat(readLine()!!.toInt()) {\n        val (n, k) = readLine()!!.split(' ').map { it.toInt() }\n        val h = readLine()!!.split(' ').map { it.toInt() }\n\n        var mn = h[0]\n        var mx = h[0]\n        var ok = true\n        for (i in 1 until n) {\n            mn = maxOf(mn - k + 1, h[i])\n            mx = minOf(mx + k - 1, h[i] + k - 1)\n            if (mn > mx) {\n                ok = false\n                break\n            }\n        }\n        if (h[n - 1] !in mn..mx)\n            ok = false\n        println(if (ok) \"YES\" else \"NO\")\n    }\n}", "interactive": false, "noSolution": false, "noTutorial": false}