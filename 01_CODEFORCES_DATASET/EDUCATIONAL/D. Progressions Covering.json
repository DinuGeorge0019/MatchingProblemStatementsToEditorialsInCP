{"link": "https://codeforces.com//contest/1661/problem/D", "problemId": "1361830", "shortId": "1661D", "contest_number": "1661", "name": "D. Progressions Covering", "statement": "You are given two arrays: an array  consisting of  zeros and an array  consisting of  integers.You can apply the following operation to the array  an arbitrary number of times: choose some subsegment of  of length  and add the arithmetic progression  to this subsegment \u2014 i.\u2009e. add  to the first element of the subsegment,  to the second element, and so on. The chosen subsegment should be inside the borders of the array  (i.e., if the left border of the chosen subsegment is , then the condition  should be satisfied). Note that the progression added is always  but not the  or anything else (i.e., the leftmost element of the subsegment always increases by , the second element always increases by  and so on).Your task is to find the  possible number of operations required to satisfy the condition  for each  from  to . Note that the condition  should be satisfied for all elements at once.", "input": "The first line of the input contains two integers  and  () \u2014 the number of elements in both arrays and the length of the subsegment, respectively. The second line of the input contains  integers  (), where  is the -th element of the array .", "output": "Print one integer \u2014 the  possible number of operations required to satisfy the condition  for each  from  to .", "tutorial": "Let's solve the problem greedily. But not from the beginning, because if we solve it from the beginning, we can't be sure what option is more optimal for the next elements (e.g. for the second element it is not clear if we need to add  to it starting our segment from the first position or add  to it starting our segment from the second position). So, let's solve the problem from right to left, then anything becomes clearer.Actually, let's operate with the array  and decrease its elements instead of using some other array. Let's carry some variables: ,  and the array  of length  (along with the answer). The variable  means the value we need to subtract from the current element from currently existing progressions,  is the number of currently existing progressions, and  means the number of progressions that will end at the position  (i.e. will not add anything from the position  and further to the left).When we consider the element , firstly let's fix  (decrease it by ). Then, let's fix  (decrease it by ). Then, let's decrease  by , and if it becomes less than or equal to zero, just proceed. Otherwise, the number by which we can decrease the -th element with one progression, equals to  (zero-indexed). Then the number of progressions we need to satisfy this element is . Let's add this number to the answer, increase  by , increase  by , and if  then we need to end these progressions somewhere, so let's add  to .Time complexity: .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n    freopen(\"input.txt\", \"r\", stdin);\n//  freopen(\"output.txt\", \"w\", stdout);\n#endif\n\n    int n, k;\n    scanf(\"%d %d\", &n, &k);\n    vector<long long> b(n);\n    for (auto &it : b) {\n        scanf(\"%lld\", &it);\n    }\n    \n    vector<long long> closed(n);\n    long long sum = 0, cnt = 0, ans = 0;\n    for (int i = n - 1; i >= 0; --i) {\n        sum -= cnt;\n        cnt -= closed[i];\n        b[i] -= sum;\n        if (b[i] <= 0) {\n            continue;\n        }\n        int el = min(i + 1, k);\n        long long need = (b[i] + el - 1) / el;\n        sum += need * el;\n        cnt += need;\n        ans += need;\n        if (i - el >= 0) {\n            closed[i - el] += need;\n        }\n    }\n    \n    printf(\"%lld\\n\", ans);\n    \n    return 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}