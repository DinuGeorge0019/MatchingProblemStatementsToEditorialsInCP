{"link": "https://codeforces.com//contest/1792/problem/E", "problemId": "1749563", "shortId": "1792E", "contest_number": "1792", "name": "E. Divisors and Table", "statement": "You are given an  multiplication table and a positive integer . A  multiplication table is a table with  rows and  columns numbered from  to , where .For each divisor  of , check: does  occur in the table at least once, and if it does, what is the  row that contains .", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of test cases. The first and only line of each test case contains three integers ,  and  (; )\u00a0\u2014 the size of the multiplication table and the integer  represented as .", "output": "For each test case, let  be  divisors of  sorted in the increasing order. And let  be an array of answers, where  is equal to the minimum row index where divisor  occurs, or , if there is no such row. Since array  may be large, first, print an integer \u00a0\u2014 the number of divisors of  that  in the  table. Next, print a single value , where  denotes the bitwise XOR operation.", "tutorial": "Firstly, let's factorize . Since  we can factorize  and  separately and then \"unite\" divisors. For example, use can get canonical representations of  and  to get canonical representation of  and then use it to generate all divisors of .Let's estimate the number of divisors . It's convenient for our purposes to estimate it as . More precisely, there are at most  divisors for  (search \"Highly Composite Numbers\" for more info).How to calculate the answer  for each divisor ? There are two ways. for each  we are searching for the minimum  that  and . Since  is fixed, the minimum  means the maximum . So let's find  instead. In other words, for each  we need to find the maximum  such that  divides  and . We can do it efficiently with  on divisors.Let  be the maximum  that is a divisor of  and . If  then, obviously, . Otherwise, we know that we are searching .Let say that  are the prime divisors of the initial number . Since  is a divisor of  and  then exists some  among the set of prime divisors such that  is a divisor of  as well. So, instead of brute search, it's enough to take a value .In other words, if  we can calculate .Ok, now we know value  for each divisor . Since we found the maximum , the last step is to calculate the desired  and if  we found the answer , otherwise () it means that  is not presented  table and .The total complexity is  per test, where  is the number of divisors of  () and  is the number of prime divisor of  (). Note that complexity is quite high, so you should write it at least a little accurate, for example store  in an array, not map, and search position of  with .There is also a way to get rid of extra  factor if you iterate through  is a smart way. (faster, easier, unproven): Let's generate a list of all divisors of  as  in the increasing order. For some divisor  we are searching the minimum  that is a divisor of  and . It means that .So let's just find the first position  such that  with  and start iterating from  onward searching the first  that is a divisor of . The found  would be the minimum  we need.It looks like, in average, we will find the correct  quite fast, or we'll break when .", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) int((a).size())\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef long double ld;\ntypedef pair<int, int> pt;\n\ntemplate<class A, class B> ostream& operator <<(ostream& out, const pair<A, B> &p) {\n\treturn out << \"(\" << p.x << \", \" << p.y << \")\";\n}\ntemplate<class A> ostream& operator <<(ostream& out, const vector<A> &v) {\n\tfore(i, 0, sz(v)) {\n\t\tif(i) out << \" \";\n\t\tout << v[i];\n\t}\n\treturn out;\n}\n\nconst int INF = int(1e9);\nconst li INF64 = li(1e18);\nconst ld EPS = 1e-9;\n\nint n;\nli m1, m2;\n\ninline bool read() {\n\tif(!(cin >> n >> m1 >> m2))\n\t\treturn false;\n\treturn true;\n}\n\nvector<pt> mFact;\nvector<li> divs;\n\nvoid factM(li m1, li m2) {\n\tmFact.clear();\n\n\tfor (int d = 2; d * d <= m1 || d * d <= m2; d++) {\n\t\tint cnt = 0;\n\t\twhile (m1 % d == 0) {\n\t\t\tm1 /= d;\n\t\t\tcnt++;\n\t\t}\n\t\twhile (m2 % d == 0) {\n\t\t\tm2 /= d;\n\t\t\tcnt++;\n\t\t}\n\t\tif (cnt > 0)\n\t\t\tmFact.push_back({d, cnt});\n\t}\n\tif (m1 > m2)\n\t\tswap(m1, m2);\n\tif (m1 > 1)\n\t\tmFact.push_back({m1, 1});\n\tif (m2 > 1) {\n\t\tif (m2 == m1)\n\t\t\tmFact.back().y++;\n\t\telse\n\t\t\tmFact.push_back({m2, 1});\n\t}\n}\n\nvoid genDivisors(int pos, li val) {\n\tif (pos >= sz(mFact)) {\n\t\tdivs.push_back(val);\n\t\treturn;\n\t}\n\tli cur = val;\n\tfore (pw, 0, mFact[pos].y + 1) {\n\t\tgenDivisors(pos + 1, cur);\n\t\tif (pw < mFact[pos].y)\n\t\t\tcur *= mFact[pos].x;\n\t}\n}\n\ninline void solve() {\n\tfactM(m1, m2);\n\n\tdivs.clear();\n\tgenDivisors(0, 1);\n\tsort(divs.begin(), divs.end());\n\n\tvector<int> ans(sz(divs), 0);\n\n\tvector<li> dp(sz(divs), -1);\n\tfore (id, 0, sz(divs)) {\n\t\tif (divs[id] <= n)\n\t\t\tdp[id] = divs[id];\n\t\tfor (auto [p, pw] : mFact) {\n\t\t\tif (divs[id] % p != 0)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tint pos = int(lower_bound(divs.begin(), divs.end(), divs[id] / p) - divs.begin());\n\t\t\tdp[id] = max(dp[id], dp[pos]);\n\t\t}\n\n\t\tif (divs[id] / dp[id] <= n)\n\t\t\tans[id] = divs[id] / dp[id];\n\t}\n\n\tint cnt = 0;\n\tint xorSum = 0;\n\tfore (i, 0, sz(ans)) {\n\t\tcnt += ans[i] > 0;\n\t\txorSum ^= ans[i];\n\t}\n\t\n//\tcout << sz(ans) << endl;\n//\tcout << ans << endl;\n\tcout << cnt << \" \" << xorSum << endl;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint tt = clock();\n#endif\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0), cout.tie(0);\n\tcout << fixed << setprecision(15);\n\n\tint t; cin >> t;\n\t\n\twhile (t--) {\n\t\t\n\t\tread();\n\t\tsolve();\n\t\t\n#ifdef _DEBUG\n\t\tcerr << \"TIME = \" << clock() - tt << endl;\n\t\ttt = clock();\n#endif\n\t}\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}