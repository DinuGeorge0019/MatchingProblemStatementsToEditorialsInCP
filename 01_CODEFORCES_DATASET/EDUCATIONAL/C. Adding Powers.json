{"link": "https://codeforces.com//contest/1312/problem/C", "problemId": "557979", "shortId": "1312C", "contest_number": "1312", "name": "C. Adding Powers", "statement": "Suppose you are performing the following algorithm. There is an array  filled with zeroes at start. The following operation is applied to the array several times \u2014 at -th step (-indexed) you can:   either choose position  () and increase  by ;  or not choose any position and skip this step. You can choose how the algorithm would behave on each step and when to stop it. The question is: can you make array  equal to the given array  ( for each ) after some step?", "input": "The first line contains one integer  () \u2014 the number of test cases. Next  lines contain test cases \u2014 two lines per test case. The first line of each test case contains two integers  and  (, ) \u2014 the size of arrays  and  and value  used in the algorithm. The second line contains  integers  () \u2014 the array you'd like to achieve.", "output": "For each test case print  (case insensitive) if you can achieve the array  after some step or  (case insensitive) otherwise.", "tutorial": "This is the solution that doesn't involve masks. Let's reverse the process and try to get all zeroes from the array : since all  we can start from maximum .The key idea: since  then there should be no more than one position  such that  and we should decrease it by . Now we can decrease  by  and repeat the same process.If at any step there are at least two  or as result, we won't get array filled with  then there is no way to build the array .", "solution": "fun main() {\n    val T = readLine()!!.toInt()\n    testCases@for (tc in 1..T) {\n        val (_, k) = readLine()!!.split(' ').map { it.toLong() }\n        val a = readLine()!!.split(' ').map { it.toLong() }.toLongArray()\n\n        var maxPower = 1L\n        while (maxPower < 1e16.toLong())\n            maxPower *= k\n\n        while (maxPower > 0) {\n            val positions = a.withIndex().filter { it.value >= maxPower }.map { it.index }\n            if (positions.isNotEmpty()) {\n                if (positions.size > 1) {\n                    println(\"NO\")\n                    continue@testCases\n                }\n                a[positions[0]] -= maxPower\n            }\n            maxPower /= k\n        }\n        if (a.max()!! > 0L) {\n            println(\"NO\")\n            continue@testCases\n        }\n        println(\"YES\")\n    }\n}", "interactive": false, "noSolution": false, "noTutorial": false}