{"link": "https://codeforces.com//contest/1701/problem/C", "problemId": "1455051", "shortId": "1701C", "contest_number": "1701", "name": "C. Schedule Management", "statement": "There are  workers and  tasks. The workers are numbered from  to . Each task  has a value \u00a0\u2014 the index of worker who is proficient in this task.Every task should have a worker assigned to it. If a worker is proficient in the task, they complete it in  hour. Otherwise, it takes them  hours.The workers work in parallel, independently of each other. Each worker can only work on one task at once.Assign the workers to all tasks in such a way that the tasks are completed as early as possible. The work starts at time . What's the minimum time all tasks can be completed by?", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of testcases. The first line of each testcase contains two integers  and  ()\u00a0\u2014 the number of workers and the number of tasks. The second line contains  integers  ()\u00a0\u2014 the index of the worker proficient in the -th task. The sum of  over all testcases doesn't exceed .", "output": "For each testcase, print a single integer\u00a0\u2014 the minimum time all tasks can be completed by.", "tutorial": "The statement should instantly scream binary search at you. Clearly, if you can assign the workers in such a way that the tasks are completed by time , you can complete them all by  or more as well.How to check if the tasks can be completed by some time ? What that means is that all workers have  hours to work on some tasks. If all tasks took  hours to complete, then each of them could complete  of them. Thus, together they would be able to complete  tasks.How to incorporate the -hour tasks into that? Well, we can redistribute the tasks in such a way that each worker first completes the tasks they are proficient in, then some other tasks if they have more time.So the general idea is the following. Let each worker  complete  -hour tasks, where  is the number of tasks the -th worker is proficient in. Then remember how many -hour tasks they can complete, which is . Finally, remember how many tasks that they are proficient in they didn't have time to complete, which is . If the sum of the number of incomplete tasks doesn't exceed the sum of the number of tasks they have time to complete, then everything can be completed in time .Worst case, it can take up to  hours to complete everything\u00a0\u2014 if you assign all tasks to a single worker, and they are not proficient in any of them.Overall complexity:  per testcase.", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nint main() {\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--){\n\t\tint n, m;\n\t\tscanf(\"%d%d\", &n, &m);\n\t\tvector<int> a(m);\n\t\tforn(i, m){\n\t\t\tscanf(\"%d\", &a[i]);\n\t\t\t--a[i];\n\t\t}\n\t\tvector<int> cnt(n);\n\t\tforn(i, m) ++cnt[a[i]];\n\t\tauto check = [&](int t){\n\t\t\tlong long fr = 0, need = 0;\n\t\t\tforn(i, n){\n\t\t\t\tif (t >= cnt[i])\n\t\t\t\t\tfr += (t - cnt[i]) / 2;\n\t\t\t\telse\n\t\t\t\t\tneed += cnt[i] - t;\n\t\t\t}\n\t\t\treturn need <= fr;\n\t\t};\n\t\tint l = 0, r = 2 * m;\n\t\tint res = -1;\n\t\twhile (l <= r){\n\t\t\tint m = (l + r) / 2;\n\t\t\tif (check(m)){\n\t\t\t\tres = m;\n\t\t\t\tr = m - 1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tl = m + 1;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", res);\n\t}\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}