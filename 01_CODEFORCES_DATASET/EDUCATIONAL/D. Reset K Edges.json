{"link": "https://codeforces.com//contest/1739/problem/D", "problemId": "1559866", "shortId": "1739D", "contest_number": "1739", "name": "D. Reset K Edges", "statement": "You are given a rooted tree, consisting of  vertices. The vertices are numbered from  to , the root is the vertex .You can perform the following operation   times:   choose an edge  of the tree such that  is a parent of ;  remove the edge ;  add an edge  (i.\u2009e. make  with its subtree a child of the root).  of a tree is the maximum depth of its vertices, and the depth of a vertex is the number of edges on the path from the root to it. For example, the depth of vertex  is , since it's the root, and the depth of all its children is .What's the smallest height of the tree that can be achieved?", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of testcases. The first line of each testcase contains two integers  and  (; )\u00a0\u2014 the number of vertices in the tree and the maximum number of operations you can perform. The second line contains  integers  ()\u00a0\u2014 the parent of the -th vertex. Vertex  is the root. The sum of  over all testcases doesn't exceed .", "output": "For each testcase, print a single integer\u00a0\u2014 the smallest height of the tree that can achieved by performing   operations.", "tutorial": "Start with the following. Let's look at the input format and consider what the operation actually does to it. Since it only changes the parent of some vertex, it modifies only one value in it. Moreover, it just assigns it to . Thus, the goal is to assign at most  values of parents to  to minimize the resulting height of the tree.In particular, that implies that we can freely rearrange the operations, since the assignments don't depend on each other.One more conclusion. Imagine we have already built some answer. One by one, we moved some subtrees to be children of the root. It could happen that we first moved some subtree of a vertex  and then applied the operation to an edge inside the subtree of . Let's show that it's always possible to rearrange the operations in the answer to avoid that. Just apply the operations in order of decreasing the depth of the vertex .If we knew what height  we want to get, we could have been making sure that cut subtree  has height at most  (since it gets increased by  when glueing it to the root), then pretending that that subtree doesn't exist anymore.Moreover, it's always required to cut subtrees with height at most . If you cut a higher subtree, then the answer can't be smaller than , since we rearranged the operation to not touch that subtree anymore.Well, let's fix that height  if we wanted that. Let's try the solve the opposite problem. How many operations will it require to make the tree height at most ? Obviously, the values for this problem are non-increasing\u00a0\u2014 the greater we allow the height to be, the less operations it will require. Thus, we will be able to apply binary search to it to find the smallest height we can achieve with at most  operations.Now we want to be choosing the subtrees of height at most  repeatedly and cutting them off until the height of the tree becomes at most .Let's think greedily. If the height of the tree is not at most  yet, then there exists a vertex with the depth greater than . Let's look at the deepest of them. That leaf has to be cut in some subtree. Otherwise, the tree won't become any less higher. What subtree is the best for it? What options do we have? That vertex itself and all its parents up until  above. It's always optimal to cut the highest of them\u00a0\u2014 the -st parent, since it will remove at least all the vertices of any other cut and some other vertices along with them. It's also always possible to remove the -st parent, since it will always have height exactly . The vertex we are looking at is the deepest in the entire tree\u00a0\u2014 there are no deeper vertices in the subtree of the -st parent.Thus, the strategy is to keep cutting the -st parent of the deepest vertex until the tree becomes at most  height.Now about the implementation details.First, we can process the vertices from the deepest upwards in their order in the original tree. The operation only removes some vertices but doesn't change the depth of the remaining ones. For example, you can do a bfs from the root to find the order.Now the -st parent. Let's find it for each vertex before starting the process. Run a dfs and maintain the stack of the ascendants. When going down the child, append it to the stack. What exiting, pop from the stack. Now you can just look at the -st element from the top of the stack. To be able to do that, simulate the stack with a vector (C++) or a list (Python).Finally, we would have to determine if the current vertex in the order is removed or not. For that, we could maintain a boolean array  for the removed vertices. Once you apply the operation, run the dfs from the removed vertex and mark all the newly removed descendants of it in . If you don't go into already marked vertices, there will be no more than  calls of the dfs.The number of cut vertices is the answer for the fixed height .Overall complexity:  per testcase.", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nint n;\nvector<vector<int>> g;\n\nvector<int> st;\nvector<int> pd;\n\nvoid init(int v, int d){\n\tst.push_back(v);\n\tif (int(st.size()) - d >= 0)\n\t\tpd[v] = st[st.size() - d];\n\tfor (int u : g[v])\n\t\tinit(u, d);\n\tst.pop_back();\n}\n\nvector<char> used;\n\nvoid dfs(int v){\n\tused[v] = true;\n\tfor (int u : g[v]) if (!used[u])\n\t\tdfs(u);\n}\n\nint get(int d){\n\tpd.assign(n, -1);\n\tinit(0, d);\n\t\n\tvector<int> ord, h(n);\n\tqueue<int> q;\n\tq.push(0);\n\twhile (!q.empty()){\n\t\tint v = q.front();\n\t\tq.pop();\n\t\tord.push_back(v);\n\t\tfor (int u : g[v]){\n\t\t\tq.push(u);\n\t\t\th[u] = h[v] + 1;\n\t\t}\n\t}\n\treverse(ord.begin(), ord.end());\n\t\n\tused.assign(n, 0);\n\tint res = 0;\n\tfor (int v : ord) if (!used[v] && h[v] > d){\n\t\t++res;\n\t\tdfs(pd[v]);\n\t}\n\t\n\treturn res;\n}\n\nint main() {\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--){\n\t\tint k;\n\t\tscanf(\"%d%d\", &n, &k);\n\t\tg.assign(n, vector<int>());\n\t\tfor (int i = 1; i < n; ++i){\n\t\t\tint p;\n\t\t\tscanf(\"%d\", &p);\n\t\t\t--p;\n\t\t\tg[p].push_back(i);\n\t\t}\n\t\tint l = 1, r = n - 1;\n\t\tint ans = n;\n\t\twhile (l <= r){\n\t\t\tint m = (l + r) / 2;\n\t\t\tif (get(m) <= k){\n\t\t\t\tans = m;\n\t\t\t\tr = m - 1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tl = m + 1;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}