{"link": "https://codeforces.com//contest/1612/problem/F", "problemId": "1198240", "shortId": "1612F", "contest_number": "1612", "name": "F. Armor and Weapons", "statement": "Monocarp plays a computer game. There are  different sets of armor and  different weapons in this game. If a character equips the -th set of armor and wields the -th weapon, their power is usually equal to ; but some combinations of armor and weapons synergize well. Formally, there is a list of  ordered pairs, and if the pair  belongs to this list, the power of the character equipped with the -th set of armor and wielding the -th weapon is not , but .Initially, Monocarp's character has got only the -st armor set and the -st weapon. Monocarp can obtain a new weapon or a new set of armor in one hour. If he wants to obtain the -th armor set or the -th weapon, he must possess a combination of an armor set and a weapon that gets his power to  . Of course, after Monocarp obtains a weapon or an armor set, he can use it to obtain new armor sets or weapons, but he can go with any of the older armor sets and/or weapons as well.Monocarp wants to obtain the -th armor set  the -th weapon. What is the minimum number of hours he has to spend on it? ", "input": "The first line contains two integers  and  () \u2014 the number of armor sets and the number of weapons, respectively. The second line contains one integer  () \u2014 the number of combinations that synergize well. Then  lines follow, the -th line contains two integers  and  (; ) meaning that the -th armor set synergizes well with the -th weapon. All pairs  are distinct.", "output": "Print one integer \u2014 the minimum number of hours Monocarp has to spend to obtain  the -th armor set and the -th weapon.", "tutorial": "Among two armor sets, one with the greater index is always better. The same can be said about two different weapons. So, it is always optimal to use and obtain the best possible weapon or armor.This observation allows us to model this problem with dynamic programming or shortest paths: let  be the minimum time in which Monocarp can obtain the armor  and the weapon ; and in each transition, we either get the best weapon we can or the best armor we can. Similarly, we can build a graph where the vertices represent these pairs , and the edges represent getting the best possible weapon/armor, and find the shortest path from  to  using BFS.Unfortunately, it is . But we can modify the BFS in the following fashion: let's analyze each layer of BFS (a layer is a set of vertices with the same distance from the origin). In each layer, there might be some redundant vertices: if two vertices  and  belong to the same layer,  and , then the vertex  is redundant.If we filter each layer, removing all redundant vertices from it and continuing BFS only from non-redundant ones, the solution will be fast enough. To prove it, let's analyze the constraints on the answer. Suppose . The answer can be bounded as , since we can reach the pair  in  steps using something similar to Fibonacci sequence building, and then go from  to  in  steps. And the number of non-redundant states on each layer is not greater than  (because, of two states with the same weapon or the same armor set, at least one is redundant). So, if we don't continue BFS from redundant vertices, it will visit at most  vertices. There might be another logarithm in the asymptotic complexity of the solution, if you use something like a set to store all combinations that synergize well, but this implementation is still fast enough.", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint n, m;\n\n#define x first\n#define y second\n\ntypedef pair<int, int> comb;\n\ncomb norm(const comb& a)\n{\n    return make_pair(min(a.x, n), min(a.y, m));\n}\n\nbool good(const comb& a)\n{\n    return a.x == n || a.y == m;\n}\n\nbool comp(const comb& a, const comb& b)\n{\n    if(a.x != b.x)\n        return a.x > b.x;\n    return a.y > b.y;\n}\n\nint main()\n{\n    scanf(\"%d %d\", &n, &m);\n    int v;\n    scanf(\"%d\", &v);\n    set<comb> s;\n    for(int i = 0; i < v; i++)\n    {\n        int x, y;\n        scanf(\"%d %d\", &x, &y);\n        s.insert(make_pair(x, y));\n    }\n    int steps = 0;\n    vector<comb> cur;\n    cur.push_back(make_pair(1, 1));\n    while(true)\n    {\n        if(cur[0] == make_pair(n, m))\n            break;\n        vector<comb> ncur;\n        for(auto x : cur)\n        {\n            int sum = x.x + x.y;\n            if(s.count(x))\n                sum++;\n            comb z = x;\n            z.x = sum;\n            ncur.push_back(norm(z));\n            z = x;\n            z.y = sum;\n            ncur.push_back(norm(z));\n        }\n        sort(ncur.begin(), ncur.end(), comp);\n        int mx = 0;\n        vector<comb> ncur2;\n        for(auto x : ncur)\n        {\n            if(x.y <= mx) continue;\n            mx = max(mx, x.y);\n            ncur2.push_back(x);\n        }\n        cur = ncur2;\n        steps++;\n    }\n    printf(\"%d\\n\", steps);\n}", "interactive": false, "noSolution": false, "noTutorial": false}