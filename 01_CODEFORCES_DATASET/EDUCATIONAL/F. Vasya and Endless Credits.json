{"link": "https://codeforces.com//contest/1107/problem/F", "problemId": "288739", "shortId": "1107F", "contest_number": "1107", "name": "F. Vasya and Endless Credits", "statement": "Vasya wants to buy himself a nice new car. Unfortunately, he lacks some money. Currently he has exactly  burles.However, the local bank has  credit offers. Each offer can be described with three numbers ,  and . Offers are numbered from  to . If Vasya takes the -th offer, then the bank gives him  burles at the beginning of the month and then Vasya pays bank  burles at the end of each month for the next  months (including the month he activated the offer). .. . Several credits can be active at the same time. It implies that Vasya pays bank the sum of  over all the  of active credits at the end of each month.Vasya wants to buy a car in the middle of some month. He just takes all the money he currently has and buys the car of that exact price.Vasya don't really care what he'll have to pay the bank back after he buys a car. He just goes out of the country on his car so that the bank can't find him anymore.What is the maximum price that car can have?", "input": "The first line contains one integer  () \u2014 the number of credit offers. Each of the next  lines contains three integers ,  and  ().", "output": "Print one integer \u2014 the maximum price of the car.", "tutorial": "Notice that if we take offer  exactly  months before we buy the car, it will provide us with  money at the time of the car purchase. Moreover, the only values of  that make sense are . This means we can immediately solve the problem via an algorithm for the assignment problem, such as min-cost flow or the Hungarian algorithm. This has a runtime of  or , which manages to fit under the time limit with a good implementation. Code: 49033783\nThe better solution is to notice that for all offers  where we don't use up all  months, it's best to sort them by  (so that the highest values of  have the lowest values of ). This leads to a very nice  DP solution: 49035446\n", "solution": "#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\n\n\ntemplate<typename flow_t, typename cost_t>\nstruct min_cost_flow {\n    static const flow_t FLOW_INF = numeric_limits<flow_t>::max() / 2;\n    static const cost_t COST_INF = numeric_limits<cost_t>::max() / 2;\n\n    struct edge {\n        int node, rev;\n        flow_t capacity;\n        cost_t cost;\n\n        edge(int _node = -1, int _rev = -1, flow_t _capacity = 0, cost_t _cost = 0)\n            : node(_node), rev(_rev), capacity(_capacity), cost(_cost) {}\n    };\n\n    int V = -1;\n    vector<vector<edge>> adj;\n    vector<cost_t> dist;\n    vector<int> prev;\n    vector<edge*> prev_edge;\n\n    min_cost_flow(int vertices = -1) {\n        if (vertices >= 0)\n            init(vertices);\n    }\n\n    void init(int vertices) {\n        V = vertices;\n        adj.assign(V, {});\n        dist.resize(V);\n        prev.resize(V);\n        prev_edge.resize(V);\n    }\n\n    void add_directional_edge(int u, int v, flow_t capacity, cost_t cost) {\n        edge uv_edge(v, adj[v].size() + (u == v ? 1 : 0), capacity, cost);\n        edge vu_edge(u, adj[u].size(), 0, -cost);\n        adj[u].push_back(uv_edge);\n        adj[v].push_back(vu_edge);\n    }\n\n    edge &reverse_edge(const edge &e) {\n        return adj[e.node][e.rev];\n    }\n\n    bool bellman_ford(int source, int sink) {\n        for (int i = 0; i < V; i++) {\n            dist[i] = COST_INF;\n            prev[i] = -1;\n            prev_edge[i] = nullptr;\n        }\n\n        vector<int> last_seen(V, -1);\n        vector<int> nodes(1, source);\n        dist[source] = 0;\n\n        for (int iteration = 0; iteration < V; iteration++) {\n            vector<int> next_nodes;\n\n            for (int node : nodes)\n                for (edge &e : adj[node])\n                    if (e.capacity > 0 && dist[node] + e.cost < dist[e.node]) {\n                        dist[e.node] = dist[node] + e.cost;\n                        prev[e.node] = node;\n                        prev_edge[e.node] = &e;\n\n                        if (last_seen[e.node] != iteration) {\n                            last_seen[e.node] = iteration;\n                            next_nodes.push_back(e.node);\n                        }\n                    }\n\n            swap(nodes, next_nodes);\n        }\n\n        return prev[sink] != -1;\n    }\n\n    struct dijkstra_state {\n        cost_t dist;\n        int node;\n\n        bool operator<(const dijkstra_state &other) const {\n            return dist > other.dist;\n        }\n    };\n\n    void dijkstra_check(int node, cost_t potential_dist, int previous, edge *previous_edge, auto &pq) {\n        if (potential_dist < dist[node]) {\n            dist[node] = potential_dist;\n            prev[node] = previous;\n            prev_edge[node] = previous_edge;\n            pq.push({dist[node], node});\n        }\n    }\n\n    bool dijkstra(int source, int sink) {\n        dist.assign(V, COST_INF);\n        prev.assign(V, -1);\n        prev_edge.assign(V, nullptr);\n\n        priority_queue<dijkstra_state> pq;\n        dijkstra_check(source, 0, -1, nullptr, pq);\n\n        while (!pq.empty()) {\n            dijkstra_state top = pq.top();\n            pq.pop();\n\n            if (top.dist > dist[top.node])\n                continue;\n\n            for (edge &e : adj[top.node])\n                if (e.capacity > 0)\n                    dijkstra_check(e.node, top.dist + e.cost, top.node, &e, pq);\n        }\n\n        return prev[sink] != -1;\n    }\n\n    void reduce_cost() {\n        for (int i = 0; i < V; i++)\n            for (edge &e : adj[i])\n                e.cost += dist[i] - dist[e.node];\n    }\n\n    pair<flow_t, cost_t> solve_min_cost_flow(int source, int sink, flow_t flow_goal = FLOW_INF) {\n        assert(V >= 0);\n\n        if (!bellman_ford(source, sink))\n            return make_pair(0, 0);\n\n        flow_t total_flow = 0;\n        cost_t total_cost = 0;\n        cost_t reduce_sum = 0;\n\n        do {\n            reduce_cost();\n            reduce_sum += dist[sink];\n            flow_t path_cap = flow_goal - total_flow;\n\n            for (int node = sink; prev[node] != -1; node = prev[node])\n                path_cap = min(path_cap, prev_edge[node]->capacity);\n\n            for (int node = sink; prev[node] != -1; node = prev[node]) {\n                edge *e = prev_edge[node];\n                assert(e->cost == 0);\n                e->capacity -= path_cap;\n                reverse_edge(*e).capacity += path_cap;\n            }\n\n            total_flow += path_cap;\n            total_cost += reduce_sum * path_cap;\n        } while (total_flow < flow_goal && dijkstra(source, sink));\n\n        return make_pair(total_flow, total_cost);\n    }\n};\n\n\nstruct assignment_problem {\n    int n;\n    vector<vector<long long>> costs;\n\n    assignment_problem(int _n = -1) : n(_n) {\n        if (n > 0)\n            costs.assign(n, vector<long long>(n, 0));\n    }\n\n    template<typename T>\n    assignment_problem(const vector<vector<T>> &_costs) {\n        build(_costs);\n    }\n\n    template<typename T>\n    void build(const vector<vector<T>> &_costs) {\n        n = _costs.size();\n        costs.assign(n, vector<long long>(n, 0));\n\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < n; j++)\n                costs[i][j] = _costs[i][j];\n    }\n\n    long long solve() {\n        int v = 2 * n + 2, source = v - 2, sink = v - 1;\n        min_cost_flow<int, long long> graph(v);\n\n        for (int i = 0; i < n; i++) {\n            graph.add_directional_edge(source, i, 1, 0);\n            graph.add_directional_edge(n + i, sink, 1, 0);\n        }\n\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < n; j++)\n                graph.add_directional_edge(i, n + j, 1, costs[i][j]);\n\n        return graph.solve_min_cost_flow(source, sink).second;\n    }\n};\n\n\nint N;\nvector<long long> A, B, K;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    cin >> N;\n    A.resize(N);\n    B.resize(N);\n    K.resize(N);\n\n    for (int i = 0; i < N; i++)\n        cin >> A[i] >> B[i] >> K[i];\n\n    assignment_problem solver(N);\n\n    for (int i = 0; i < N; i++)\n        for (long long position = 0; position < N; position++)\n            solver.costs[i][position] = -(max(A[i] - min(K[i], position) * B[i], 0LL));\n\n    cout << -solver.solve() << '\\n';\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}