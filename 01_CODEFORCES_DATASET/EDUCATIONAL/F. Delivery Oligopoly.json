{"link": "https://codeforces.com//contest/1155/problem/F", "problemId": "334466", "shortId": "1155F", "contest_number": "1155", "name": "F. Delivery Oligopoly", "statement": "The whole delivery market of Berland is controlled by two rival companies: BerEx and BerPS. They both provide fast and reliable delivery services across all the cities of Berland.The map of Berland can be represented as an  graph. The cities are vertices and the roads are edges between them. Each pair of cities has no more than one road between them. Each road connects different cities.BerEx and BerPS are so competitive that for each pair of cities  they have set up their paths from  to  in such a way that . It is guaranteed that it was possible.Now Berland government decided to cut down the road maintenance cost by abandoning some roads. Obviously, they want to maintain as little roads as possible. However, they don't want to break the entire delivery system. So BerEx and BerPS should still be able to have their paths between every pair of cities non-intersecting.What is the minimal number of roads Berland government can maintain?", "input": "The first line contains two integers  and  (, ) \u2014 the number of cities and the number of roads between them. Each of the next  lines contains two integers  and  (, ) \u2014 the cities connected by the next road.  It is guaranteed that each pair of cities has no more than one road between them. It is guaranteed that each pair of cities have at least two paths between them that don't share a single road.", "output": "The first line should contain a single integer  \u2014 the minimum number of roads Berland government can maintain so that BerEx and BerPS are still able to have their paths between every pair of cities non-intersecting. The next  lines should contain the list of roads which are being maintained. Each line of form \"\", where  and  are cities connected by the next road. If there are multiple lists of minimum size, print any of them. The order of roads in the list doesn't matter.", "tutorial": "Let's use dynamic programming to solve this problem. We will start with a single biconnected component consisting of vertex , and connect other vertices to it. So, the state of our dynamic programming will be a  of vertices that are in the same biconnected component with .How can we extend a biconnected component in such a way that some other vertices are added into it, but it is still biconnected? We will add a path (possibly cyclic) that starts in some vertex  belonging to the , goes through some vertices , and ends in some vertex  belonging to the  (possibly ). If for every triple (, , ) we precalculate some path that starts in , goes through vertices from  and ends in  (and  does not contain neither  nor ), then we can solve the problem in : there will be  states, for every state we will iterate on two vertices  and  belonging to the , and the number of possible pairs of non-intersecting masks  and  is .The only thing that's left is precalculating the paths for triples (, , ). That can be done with auxiliary dynamic programming  which will denote whether such a path exists. For every edge  of the original graph,  is true, and we can go from  to some state , where  will contain all vertices from  and vertex  (and we should ensure that there is an edge  in the graph and the  didn't contain vertex  earlier). We should also somehow be able to restore the paths from this dp, and we also should be careful not to choose the same edge twice (for example, if we start a path by edge , we should not use the same edge to return to ) \u2014 both these things can be done, for example, by storing next-to-last vertex in the path. ", "solution": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N = 14;\nconst int INF = int(1e9);\n\nint dp[1 << N];\nint par[1 << N];\nint last[1 << N];\npair<int, int> last_pair[1 << N];\nint dp2[N][N][1 << N];\nint lastv[N][N][1 << N];\nvector<int> bits[1 << N];\n\nint n;\nint m;\nvector<int> g[N];\n\nint main()\n{\n\tcin >> n >> m;\n\tfor(int i = 0; i < m; i++)\n\t{\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t--x;\n\t\t--y;\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t}\n\tfor(int i = 0; i < (1 << n); i++)\n\t\tdp[i] = INF;\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = 0; j < n; j++)\n\t\t\tfor(int z = 0; z < (1 << n); z++)\n\t\t\t\tdp2[i][j][z] = INF;\n\tfor(int i = 0; i < n; i++)\n\t\tfor(auto x : g[i])\n\t\t{\n\t\t\tdp2[i][x][0] = 1;\n\t\t\tlastv[i][x][0] = i;\n\t\t}\n\tfor(int mask = 0; mask < (1 << n); mask++)\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tfor(int j = 0; j < n; j++)\n\t\t\t{\n\t\t\t\tif((mask & (1 << i)) || (mask & (1 << j)) || (i == j) || (dp2[i][j][mask] == INF))\n\t\t\t\t\tcontinue;\n\t\t\t\tfor(auto z : g[j])\n\t\t\t\t{\n\t\t\t\t\tif(mask & (1 << z)) continue;\n\t\t\t\t\tif(z == lastv[i][j][mask]) continue;\n\t\t\t\t\tint nmask = mask ^ (1 << j);\n\t\t\t\t\tif(dp2[i][z][nmask] == INF)\n\t\t\t\t\t{\n\t\t\t\t\t\tdp2[i][z][nmask] = 1;\n\t\t\t\t\t\tlastv[i][z][nmask] = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\tfor(int mask = 0; mask < (1 << n); mask++)\n\t\tfor(int j = 0; j < n; j++)\n\t\t\tif(mask & (1 << j))\n\t\t\t\tbits[mask].push_back(j);\n\tdp[1] = 0;\n\tfor(int mask = 0; mask < (1 << n); mask++)\n\t\tfor(int addmask = mask; addmask; addmask = (addmask - 1) & mask)\n\t\t{\n\t\t\tint lastmask = mask ^ addmask;\n\t\t\tint cnt = __builtin_popcount(addmask) + 1;\n\t\t\tif(dp[lastmask] + cnt >= dp[mask])\n\t\t\t\tcontinue;\n\t\t\tbool f = false;\n\t\t\tfor(auto x : bits[lastmask])\n\t\t\t{\n\t\t\t\tfor(auto y : bits[lastmask])\n\t\t\t\t{\n\t\t\t\t\tif(dp2[x][y][addmask] == 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[mask] = dp[lastmask] + cnt;\n\t\t\t\t\t\tlast_pair[mask] = make_pair(x, y);\n\t\t\t\t\t\tlast[mask] = addmask;\n\t\t\t\t\t}\n\t\t\t\t\tif(f) break;\n\t\t\t\t}\n\t\t\t\tif(f) break;\n\t\t\t}\n\t\t}\n\tif(dp[(1 << n) - 1] == INF)\n\t\tcout << -1 << endl;\n\telse\n\t{\n\t\tcout << dp[(1 << n) - 1] << endl;\n\t\tint cur = (1 << n) - 1;\n\t\twhile(cur != 1)\n\t\t{\n\t\t\tint lst = last[cur];\n\t\t\tint x = last_pair[cur].first;\n\t\t\tint y = last_pair[cur].second;\n\t\t\tcur ^= lst;\n\t\t\twhile(lst)\n\t\t\t{\n\t\t\t\tint ny = lastv[x][y][lst];\n\t\t\t\tcout << y + 1 << \" \" << ny + 1 << endl;\n\t\t\t\tlst ^= (1 << ny);\n\t\t\t\ty = ny;\n\t\t\t}\n\t\t\tcout << x + 1 << \" \" << y + 1 << endl;\n\t\t}\n\t}\n}", "interactive": false, "noSolution": false, "noTutorial": false}