{"link": "https://codeforces.com//contest/660/problem/A", "problemId": "54407", "shortId": "660A", "contest_number": "660", "name": "A. Co-prime Array", "statement": "You are given an array of  elements, you must make it a co-prime array in as few moves as possible.In each move you can insert any positive integral number you want not greater than  in any place in the array.An array is co-prime if any two adjacent numbers of it are co-prime.In the number theory, two integers  and  are said to be co-prime if the only positive integer that divides both of them is .", "input": "The first line contains integer  () \u2014 the number of elements in the given array. The second line contains  integers  () \u2014 the elements of the array .", "output": "Print integer  on the first line \u2014 the least number of elements needed to add to the array  to make it co-prime. The second line should contain  integers  \u2014 the elements of the array  after adding  elements to it. Note that the new array should be co-prime, so any two adjacent values should be co-prime. Also the new array should be got from the original array  by adding  elements to it. If there are multiple answers you can print any one of them.", "tutorial": "Note that we should insert some number between any adjacent not co-prime elements. On other hand we always can insert the number .\n", "solution": "const int N = 1010;\n\nint n, a[N];\n\nbool read() {\n\tif (!(cin >> n)) return false;\n\tforn(i, n) assert(scanf(\"%d\", &a[i]) == 1);\n\treturn true;\n}\n\nvoid solve() {\n\tfunction<int(int, int)> gcd = [&](int a, int b) { return !a ? b : gcd(b % a, a); };\n\n\tvector<int> ans;\n\tforn(i, n) {\n\t\tans.pb(a[i]);\n\t\tif (i + 1 < n && gcd(a[i], a[i + 1]) > 1)\n\t\t\tans.pb(1);\n\t}\n\n\tcout << sz(ans) - n << endl;\n\tforn(i, sz(ans)) {\n\t\tif (i) putchar(' ');\n\t\tprintf(\"%d\", ans[i]);\n\t}\n\tputs(\"\");\n}", "interactive": false, "noSolution": false, "noTutorial": false}