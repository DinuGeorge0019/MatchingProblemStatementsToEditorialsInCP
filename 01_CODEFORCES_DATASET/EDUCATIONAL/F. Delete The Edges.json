{"link": "https://codeforces.com//contest/1494/problem/F", "problemId": "913255", "shortId": "1494F", "contest_number": "1494", "name": "F. Delete The Edges", "statement": "You are given an undirected connected graph consisting of  vertices and  edges. Your goal is to destroy all edges of the given graph.You may choose any vertex as the starting one and begin walking from it along the edges. When you walk along an edge, you destroy it. Obviously, you cannot walk along an edge if it is destroyed.You can perform the  operation at most once during your walk, and this operation can only be performed when you are at some vertex (you cannot perform it while traversing an edge). After the , the edges you go through are deleted in the following way: the first edge after the  is not destroyed, the second one is destroyed, the third one is not destroyed, the fourth one is destroyed, and so on. You cannot switch back to the original mode, and you don't have to perform this operation if you don't want to.Can you destroy all the edges of the given graph?", "input": "The first line contains two integers  and  (; )) \u2014 the numbef of vertices and the number of edges in the graph. Then  lines follow, each containing two integers  and  (; ) \u2014 the endpoints of the -th edge.  These edges form a connected undirected graph without multiple edges.", "output": "If it's impossible to destroy all of the edges, print . Otherwise, print the sequence of your actions as follows. First, print  \u2014 the number of actions (). Then, print the sequence itself, consisting of  integers. The first integer should be the index of the starting vertex. Then, each of the next integers should be either the index of the next vertex in your traversal, or  if you use . You are allowed to use  at most once. If there are multiple answers, print any of them.", "tutorial": "Let's suppose our graph is split into two graphs  and , the first graph contains the edges we delete before the mode shift, the second graph contains the edges we delete after the mode shift.It's quite obvious that the graph  has an eulerian path. The structure of  is a bit harder to analyze, but we can prove that it is always a star graph (a vertex and some other vertices connected directly to it), and the center of the star coincides with the last vertex in the eulerian path in . To prove that  is a star graph, we can consider the second part of the path (after the mode shift) backward: the last edge we traversed was deleted, and the previous-to-last move could have been only along that edge. The third-last and the fourth-last moves should have been along another edge connecting some vertex to the center of the star, and so on.Okay, how do we find a way to split the graph into  and ? Iterate on the center of the star (let it be ). For the graph  to contain an eulerian path, it should have at most  vertices with an odd degree. Let's construct  in such a way that we minimize the number of odd vertices in \u00a0\u2014 for each edge incident to , we either move it to  or  in such a way that the resulting degree of the other vertex is even. All other edges belong to .If there is an eulerian path in  that ends in , we are done. Otherwise, we should iterate on some edge adjacent to  and change its status (in order to check if  can have an eulerian path after that). We can't \"flip\" two edges because flipping two edges increases the number of odd vertices in  at least by  (if it is already  or greater, the eulerian path won't exist, and if it's , then flipping two edges creates two odd vertices, none of which is , so eulerian path can't end in ). After flipping each edge, we try to find an eulerian path in  once again and flip the edge back. After checking the vertex  as the center of the star, we return all adjacent edges to  and move to the next vertex.The whole algorithm requires checking for the existence of the eulerian path  times, so it should work in  or  depending on the implementation.Fun fact: initially I wanted to give a harder version of a problem with  that would require some sort of dynamic connectivity to check for an eulerian path fast, but when I started coding it, I realized that implementation there was a bit painful, so I've decided to drop the constraints to allow quadratic solutions.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 300043;\n\nint n, m;\nset<int> g[N];\nset<int> g2[N];\n\nvector<int> res;\n\nvoid euler(int x)\n{\n    while(!g2[x].empty())\n    {\n        int y = *g2[x].begin();\n        g2[x].erase(y);\n        g2[y].erase(x);\n        euler(y);\n    }\n    res.push_back(x);\n}\n\nbool check(int c)\n{\n    for(int i = 1; i <= n; i++)\n        g2[i] = g[i];\n    res = vector<int>();\n    euler(c);\n    int curm = 0;\n    for(int i = 1; i <= n; i++)\n        curm += g[i].size();\n    for(int i = 1; i <= n; i++)\n        g2[i] = g[i];\n    for(int i = 1; i < res.size(); i++)\n    {\n        int x = res[i - 1];\n        int y = res[i];\n        if(g2[x].count(y) != 1)\n            return false;\n        g2[x].erase(y);\n        g2[y].erase(x);\n    }\n    return curm / 2 + 1 == res.size();    \n}\n\nint main()\n{\n    scanf(\"%d %d\", &n, &m);\n    for(int i = 0; i < m; i++)\n    {\n        int x, y;\n        scanf(\"%d %d\", &x, &y);\n        g[x].insert(y);\n        g[y].insert(x);\n    }\n    for(int i = 1; i <= n; i++)\n    {\n        set<int> pr = g[i];\n        set<int> diff;\n        for(auto x : pr)\n            if(g[x].size() % 2 == 1)\n            {\n                g[i].erase(x);\n                g[x].erase(i);\n                diff.insert(x);\n            }\n        if(check(i))\n        {\n            res.push_back(-1);\n            for(auto x : diff)\n            {\n                res.push_back(x);\n                res.push_back(i);\n            }\n            printf(\"%d\\n\", res.size());\n            for(auto x : res) printf(\"%d \", x);\n            puts(\"\");\n            exit(0);\n        }\n        for(auto x : pr)\n        {\n            if(g[i].count(x))\n            {\n                g[i].erase(x);\n                g[x].erase(i);\n                diff.insert(x);\n            }\n            else\n            {\n                g[i].insert(x);\n                g[x].insert(i);\n                diff.erase(x);\n            }\n            if(check(i))\n            {\n                res.push_back(-1);\n                for(auto x : diff)\n                {\n                    res.push_back(x);\n                    res.push_back(i);\n                }\n                printf(\"%d\\n\", res.size());\n                for(auto x : res) printf(\"%d \", x);\n                puts(\"\");\n                exit(0);\n            }\n            if(g[i].count(x))\n            {\n                g[i].erase(x);\n                g[x].erase(i);\n                diff.insert(x);\n            }\n            else\n            {\n                g[i].insert(x);\n                g[x].insert(i);\n                diff.erase(x);\n            }\n        }\n        for(auto x : diff)\n        {\n            g[i].insert(x);\n            g[x].insert(i);\n        }\n    }\n    puts(\"0\");\n}", "interactive": false, "noSolution": false, "noTutorial": false}