{"link": "https://codeforces.com//contest/1795/problem/B", "problemId": "1785698", "shortId": "1795B", "contest_number": "1795", "name": "B. Ideal Point", "statement": "You are given  one-dimensional segments (each segment is denoted by two integers\u00a0\u2014 its endpoints).Let's define the function  as the number of segments covering point  (a segment covers the point  if , where  is the left endpoint and  is the right endpoint of the segment).An integer point  is called  if it belongs to more segments than any other integer point, i.\u2009e.  is true for any other integer point .You are given an integer . Your task is to determine whether it is possible to remove some (possibly zero) segments, so that the given point  becomes .", "input": "The first line contains one integer  ()\u00a0\u2014 the number of test cases. The first line of each test case contains two integers  and  (). Then  lines follow, -th line of them contains two integers  and  (; )\u00a0\u2014 the endpoints of the -th segment.", "output": "For each test case, print  if it is possible to remove some (possibly zero) segments, so that the given point  becomes , otherwise print . You may print each letter in any case (, ,  will all be recognized as positive answer, ,  and  will all be recognized as negative answer).", "tutorial": "First of all, let's delete all segments that do not cover the point  (because they increase the value of the function  at points other than ). If there are no segments left, then the answer is . Otherwise, all segments cover the point . And it remains to check whether the point  is the only point which is covered by all segments. Note that it does not make sense to delete any of the remaining segments, because if there are several points with maximum value of , then deleting segments can only increase their number.To check the number of points with the maximum value of , you can iterate over  from  to  and calculate , because of the small number of segments in the problem. A faster way is to check the size of the intersection of all segments. The left boundary of the intersection is , and the right boundary is ; if , then the point  is ideal, otherwise it is not.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  int t;\n  cin >> t;\n  while (t--) {\n    int n, k;\n    cin >> n >> k;\n    int L = 0, R = 55;\n    while (n--) {\n      int l, r;\n      cin >> l >> r;\n      if (l <= k && k <= r)\n        L = max(L, l), R = min(R, r);\n    }\n    cout << (L == R ? \"YES\\n\" : \"NO\\n\");\n  }\n}", "interactive": false, "noSolution": false, "noTutorial": false}