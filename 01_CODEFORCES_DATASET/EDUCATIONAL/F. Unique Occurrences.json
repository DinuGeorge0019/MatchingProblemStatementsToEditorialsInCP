{"link": "https://codeforces.com//contest/1681/problem/F", "problemId": "1408807", "shortId": "1681F", "contest_number": "1681", "name": "F. Unique Occurrences", "statement": "You are given a tree, consisting of  vertices. Each edge has an integer value written on it.Let  be the number of values that appear  on the edges of a simple path between vertices  and .Calculate the sum of  over all pairs of vertices  and  such that .", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of vertices in the tree. Each of the next  lines contains three integers  and  ()\u00a0\u2014 the description of an edge: the vertices it connects and the value written on it. The given edges form a tree.", "output": "Print a single integer\u00a0\u2014 the sum of  over all pairs of vertices  and  such that .", "tutorial": "Let's use contribution to the sum technique to simplify the problem. Instead of counting the number of colors that occure only once for each path, let's, for each color, count the number of paths that contain this color exactly once. Now we can solve the problem independently for each color, and sum up the answers.The first intended solution was the following. So we want to calculate the answer for some color . Mark all edges of color  as good, the rest are bad. Then we can calculate \u00a0\u2014 the number of paths up to vertex  such that they contain either  or  good edges. The transitions should be pretty easy, and the answer should be updated when you consider gluing up paths from different children in each vertex. Obviously, this is  per color, so  overall.However, we can only calculate this dynamic programming as easily on a virtual tree of vertices adjacent to all good edges. How to calculate the dp for some vertex ? First, push the paths from all virtual children to . That was enough in the dp for the entire tree but now there are also removed vertices that could also have paths starting in them. All these paths contain  good edges (otherwise, they would have had virtual vertices on them). Their amount is the following: the size of the real subtree of  minus the sizes of real subtrees of all its virtual children. The rest is exactly the same as in the dp on the real tree.A little fun trick. Usually, you want to add lca of adjacent vertices to the virtual tree. But that's actually not needed here: you can just add the root of the tree and link the vertices without a parent to them. That won't change the result of the dp.That solution works in  or .The second intended solution is slower complexity-wise but not time-wise. In the first solution we wanted to leave only the good edges in the tree. Here, we want to remove only them. Consider the resulting connected components. What's the number of paths that contain only one of the good edges? It's actually the product of sizes of the connected components this edge connects.So we want to remove edges, add edges and maintain the sizes of the connected components of the tree. That's basically the same problem as dynamic connectivity. The  implementation works well enough.", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nstruct edge{\n\tint u, w;\n};\n\nint n;\nvector<vector<edge>> g;\nvector<vector<int>> ng;\nvector<int> tin, tout, siz, ord;\nint T;\n\nvector<int> pw;\n\nvoid init(int v, int p = -1){\n\ttin[v] = T++;\n\tord.push_back(v);\n\tsiz[v] = 1;\n\tfor (const auto &it : g[v]){\n\t\tint u = it.u, w = it.w;\n\t\tif (u == p) continue;\n\t\tpw[u] = w;\n\t\tinit(u, v);\n\t\tsiz[v] += siz[u];\n\t}\n\ttout[v] = T;\n}\n\nint isp(int v, int u){\n\treturn tin[v] <= tin[u] && tout[v] >= tout[u];\n}\n\nvector<int> nsiz;\nvector<vector<int>> dp;\n\nlong long dfs(int v, int x){\n\tlong long res = 0;\n\tfor (int u : ng[v])\n\t\tres += dfs(u, x);\n\tdp[v][0] = siz[v];\n\tdp[v][1] = 0;\n\tfor (int u : ng[v]) dp[v][0] -= siz[u];\n\tfor (int u : ng[v]){\n\t\tif (pw[u] == x){\n\t\t\tres += dp[u][0] * 1ll * dp[v][0];\n\t\t\tdp[v][1] += dp[u][0];\n\t\t}\n\t\telse{\n\t\t\tres += dp[u][0] * 1ll * dp[v][1];\n\t\t\tres += dp[u][1] * 1ll * dp[v][0];\n\t\t\tdp[v][0] += dp[u][0];\n\t\t\tdp[v][1] += dp[u][1];\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\t\n\tg.resize(n);\n\tforn(i, n - 1){\n\t\tint v, u, w;\n\t\tscanf(\"%d%d%d\", &v, &u, &w);\n\t\t--v, --u, --w;\n\t\tg[v].push_back({u, w});\n\t\tg[u].push_back({v, w});\n\t}\n\t\n\tT = 0;\n\ttin.resize(n);\n\ttout.resize(n);\n\tsiz.resize(n);\n\tpw.resize(n, -1);\n\tinit(0);\n\t\n\tvector<vector<int>> sv(n, vector<int>(1, 0));\n\tfor (int v : ord) for (auto it : g[v])\n\t\tsv[it.w].push_back(v);\n\t\n\tng.resize(n);\n\tnsiz.resize(n);\n\tdp.resize(n, vector<int>(2));\n\tlong long ans = 0;\n\tforn(i, n) if (!sv[i].empty()){\n\t\tsv[i].resize(unique(sv[i].begin(), sv[i].end()) - sv[i].begin());\n\t\tvector<int> st;\n\t\tfor (int v : sv[i]){\n\t\t\twhile (!st.empty() && !isp(st.back(), v))\n\t\t\t\tst.pop_back();\n\t\t\tif (!st.empty())\n\t\t\t\tng[st.back()].push_back(v);\n\t\t\tst.push_back(v);\n\t\t}\n\t\tans += dfs(0, i);\n\t\t\n\t\tfor (int v : sv[i]) ng[v].clear();\n\t}\n\t\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}