{"link": "https://codeforces.com//contest/1620/problem/C", "problemId": "1233290", "shortId": "1620C", "contest_number": "1620", "name": "C. BA-String", "statement": "You are given an integer  and a string  that consists only of characters 'a' (a lowercase Latin letter) and '*' (an asterisk).Each asterisk should be replaced with several (from  to  inclusive) lowercase Latin letters 'b'. Different asterisk can be replaced with different counts of letter 'b'.The result of the replacement is called a .Two strings  and  are different if they either have different lengths or there exists such a position  that .A string  is lexicographically smaller than a string  if and only if one of the following holds:    is a prefix of , but ;  in the first position where  and  differ, the string  has a letter that appears earlier in the alphabet than the corresponding letter in . Now consider all different BA-strings and find the -th lexicographically smallest of them.", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of testcases. The first line of each testcase contains three integers ,  and  (; ; ).  is the length of string . The second line of each testcase is a string . It consists of  characters, each of them is either 'a' (a lowercase Latin letter) or '*' (an asterisk). The sum of  over all testcases doesn't exceed .  String  contains at least one character 'a'.", "output": "For each testcase, print a single string, consisting only of characters 'b' and 'a' (lowercase Latin letters)\u00a0\u2014 the -th lexicographically smallest BA-string.", "tutorial": "Find all segments of asterisks in the string. Let there be  of them, and the number of asterisks in them be . That tells us that the -th segment of asterisks can be replaced with at most  letters 'b'.Notice that we can compare two strings lexicographically using just the number of letters 'b' that replace each of  segments of asterisks. Let that sequence for some string  be  and that sequence for some string  be . Then  if and only if . That is, there exists such position  that . The proof is trivial.So we can actually look at the sequence  as some kind of number in a mixed base. The lowest \"digit\"  can be of one of  values (from  to ). The second lowest\u00a0\u2014 one of . And so on. Then, comparison of two strings is the same as comparison of these two mixed base numbers.Thus, the task is to convert number  to this mixed base. Turns out, it's not that hard. In base , for example, the lowest digit can be determined as the remainder of the number of dividing by . Here it will be the remainder of dividing by . After that, divide and floor the number and proceed to the next \"digit\".After  steps are done, the \"digits\" of that mixed base number tell exactly how many letters 'b' should replace each segment of asterisks.Overall complexity:  per testcase to recover the string,  to print it.", "solution": "for _ in range(int(input())):\n  n, k, x = map(int, input().split())\n  x -= 1\n  s = input()[::-1]\n  res = []\n  i = 0\n  while i < n:\n    if s[i] == 'a':\n      res.append(s[i])\n    else:\n      j = i\n      while j + 1 < n and s[j + 1] == s[i]:\n        j += 1\n      cur = (j - i + 1) * k + 1\n      res.append('b' * (x % cur))\n      x //= cur\n      i = j\n    i += 1\n  print(''.join(res[::-1]))", "interactive": false, "noSolution": false, "noTutorial": false}