{"link": "https://codeforces.com//contest/1334/problem/E", "problemId": "590685", "shortId": "1334E", "contest_number": "1334", "name": "E. Divisor Paths", "statement": "You are given a positive integer . Let's build the following graph from it:   each vertex is a divisor of  (not necessarily prime,  and  itself are also included);  two vertices  and  () have an undirected edge between them if  is divisible by  and  is a prime;  the weight of an edge is the number of divisors of  that are not divisors of . For example, here is the graph for :   Edge  has weight  because  has divisors  and  has divisors . Thus, there are  divisors of  that are not divisors of  \u2014 .There is no edge between  and  because  is not divisible by . There is no edge between  and  because  is not a prime.Let the length of the path between some vertices  and  in the graph be the total weight of edges on it. For example, path  has length . The empty path has length .So the shortest path between two vertices  and  is the path that has the minimal possible length.Two paths  and  are different if there is either a different number of edges in them or there is a position  such that  and  are different edges.You are given  queries of the following form:     \u2014 calculate the  between vertices  and . The answer for each query might be large so print it modulo .", "input": "The first line contains a single integer  () \u2014 the number the graph is built from. The second line contains a single integer  () \u2014 the number of queries. Each of the next  lines contains two integers  and  (). It is guaranteed that  is divisible by both  and  (both  and  are divisors of ).", "output": "Print  integers \u2014 for each query output the  between the two given vertices modulo .", "tutorial": "Let's define the semantics of moving along the graph. On each step the current number is either multiplied by some prime or divided by it.I claim that the all shortest paths from  to  always go through . Moreover, the vertex numbers on the path first only decrease until  and only increase after it.Let's watch what happens to the divisors list on these paths. At first, all the divisors of  that are not divisors of  are removed from the list. Now we reach gcd and we start adding the divisors of  that are missing from the list. The length of the path is this total number of changes to the list. That shows us that these paths are the shortest by definition.If we ever take a turn off that path, we either will add some divisor that we will need to remove later or remove some divisor that we will need to add later. That makes the length of the path not optimal.Now let's learn to calculate the number of paths. The parts before gcd and after it will be calculated separately, the answer is the product of answers for both parts.How many paths are there to gcd? Well, let's divide  by , that will give us the primes that should be removed from . You can remove them in any order because the length of the path is always the same. That is just the number of their permutations with repetitions (you might also know that formula as multinomial coefficient).The number of paths from  to  is calculated the same way.To find the primes in  you can factorize  beforehand and only iterate over the primes of .Overall complexity: .", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int MOD = 998244353;\n\nint add(int a, int b){\n\ta += b;\n\tif (a >= MOD)\n\t\ta -= MOD;\n\tif (a < 0)\n\t\ta += MOD;\n\treturn a;\n}\n\nint mul(int a, int b){\n\treturn a * 1ll * b % MOD;\n}\n\nint binpow(int a, int b){\n\tint res = 1;\n\twhile (b){\n\t\tif (b & 1)\n\t\t\tres = mul(res, a);\n\t\ta = mul(a, a);\n\t\tb >>= 1;\n\t}\n\treturn res;\n}\n\nint main() {\n\tlong long d;\n\tscanf(\"%lld\", &d);\n\tint q;\n\tscanf(\"%d\", &q);\n\t\n\tvector<long long> primes;\n\tfor (long long i = 2; i * i <= d; ++i) if (d % i == 0){\n\t\tprimes.push_back(i);\n\t\twhile (d % i == 0) d /= i;\n\t}\n\tif (d > 1){\n\t\tprimes.push_back(d);\n\t}\n\t\n\tvector<int> fact(100), rfact(100);\n\tfact[0] = 1;\n\tfor (int i = 1; i < 100; ++i)\n\t\tfact[i] = mul(fact[i - 1], i);\n\trfact[99] = binpow(fact[99], MOD - 2);\n\tfor (int i = 98; i >= 0; --i)\n\t\trfact[i] = mul(rfact[i + 1], i + 1);\n\t\n\tforn(i, q){\n\t\tlong long x, y;\n\t\tscanf(\"%lld%lld\", &x, &y);\n\t\tvector<int> up, dw;\n\t\tfor (auto p : primes){\n\t\t\tint cnt = 0;\n\t\t\twhile (x % p == 0){\n\t\t\t\t--cnt;\n\t\t\t\tx /= p;\n\t\t\t}\n\t\t\twhile (y % p == 0){\n\t\t\t\t++cnt;\n\t\t\t\ty /= p;\n\t\t\t}\n\t\t\tif (cnt < 0) dw.push_back(-cnt);\n\t\t\telse if (cnt > 0) up.push_back(cnt);\n\t\t}\n\t\tint ans = 1;\n\t\tans = mul(ans, fact[accumulate(up.begin(), up.end(), 0)]);\n\t\tfor (auto it : up) ans = mul(ans, rfact[it]);\n\t\tans = mul(ans, fact[accumulate(dw.begin(), dw.end(), 0)]);\n\t\tfor (auto it : dw) ans = mul(ans, rfact[it]);\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}