{"link": "https://codeforces.com//contest/1613/problem/F", "problemId": "1209366", "shortId": "1613F", "contest_number": "1613", "name": "F. Tree Coloring", "statement": "You are given a rooted tree consisting of  vertices numbered from  to . The root of the tree is the vertex .You have to color all vertices of the tree into  colors (also numbered from  to ) so that there is exactly one vertex for each color. Let  be the color of vertex , and  be the parent of vertex  in the rooted tree. The coloring is considered beautiful if there is no vertex  () such that , i.\u2009e. no vertex such that its color is less than the color of its parent by .Calculate the number of beautiful colorings, and print it modulo .", "input": "The first line contains one integer  () \u2014 the number of vertices in the tree. Then  lines follow, the -th line contains two integers  and  (; ) denoting an edge between the vertex  and the vertex . These edges form a tree.", "output": "Print one integer \u2014 the number of beautiful colorings, taken modulo .", "tutorial": "When a problem asks us to calculate the number of combinatorial objects that meet some constraints, we can sometimes use inclusion-exclusion formula. Let's try to apply it in this problem.We could use  constraints that should not be violated. The -th constraint is formulated as follows:  (there will be a constraint of this type for each ). Suppose we violated  of these constraints (and have chosen which  constraints to violate), then the number of colorings that meet these violations is  (for  vertices, the colors on them depend on some other independent vertices, so we can assign only colors for independent vertices). So, the answer can be calculated as follows: ,where  is the number of ways to choose  constraints to violate.One initial guess how to calculate  is that , as it would be calculated in other, more usual inclusion-exclusion problems. Unfortunately, in this problem, the constraints we violate are not independent. For example, if a vertex has several sons, we can violate the constraint only on at most one edge leading from a vertex to its son simultaneously, we cannot violate two or more such constraints.Let's take care of this issue as follows: we can write a dynamic programming of the form  is the number of ways to process  first vertices of the tree and choose exactly  edges leading from these nodes to their sons so that no vertex has more than one edge leading to its sons chosen. Then,  is exactly the number of ways to choose  edges in the tree so that no vertex has more than one chosen edge leading to its sons, and that will be equal to .We can calculate this dynamic programming in a knapsack fashion in , but it is too slow. Instead, let's optimize this knapsack DP with FFT: for each vertex , introduce a polynomial , where  is the number of children of the vertex . Coefficients of this polynomial for the first vertex are the values of ; coefficients of the product of this polynomial with the polynomial for the second vertex are the values of , and so on; to obtain the values of , we have to multiply all these polynomials, and using FFT + divide-and-conquer, we can do it in .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define fore(i, l, r) for (int i = int(l); i < int(r); ++i)\n#define sz(a) int((a).size())\n\nconst int MOD = 998244353;\n\nstruct Mint\n{\n  int val;\n\n  bool operator==(const Mint& other)\n  {\n    return val == other.val;\n  }\n\n  Mint operator+(const Mint& other)\n  {\n    int res = val + other.val;\n    while(res >= MOD) res -= MOD;\n    while(res < 0) res += MOD;\n    return Mint(res);\n  }\n\n  Mint operator-(const Mint& other)\n  {\n    int res = val - other.val;\n    while(res >= MOD) res -= MOD;\n    while(res < 0) res += MOD;\n    return Mint(res);  \n  }\n\n  Mint operator*(const Mint& other)\n  {\n    return Mint((val * 1ll * other.val) % MOD);\n  }\n\n  Mint pow(int y)\n  {\n    Mint z(1);\n    Mint x(val);\n    while(y > 0)\n    {\n      if(y % 2 == 1) z = z * x;\n      x = x * x;\n      y /= 2;\n    }\n    return z;\n  }\n\n  Mint operator/(const Mint& other)\n  {\n    return Mint(val) * Mint(other.val).pow(MOD - 2);\n  }\n\n  Mint() {\n      val = 0;\n  };\n  Mint(int x)\n  {\n    while(x >= MOD) x -= MOD;\n    while(x < 0) x += MOD;\n    val = x;\n  };\n};\n\nostream& operator<<(ostream& out, const Mint& x)\n{\n  return out << x.val;\n}\n\nconst int g = 3;\nconst int LOGN = 19;\n\nvector<Mint> w[LOGN];\nvector<int> rv[LOGN];\n\nvoid prepare() {\n  Mint wb = Mint(g).pow((MOD - 1) / (1 << LOGN));\n  forn(st, LOGN - 1) {\n    w[st].assign(1 << st, 1);\n    Mint bw = wb.pow(1 << (LOGN - st - 1));\n    Mint cw = 1;\n    forn(k, 1 << st) {\n      w[st][k] = cw;\n      cw = cw * bw;\n    }\n  }\n  forn(st, LOGN) {\n    rv[st].assign(1 << st, 0);\n    if (st == 0) {\n      rv[st][0] = 0;\n      continue;\n    }\n    int h = (1 << (st - 1));\n    forn(k, 1 << st)\n      rv[st][k] = (rv[st - 1][k & (h - 1)] << 1) | (k >= h);\n  }\n}\n\nvoid ntt(vector<Mint> &a, bool inv) {\n  int n = sz(a);\n  int ln = __builtin_ctz(n);\n  forn(i, n) {\n    int ni = rv[ln][i];\n    if (i < ni) swap(a[i], a[ni]);\n  }\n  forn(st, ln) {\n    int len = 1 << st;\n    for (int k = 0; k < n; k += (len << 1)) {\n      fore(pos, k, k + len){\n        Mint l = a[pos];\n        Mint r = a[pos + len] * w[st][pos - k];\n        a[pos] = l + r;\n        a[pos + len] = l - r;\n      }\n    }\n  }\n  if (inv) {\n    Mint rn = Mint(n).pow(MOD - 2);\n    forn(i, n) a[i] = a[i] * rn;\n    reverse(a.begin() + 1, a.end());\n  }\n}\n\nvector<Mint> mul(vector<Mint> a, vector<Mint> b) {\n  int cnt = 1 << (32 - __builtin_clz(sz(a) + sz(b) - 1));\n  a.resize(cnt);\n  b.resize(cnt);\n  ntt(a, false);\n  ntt(b, false);\n  vector<Mint> c(cnt);\n  forn(i, cnt) c[i] = a[i] * b[i];\n  ntt(c, true);\n  return c;\n}\n\nvector<Mint> norm(vector<Mint> a)\n{\n  while(a.size() > 1 && a.back() == Mint(0))\n    a.pop_back();\n  return a;\n}\n\nconst int N = 250043;\nvector<int> G[N];\nint d[N];\n\nMint fact[N * 2];\nMint rev[N * 2];\n\nvoid dfs(int x, int p)\n{\n  if(p != x) d[p]++;\n  for(auto y : G[x]) if(y != p) dfs(y, x);\n}\n\nMint C(int n, int k)\n{\n  return fact[n] * rev[k] * rev[n - k];\n}\n\nint main()\n{\n  prepare();\n  fact[0] = Mint(1);\n  for(int i = 1; i < N * 2; i++) fact[i] = fact[i - 1] * i;\n  for(int i = 0; i < N * 2; i++) rev[i] = Mint(1) / fact[i];\n  int n;\n  scanf(\"%d\", &n);\n  for(int i = 0; i < n - 1; i++)\n  {\n    int x, y;\n    scanf(\"%d %d\", &x, &y);\n    --x;\n    --y;\n    G[x].push_back(y);\n    G[y].push_back(x);  \n  }\n  dfs(0, 0);\n  vector<vector<Mint>> cur;\n  for(int i = 0; i < n; i++)\n    if(d[i] > 0)\n      cur.push_back(vector<Mint>({Mint(1), Mint(d[i])}));\n  while(cur.size() > 1)\n  {\n    vector<vector<Mint>> ncur;\n    for(int i = 0; i + 1 < cur.size(); i += 2)\n      ncur.push_back(norm(mul(cur[i], cur[i + 1])));\n    if(cur.size() % 2 == 1) ncur.push_back(cur.back());\n    cur = ncur;  \n  }\n  Mint ans = 0;\n  for(int i = 0; i < cur[0].size(); i++)\n  {\n    if(i % 2 == 0) ans = ans + cur[0][i] * fact[n - i];\n    else ans = ans - cur[0][i] * fact[n - i];\n  }\n  cout << ans << endl;\n}", "interactive": false, "noSolution": false, "noTutorial": false}