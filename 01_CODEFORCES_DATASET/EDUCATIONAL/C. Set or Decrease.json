{"link": "https://codeforces.com//contest/1622/problem/C", "problemId": "1242579", "shortId": "1622C", "contest_number": "1622", "name": "C. Set or Decrease", "statement": "You are given an integer array  and integer .In one step you can   either choose some index  and decrease  by one (make );  or choose two indices  and  and set  equal to  (make ). What is the minimum number of steps you need to make the sum of array ? (You are allowed to make values of array negative).", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of test cases. The first line of each test case contains two integers  and  (; )\u00a0\u2014 the size of array  and upper bound on its sum. The second line of each test case contains  integers  ()\u00a0\u2014 the array itself. It's guaranteed that the sum of  over all test cases doesn't exceed .", "output": "For each test case, print one integer\u00a0\u2014 the minimum number of steps to make .", "tutorial": "First, we can prove that the optimal way to perform operations is first, decrease the minimum value several (maybe, zero) times, then take several (maybe, zero) maximums and make them equal to the minimum value. The proof consists of several steps:   Prove that first, we make decreases, only then sets:   if some  is done after some  then if there were no modification of  then you can just move  earlier. Otherwise, there were , and you can replace (... ,  ...) with (... ,  ...). We demonstrated how to move decrease operations before set operations.   Prove that it's optimal to decrease only one element :   instead of decreasing  by  and  by  (where ), we can decrease  by  and replace all  with .   It's optimal to decrease the minimum element\u00a0\u2014 it follows from proof of previous step.  If we make  set operations, it's optimal to set minimum value to  maximum elements\u00a0\u2014 should be obvious. To use the strategy, we'll firstly sort array  in non-decreasing order. In this case, we'll decrease  by  and perform set to  elements . The question is: how to minimize value of ?Note, that  (since setting the same position multiple times has no sense). Let's iterate over all possible values of  and determine the minimum  needed.The resulting array will consists of . Let's say that  (and all  can be precomputed beforehand). Then the sum of array will become , and we need    or, since we need minimum possible , Using the formula above, we can for each  () calculate minimum  required. But to be accurate, value  may be negative, and, usually in programming languages, integer division  for negative  returns  instead of .There is an alternative solution: note that if , then . Note that if  then resulting value of  is in  and there are at most  possible value for . So, you can iterate over all possible  and for each  calculate minimum required  either with binary search or two pointers.", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) int((a).size())\n\ntypedef long long li;\n\nconst int INF = int(1e9);\nconst li INF64 = li(1e18);\n\nint n;\nli k;\nvector<int> a;\n\ninline bool read() {\n\tif(!(cin >> n >> k))\n\t\treturn false;\n\ta.resize(n);\n\tfore (i, 0, n)\n\t\tcin >> a[i];\n\treturn true;\n}\n\nli accurateFloor(li a, li b) {\n\tli val = a / b;\n\twhile (val * b > a)\n\t\tval--;\n\treturn val;\n}\n\ninline void solve() {\n\tsort(a.begin(), a.end());\n\tvector<li> pSum(n + 1, 0);\n\tfore (i, 0, n)\n\t\tpSum[i + 1] = pSum[i] + a[i];\n\t\n\tli ans = 1e18;\n\tfore (y, 0, n) {\n\t\t//(a[0] - x)(y + 1) + (pSum[n - y] - a[0]) <= k\n\t\t//a[0] - x <= (k - pSum[n - y] + a[0]) / (y + 1)\n\t\t//x == a[0] - (k - pSum[n - y] + a[0]) / (y + 1)\n\t\t\n\t\tli x = a[0] - accurateFloor(k - pSum[n - y] + a[0], y + 1);\n\t\tans = min(ans, y + max(0LL, x));\n\t}\n\tcout << ans << endl;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n#endif\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0), cout.tie(0);\n\t\n\tint t; cin >> t;\n\twhile (t--) {\n\t\tread();\n\t\tsolve();\n\t}\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}