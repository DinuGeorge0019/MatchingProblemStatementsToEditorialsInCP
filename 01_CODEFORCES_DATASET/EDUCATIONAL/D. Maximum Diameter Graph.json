{"link": "https://codeforces.com//contest/1082/problem/D", "problemId": "64165", "shortId": "1082D", "contest_number": "1082", "name": "D. Maximum Diameter Graph", "statement": "Graph constructive problems are back! This time the graph you are asked to build should match the following properties.The graph is connected if and only if there exists a path between every pair of vertices.The diameter (aka \"longest shortest path\") of a connected undirected graph is the maximum number of edges in the  path between any pair of its vertices.The degree of a vertex is the number of edges incident to it.Given a sequence of  integers  construct a  graph of  vertices such that:  the graph contains no self-loops and no multiple edges;  the degree  of the -th vertex doesn't exceed  (i.e. );  the diameter of the graph is maximum possible. Output the resulting graph or report that no solution exists.", "input": "The first line contains a single integer  () \u2014 the number of vertices in the graph. The second line contains  integers  () \u2014 the upper limits to vertex degrees.", "output": "Print \"\" if no graph can be constructed under the given conditions. Otherwise print \"\" and the diameter of the resulting graph in the first line. The second line should contain a single integer  \u2014 the number of edges in the resulting graph. The -th of the next  lines should contain two integers  (, ) \u2014 the description of the -th edge. The graph should contain no multiple edges \u2014 for each pair  you output, you should output no more pairs  or .", "tutorial": "Let's construct the graph the following manner. Take all the vertices with  and build a bamboo out of them. Surely, all but the end ones will have degree , the diameter now is the number of vertices minus 1.One can show that building the graph any other way won't make the diameter greater.How should we distribute the other vertices? Two of them can be used to increase diameter. And all the others won't matter, they can be paired with any of the vertices with degrees to spare. If no loops are added then the diameter won't change \u2014 the path that was the longest won't become any shorter.All those facts imply that the graph should be a tree and the sum of  should be at least .Overall complexity: .", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int N = 1000 + 7;\n\nint n;\nint a[N];\n\nint main() {\n\tscanf(\"%d\", &n);\n\tforn(i, n)\n\t\tscanf(\"%d\", &a[i]);\n\t\n\tint sum = 0;\n\tforn(i, n)\n\t\tsum += a[i];\n\t\n\tif (sum < 2 * n - 2){\n\t\tputs(\"NO\");\n\t\treturn 0;\n\t}\n\t\n\tvector<int> ones;\n\tforn(i, n) if (a[i] == 1){\n\t\ta[i] = 0;\n\t\tones.push_back(i);\n\t}\n\t\n\tint t = ones.size();\n\tint dm = (n - t) - 1 + min(2, t);\n\tprintf(\"YES %d\\n%d\\n\", dm, n - 1);\n\t\n\tint lst = -1;\n\tif (!ones.empty()){\n\t\tlst = ones.back();\n\t\tones.pop_back();\n\t}\n\t\n\tforn(i, n){\n\t\tif (a[i] > 1){\n\t\t\tif (lst != -1){\n\t\t\t\t--a[lst];\n\t\t\t\t--a[i];\n\t\t\t\tprintf(\"%d %d\\n\", lst + 1, i + 1);\n\t\t\t}\n\t\t\tlst = i;\n\t\t}\n\t}\n\t\n\tfor (int i = n - 1; i >= 0; --i){\n\t\twhile (!ones.empty() && a[i] > 0){\n\t\t\t--a[i];\n\t\t\tprintf(\"%d %d\\n\", i + 1, ones.back() + 1);\n\t\t\tones.pop_back();\n\t\t}\n\t}\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}