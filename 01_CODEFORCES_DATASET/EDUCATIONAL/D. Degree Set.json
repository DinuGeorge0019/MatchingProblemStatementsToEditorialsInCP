{"link": "https://codeforces.com//contest/976/problem/D", "problemId": "179788", "shortId": "976D", "contest_number": "976", "name": "D. Degree Set", "statement": "You are given a sequence of  positive integers  (). Your task is to construct an undirected graph such that:  there are exactly  vertices;  there are no self-loops;  there are no multiple edges;  there are no more than  edges;  its  is equal to . Vertices should be numbered  through . is an array  with length equal to the number of vertices in a graph such that  is the number of vertices adjacent to -th vertex. is a sorted in increasing order sequence of all distinct values from the .It is guaranteed that there exists such a graph that all the conditions hold, and it contains no more than  edges.Print the resulting graph.", "input": "The first line contains one integer  () \u2014 the size of the degree set. The second line contains  integers  (, ) \u2014 the degree set.", "output": "In the first line print one integer  () \u2014 the number of edges in the resulting graph. It is guaranteed that there exists such a graph that all the conditions hold and it contains no more than  edges. Each of the next  lines should contain two integers  and  () \u2014 the description of the -th edge.", "tutorial": "We prove that the answer always always exists by constructing it.   Graph for  is a single vertex;  Graph for  is a clique of  vertices;  Graph for some  is obtained from the graph  by adding  vertices initially connected to nothing and  vertices connected to all previously mentioned ones. The vertices connected to nothing got degrees , the vertices from the previous step increased their degrees by  and finally there appeared vertices of degree . The number is vertices is  as needed.", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\ntypedef pair<int, int> pt;\n\nconst int N = 100 * 1000 + 13;\n\nint n;\nvector<int> d;\nvector<int> g[N];\n\nvector<pt> construct(int st, vector<int> d){\n\tif (d.empty())\n\t\treturn vector<pt>();\n\t\n\tvector<pt> res;\n\tforn(i, d[0])\n\t\tfor (int j = st + i + 1; j <= st + d.back(); ++j)\n\t\t\tres.push_back({st + i, j});\n\t\n\tint nxt = st + d[0];\n\tfor (int i = 1; i < int(d.size()); ++i)\n\t\td[i] -= d[0];\n\td.erase(d.begin());\n\tif (!d.empty())\n\t\td.pop_back();\n\t\n\tauto tmp = construct(nxt, d);\n\tfor (auto it : tmp)\n\t\tres.push_back(it);\n\t\n\treturn res;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\td.resize(n);\n\tforn(i, n)\n\t\tscanf(\"%d\", &d[i]);\n\tauto res = construct(0, d);\n\tprintf(\"%d\\n\", int(res.size()));\n\tfor (auto it : res)\n\t\tprintf(\"%d %d\\n\", it.first + 1, it.second + 1);\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}