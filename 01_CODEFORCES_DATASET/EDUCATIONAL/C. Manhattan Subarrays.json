{"link": "https://codeforces.com//contest/1550/problem/C", "problemId": "1045983", "shortId": "1550C", "contest_number": "1550", "name": "C. Manhattan Subarrays", "statement": "Suppose you have two points  and . Let's denote the Manhattan distance between them as .Let's say that three points , ,  form a  triple if .Let's say that an array  is  if it is impossible to choose three  indices , ,  such that the points ,  and  form a bad triple.You are given an array . Calculate the number of  subarrays of . A subarray of the array  is the array  for some .Note that, according to the definition, subarrays of length  and  are .", "input": "The first line contains one integer  ()\u00a0\u2014 the number of test cases. The first line of each test case contains one integer  ()\u00a0\u2014 the length of array . The second line of each test case contains  integers  (). It's guaranteed that the sum of  doesn't exceed .", "output": "For each test case, print the number of  subarrays of array .", "tutorial": "Let's figure out criteria for the bad triple , , . It's not hard to prove that the triple is bad, iff point  lies inside the bounding box of points  and . In other words, if  and .Now, looking at points ,  and  we can see that the bad situation may arise only if \u00a0\u2014 so we can check only ordered triples.Looking closely at inequality  we can note that there are two situations where  forms a bad triple: when either  or . In other words, subarray is bad if and only if it contains either non-decreasing subsequence of length  or non-increasing subsequence of length .The final observation is that any sequence of length at least  contains either non-decreasing or non-increasing subsequence of length . It's not hard to prove it, either brute-forcing all possible variants (of relative orders) on paper, or searching/remembering the theorem that says it.As a result you need to check only subarrays of length at most  whichever the way you want. The complexity is .", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) int((a).size())\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef long double ld;\ntypedef pair<li, li> pt;\n\nconst int INF = int(1e9);\nconst li INF64 = li(1e18);\nconst ld EPS = 1e-9;\n\nint n;\nvector<li> a;\n\ninline bool read() {\n\tif(!(cin >> n))\n\t\treturn false;\n\ta.resize(n);\n\tfore (i, 0, n)\n\t\tcin >> a[i];\n\treturn true;\n}\n\nli d(const pt &a, const pt &b) {\n\treturn abs(a.x - b.x) + abs(a.y - b.y);\n}\n\ninline void solve() {\n\tli ans = 0;\n\tfore (i, 0, n) {\n\t\tfore (j, i, n) {\n\t\t\tif (i + 2 <= j) {\n\t\t\t\tbool ok = true;\n\t\t\t\tfore (i1, i, j) fore (i2, i1 + 1, j) {\n\t\t\t\t\tif (d(pt(a[i1], i1), pt(a[j], j)) == d(pt(a[i1], i1), pt(a[i2], i2)) + d(pt(a[i2], i2), pt(a[j], j)))\n\t\t\t\t\t\tok = false;\n\t\t\t\t}\n\t\t\t\tif (!ok)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tans++;\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint tt = clock();\n#endif\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0), cout.tie(0);\n\tcout << fixed << setprecision(15);\n\n\tint t; cin >> t;\n\t\n\twhile(t--) {\n\t\tread();\n\t\tsolve();\n\t\t\n#ifdef _DEBUG\n\t\tcerr << \"TIME = \" << clock() - tt << endl;\n\t\ttt = clock();\n#endif\n\t}\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}