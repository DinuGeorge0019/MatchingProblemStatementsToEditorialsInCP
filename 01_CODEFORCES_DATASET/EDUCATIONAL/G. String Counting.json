{"link": "https://codeforces.com//contest/1487/problem/G", "problemId": "897753", "shortId": "1487G", "contest_number": "1487", "name": "G. String Counting", "statement": "You have  letters '',  letters '', ...,  letters ''. You want to build a  string of length  from them (obviously, you cannot use the -th letter more than  times). .A string is called  if there are no palindromic contiguous substrings of odd length greater than  in it. For example, the string \"\" is not beautiful, it has several palindromic substrings of odd length greater than  (for example, \"\"). Another example: the string \"\" is .Calculate the number of different strings you can build, and print the answer modulo .", "input": "The first line contains one integer  (). The second line contains  integers , , ...,  ().", "output": "Print one integer \u2014 the number of strings you can build, taken modulo .", "tutorial": "Suppose there is no constraint on the number of letters used. Then this problem can be solved with the following dynamic programming: let  be the number of strings of length  ending with characters  and  that don't contain palindromes of odd length greater than  (obviously, each forbidden palindrome contains a subpalindrome of length , so we only need to ensure that there are no palindromes of length ).The thing we are going to use in order to ensure that all the constraints on the number of characters are met is inclusion-exclusion. Since each , at most two characters can violate their constraints in a single string, so we will iterate on some character of the alphabet and subtract the number of strings violating the constraint on this character from the answer, then iterate on a pair of characters and add the number of strings violating the constraints on these two characters to the answer.Okay, how to calculate the number of strings violating the constraint on some fixed character? Let's use dynamic programming  \u2014 the number of strings such that they contain  characters,  of them have the same type that we fixed, the previous-to-last character is  and the last character is . The number of states here seems to be something about , but in fact,  and  can be optimized to have only two different values since we are interested in two types of characters: the ones that coincide with the character we fixed, and the ones that don't.Okay, what about violating the constraints on two characters? The same method can be used here: let  be the number of strings consisting of  characters such that the number of occurrences of the first fixed character is , the number of occurrences of the second fixed character is , the previous-to-last character is  and the last character is . Again, at first it seems that there are up to  states, but  and  can be optimized to have only  different values, so the number of states is actually .It seems that we have to run this dynamic programming for each pair of characters, right? In fact, no, , the only difference is which states violate the constraints and which don't. We can run this dp only once, and when we need an answer for the pair of characters , we can use two-dimensional prefix sums to query the sum over  with ,  and  in . In fact, this dynamic programming can also be used for the first and the second part of the solution (calculating the strings that don't violate any constraints and the strings that violate the constraints on one character), so the hardest part of the solution runs in , though with a pretty big constant factor.", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int MOD = 998244353;\nconst int N = 402;\n\nint add(int x, int y)\n{\n    x += y;\n    while(x >= MOD) x -= MOD;\n    while(x < 0) x += MOD;\n    return x;\n}\n\nint sub(int x, int y)\n{\n    return add(x, -y);\n}\n\nint mul(int x, int y)\n{\n    return (x * 1ll * y) % MOD;\n}\n\nint c[26];\nint dp[2][N][N][3][3];\nint sumDp[N][N];\nint p1[N][N];\nint p2[N][N];\nint n;\n\nint main()\n{\n    cin >> n;\n    for(int i = 0; i < 26; i++)\n        cin >> c[i];\n    for(int i = 0; i < 26; i++)\n        for(int j = 0; j < 26; j++)\n            for(int k = 0; k < 26; k++)\n                if(i != k)\n                {                                                                    \n                    multiset<int> s = {i, j, k};\n                    dp[1][s.count(0)][s.count(1)][min(2, j)][min(2, k)]++;\n                }\n    for(int i = 4; i <= n; i++)\n    {\n        for(int j = 0; j < N; j++)\n            for(int k = 0; k < N; k++)\n                for(int x = 0; x < 3; x++)\n                    for(int y = 0; y < 3; y++)\n                    {\n                        dp[0][j][k][x][y] = dp[1][j][k][x][y];\n                        dp[1][j][k][x][y] = 0;\n                    }\n        for(int j = 0; j < N; j++)\n            for(int k = 0; k < N; k++)\n                for(int x = 0; x < 3; x++)\n                    for(int y = 0; y < 3; y++)\n                    {\n                        int cur = dp[0][j][k][x][y];\n                        if(cur == 0) continue;\n                        for(int z = 0; z < 3; z++)\n                        {                      \n                            int& nw = dp[1][j + (z == 0 ? 1 : 0)][k + (z == 1 ? 1 : 0)][y][z];\n                            nw = add(nw, mul(cur, (z == 2 ? 24 : 1) - (z == x ? 1 : 0)));\n                        }\n                    }\n    }\n    for(int i = 0; i < N; i++)\n        for(int j = 0; j < N; j++)\n            for(int k = 0; k < 3; k++)\n                for(int l = 0; l < 3; l++)\n                    sumDp[i][j] = add(sumDp[i][j], dp[1][i][j][k][l]);\n    for(int i = 0; i < N; i++)\n    {\n        p1[i][N - 1] = sumDp[i][N - 1];\n        for(int j = N - 2; j >= 0; j--)\n            p1[i][j] = add(sumDp[i][j], p1[i][j + 1]);\n    }\n    for(int j = 0; j < N; j++)\n    {\n        p2[N - 1][j] = p1[N - 1][j];\n        for(int i = N - 2; i >= 0; i--)\n            p2[i][j] = add(p1[i][j], p2[i + 1][j]);\n    }\n    int ans = p2[0][0]; \n    for(int i = 0; i < 26; i++)\n    {\n        for(int j = 0; j < N; j++)\n            for(int k = c[i] + 1; k < N; k++)\n                ans = sub(ans, sumDp[k][j]);\n    }\n    for(int i = 0; i < 26; i++)\n        for(int j = 0; j < i; j++)\n            ans = add(ans, p2[c[i] + 1][c[j] + 1]);\n    cout << ans << endl;    \n}", "interactive": false, "noSolution": false, "noTutorial": false}