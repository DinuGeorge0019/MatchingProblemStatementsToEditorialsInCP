{"link": "https://codeforces.com//contest/1202/problem/C", "problemId": "385664", "shortId": "1202C", "contest_number": "1202", "name": "C. You Are Given a WASD-string...", "statement": "You have a string  \u2014 a sequence of commands for your toy robot. The robot is placed in some cell of a  grid. He can perform four commands:  'W' \u2014 move one cell up;  'S' \u2014 move one cell down;  'A' \u2014 move one cell left;  'D' \u2014 move one cell right. Let  be the grid of minimum possible area such that there is a position in the grid where you can place the robot in such a way that it will not fall from the grid while running the sequence of commands . For example, if  then  is the  grid:  you can place the robot in the cell ;  the robot performs the command 'D' and moves to ;  the robot performs the command 'S' and moves to ;  the robot performs the command 'A' and moves to ;  the robot performs the command 'W' and moves to ;  the robot performs the command 'W' and moves to ;  the robot performs the command 'A' and moves to ;  the robot performs the command 'W' and moves to .   You have  extra letters: one 'W', one 'A', one 'S', one 'D'. You'd like to insert  in any position of sequence  to minimize the area of .What is the minimum area of  you can achieve?", "input": "The first line contains one integer  () \u2014 the number of queries. Next  lines contain queries: one per line. This line contains single string  (, ) \u2014 the sequence of commands. It's guaranteed that the total length of  over all queries doesn't exceed .", "output": "Print  integers: one per query. For each query print the minimum area of  you can achieve.", "tutorial": "The problem asks us to maintain the bounding box while inserting the character of one of  types between every adjacent characters in . Of course, we can do it, but do we really  to do it in such  way? Let's think a little. Inserting 'W' or 'S' doesn't affect the width of the bounding box, and 'A' or 'D' doesn't affect the height. So, they are absolutely independent! And we can divide our WASD-string on WS-string and AD-string. Moreover, inserting 'W' or 'S' in WS-string and 'A' or 'D' in AD-string is almost same thing, so we don't even need to write different code for different string!How to handle only WS-string? Let's replace 'W' as  and 'S' as  and suppose that we started in position . Then the position, where we go after  commands, is just prefix sum of first  elements (). Then the length of the bounding box is (maximum position - minimum position + 1). The maximum (minimum) position is a maximum (minimum) element in array of prefix sums .What the inserted value do? It add  to suffix of . Let's choose, for example, . The  can't decrease the maximum, but can increase the minimum, so we need to place it somewhere before all minimums in  (or before the first minimum). But, if we place it before any of maximum elements then we will increase it and prevent decreasing the length of bounding box. So we need to place  somewhere after all maximums on  (or after the last maximum). And here goes the solution: find position  of the first minimum in  and position  of the last maximum. If  then we can insert  and decrease the length of bounding box (but, since, we insert command that move robot, we can't achieve bounding box of length ).What to do with ? Just multiply  by  and now we can insert  instead of  in absolutely same manner.What to do with AD-string? Denote 'A' as  and 'D' as  and everything is absolutely the same.", "solution": "const val INF = 1e9.toInt()\n\nfun main(args: Array<String>) {\n    val T = readLine()!!.toInt()\n    for (tc in 1..T) {\n        val s = readLine()!!\n        val alp = arrayOf(\"WS\", \"AD\")\n        val aDir = arrayOf(\n                s.filter { alp[0].indexOf(it) != -1 },\n                s.filter { alp[1].indexOf(it) != -1 }\n        )\n\n        val baseW = arrayOf(INF, INF)\n        val bestW = arrayOf(INF, INF)\n\n        for (k in 0..1) {\n            val pSum = arrayListOf(0)\n            for (c in aDir[k]) {\n                val add = if (c == alp[k][0]) +1 else -1\n                pSum.add(pSum.last() + add)\n            }\n\n            for (tp in 0..1) {\n                val firstMin = pSum.withIndex().minBy { it.value }!!.index\n                val lastMax = pSum.withIndex().reversed().maxBy { it.value }!!.index\n\n                val curBase = pSum[lastMax] - pSum[firstMin] + 1\n                var curBest = curBase\n                if (curBase > 2 && lastMax < firstMin)\n                    --curBest\n\n                baseW[k] = minOf(baseW[k], curBase)\n                bestW[k] = minOf(bestW[k], curBest)\n\n                for (i in pSum.indices)\n                    pSum[i] = -pSum[i]\n            }\n        }\n\n        println(\"${minOf(baseW[0] * 1L * bestW[1], baseW[1] * 1L * bestW[0] )}\")\n    }\n}", "interactive": false, "noSolution": false, "noTutorial": false}