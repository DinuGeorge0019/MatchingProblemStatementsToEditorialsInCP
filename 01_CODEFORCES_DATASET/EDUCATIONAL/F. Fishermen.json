{"link": "https://codeforces.com//contest/1728/problem/F", "problemId": "1534227", "shortId": "1728F", "contest_number": "1728", "name": "F. Fishermen", "statement": "There are  fishermen who have just returned from a fishing trip. The -th fisherman has caught a fish of size .The fishermen will choose some order in which they are going to tell the size of the fish they caught (the order is just a permutation of size ). However, they are not entirely honest, and they may \"increase\" the size of the fish they have caught.Formally, suppose the chosen order of the fishermen is . Let  be the value which the -th fisherman in the order will tell to the other fishermen. The values  are chosen as follows:  the first fisherman in the order just honestly tells the actual size of the fish he has caught, so ;  every other fisherman wants to tell a value that is  than the value told by the previous fisherman, and is divisible by the size of the fish that the fisherman has caught. So, for ,  is the smallest integer that is both  than  and  . For example, let , . If the chosen order is , then:  ;   is the smallest integer divisible by  and greater than , which is ;   is the smallest integer divisible by  and greater than , which is ;   is the smallest integer divisible by  and greater than , which is ;   is the smallest integer divisible by  and greater than , which is ;   is the smallest integer divisible by  and greater than , which is ;   is the smallest integer divisible by  and greater than , which is . You have to choose the order of fishermen in a way that yields the minimum possible .", "input": "The first line contains one integer  () \u2014 the number of fishermen. The second line contains  integers  ().", "output": "Print one integer \u2014 the minimum possible value of  you can obtain by choosing the order of fishermen optimally.", "tutorial": "Suppose we have fixed some order of fishermen and calculated the values of . Then, we have the following constraints on :  all values of  are pairwise distinct;  for every ,  divides . Not every possible array  meeting these constraints can be achieved with some order of fishermen, but we can show that if we choose an array  with the  among the arrays meeting these two constraints, there exists an ordering of fishermen which yields this array . The proof is simple \u2014 suppose the ordering of fishermen is the following one: the first fisherman is the one with minimum , the second one \u2014 the one with the second minimum , and so on. It's obvious that if we generate the values of  according to this order, they won't be greater than the values in the array we have chosen. And if some value is less than the value in the chosen array , it means that we haven't chosen the array with the minimum possible sum. So, we can rephrase the problem as the following one: for each , choose the value of  so that it is divisible by , all  are distinct, and their sum is minimized.Using the pigeonhole principle, we can show that for every , we need to consider only the values of  among . So, we can formulate the problem as an instance of the weighted bipartite matching: build a graph with two parts, where the left part contains  nodes representing the values of , the right part represents the values of the form  where , and there exists an edge between a vertex in the left part representing the number  and a vertex in the right part representing the number  with cost  if and only if  for some integer . .Okay, now we need to solve this weighted matching problem, but how? The number of vertices is , and the number of edges is  as well, so mincost flow will run in  or , which is too much. Instead, we can notice that the cost of the edges incident to the same vertex in the right part is the same, so we can swap the parts of the graph, sort the vertices of the new left part (representing the numbers ) according to their costs, and run the classical Kuhn's algorithm in sorted order. Kuhn's algorithm in its original implementation will always match a vertex if it is possible, so it obtains the minimum total cost for the matching if we do it in sorted order.But this is still ! What should we do? Well, there are some implementations of Kuhn's algorithm which can run on graphs of size about  (sometimes even ). Why can't we use one of these? Unfortunately, . For example, greedy initialization of matching won't work. So we need to choose optimizations carefully.The model solution uses the following optimization of Kuhn's algorithm: . With this optimization, Kuhn's algorithm works in , where  is the size of the maximum matching,  is the number of edges, and  is the number of vertices. So, this results in a solution with complexity of .I think it's possible to show that some other optimizations of Kuhn can also work, but the one I described is enough.", "solution": "#include <bits/stdc++.h>     \n\nusing namespace std;\n\nconst int N = 1003;\n\nint n;\nint a[N];\nvector<int> g[N * N];\nint mt[N];\nbool used[N * N];\nvector<int> val;\n\nbool kuhn(int x)\n{\n    if(used[x]) return false;\n    used[x] = true;\n    for(auto y : g[x])\n        if(mt[y] == -1 || kuhn(mt[y]))\n        {\n            mt[y] = x;\n            return true;\n        }\n    return false;\n}\n\nint main()\n{\n    cin >> n;\n    for(int i = 0; i < n; i++) cin >> a[i];\n    for(int i = 0; i < n; i++)\n        for(int j = 1; j <= n; j++)\n            val.push_back(a[i] * j);\n    sort(val.begin(), val.end());\n    val.erase(unique(val.begin(), val.end()), val.end());\n    int v = val.size();\n    long long ans = 0;\n    for(int i = 0; i < n; i++)\n        for(int j = 1; j <= n; j++)\n        {\n            int k = lower_bound(val.begin(), val.end(), a[i] * j) - val.begin();\n            g[k].push_back(i);\n        }\n    for(int i = 0; i < n; i++) mt[i] = -1;\n    for(int i = 0; i < v; i++)\n    {\n        if(kuhn(i))\n        {\n            ans += val[i];\n            for(int j = 0; j < v; j++) used[j] = false;\n        }\n    }\n    cout << ans << endl;\n}", "interactive": false, "noSolution": false, "noTutorial": false}