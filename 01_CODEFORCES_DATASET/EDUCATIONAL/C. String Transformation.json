{"link": "https://codeforces.com//contest/946/problem/C", "problemId": "162808", "shortId": "946C", "contest_number": "946", "name": "C. String Transformation", "statement": "You are given a string  consisting of  small english letters.In one move you can replace any character of this string to the next character in alphabetical order ( will be replaced with ,  will be replaced with , etc.). You cannot replace letter  with any other letter.Your target is to make some number of moves (not necessary minimal) to get string  (english alphabet) as a subsequence. Subsequence of the string is the string that is obtained by deleting characters at some positions. You need to print the string that will be obtained from the given string and will be contain english alphabet as a subsequence or say that it is impossible.", "input": "The only one line of the input consisting of the string  consisting of  () small english letters.", "output": "If you can get a string that can be obtained from the given string and will contain english alphabet as a subsequence, print it. Otherwise print \u00ab-1\u00bb (without quotes).", "tutorial": "The problem can be solved by the next greedy algorithm. At first we need to store the last character of the alphabet we haven't obtained, for example, in variable  (initially it will be equal to ). Then we will just iterate over all characters of the string from left to right and if the current character of the string is not greater than , we just replace it to  and increase  by 1. If in any moment  will be greater than , we got the answer. And if after iterating over the string  will be not greater than , the answer is \u00ab-1\u00bb.", "solution": "// {{{ by shik\n#include <bits/stdc++.h>\n#pragma GCC diagnostic ignored \"-Wunused-result\"\n#pragma GCC diagnostic ignored \"-Wunused-function\"\n#define SZ(x) ((int)(x).size())\n#define ALL(x) begin(x), end(x)\n#define REP(i, n) for (int i = 0; i < int(n); i++)\n#define REP1(i, a, b) for (int i = (a); i <= int(b); i++)\n#define MP make_pair\n#define PB push_back\nusing namespace std;\ntypedef int64_t LL;\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\n\nnamespace { namespace shik {\n\ntemplate<class T> void _R(T &x) { cin >> x; }\nvoid _R(int &x) { scanf(\"%d\", &x); }\nvoid _R(int64_t &x) { scanf(\"%\" SCNd64, &x); }\nvoid _R(double &x) { scanf(\"%lf\", &x); }\nvoid _R(char &x) { scanf(\" %c\", &x); }\nvoid _R(char *x) { scanf(\"%s\", x); }\nvoid R() {}\ntemplate<class T, class... U> void R(T &head, U &... tail) { _R(head); R(tail...); }\n\ntemplate<class T> void _W(const T &x) { cout << x; }\nvoid _W(const int &x) { printf(\"%d\", x); }\nvoid _W(const int64_t &x) { printf(\"%\" PRId64, x); }\nvoid _W(const double &x) { printf(\"%.16f\", x); }\nvoid _W(const char &x) { putchar(x); }\nvoid _W(const char *x) { printf(\"%s\", x); }\ntemplate<class T> void _W(const vector<T> &x) { for (auto i = x.begin(); i != x.end(); _W(*i++)) if (i != x.cbegin()) putchar(' '); }\nvoid W() {}\ntemplate<class T, class... U> void W(const T &head, const U &... tail) { _W(head); putchar(sizeof...(tail) ? ' ' : '\\n'); W(tail...); }\n\n#ifdef SHIK\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\ntemplate<class T, class F = less<T>> void sort_uniq(vector<T> &v, F f = F()) { sort(begin(v), end(v), f); v.resize(unique(begin(v), end(v)) - begin(v)); }\ntemplate<class T> inline T bit(T x, int i) { return (x >> i) & 1; }\ntemplate<class T> inline bool chkmax(T &a, const T &b) { return b > a ? a = b, true : false; }\ntemplate<class T> inline bool chkmin(T &a, const T &b) { return b < a ? a = b, true : false; }\ntemplate<class T> using MaxHeap = priority_queue<T>;\ntemplate<class T> using MinHeap = priority_queue<T, vector<T>, greater<T>>;\n\n// }}}\n\nconst int N=1e5+10;\nchar s[N];\nvoid main() {\n    R(s);\n    int n=strlen(s);\n    char c='a';\n    REP(i,n) {\n        if ( c>'z' || s[i]>c ) continue;\n        s[i]=c++;\n    }\n    if ( c>'z' ) W(s);\n    else W(-1);\n}\n\n// {{{ main\n}}\nint main() { shik::main(); return 0; }\n// }}}\n", "interactive": false, "noSolution": false, "noTutorial": false}