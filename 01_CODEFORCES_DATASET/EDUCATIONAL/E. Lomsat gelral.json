{"link": "https://codeforces.com//contest/600/problem/E", "problemId": "41577", "shortId": "600E", "contest_number": "600", "name": "E. Lomsat gelral", "statement": "You are given a rooted tree with root in vertex . Each vertex is coloured in some colour.Let's call colour  dominating in the subtree of vertex  if there are no other colours that appear in the subtree of vertex  more times than colour . So it's possible that two or more colours will be dominating in the subtree of some vertex.The subtree of vertex  is the vertex  and all other vertices that contains vertex  in each path to the root.For each vertex  find the sum of all dominating colours in the subtree of vertex .", "input": "The first line contains integer  () \u2014 the number of vertices in the tree. The second line contains  integers  (),  \u2014 the colour of the -th vertex. Each of the next  lines contains two integers  () \u2014 the edge of the tree. The first vertex is the root of the tree.", "output": "Print  integers \u2014 the sums of dominating colours for each vertex.", "tutorial": "The name of this problem is anagram for ''Small to large''. There is a reason for that :-) The author solution for this problem uses the classic technique for computing sets in tree. The simple solution is the following: let's find for each vertex v the ''map<int, int>'' \u2014 the number of occurences for each colour, ''set<pair<int, int>>'' \u2014 pairs the number of occurences and the colour, and the number sum \u2014 the sum of most frequent colours in subtree of v. To find that firstly we should find the same thing for all childs of v and then merge them to one. These solution is correct but too slow (it works in O(n2logn) time). Let's improve that solution: every time when we want to merge two map-s a and b let's merge the smaller one to larger simply by iterating over all elements of the smaller one (this is the ``Small to large''). Let's consider some vertex v: every time when vertex v will be moved from one map to another the size of the new map will be at least two times larger. So each vertex can be moved not over than logn times. Each moving can be done in O(logn) time. If we accumulate that values by all vertices then we get the complexity O(nlog2n).\nI saw the solutions that differs from author's but this technique can be used in a lot of other problems.\n", "solution": "/*\nNight time, see the castles burning\nSmoke in the skies and tears in their eyes\nAs the world keeps turning\n\nSleep now, hear a distant thunder\nIt's far away at least for today\nClose your eyes and wonder\n\nSpring turns so quickly to summer\nSummer so quickly to fall\nIt seemed far away or it was yesterday\nWhen time didn't matter at all\n\nAnd then you met your winter\nWhile dancing with her daughters\nTill tired and cold, were much wiser than bold\nYou wait for tomorrow to call\n\nAll of your life you have waited alone for a Savior\nHe's not coming\nA carousel horse who is constantly lost\nStanding still but always running\n\nAnd all of those things that you needed so bad\nYou have found they mean nothing\nAnd, oh Lord, I'm coming home\n\nI'm searching through the haze\nThat's drifting through my mind\nStare in my looking glass\nAnd wonder who I'll find\n\nNo one would listen\nTo a man upon the water\nUntil they were old and their mountains of gold\nCouldn't buy any more time\n\nAll of your life you have waited alone for the Savior\nHe's not coming\nA carousel horse who is constantly lost\nStanding still but always running\n\nAnd all of those things that you needed so bad\nYou have found they mean nothing\nAnd, oh Lord, I'm coming home\n\nAll of your life you have waited alone for the Savior\nHe's not coming\nA carousel horse who is constantly lost\nStanding still but always running\n\nAnd all of those things that you needed so bad\nYou have found they mean nothing\nAnd, oh Lord, I'm coming home\nAnd, oh Lord, I'm coming home\nAnd, oh Lord, I'm coming\n*/\n\n//#pragma comment(linker, \"/STACK:16777216\")\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <complex>\n#include <math.h>\n#include <set>\n#include <vector>\n#include <map>  \n#include <queue>\n#include <stdio.h>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <ctime>\n#include <memory.h>\n#include <ctime> \n#include <assert.h>\n\n#define y0 sdkfaslhagaklsldk\n#define y1 aasdfasdfasdf\n#define yn askfhwqriuperikldjk\n#define j1 assdgsdgasghsf\n#define tm sdfjahlfasfh\n#define lr asgasgash\n\n#define eps 1e-16\n#define M_PI 3.141592653589793\n#define bs 1000000007\n#define bsize 512\n\nconst int N = 200005;\n\nusing namespace std;\n\nint n;\nint c[N];\nmap<int, int> S[N];\nint w[N];\nint used[N];\nint mx[N];\nlong long cnt[N];\nvector<int> g[N];\nlong long ans[N];\n\nvoid run_merge(int a,int b)\n{\n\tif (S[w[a]].size()<S[w[b]].size())\n\t{\n\t\tswap(w[a],w[b]);\n\t}\n\tint id=w[a];\n\tmap<int, int>::iterator it;\n\t\n\tfor (it=S[w[b]].begin();it!=S[w[b]].end();it++)\n\t{\n\t\tint val=(*it).first;\n\t\tint amount=(*it).second;\n\t\tS[id][val]+=amount;\n\t\tif (S[id][val]>mx[id])\n\t\t{\n\t\t\tmx[id]=S[id][val];\n\t\t\tcnt[id]=0;\n\t\t}\n\t\tif (S[id][val]==mx[id])\n\t\t\tcnt[id]+=val;\n\t}\n}\n\nvoid dfs(int v)\n{\n\tused[v]=1;\n\tfor (int i=0;i<g[v].size();i++)\n\t{\n\t\tint to=g[v][i];\n\t\tif (used[to])\n\t\t\tcontinue;\n\t\tdfs(to);\n\t\trun_merge(v,to);\n\t}\n//\tcout<<v<<\" \"<<mx[w[v]]<<\" \"<<cnt[w[v]]<<endl;\n\tans[v]=cnt[w[v]];\n}\n\nint main(){\n\t//freopen(\"beavers.in\",\"r\",stdin);\n\t//freopen(\"beavers.out\",\"w\",stdout);\n\t//freopen(\"F:/in.txt\",\"r\",stdin);\n\t//freopen(\"F:/output.txt\",\"w\",stdout);\n\tios_base::sync_with_stdio(0);\n\t//cin.tie(0);\n\t\n\tcin>>n;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tcin>>c[i];\n\t\tS[i][c[i]]=1;\n\t\tw[i]=i;\n\t\tmx[i]=1;\n\t\tcnt[i]=c[i];\n\t}\n\t\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t}\n\t\n\tdfs(1);\n\t\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tif (i>1)\n\t\t\tcout<<\" \";\n\t\tcout<<ans[i];\n\t}\n\tcout<<endl;\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}