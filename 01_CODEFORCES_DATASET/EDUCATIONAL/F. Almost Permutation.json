{"link": "https://codeforces.com//contest/863/problem/F", "problemId": "123496", "shortId": "863F", "contest_number": "863", "name": "F. Almost Permutation", "statement": "Recently Ivan noticed an array  while debugging his code. Now Ivan can't remember this array, but the bug he was trying to fix didn't go away, so Ivan thinks that the data from this array might help him to reproduce the bug.Ivan clearly remembers that there were  elements in the array, and each element was not less than  and not greater than . Also he remembers  facts about the array. There are two types of facts that Ivan remembers:      \u2014 for each  such that  ;      \u2014 for each  such that  . Also Ivan thinks that this array was a permutation, but he is not so sure about it. He wants to restore some array that corresponds to the  facts that he remembers and is very similar to permutation. Formally, Ivan has denoted the  of array as follows:, where  is the number of occurences of  in the array.Help Ivan to determine minimum possible  of the array that corresponds to the facts!", "input": "The first line contains two integer numbers  and  (, ). Then  lines follow, each representing a fact about the array. -th line contains the numbers , ,  and  for -th fact (, , ,  denotes the type of the fact).", "output": "If the facts are controversial and there is no array that corresponds to them, print . Otherwise, print minimum possible  of the array.", "tutorial": "This problem can be solved with mincost maxflow approach.Let's construct a following network:  Construct a vertex for every number from  to . For each of these vertices add  directed edges from the source to this vertex, the capacity of each edge will be , and the costs will be  (so pushing  flow from the source to the vertex will cost exactly );  Also construct a vertex for every index of the array. For each number make add a directed edge with capacity  and cost  to every position in the array such that this number can be put into this position, and for every index make a directed edge from the vertex constructed for this index to the sink with capacity  and cost . Minimum cost maximum flow in this network will construct a suitable array with minimum cost, so the answer to the problem is minimum cost of maximum flow in the network.", "solution": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))\n#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))\nstatic const int INF = 0x3f3f3f3f; static const long long INFL = 0x3f3f3f3f3f3f3f3fLL;\ntypedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;\ntemplate<typename T, typename U> static void amin(T &x, U y) { if (y < x) x = y; }\ntemplate<typename T, typename U> static void amax(T &x, U y) { if (x < y) x = y; }\n\nusing Weight = int;\nconst Weight InfWeight = INF;\nWeight hungarianMin(const vector<vector<Weight> > &A) {\n\tif (A.empty()) return 0;\n\tint h = A.size(), n = A[0].size();\n\tif (h > n) return InfWeight;\n\tvector<Weight> fx(h), fy(n);\n\tvector<int> x(h, -1), y(n, -1);\n\tvector<int> t(n), s(h + 1);\n\tfor (int i = 0; i < h; ) {\n\t\tfill(t.begin(), t.end(), -1);\n\t\ts[0] = i;\n\t\tint q = 0;\n\t\tfor (int p = 0; p <= q; ++ p) {\n\t\t\tfor (int k = s[p], j = 0; j < n; ++ j) {\n\t\t\t\tif (fx[k] + fy[j] == A[k][j] && t[j] < 0) {\n\t\t\t\t\ts[++ q] = y[j];\n\t\t\t\t\tt[j] = k;\n\t\t\t\t\tif (s[q] < 0) {\n\t\t\t\t\t\tfor (p = j; p >= 0; j = p) {\n\t\t\t\t\t\t\ty[j] = k = t[j];\n\t\t\t\t\t\t\tp = x[k];\n\t\t\t\t\t\t\tx[k] = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t++ i;\n\t\t\t\t\t\tgoto continue_;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (0) {\n\t\tcontinue_:;\n\t\t} else {\n\t\t\tWeight d = InfWeight;\n\t\t\tfor (int j = 0; j < n; j++) if (t[j] < 0) {\n\t\t\t\tfor (int k = 0; k <= q; ++ k) if (A[s[k]][j] != InfWeight)\n\t\t\t\t\td = min(d, A[s[k]][j] - fx[s[k]] - fy[j]);\n\t\t\t}\n\t\t\tif (d == InfWeight)\n\t\t\t\treturn InfWeight;\n\t\t\tfor (int j = 0; j < n; ++ j) {\n\t\t\t\tif (t[j] >= 0)\n\t\t\t\t\tfy[j] -= d;\n\t\t\t}\n\t\t\tfor (int k = 0; k <= q; ++ k)\n\t\t\t\tfx[s[k]] += d;\n\t\t}\n\t}\n\tWeight res = 0;\n\tfor (int i = 0; i < h; ++ i)\n\t\tres += A[i][x[i]];\n\treturn res;\n}\n\nint main() {\n\tint n; int q;\n\twhile (~scanf(\"%d%d\", &n, &q)) {\n\t\tvector<int> lo(n, 1), up(n, n);\n\t\trep(qi, q) {\n\t\t\tint t; int l; int r; int v;\n\t\t\tscanf(\"%d%d%d%d\", &t, &l, &r, &v), -- l;\n\t\t\tif (t == 1) {\n\t\t\t\treu(i, l, r)\n\t\t\t\t\tamax(lo[i], v);\n\t\t\t} else {\n\t\t\t\treu(i, l, r)\n\t\t\t\t\tamin(up[i], v);\n\t\t\t}\n\t\t}\n\t\tbool ok = true;\n\t\trep(i, n)\n\t\t\tok &= lo[i] <= up[i];\n\t\tif (!ok) {\n\t\t\tputs(\"-1\");\n\t\t\tcontinue;\n\t\t}\n\t\tvector<vector<int>> A(n, vector<int>(n * n, INF));\n\t\trep(i, n) {\n\t\t\trer(x, lo[i], up[i]) {\n\t\t\t\trep(k, n)\n\t\t\t\t\tA[i][(x - 1) * n + k] = 2 * k + 1;\n\t\t\t}\n\t\t}\n\t\tint ans = hungarianMin(A);\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}