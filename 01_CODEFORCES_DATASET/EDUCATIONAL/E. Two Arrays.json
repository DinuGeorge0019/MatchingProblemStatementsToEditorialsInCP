{"link": "https://codeforces.com//contest/1366/problem/E", "problemId": "646803", "shortId": "1366E", "contest_number": "1366", "name": "E. Two Arrays", "statement": "You are given two arrays  and . Array  is sorted in ascending order ( for each  from  to ).You have to divide the array  into  consecutive subarrays so that, for each  from  to , the minimum on the -th subarray is equal to . Note that each element belongs to exactly one subarray, and they are formed in such a way: the first several elements of  compose the first subarray, the next several elements of  compose the second subarray, and so on.For example, if  and  then there are two good partitions of array :   ;  . You have to calculate the number of ways to divide the array . Since the number can be pretty large print it modulo .", "input": "The first line contains two integers  and  ()\u00a0\u2014 the length of arrays  and  respectively. The second line contains  integers  ()\u00a0\u2014 the array . The third line contains  integers  ()\u00a0\u2014 the array .", "output": "In only line print one integer \u2014 the number of ways to divide the array  modulo .", "tutorial": "At first, let's reverse arrays  and . Now array  is sorted in descending order.Now let's find minimum index  such that . If there is no such index or if  then the answer is  (because minimum on any prefix of array  will never be equal to ).Otherwise, let's find the minimum index  such that . If there is no such index or if  then the answer is . Also let's find the minimum index  such that  (it can't be greater than ). The first subarray starts in position  and ends in any position  (because if it ends in position  or further, then the minimum in the first subarray is greater than ). So there are  ways to split subarrays  and .A similar approach can be used to calculate the number of ways to split the second and third subarrays and, so on.After all, you have to check that minimum in the last subarray is equal to  (otherwise the answer is ).", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 200005;\nconst int MOD = 998244353;\n\nint mul(int a, int b) {\n    return (a * 1LL * b) % MOD;\n}\n\nint n, m;\nint a[N], b[N];\n\nint main() {\t\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 0; i < n; ++i) scanf(\"%d\", a + i);\n    for (int i = 0; i < m; ++i) scanf(\"%d\", b + i);\n    \n    reverse(a, a + n);\n    reverse(b, b + m);\n    a[n] = -1;\n    \n    int mn = a[0];\n    int pos = 0;\n    while (pos < n && mn > b[0]) {\n        ++pos;\n        mn = min(mn, a[pos]);\n    }\n    \n    if (pos == n || mn < b[0]) {\n       puts(\"0\");\n       return 0;\n    }\n    \n    assert(mn == b[0]);\n    int res = 1;\n    int ib = 0;\n    while (true) {\n        assert(mn == b[ib]);\n        if (ib == m - 1){\n            if(*min_element(a + pos, a + n) != b[ib]) {\n               puts(\"0\");\n               return 0;\n            }\n            break;\n        }\n        \n        bool f = true;\n        int npos = pos;\n        while (npos < n && mn != b[ib + 1]) {\n            ++npos;\n            mn = min(mn, a[npos]);\n            \n            if (f && mn < b[ib]){\n                f = false;\n                res = mul(res, npos - pos);\n            }\n        }\n        \n        if (npos == n || mn != b[ib + 1]) {\n            puts(\"0\");\n            return 0;\n        }\n        \n        ++ib;\n        pos = npos;\n    }\n    \n    printf(\"%d\\n\", res);\n    return 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}