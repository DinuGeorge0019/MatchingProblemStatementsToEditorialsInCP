{"link": "https://codeforces.com//contest/1569/problem/E", "problemId": "1103183", "shortId": "1569E", "contest_number": "1569", "name": "E. Playoff Restoration", "statement": " teams participate in a playoff tournament. The tournament consists of  games. They are held as follows: first of all, the teams are split into pairs: team  plays against team , team  plays against team  (exactly in this order), and so on (so,  games are played in that phase). When a team loses a game, it is eliminated, and each game results in elimination of one team (there are no ties). After that, only  teams remain. If only one team remains, it is declared the champion; otherwise,  games are played: in the first one of them, the winner of the game \" vs \" plays against the winner of the game \" vs \", then the winner of the game \" vs \" plays against the winner of the game \" vs \", and so on. This process repeats until only one team remains.After the tournament ends, the teams are assigned places according to the tournament phase when they were eliminated. In particular:  the winner of the tournament gets place ;  the team eliminated in the finals gets place ;  both teams eliminated in the semifinals get place ;  all teams eliminated in the quarterfinals get place ;  all teams eliminated in the 1/8 finals get place , and so on. For example, this picture describes one of the possible ways the tournament can go with , and the resulting places of the teams:  After a tournament which was conducted by the aforementioned rules ended, its results were encoded in the following way. Let  be the place of the -th team in the tournament. The hash value of the tournament  is calculated as , where  is some given integer.Unfortunately, due to a system crash, almost all tournament-related data was lost. The only pieces of data that remain are the values of ,  and . You are asked to restore the resulting placing of the teams in the tournament, if it is possible at all.", "input": "The only line contains three integers ,  and  (; ; ).", "output": "If it is impossible to find any placing of the teams that is consistent with the data you have, print one integer . Otherwise, print  integers, where -th integer should be equal to  (the place of the -th team). Note that your answer should be consistent with one of the possible ways the tournament could go, and note that the initial structure of the tournament is fixed (for example, teams  and  always play in the first phase of the tournament against each other). If there are multiple ways to restore the places of the teams which are consistent with the data you have, print any of them.", "tutorial": "There are exactly  games in the tournament, each game has only two possible outcomes. So it's possible to bruteforce all  possible ways the tournament could go if  is not large. In fact, this solution is fast enough when , so if we somehow can handle the case , we will have a working solution.To handle , let's divide the teams into two groups: teams from  to  and teams from  to . There will be exactly  matches in each group, and the winners of these two groups will play in the finals. The number of possible ways the games in a group can go is just , so let's try to bruteforce all possible results in each group and somehow \"merge\" them into the results of the whole tournament.The main idea is to rewrite  as , where , and , find all possible values for  and , and choose a pair of values that yields exactly the given value of .We will handle two separate cases: the winner of the first group wins the whole tournament, or the winner of the second group wins the whole tournament. Suppose we are handling the first case (the second is symmetrical). By choosing the results of matches in the first group, we determine the places of the teams from the first group : the winner of the first group gets place , the team eliminated in the last match of the first group gets place , and so on. It means that by choosing one of the  possible results in the first group, we can calculate . Let's bruteforce these  combinations of results in the first group and store them in some data structure that allows to check whether some value of  is achievable (in the model solution, it's a  which maps reachable values of  to combinations of results that yield these values). Then, by choosing the results of matches in the second group, we can calculate ; so the remaining part of the solution is to bruteforce all  possible results in the second group, calculate  for them, and check that  such that  can be achieved by choosing the results in the first group. Don't forget to also handle the case when the team which wins in the first group loses in the finals (it is almost the same, but the winner in the first group gets place  and the winner in the second group gets place ).The technique I've described here (instead of bruteforcing all possible variants, split the thing we try to bruteforce into two parts, bruteforce them separatedly, and then try to \"merge\" the parts) is called  and can be used to solve a large variety of problems.", "solution": "#include <bits/stdc++.h>     \n\nusing namespace std;\n\nconst int MOD = 998244353;\n\nint add(int x, int y)\n{\n \tx += y;\n \twhile(x >= MOD) x -= MOD;\n \twhile(x < 0) x += MOD;\n \treturn x;\n}\n\nint mul(int x, int y)\n{\n \treturn (x * 1ll * y) % MOD;\n}\n\nint binpow(int x, int y)\n{\n \tint z = 1;\n \twhile(y)\n \t{\n \t \tif(y & 1) z = mul(z, x);\n \t \tx = mul(x, x);\n \t \ty >>= 1;\n \t}\n \treturn z;\n}\n\nvector<int> evaluate(int n, int choice_mask)\n{\n \tint cur_place = n / 2 + 1;\n \tint cur_bit = n - 2;\n \tvector<int> p(n);\n \tvector<int> c(n);\n \tfor(int i = 0; i < n; i++)\n \t\tc[i] = i;\n \twhile(c.size() != 1)\n \t{\n \t\tvector<int> nc;\n \t \tfor(int i = 0; i < c.size(); i += 2)\n \t \t{\n \t \t \tif(choice_mask & (1 << cur_bit))\n \t \t \t{\n \t \t \t\tp[c[i]] = cur_place;\n \t \t \t\tnc.push_back(c[i + 1]);\n \t \t \t}\n \t \t \telse\n \t \t \t{\n \t \t \t\tp[c[i + 1]] = cur_place;\n \t \t \t\tnc.push_back(c[i]);\n \t \t \t}\n \t \t \tcur_bit--;\n \t \t}\n \t \tc = nc;\n \t \tcur_place /= 2;\n  \t\tcur_place++;\n\t}\n\tp[c[0]] = 1;\n\treturn p;\n}\n\nvector<int> adjust(int n, vector<int> p, bool winning)\n{\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif(p[i] == 1)\n\t\t{\n\t\t \tif(!winning) p[i]++;\t\n\t\t}\n\t\telse\n\t\t \tp[i] = p[i] * 2 - 1;\n\t}\n\treturn p;\n}\t\n\nint get_hash(int n, vector<int> p, int A, bool partial = false, bool winning = false, int shift = 0)\n{\n\tif(partial)\n\t\tp = adjust(n, p, winning);\n \tint res = 0;\n \tfor(int i = 0; i < n; i++)\n \t\tres = add(res, mul(add(i + 1, shift), binpow(A, p[i])));\n \treturn res;\n}\n\nint main()\n{\n \tint k, A, h;\n \tcin >> k >> A >> h;\n \tif(k <= 4)\n \t{\n \t\tfor(int i = 0; i < (1 << ((1 << k) - 1)); i++)\n \t\t{             \n \t\t\tvector<int> p = evaluate(1 << k, i);\n \t\t\tif(get_hash(1 << k, p, A) == h)\n \t\t\t{\n \t\t \t\tfor(auto x : p) cout << x << \" \";\n \t\t \t\tcout << endl;\n \t\t \t\treturn 0;\n \t\t\t}\n \t\t}\n \t}\n \telse\n \t{\n \t\tint mask_left = -1;\n \t\tint mask_right = -1;\n \t\tbool left_win = false;\n \t\tfor(int c = 0; c < 2; c++)\n \t\t{\n \t\t \tmap<int, int> left_map;\n \t\t \tfor(int i = 0; i < (1 << 16); i++)\n \t\t \t{\n \t\t \t \tvector<int> p = evaluate(16, i);\n \t\t \t \tint left_hash = get_hash(16, p, A, true, c == 0, 0);\n \t\t \t \tleft_map[left_hash] = i;\t\n \t\t \t}\n \t\t \tfor(int i = 0; i < (1 << 16); i++)\n \t\t \t{\n \t\t \t \tvector<int> p = evaluate(16, i);\n \t\t \t \tint right_hash = get_hash(16, p, A, true, c == 1, 16);\n \t\t \t \tint left_hash = add(h, MOD - right_hash);\n \t\t \t \tif(left_map.count(left_hash))\n \t\t \t \t{\n \t\t \t \t \tmask_left = left_map[left_hash];\n \t\t \t \t \tmask_right = i;\n \t\t \t \t \tleft_win = (c == 0);\n \t\t \t \t}\n \t\t \t}\n \t \t}\n \t \tif(mask_left != -1)\n \t\t{\n \t \t\tvector<int> ans_left = evaluate(16, mask_left);\n \t \t\tvector<int> ans_right = evaluate(16, mask_right);\n \t \t\tans_left = adjust(16, ans_left, left_win);\n \t \t\tans_right = adjust(16, ans_right, !left_win);\n \t \t\tfor(auto x : ans_left)\n \t \t\t\tcout << x << \" \";\n \t   \t\tfor(auto x : ans_right)\n \t   \t\t\tcout << x << \" \";\n \t   \t\treturn 0;\n \t\t}        \n \t}\n \tcout << -1 << endl;\n \treturn 0;\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}