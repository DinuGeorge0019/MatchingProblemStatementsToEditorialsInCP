{"link": "https://codeforces.com//contest/616/problem/F", "problemId": "45349", "shortId": "616F", "contest_number": "616", "name": "F. Expensive Strings", "statement": "You are given  strings . Each string has cost .Let's define the function of string , where  is the number of occurrences of  in ,  is the length of the string . Find the maximal value of function  over all strings.Note that the string  is not necessarily some string from .", "input": "The first line contains the only integer  () \u2014 the number of strings in . Each of the next  lines contains contains a non-empty string .  contains only lowercase English letters. It is guaranteed that the sum of lengths of all strings in  is not greater than . The last line contains  integers  () \u2014 the cost of the -th string.", "output": "Print the only integer  \u2014 the maximal value of the function  over all strings . Note one more time that the string  is not necessarily from .", "tutorial": "This problem is a typical problem for some suffix data structure. Four competitors who solved this problem during the contest used suffix automaton and one competitor used suffix tree. My own solution used suffix tree so I'll describe solution with tree (I think it's simple except of the building of the tree).\nLet's build the new string by concatenation of all strings from input separating them by different separators. The number of separators is  so the alphabet is also . So we should use map<int, int> to store the tree and the complexity is increased by . Let's build the suffix tree for the new string. Let's match all the separators to the strings from the left of the separator. Let's run dfs on the suffix tree that doesn't move over separators and returns the sum of the costs of the strings matched to the separators from the subtree of the current vertex. Easy to see that we should simply update the answer by the product of the depth of the current vertex and the sum in the subtree of the current vertex.\n", "solution": "\n            #include <bits/stdc++.h>\n\u00a0\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n#define ford(i, n) for (int i = int(n) - 1; i >= 0; i--)\n#define fore(i, l, r) for (int i = int(l); i < int(r); i++)\n#define correct(x, y, n, m) (0 <= (x) && (x) < (n) && 0 <= (y) && (y) < (m))\n#define all(a) (a).begin(), (a).end()\n#define sz(a) int((a).size())\n#define pb(a) push_back(a)\n#define mp(x, y) make_pair((x), (y))\n#define x first\n#define y second\n\u00a0\nusing namespace std;\n\u00a0\ntypedef long long li;\ntypedef long double ld;\ntypedef pair<int, int> pt;\n\u00a0\ntemplate<typename X> inline X abs(const X& a) { return a < 0? -a: a; }\ntemplate<typename X> inline X sqr(const X& a) { return a * a; }\n\u00a0\nconst int INF = int(1e9);\nconst li INF64 = li(1e18);\nconst ld EPS = 1e-9, PI = 3.1415926535897932384626433832795;\n\u00a0\nconst int NN = 100100, L = 500100;\n\u00a0\nint k;\nchar buf[L];\nstring a[NN];\nint c[NN];\n\u00a0\ninline bool read() {\n\u00a0 \u00a0 if (!(cin >> k)) return false;\n\u00a0 \u00a0 forn(i, k) {\n\u00a0 \u00a0 \u00a0 \u00a0 assert(scanf(\"%s\", buf) == 1);\n\u00a0 \u00a0 \u00a0 \u00a0 a[i] = string(buf);\n\u00a0 \u00a0 }\n\u00a0 \u00a0 forn(i, k) assert(scanf(\"%d\", &c[i]) == 1);\n\u00a0 \u00a0 return true;\n}\n\u00a0\nstruct node {\n\u00a0 \u00a0 int l, r;\n\u00a0 \u00a0 int parent, link;\n\u00a0 \u00a0 map<int, int> next;\n\u00a0 \u00a0 node(int l = 0, int r = 0, int parent = 0): l(l), r(r), parent(parent) {\n\u00a0 \u00a0 \u00a0 \u00a0 link = -1;\n\u00a0 \u00a0 \u00a0 \u00a0 next.clear();\n\u00a0 \u00a0 }\n};\nstruct state {\n\u00a0 \u00a0 int v, pos;\n\u00a0 \u00a0 state(int v = 0, int pos = 0): v(v), pos(pos) { }\n};\nconst int N = 1000 * 1000 + 3;\nint n;\nint s[N];\nint tsz = 1;\nnode t[2 * N];\nstate ptr;\ninline int len(int v) { return t[v].r - t[v].l; }\ninline int split(state st) {\n\u00a0 \u00a0 if (st.pos == 0) return t[st.v].parent;\n\u00a0 \u00a0 if (st.pos == len(st.v)) return st.v;\n\u00a0 \u00a0 int cur = tsz++;\n\u00a0 \u00a0 t[cur] = node(t[st.v].l, t[st.v].l + st.pos, t[st.v].parent);\n\u00a0 \u00a0 t[cur].next[s[t[st.v].l + st.pos]] = st.v;\n\u00a0 \u00a0 t[t[st.v].parent].next[s[t[st.v].l]] = cur;\n\u00a0 \u00a0 t[st.v].parent = cur;\n\u00a0 \u00a0 t[st.v].l += st.pos;\n\u00a0 \u00a0 return cur;\n}\nstate go(state st, int l, int r) {\n\u00a0 \u00a0 while (l < r) {\n\u00a0 \u00a0 \u00a0 \u00a0 if (st.pos == len(st.v)) {\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if (!t[st.v].next.count(s[l])) return state(-1, -1);\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 st = state(t[st.v].next[s[l]], 0);\n\u00a0 \u00a0 \u00a0 \u00a0 }\n\u00a0 \u00a0 \u00a0 \u00a0 else {\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if (s[t[st.v].l + st.pos] != s[l]) return state(-1, -1);\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 int d = min(len(st.v) - st.pos, r - l);\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 l += d;\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 st.pos += d;\n\u00a0 \u00a0 \u00a0 \u00a0 }\n\u00a0 \u00a0 }\n\u00a0 \u00a0 return st;\n}\nint link(int v) {\n\u00a0 \u00a0 int& ans = t[v].link;\n\u00a0 \u00a0 if (ans != -1) return ans;\n\u00a0 \u00a0 if (v == 0) return ans = 0;\n\u00a0 \u00a0 int p = t[v].parent;\n\u00a0 \u00a0 return ans = split(go(state(link(p), len(link(p))), t[v].l + (p == 0), t[v].r));\n}\ninline void treeExtand(int i) {\n\u00a0 \u00a0 while (true) {\n\u00a0 \u00a0 \u00a0 \u00a0 state next = go(ptr, i, i + 1);\n\u00a0 \u00a0 \u00a0 \u00a0 if (next.v != -1) {\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ptr = next;\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 break;\n\u00a0 \u00a0 \u00a0 \u00a0 }\n\u00a0 \u00a0 \u00a0 \u00a0 int mid = split(ptr), cur = tsz++;\n\u00a0 \u00a0 \u00a0 \u00a0 t[cur] = node(i, n, mid);\n\u00a0 \u00a0 \u00a0 \u00a0 t[mid].next[s[i]] = cur;\n\u00a0 \u00a0 \u00a0 \u00a0 if (mid == 0) break;\n\u00a0 \u00a0 \u00a0 \u00a0 ptr = state(link(mid), len(link(mid)));\n\u00a0 \u00a0 }\n}\n\u00a0\nli ans;\nset<pt> pos;\n\u00a0\nli dfs(int v, int len) {\n\u00a0 \u00a0 //if (v) assert(t[v].l < t[v].r);\n\u00a0 \u00a0 li sum = 0;\n\u00a0 \u00a0 auto it = pos.lower_bound(mp(t[v].l, -INF));\n\u00a0 \u00a0 if (it != pos.end() && it->x < t[v].r) {\n\u00a0 \u00a0 \u00a0 \u00a0 //cerr << \"len=\" << len << \" l=\" << t[v].l << \" r=\" << t[v].r << endl;\n\u00a0 \u00a0 \u00a0 \u00a0 sum += it->y;\n\u00a0 \u00a0 \u00a0 \u00a0 if (it->x > t[v].l) {\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 len += it->x - t[v].l;\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ans = max(ans, len * sum);\n\u00a0 \u00a0 \u00a0 \u00a0 }\n\u00a0 \u00a0 \u00a0 \u00a0 return sum;\n\u00a0 \u00a0 }\n\u00a0\n\u00a0 \u00a0 len += t[v].r - t[v].l;\n\u00a0 \u00a0 for (auto nt : t[v].next)\n\u00a0 \u00a0 \u00a0 \u00a0 sum += dfs(nt.y, len);\n\u00a0 \u00a0 ans = max(ans, len * sum);\n\u00a0 \u00a0 return sum;\n}\n\u00a0\ninline ostream& operator<< (ostream& out, const pt& p) { return out << \"(\" << p.x << \", \" << p.y << \")\"; }\n\u00a0\ninline void solve() {\n\u00a0 \u00a0 n = 0;\n\u00a0 \u00a0 pos.clear();\n\u00a0 \u00a0 forn(i, k) {\n\u00a0 \u00a0 \u00a0 \u00a0 forn(j, sz(a[i])) s[n++] = int(a[i][j]);\n\u00a0 \u00a0 \u00a0 \u00a0 pos.insert(mp(n, c[i]));\n\u00a0 \u00a0 \u00a0 \u00a0 s[n++] = 300 + i;\n\u00a0 \u00a0 }\n\u00a0\n\u00a0 \u00a0 //for (auto it : pos) cerr << it << ' '; cerr << endl;\n\u00a0\n\u00a0 \u00a0 //cerr << n << endl;\n\u00a0 \u00a0 //forn(i, n) cerr << s[i] << ' '; cerr << endl;\n\u00a0 \u00a0 \n\u00a0 \u00a0 forn(i, tsz) t[i] = node();\n\u00a0 \u00a0 ptr = state();\n\u00a0 \u00a0 tsz = 1;\n\u00a0 \u00a0 forn(i, n) treeExtand(i);\n\u00a0\n\u00a0 \u00a0 ans = 0;\n\u00a0 \u00a0 dfs(0, 0);\n\u00a0 \u00a0 cout << ans << endl;\n\u00a0\n\u00a0 \u00a0 /*li s = 0;\n\u00a0 \u00a0 forn(i, k) s += c[i];\n\u00a0 \u00a0 cerr << s << endl;*/\n}\n\u00a0\nint main() {\n#ifdef SU1\n\u00a0 \u00a0 assert(freopen(\"input.txt\", \"rt\", stdin));\n\u00a0 \u00a0 //assert(freopen(\"output.txt\", \"wt\", stdout));\n#endif\n\u00a0 \u00a0 \n\u00a0 \u00a0 cout << setprecision(10) << fixed;\n\u00a0 \u00a0 cerr << setprecision(5) << fixed;\n\u00a0\n\u00a0 \u00a0 while (read()) {\n\u00a0 \u00a0 \u00a0 \u00a0 solve();\n\u00a0 \u00a0 \u00a0 \u00a0 //break;\n\u00a0 \u00a0 }\n\u00a0 \u00a0 \n\u00a0 \u00a0 return 0;\n}\n        ", "interactive": false, "noSolution": false, "noTutorial": false}