{"link": "https://codeforces.com//contest/1036/problem/F", "problemId": "216422", "shortId": "1036F", "contest_number": "1036", "name": "F. Relatively Prime Powers", "statement": "Consider some positive integer . Its prime factorization will be of form Let's call   if the greatest common divisor of the sequence  is equal to . For example, numbers , ,  are  and numbers  (),  () are not.Count the number of  integers from  to .Each testcase contains several values of , for each of them you are required to solve the problem separately.", "input": "The first line contains a single integer  () \u2014 the number of values of  in the testcase. Each of the next  lines contains a single integer  ().", "output": "Print  lines \u2014 the -th line should contain the number of  numbers from  to .", "tutorial": "Whoops, it seems, this problem can be done in a similar manner as in problem .Firstly, is some number  has  of the prime powers not equal to , then you can take root 'th power from it. That is the same as dividing all powers by .Now it turned out, there are really a small amount of these numbers up to  (if you take the squares out).Actually, our solution wasn't that. Let's count the answer using inclusion-exclusion principle. For this Mobius function can be used. The answer is:.The power part is the amount of numbers, which raised to the -th power becomes less ot equal to . This turns zero for like  iterations on  for any  up to . However, calculating each log as it is will lead to a  solution, which might be too slow.Let's process the queries in the decreasing order of .  will be calculated naively each time (in  (or however complexity has the built-in function,  maybe) or ). The rest powers will be initialized with their upper limits in the start (like  for ,  for  and so on). Now proceeding to the next number will only decrease the current maximum number for each power. Subtract one until you reach the needed number and check in . Overall complexity: .", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int K = 100;\nconst int N = 100 * 1000 + 13;\nconst long long INF64 = 3e18;\n\nint mu[K];\n\nvoid precalc(){\n    static bool prime[K];\n    static int lst[K];\n    \n    memset(prime, false, sizeof(prime));\n    forn(i, K) lst[i] = i;\n    \n    for (int i = 2; i < K; ++i){\n        if (lst[i] == i) mu[i] = 1;\n        for (int j = 2 * i; j < K; j += i){\n            lst[j] = min(lst[j], lst[i]);\n            if (lst[j] == lst[i])\n                mu[j] = 0;\n            else\n                mu[j] = -mu[i];\n        }\n    }\n}\n\nint mx[K];\n\nlong long binpow(long long a, int b){\n    long long res = 1;\n    while (b){\n        if (b & 1){\n            if (res < INF64 / a) res *= a;\n            else return INF64;\n        }\n        if (b > 1){\n            if (a < INF64 / a) a *= a;\n            else return INF64;\n        }\n        b >>= 1;\n    }\n    return res;\n}\n\nlong long calc(long long n){\n    int pw = 63 - __builtin_clzll(n);\n    for (int i = 3; i <= pw; ++i){\n        if (mu[i] == 0) continue;\n        while (binpow(mx[i], i) > n)\n            --mx[i];\n    }\n    \n    long long res = n - 1;\n    for (int i = 2; i <= pw; ++i)\n        res -= mu[i] * (mx[i] - 1);\n    \n    return res;\n}\n\nint get_sqrt(long long n){\n    int l = 1, r = 1000000000;\n    while (l < r - 1){\n        int m = (l + r) / 2;\n        if (m * 1ll * m <= n)\n            l = m;\n        else\n            r = m;\n    }\n    return (r * 1ll * r <= n ? r : l);\n}\n\nlong long ans[N];\n\nint main() {\n    precalc();\n    int T;\n    scanf(\"%d\", &T);\n    vector<pair<long long, int>> q;\n    \n    forn(i, T){\n        long long n;\n        scanf(\"%lld\", &n);\n        q.push_back({n, i});\n    }\n    \n    sort(q.begin(), q.end(), greater<pair<long long, int>>());\n    mx[3] = 1000000;\n    mx[4] = 31622;\n    mx[5] = 3981;\n    for (int i = 6; i < K; ++i)\n        mx[i] = 1000;\n    \n    forn(z, T){\n        long long n = q[z].first;\n        mx[2] = get_sqrt(n);\n        ans[q[z].second] = calc(n);\n    }\n    \n    forn(i, T)\n        printf(\"%lld\\n\", ans[i]);\n    return 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}