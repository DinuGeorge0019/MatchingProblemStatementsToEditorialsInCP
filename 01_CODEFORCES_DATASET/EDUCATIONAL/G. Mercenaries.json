{"link": "https://codeforces.com//contest/1400/problem/G", "problemId": "709189", "shortId": "1400G", "contest_number": "1400", "name": "G. Mercenaries", "statement": "Polycarp plays a (yet another!) strategic computer game. In this game, he leads an army of mercenaries.Polycarp wants to gather his army for a quest. There are  mercenaries for hire, and the army should consist of some subset of them.The -th mercenary can be chosen if the  number of chosen mercenaries is not less than  (otherwise he deems the quest to be doomed) and not greater than  (he doesn't want to share the trophies with too many other mercenaries). Furthermore,  pairs of mercenaries hate each other and cannot be chosen for the same quest. How many  subsets does Polycarp need to consider? In other words, calculate the number of non-empty subsets of mercenaries such that the size of this subset belongs to  for each chosen mercenary, and there are no two mercenaries in the subset that hate each other.The answer may be large, so calculate it modulo .", "input": "The first line contains two integers  and  (, ) \u2014 the number of mercenaries and the number of pairs of mercenaries that hate each other. Then  lines follow, the -th of them contains two integers  and  (). Then  lines follow, the -th of them contains two integers  and  () denoting that the mercenaries  and  hate each other. There are no two equal pairs in this list.", "output": "Print one integer \u2014 the number of non-empty subsets meeting the constraints, taken modulo .", "tutorial": "In order to take care of the  and  constraints, we can iterate on the number of mercenaries we'll choose and find the number of choices for each count. The key constraint in this problem is that  is at most 20, which means that there can only be a few connected components that aren't just a single node. In particular, the largest possible connected component size is 21 (since a connected graph with  edges has at most  nodes).\nThis means that for each connected component we can iterate over all of the subsets of nodes in that component and check whether the subset is a valid choice (i.e., is an independent set). We can then do a DP for each component where dp(mask, k) = the number of submasks of mask that have k ones and represent a valid independent set subset of the component.\nFinally we can iterate over the total number of mercenaries we want. We can then do a knapsack over each of the components, making sure to only consider nodes in each component where  and  work with our number of mercenaries. Finally we determine how many valid  mercenaries are available outside of our components, and the rest is a simple choose function. Code: 90977154\n", "solution": "#include <algorithm>\n#include <array>\n#include <cassert>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\ntemplate<typename T> ostream& operator<<(ostream &os, const vector<T> &v) { os << '{'; string sep; for (const auto &x : v) os << sep << x, sep = \", \"; return os << '}'; }\ntemplate<typename T, size_t size> ostream& operator<<(ostream &os, const array<T, size> &arr) { os << '{'; string sep; for (const auto &x : arr) os << sep << x, sep = \", \"; return os << '}'; }\ntemplate<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << '(' << p.first << \", \" << p.second << ')'; }\n\nvoid dbg_out() { cerr << endl; }\ntemplate<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cerr << ' ' << H; dbg_out(T...); }\n\n#ifdef NEAL_DEBUG\n#define dbg(...) cerr << \"(\" << #__VA_ARGS__ << \"):\", dbg_out(__VA_ARGS__)\n#else\n#define dbg(...)\n#endif\n\ntemplate<const int &MOD>\nstruct _m_int {\n    int val;\n\n    _m_int(int64_t v = 0) {\n        if (v < 0) v = v % MOD + MOD;\n        if (v >= MOD) v %= MOD;\n        val = int(v);\n    }\n\n    _m_int(uint64_t v) {\n        if (v >= MOD) v %= MOD;\n        val = int(v);\n    }\n\n    _m_int(int v) : _m_int(int64_t(v)) {}\n    _m_int(unsigned v) : _m_int(uint64_t(v)) {}\n\n    static int inv_mod(int a, int m = MOD) {\n        // https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm#Example\n        int g = m, r = a, x = 0, y = 1;\n\n        while (r != 0) {\n            int q = g / r;\n            g %= r; swap(g, r);\n            x -= q * y; swap(x, y);\n        }\n\n        return x < 0 ? x + m : x;\n    }\n\n    explicit operator int() const { return val; }\n    explicit operator unsigned() const { return val; }\n    explicit operator int64_t() const { return val; }\n    explicit operator uint64_t() const { return val; }\n    explicit operator double() const { return val; }\n    explicit operator long double() const { return val; }\n\n    _m_int& operator+=(const _m_int &other) {\n        val -= MOD - other.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n\n    _m_int& operator-=(const _m_int &other) {\n        val -= other.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n\n    static unsigned fast_mod(uint64_t x, unsigned m = MOD) {\n#if !defined(_WIN32) || defined(_WIN64)\n        return unsigned(x % m);\n#endif\n        // Optimized mod for Codeforces 32-bit machines.\n        // x must be less than 2^32 * m for this to work, so that x / m fits in an unsigned 32-bit int.\n        unsigned x_high = unsigned(x >> 32), x_low = unsigned(x);\n        unsigned quot, rem;\n        asm(\"divl %4\\n\"\n            : \"=a\" (quot), \"=d\" (rem)\n            : \"d\" (x_high), \"a\" (x_low), \"r\" (m));\n        return rem;\n    }\n\n    _m_int& operator*=(const _m_int &other) {\n        val = fast_mod(uint64_t(val) * other.val);\n        return *this;\n    }\n\n    _m_int& operator/=(const _m_int &other) {\n        return *this *= other.inv();\n    }\n\n    friend _m_int operator+(const _m_int &a, const _m_int &b) { return _m_int(a) += b; }\n    friend _m_int operator-(const _m_int &a, const _m_int &b) { return _m_int(a) -= b; }\n    friend _m_int operator*(const _m_int &a, const _m_int &b) { return _m_int(a) *= b; }\n    friend _m_int operator/(const _m_int &a, const _m_int &b) { return _m_int(a) /= b; }\n\n    _m_int& operator++() {\n        val = val == MOD - 1 ? 0 : val + 1;\n        return *this;\n    }\n\n    _m_int& operator--() {\n        val = val == 0 ? MOD - 1 : val - 1;\n        return *this;\n    }\n\n    _m_int operator++(int) { _m_int before = *this; ++*this; return before; }\n    _m_int operator--(int) { _m_int before = *this; --*this; return before; }\n\n    _m_int operator-() const {\n        return val == 0 ? 0 : MOD - val;\n    }\n\n    friend bool operator==(const _m_int &a, const _m_int &b) { return a.val == b.val; }\n    friend bool operator!=(const _m_int &a, const _m_int &b) { return a.val != b.val; }\n    friend bool operator<(const _m_int &a, const _m_int &b) { return a.val < b.val; }\n    friend bool operator>(const _m_int &a, const _m_int &b) { return a.val > b.val; }\n    friend bool operator<=(const _m_int &a, const _m_int &b) { return a.val <= b.val; }\n    friend bool operator>=(const _m_int &a, const _m_int &b) { return a.val >= b.val; }\n\n    _m_int inv() const {\n        return inv_mod(val);\n    }\n\n    _m_int pow(int64_t p) const {\n        if (p < 0)\n            return inv().pow(-p);\n\n        _m_int a = *this, result = 1;\n\n        while (p > 0) {\n            if (p & 1)\n                result *= a;\n\n            p >>= 1;\n\n            if (p > 0)\n                a *= a;\n        }\n\n        return result;\n    }\n\n    friend ostream& operator<<(ostream &os, const _m_int &m) {\n        return os << m.val;\n    }\n};\n\nextern const int MOD = 998244353;\nusing mod_int = _m_int<MOD>;\n\n\nvector<mod_int> inv, factorial, inv_factorial;\nint prepared_maximum = -1;\n\nvoid prepare_factorials(int64_t maximum) {\n    static int prepare_calls = 0;\n\n    if (prepare_calls++ == 0) {\n        // Make sure MOD is prime, which is necessary for the inverse algorithm below.\n        for (int p = 2; p * p <= MOD; p += p % 2 + 1)\n            assert(MOD % p != 0);\n\n        inv = {0, 1};\n        factorial = inv_factorial = {1, 1};\n        prepared_maximum = 1;\n    }\n\n    if (maximum > prepared_maximum) {\n        inv.resize(maximum + 1);\n        factorial.resize(maximum + 1);\n        inv_factorial.resize(maximum + 1);\n\n        for (int i = prepared_maximum + 1; i <= maximum; i++) {\n            inv[i] = inv[MOD % i] * (MOD - MOD / i);\n            factorial[i] = i * factorial[i - 1];\n            inv_factorial[i] = inv[i] * inv_factorial[i - 1];\n        }\n\n        prepared_maximum = int(maximum);\n    }\n}\n\nmod_int choose(int64_t n, int64_t r) {\n    if (r < 0 || r > n) return 0;\n    return factorial[n] * inv_factorial[r] * inv_factorial[n - r];\n}\n\nmod_int inv_choose(int64_t n, int64_t r) {\n    assert(0 <= r && r <= n);\n    return inv_factorial[n] * factorial[r] * factorial[n - r];\n}\n\nmod_int permute(int64_t n, int64_t r) {\n    if (r < 0 || r > n) return 0;\n    return factorial[n] * inv_factorial[n - r];\n}\n\nmod_int inv_permute(int64_t n, int64_t r) {\n    assert(0 <= r && r <= n);\n    return inv_factorial[n] * factorial[n - r];\n}\n\nstruct union_find {\n    // When data[x] < 0, x is a root and -data[x] is its tree size. When data[x] >= 0, data[x] is x's parent.\n    vector<int> data;\n    int components = 0;\n\n    union_find(int n = -1) {\n        if (n >= 0)\n            init(n);\n    }\n\n    void init(int n) {\n        data.assign(n + 1, -1);\n        components = n;\n    }\n\n    int find(int x) {\n        return data[x] < 0 ? x : data[x] = find(data[x]);\n    }\n\n    int get_size(int x) {\n        return -data[find(x)];\n    }\n\n    bool unite(int x, int y) {\n        x = find(x);\n        y = find(y);\n\n        if (x == y)\n            return false;\n\n        if (-data[x] < -data[y])\n            swap(x, y);\n\n        data[x] += data[y];\n        data[y] = x;\n        components--;\n        return true;\n    }\n};\n\n\nint N, M;\nvector<int> L, R;\nvector<vector<int>> adj;\nvector<vector<int>> components;\nvector<vector<vector<int>>> component_dp;\n// vector<int> which_component;\n\nbool edge_exists(int a, int b) {\n    return binary_search(adj[a].begin(), adj[a].end(), b);\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n#ifndef NEAL_DEBUG\n    cin.tie(nullptr);\n#endif\n\n    cin >> N >> M;\n    prepare_factorials(N);\n    L.resize(N);\n    R.resize(N);\n\n    for (int i = 0; i < N; i++)\n        cin >> L[i] >> R[i];\n\n    adj.assign(N, {});\n    union_find UF(N);\n\n    for (int i = 0; i < M; i++) {\n        int a, b;\n        cin >> a >> b;\n        a--; b--;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n        UF.unite(a, b);\n    }\n\n    for (int i = 0; i < N; i++)\n        sort(adj[i].begin(), adj[i].end());\n\n    for (int root = 0; root < N; root++)\n        if (UF.find(root) == root && UF.get_size(root) > 1) {\n            vector<int> component;\n\n            for (int i = 0; i < N; i++)\n                if (UF.find(i) == root)\n                    component.push_back(i);\n\n            components.push_back(component);\n        }\n\n    // which_component.assign(N, -1);\n\n    // for (int c = 0; c < int(components.size()); c++)\n    //     for (int x : components[c])\n    //         which_component[x] = c;\n\n    component_dp.assign(components.size(), {});\n\n    for (int c = 0; c < int(components.size()); c++) {\n        auto &component = components[c];\n        auto &dp = component_dp[c];\n        int C = int(component.size());\n        vector<vector<bool>> bad(C, vector<bool>(C, false));\n\n        for (int i = 0; i < C; i++)\n            for (int j = i + 1; j < C; j++)\n                bad[i][j] = edge_exists(component[i], component[j]);\n\n        dp.assign(1 << C, vector<int>(C + 1, 0));\n\n        for (int mask = 0; mask < 1 << C; mask++) {\n            bool works = true;\n\n            for (int i = 0; i < C && works; i++)\n                if (mask >> i & 1)\n                    for (int j = i + 1; j < C && works; j++)\n                        if ((mask >> j & 1) && bad[i][j])\n                            works = false;\n\n            if (works)\n                dp[mask][__builtin_popcount(mask)] = 1;\n        }\n\n        for (int bit = 0; bit < C; bit++)\n            for (int mask = 0; mask < 1 << C; mask++)\n                if ((mask >> bit & 1) == 0)\n                    for (int i = 0; i < C; i++)\n                        dp[mask | 1 << bit][i] += dp[mask][i];\n\n        dbg(dp);\n    }\n\n    vector<int> freq(N + 2, 0);\n\n    for (int i = 0; i < N; i++) {\n        freq[L[i]]++;\n        freq[R[i] + 1]--;\n    }\n\n    for (int i = 1; i <= N; i++)\n        freq[i] += freq[i - 1];\n\n    mod_int answer = 0;\n\n    for (int num = 1; num <= N; num++) {\n        int merc = freq[num];\n        vector<mod_int> knapsack(2 * M + 1, 0);\n        knapsack[0] = 1;\n        int in_component = 0;\n\n        for (int c = 0; c < int(components.size()); c++) {\n            auto &component = components[c];\n            int C = int(component.size());\n            int mask = 0;\n\n            for (int i = 0; i < C; i++)\n                if (L[component[i]] <= num && num <= R[component[i]])\n                    mask |= 1 << i;\n\n            in_component += __builtin_popcount(mask);\n\n            for (int count = M - 1; count >= 0; count--)\n                for (int add = 1; add <= C; add++)\n                    knapsack[count + add] += knapsack[count] * component_dp[c][mask][add];\n        }\n\n        for (int have = 0; have <= M; have++)\n            answer += knapsack[have] * choose(merc - in_component, num - have);\n    }\n\n    cout << answer << '\\n';\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}