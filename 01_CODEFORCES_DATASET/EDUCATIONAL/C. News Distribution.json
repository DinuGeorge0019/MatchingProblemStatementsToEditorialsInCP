{"link": "https://codeforces.com//contest/1167/problem/C", "problemId": "344632", "shortId": "1167C", "contest_number": "1167", "name": "C. News Distribution", "statement": "In some social network, there are  users communicating with each other in  groups of friends. Let's analyze the process of distributing some news between users.Initially, some user  receives the news from some source. Then he or she sends the news to his or her friends (two users are friends if there is at least one group such that both of them belong to this group). Friends continue sending the news to their friends, and so on. The process ends when there is no pair of friends such that one of them knows the news, and another one doesn't know.For each user  you have to determine what is the number of users that will know the news if initially only user  starts distributing it. ", "input": "The first line contains two integers  and  () \u2014 the number of users and the number of groups of friends, respectively. Then  lines follow, each describing a group of friends. The -th line begins with integer  () \u2014 the number of users in the -th group. Then   integers follow, denoting the users belonging to the -th group. It is guaranteed that .", "output": "Print  integers. The -th integer should be equal to the number of users that will know the news if user  starts distributing it.", "tutorial": "The first intention after reading the problem is to reformulate it in graph theory terms. Let people be vertices, edge between two vertices  and  exists if  and  have some group in common. Basically, if person  starts distributing the news, everyone in his connectivity component recieves it. Thus, the task is to calculate the number of vertices of each vertex component.As of now, the graph can have up to  edges (consider the case where everyone is in the same group). Let's reduce the number of edges without changing connectivity components. For each group you know for sure that people in it are in the same component. Let's connect not just every pair of vertices in it, but every pair of neighbouring ones in each group. It's easy to see that they are still in the same component.This graph will have  edges which is a much smaller number. You can use dfs or dsu to find the components and their sizes.Overall complexity: .", "solution": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1000043;\nvector<int> g[N];\n\nint color[N];\nint siz[N];\nint n, m;\nint cc = 0;\n\nint dfs(int x)\n{\n\tif(color[x])\n\t\treturn 0;\n\tcolor[x] = cc;\n\tint ans = (x < n ? 1 : 0);\n\tfor(auto y : g[x])\n\t\tans += dfs(y);\n\treturn ans; \n}\n\nint main()\n{\n\tscanf(\"%d %d\", &n, &m);\n\tfor(int i = 0; i < m; i++)\n\t{\n\t\tint k;\n\t\tscanf(\"%d\", &k);\n\t\tfor(int j = 0; j < k; j++)\n\t\t{\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\t--x;\n\t\t\tg[x].push_back(i + n);\n\t\t\tg[i + n].push_back(x);\n\t\t}\n\t}\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif(!color[i])\n\t\t{\n\t\t\tcc++;\n\t\t\tsiz[cc] = dfs(i);\n\t\t}\n\t\tprintf(\"%d \", siz[color[i]]);\n\t}\n}", "interactive": false, "noSolution": false, "noTutorial": false}