{"link": "https://codeforces.com//contest/1197/problem/F", "problemId": "376707", "shortId": "1197F", "contest_number": "1197", "name": "F. Coloring Game", "statement": "Alice and Bob want to play a game. They have  colored paper strips; the -th strip is divided into  cells numbered from  to . Each cell can have one of  colors.In the beginning of the game, Alice and Bob put  chips, the -th chip is put in the -th cell of the -th strip. Then they take turns, Alice is first. Each player during their turn has to choose one chip and move it ,  or  cells backwards (i.\u2009e. if the current cell is , then the chip can be moved to the cell ,  or ). There are two restrictions: the chip cannot leave the borders of the strip (for example, if the current cell is , then you can't move the chip  cells backwards); and some moves may be prohibited because of color of the current cell (a matrix  with size  is given, where  if it is possible to move the chip  cells backwards from the cell which has color , or  if such move is prohibited). The player who cannot make a move loses the game.Initially some cells may be uncolored. Bob can color all uncolored cells as he wants (but he cannot leave any cell uncolored). Let's call a coloring  if Bob can win the game no matter how Alice acts, if the cells are colored according to this coloring. Two colorings are different if at least one cell is colored in different colors in these two colorings.Bob wants you to calculate the number of good colorings. Can you do it for him?Since the answer can be really large, you have to print it modulo .", "input": "The first line contains one integer  \u2014 the number of paper strips (). The second line contains  integers , , ...,  (), where  is the number of cells in the -th strip. The third line contains one integer  () \u2014 the number of cells that are already colored. Then  lines follow, each describing an already colored cell. The -th of these lines contains three integers ,  and  (, , ) denoting that the cell  in the strip  has color . It is guaranteed that if , then either  or  (or both). Then  lines follow, -th line containing  numbers , ,  (). If , then it is possible to move the chip  cells backwards from the cell having color ; if , then such move is impossible.", "output": "Print one integer: the number of good colorings, taken modulo .", "tutorial": "Suppose there is only one strip and we want to count the number of ways to paint it. We can do it with some dynamic programming: let $$$dp_{i, r_1, r_2, r_3}$$$ be the number of ways to paint first $$$i$$$ cells of the strip so that $$$r_1$$$ denotes the result of the game if it starts in the last cell ($$$r_1 = 0$$$ if the player that makes a turn from this state loses, or $$$r_1 = 1$$$ if he wins), $$$r_2$$$ \u2014 the result if the game starts in the second-to-last, and so on. Then, if we paint the next cell, we can easily determine the result of the game starting in it, using the values of $$$r_i$$$ and the set of possible moves: if there is a value $$$r_i = 0$$$ such that we can move the chip $$$i$$$ cells backwards from the cell we just painted, then that cell is a winning one (if the game starts in it, the first player wins), otherwise it is a losing one.This dynamic programming works too slow since the strip can be very long, but we can skip long uncolored segments converting the transitions of this dp into matrix-vector multiplication: each possible combination of values of ($$$r_1$$$, $$$r_2$$$, $$$r_3$$$) can be encoded as a number from $$$0$$$ to $$$7$$$, and we may construct a $$$8 \\times 8$$$ transition matrix $$$T$$$: $$$T_{i, j}$$$ will be equal to the number of ways to color one cell so that the previous values of ($$$r_1$$$, $$$r_2$$$, $$$r_3$$$) have code $$$i$$$, and the next values have code $$$j$$$. To model painting $$$k$$$ consecutive uncolored segments, we may compute $$$T^k$$$ with fast exponentiation method. Now we can solve the problem for one strip.What changes if we try to apply the same method to solve the problem with many strips? Unfortunately, we can't analyze each cell as \"winning\" or \"losing\" now, we need more information. When solving a problem related to a combination of acyclic games, we may use Sprague-Grundy theory (you can read about it here: https://cp-algorithms.com/game_theory/sprague-grundy-nim.html). Instead of marking each cell as \"winning\" or \"losing\", we can analyze the Grundy value of each cell. When considering a strip, we should count the number of ways to color it so that its Grundy is exactly $$$x$$$ (we should do it for every possible value of $$$x$$$), which can help us to solve the initial problem with the following dynamic programming: $$$z_{i, j}$$$ is the number of ways to color $$$i$$$ first strips so that the Grundy value of their combination is exactly $$$j$$$.The only thing that's left to consider is how do we count the number of ways to color a single strip so that its Grundy value is fixed. We can to it by modifying the method described in the first paragraph: let $$$dp_{i, r_1, r_2, r_3}$$$ be the number of ways to paint $$$i$$$ first cells so that the Grundy value of the last cell is $$$r_1$$$, the value of the previous-to-last cell is $$$r_2$$$, and so on. Since we have only $$$3$$$ possible moves, the Grundy values are limited to $$$3$$$, and each possible combination of values of ($$$r_1$$$, $$$r_2$$$, $$$r_3$$$) can be encoded as a number from $$$0$$$ to $$$63$$$. The transition matrix $$$T$$$ that allows us to skip long uncolored segments will be a $$$64 \\times 64$$$ one, so if we will just exponentiate it every time we want to skip a segment, we'll get TL \u2014 but we can optimize it by precalculating $$$T$$$, $$$T^2$$$, $$$T^4$$$, ..., $$$T^{2^{30}}$$$ and using matrix-vector multiplication instead of matrix-matrix multiplication every time we skip an uncolored segment.", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int MOD = 998244353;\n\nint add(int x, int y)\n{\n\treturn (x + y) % MOD;\n}\n\nint mul(int x, int y)\n{\n\treturn (x * 1ll * y) % MOD;\n}\n\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\n\nvec mul(const mat& a, const vec& b)\n{\n\tint n = a.size();\n\tint m = b.size();\n\tvector<int> c(m);\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = 0; j < m; j++)\n\t\t\tc[i] = add(c[i], mul(b[j], a[i][j]));\n\treturn c;\n}\n\nmat add(const mat& a, const mat& b)\n{\n\tint n = a.size();\n\tint m = a[0].size();\n\tmat c(n, vec(m, 0));\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = 0; j < m; j++)\n\t\t\tc[i][j] = add(a[i][j], b[i][j]);\n\treturn c;\n}\n\nmat mul(const mat& a, const mat& b)\n{\n\tint x = a.size();\n\tint y = b.size();\n\tint z = b[0].size();\n\tmat c(x, vec(z, 0));\n\tfor(int i = 0; i < x; i++)\n\t\tfor(int j = 0; j < y; j++)\n\t\t\tfor(int k = 0; k < z; k++)\n\t\t\t\tc[i][k] = add(c[i][k], mul(a[i][j], b[j][k]));\n\treturn c;\n}\n\nmat binpow(mat a, int d)\n{\n\tint n = a.size();\n\tmat c = mat(n, vec(n, 0));\n\tfor(int i = 0; i < n; i++) c[i][i] = 1;\n\twhile(d > 0)\n\t{\n\t\tif(d % 2 == 1) c = mul(c, a);\n\t\ta = mul(a, a);\n\t\td /= 2;\n\t}\n\treturn c;\n}\n\nint f[3][3];\n\nint extend(int color, vector<int> last_numbers)\n{\n\tvector<int> used(4, 0);\n\tfor(int i = 0; i < 3; i++)\n\t\tif(f[color][i])\n\t\t\tused[last_numbers[i]] = 1;\n\tfor(int i = 0; i <= 3; i++)\n\t\tif(used[i] == 0)\n\t\t\treturn i;\n\treturn 3;\n}\n\nvector<int> extend_state(int color, vector<int> last_numbers)\n{\n\tint z = extend(color, last_numbers);\n\tlast_numbers.insert(last_numbers.begin(), z);\n\tlast_numbers.pop_back();\n\treturn last_numbers;\n}\n\nvector<int> int2state(int x)\n{\n\tvector<int> res;\n\tfor(int i = 0; i < 3; i++)\n\t{\n\t\tres.push_back(x % 4);\n\t\tx /= 4;\n\t}\n\treturn res;\n}\n\nint state2int(const vector<int>& x)\n{\n\tint res = 0;\n\tint deg = 1;\n\tfor(auto y : x)\n\t{\n\t\tres += deg * y;\n\t\tdeg *= 4;\n\t}\n\treturn res;\n}\n\nmat form_matrix(int color)\n{\n\tmat res(64, vec(64, 0));\n\tfor(int i = 0; i < 64; i++)\n\t{\n\t\tint j = state2int(extend_state(color, int2state(i)));\n\t\tres[j][i] = add(res[j][i], 1);\n\t}\n\treturn res;\n}\n\nmat color_matrices[3];\nmat full_matrix;\n\nvector<pair<int, int> > colored[1043];\nint len[1043];\nint dp[1043][4];\n\nmat full_pows[31];\n\nvoid precalc_pows()\n{\n\tfull_pows[0] = full_matrix;\n\tfor(int i = 0; i <= 30; i++)\n\t\tfull_pows[i + 1] = mul(full_pows[i], full_pows[i]);\n}\n\nvec powmul(int d, vec b)\n{\n\tfor(int i = 0; i <= 30; i++)\n\t{\n\t\tif(d % 2 == 1) \n\t\t\tb = mul(full_pows[i], b);\n\t\td /= 2;\n\t}\n\treturn b;\n}\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tfor(int i = 0; i < n; i++)\n\t\tcin >> len[i];\n\tint m;\n\tcin >> m;\n\tfor(int i = 0; i < m; i++)\n\t{\n\t\tint x, y, c;\n\t\tcin >> x >> y >> c;\n\t\t--x;\n\t\t--y;\n\t\t--c;\n\t\tcolored[x].push_back(make_pair(y, c));\n\t}\n\tfor(int i = 0; i < n; i++)\n\t\tsort(colored[i].begin(), colored[i].end());\n\tfor(int i = 0; i < 3; i++)\n\t\tfor(int j = 0; j < 3; j++)\n\t\t\tcin >> f[i][j];\n\t\n\tfor(int i = 0; i < 3; i++)\n\t\tcolor_matrices[i] = form_matrix(i);\n\tfull_matrix = color_matrices[0];\n\tfor(int i = 1; i < 3; i++)\n\t\tfull_matrix = add(full_matrix, color_matrices[i]);\n\tprecalc_pows();\n\t\t\n\tdp[0][0] = 1;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tvec cur(64);\n\t\tcur[state2int({3, 3, 3})] = 1;\n\t\tint last = 0;\n\t\tfor(auto x : colored[i])\n\t\t{\n\t\t\tcur = powmul(x.first - last, cur);\n\t\t\tcur = mul(color_matrices[x.second], cur);\n\t\t\tlast = x.first + 1;\n\t\t}\n\t\tcur = powmul(len[i] - last, cur);\n\t\tfor(int j = 0; j < 4; j++)\n\t\t\tfor(int k = 0; k < 64; k++)\n\t\t\t{\n\t\t\t\tvector<int> s = int2state(k);\n\t\t\t\tdp[i + 1][j ^ s[0]] = add(dp[i + 1][j ^ s[0]], mul(dp[i][j], cur[k]));\n\t\t\t}\n\t}\n\tcout << dp[n][0] << endl;\n}", "interactive": false, "noSolution": false, "noTutorial": false}