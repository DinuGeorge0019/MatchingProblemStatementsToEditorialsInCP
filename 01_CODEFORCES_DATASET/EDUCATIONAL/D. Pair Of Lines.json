{"link": "https://codeforces.com//contest/961/problem/D", "problemId": "171415", "shortId": "961D", "contest_number": "961", "name": "D. Pair Of Lines", "statement": "You are given  points on Cartesian plane. Every point is a lattice point (i.\u2009e. both of its coordinates are integers), and all points are distinct.You may draw two straight lines (not necessarily distinct). Is it possible to do this in such a way that every point lies on at least one of these lines?", "input": "The first line contains one integer   \u2014 the number of points you are given. Then  lines follow, each line containing two integers  and  \u2014 coordinates of -th point. All  points are distinct.", "output": "If it is possible to draw two straight lines in such a way that each of given points belongs to at least one of these lines, print . Otherwise, print .", "tutorial": "If the number of points is less than , then the answer is obviously . Else let's fix first  points. Check if there is a solution if -st and -nd points lie on the same line. Just erase all points which lie on this line and check the remaining points if they belong to one line. If we didn't find the answer, let's check points  and  in the same way. If its failed again then line which contains point  can't contain points  and , so points  and  must lie on one line. If we didn't succeed again, then there is no way to do it, so the answer is .Checking that points ,  and  belong to the same line can be done by calculating 2d version of cross product . It equals to  if vectors  and  are collinear.", "solution": "#include <bits/stdc++.h>\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n\n#define all(a) (a).begin(), (a).end()\n#define sz(a) int(a.size())\n#define mp make_pair\n\n#define x first\n#define y second\n\nusing namespace std;\n\ntypedef long long li;\ntypedef pair<int, int> pt;\n\ninline pt operator -(const pt &a, const pt &b) {\n\treturn {a.x - b.x, a.y - b.y};\n}\n\ninline li cross(const pt &a, const pt &b) {\n\treturn a.x * 1ll * b.y - a.y * 1ll * b.x;\n}\n\nconst int N = 200 * 1000 + 555;\n\nint n;\npt p[N];\n\ninline bool read() {\n\tif(!(cin >> n))\n\t\treturn false;\n\t\n\tfore(i, 0, n)\n\t\tscanf(\"%d%d\", &p[i].x, &p[i].y);\n\treturn true;\n}\n\nbool used[N];\n\nbool check() {\n\tint i1 = -1, i2 = -1;\n\tfore(i, 0, n) {\n\t\tif(used[i])\n\t\t\tcontinue;\n\t\tif(i1 == -1)\n\t\t\ti1 = i;\n\t\telse if(i2 == -1)\n\t\t\ti2 = i;\n\t}\n\tif(i2 == -1)\n\t\treturn true;\n\t\t\n\tfore(i, 0, n) {\n\t\tif(used[i])\n\t\t\tcontinue;\n\t\tif(cross(p[i2] - p[i1], p[i] - p[i1]) != 0)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nbool check2(pt a, pt b) {\n\tmemset(used, 0, sizeof used);\n\tfore(i, 0, n)\n\t\tif(cross(b - a, p[i] - a) == 0)\n\t\t\tused[i] = 1;\n\treturn check();\n}\n\ninline void solve() {\n\tif(n <= 2) {\n\t\tputs(\"YES\");\n\t\treturn;\n\t}\n\t\n\tif(check2(p[0], p[1]) || check2(p[0], p[2]) || check2(p[1], p[2]))\n\t\tputs(\"YES\");\n\telse\n\t\tputs(\"NO\");\n}\n\nint main(){\n\tif(read()) {\n\t\tsolve();\n\t}\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}