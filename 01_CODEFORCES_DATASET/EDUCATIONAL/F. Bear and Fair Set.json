{"link": "https://codeforces.com//contest/628/problem/F", "problemId": "48834", "shortId": "628F", "contest_number": "628", "name": "F. Bear and Fair Set", "statement": "Limak is a grizzly bear. He is big and dreadful. You were chilling in the forest when you suddenly met him. It's very unfortunate for you. He will eat all your cookies unless you can demonstrate your mathematical skills. To test you, Limak is going to give you a puzzle to solve.It's a well-known fact that Limak, as every bear, owns a set of numbers. You know some information about the set:  The elements of the set are distinct positive integers.  The number of elements in the set is . The number  is divisible by .  All elements are between  and , inclusive: bears don't know numbers greater than .  For each  in , the set contains exactly  elements that give remainder  when divided by . (That is, there are  elements divisible by ,  elements of the form ,  elements of the form , and so on.) Limak smiles mysteriously and gives you  hints about his set. The -th hint is the following sentence: \"If you only look at elements that are between  and , inclusive, you will find exactly  such elements in my set.\"In a moment Limak will tell you the actual puzzle, but something doesn't seem right... That smile was very strange. You start to think about a possible reason. Maybe Limak cheated you? Or is he a fair grizzly bear?Given , ,  and hints, check whether Limak can be fair, i.e. there exists at least one set satisfying the given conditions. If it's possible then print ''\". Otherwise, print ''\".", "input": "The first line contains three integers ,  and  (, ,  divisible by ) \u2014 the size of the set, the upper limit for numbers in the set and the number of hints. The next  lines describe the hints. The -th of them contains two integers  and  (, ).", "output": "Print ''\" if there exists at least one set that has all the required properties and matches all the given hints. Otherwise, print ''\".", "tutorial": "At the beginning, to make things simpler, we should add a query (hint) with , and then sort queries by . Sorted queries (hints) divide interval  into  disjoint intervals. For each interval we know how many elements should be there.\nLet's build a graph and find a max flow there. The answer is \"YES\" only if the flow is .\n   The first group  contains  vertices, representing possible remainders.   The second group  contains  vertices, representing intervals. \nEach vertex from  should be connected with the source by an edge with capacity . Each vertex from  should be connected with the sink by an edge with capacity equal to the size of the interval. Between each vertex  from  and  from  should be an edge with capacity equal to the number of numbers in the interval , giving remainder  when divided by .\nYou can also use see that it's similar to finding matching. In fact, we can use the Hall's marriage theorem. For each of  sets of vertices from  (sets of remainders) iterate over intervals and count how many numbers we can take from  with remainders from the fixed set of remainders.\n", "solution": "// Bear and Fair Set, by Errichto#include<bits/stdc++.h>using namespace std;\u00a0const int K = 5;\u00a0void NO() {\tputs(\"unfair\");\texit(0);}\u00a0int main() {\tint n, b, q;\tscanf(\"%d%d%d\", &n, &b, &q);\tvector<pair<int,int>> w;\tw.push_back(make_pair(b, n));\twhile(q--) {\t\tint a, b;\t\tscanf(\"%d%d\", &a, &b);\t\tw.push_back(make_pair(a, b));\t}\tsort(w.begin(), w.end());\t// use the Hall's theorem\t// check all 2^K sets of remainders\tfor(int mask = 0; mask < (1 << K); ++mask) {\t\tint at_least = 0, at_most = 0;\u00a0\t\tint prev_upto = 0, prev_quan = 0;\t\tfor(pair<int,int> query : w) {\t\t\tint now_upto = query.first, now_quan = query.second;\t\t\tint places_matching = 0; // how many do give remainder from \"mask\"\t\t\tint places_other = 0;\t\t\tfor(int i = prev_upto + 1; i <= now_upto; ++i) {\t\t\t\tif(mask & (1 << (i % K)))\t\t\t\t\t++places_matching;\t\t\t\telse\t\t\t\t\t++places_other;\t\t\t}\t\t\tif(now_quan < prev_quan) NO();\t\t\tint quan = now_quan - prev_quan;\t\t\tint places_total = now_upto - prev_upto;\t\t\tassert(places_total == places_matching + places_other);\t\t\tif(quan > places_total) NO();\u00a0\t\t\tat_least += max(0, quan - places_other);\t\t\tat_most += min(quan, places_matching);\u00a0\t\t\tprev_upto = now_upto;\t\t\tprev_quan = now_quan;\t\t}\u00a0\t\t// \"mask\" represents a set of popcount(mask) remainders\t\t// their total degree is (n/K)*popcount(mask)\t\tint must_be = n / K * __builtin_popcount(mask);\t\tif(!(at_least <= must_be && must_be <= at_most)) NO();\t}\tputs(\"fair\");\t\t\treturn 0;}\u00a0", "interactive": false, "noSolution": false, "noTutorial": false}