{"link": "https://codeforces.com//contest/1469/problem/B", "problemId": "847527", "shortId": "1469B", "contest_number": "1469", "name": "B. Red and Blue", "statement": "Monocarp had a sequence  consisting of  integers . He painted the elements into two colors, red and blue;  elements were painted red, all other  elements were painted blue.After painting the elements, he has written two sequences  and . The sequence  consisted of all red elements of  ; similarly, the sequence  consisted of all blue elements of  .Unfortunately, the original sequence was lost, and Monocarp only has the sequences  and . He wants to restore the original sequence. In case there are multiple ways to restore it, he wants to choose a way to restore that maximizes the value of Help Monocarp to calculate the maximum possible value of .", "input": "The first line contains one integer  () \u2014 the number of test cases. Then the test cases follow. Each test case consists of four lines. The first line of each test case contains one integer  (). The second line contains  integers  (). The third line contains one integer  (). The fourth line contains  integers  ().", "output": "For each test case, print one integer \u2014 the maximum possible value of .", "tutorial": "Denote  as the sum of first  elements of , and  as the sum of first  elements of . These values can be calculated in  with prefix sums.The first solution is to use dynamic programming. Let  be the maximum value of  if we placed the first  elements of  and the first  elements of . Transitions can be performed in : we either place an element from  (then we go to  and update it with ), or place an element from  (then we go to  and update it with ). The answer is stored in , and this solution works in .The second solution: observe that the sum of several first elements of  is the sum of several first elements of  and several first elements of . So each prefix sum of  (and the answer itself) is not greater than . It's easy to show how to obtain exactly this answer: let  be the value of  such that  is maximized, and  be the value of  such that  is maximized. Let's place the first  elements of , then the first  elements of  (so the current sum is exactly ), and place all of the remaining elements in any possible order. So, the answer is . This solution works in .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvoid solve() {\n\tint n;\n\tcin >> n;\n\tvector<int> r(n);\n\tfor (int &x : r) cin >> x;\n\tint m;\n\tcin >> m;\n\tvector<int> b(m);\n\tfor (int &x : b) cin >> x;\n\tpartial_sum(r.begin(), r.end(), r.begin());\n\tpartial_sum(b.begin(), b.end(), b.begin());\n\tcout << max(0, *max_element(r.begin(), r.end())) + max(0, *max_element(b.begin(), b.end())) << '\\n';\n}\n\nint main() {\n\tint t;\n\tcin >> t;\n\twhile (t--) solve();\n}", "interactive": false, "noSolution": false, "noTutorial": false}