{"link": "https://codeforces.com//contest/1117/problem/E", "problemId": "300045", "shortId": "1117E", "contest_number": "1117", "name": "E. Decypher the String", "statement": " You may use  in C++,  in Java,  in Python or  in Pascal to flush the output. If you use some other programming language, consult its documentation. You may also refer to the guide on interactive problems: https://codeforces.com/blog/entry/45307.You are given a string  consisting of  lowercase Latin letters. This string was cyphered as follows: initially, the jury had a string  consisting of  lowercase Latin letters. Then they applied a sequence of no more than  (possibly zero) operations. -th operation is denoted by two integers  and  (), and means swapping two elements of the string with indices  and . All operations were done in the order they were placed in the sequence. For example, if  is  and  following operations are performed: ; , then after the first operation the current string is , and after the second operation the current string is , so  is .You are asked to restore the original string . Unfortunately, you have no information about the operations used in the algorithm (you don't even know if there were any operations in the sequence). But you may run the same sequence of operations on any string you want, provided that it contains only lowercase Latin letters and its length is , and get the resulting string after those operations.Can you guess the original string  asking the testing system to run the sequence of swaps no more than  times?.", "input": "Initially the testing system sends one string , consisting of lowercase Latin letters ().", "output": "To give the answer, your program should print one line   . After that, it should flush the output and terminate gracefully.", "tutorial": "Since a sequence of swaps denotes some permutation, let's try to restore the permutation  that was used to transform  into , and then get  by applying inverse permutation. If  was  or less, then we could get  just by asking one query: send a string where no character occurs twice, and the resulting positions of characters uniquely determine the permutation. Unfortunately,  may be greater than  \u2014 but we can ask more than one query.The main idea is the following: for each index , we may choose a triple of characters, so all triples are distinct. There are  different triples, and that's greater than , so each index can be uniquely determined. Then, after we choose a triple for each index, ask three queries as follows: in the first query, the -th character of the string is the first character in the triple representing index ; in the second query we use the second characters from all triples, and in the third query \u2014 the third characters. Let ,  and  be the strings we sent, and ,  and  be the strings we received as answers. The permutation maps index  to index  if and only if ,  and  \u2014 because if some other index is mapped to , then at least one of the aforementioned equalities is false since all triples of characters are distinct. Using this fact, we may recover the permutation .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n\tstring t;\n\tcin >> t;\n\tint n = t.size();\n\tstring s1(n, 'a'), s2(n, 'a'), s3(n, 'a');\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\ts1[i] = char('a' + (i % 26));\n\t\ts2[i] = char('a' + ((i / 26) % 26));\n\t\ts3[i] = char('a' + ((i / 26 / 26) % 26));\n\t}\n\tcout << \"? \" << s1 << endl;\n\tstring t1;\n\tcin >> t1;\n\tcout << \"? \" << s2 << endl;\n\tstring t2;\n\tcin >> t2;\n\tcout << \"? \" << s3 << endl;\n\tstring t3;\n\tcin >> t3;\n\tvector<int> p(n);\n\tfor(int i = 0; i < n; i++)\n\t\tp[i] = (t1[i] - 'a') + (t2[i] - 'a') * 26 + (t3[i] - 'a') * 26 * 26;\n\tstring s(n, 'a');\n\tfor(int i = 0; i < n; i++)\n\t\ts[p[i]] = t[i];\n\tcout << \"! \" << s << endl;\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}