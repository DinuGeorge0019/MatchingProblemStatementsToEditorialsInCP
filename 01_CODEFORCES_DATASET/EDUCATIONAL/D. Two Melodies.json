{"link": "https://codeforces.com//contest/813/problem/D", "problemId": "108591", "shortId": "813D", "contest_number": "813", "name": "D. Two Melodies", "statement": "Alice is a beginner composer and now she is ready to create another masterpiece. And not even the single one but two at the same time! Alice has a sheet with  notes written on it. She wants to take two such non-empty non-intersecting subsequences that both of them form a  and sum of their lengths is maximal.Subsequence forms a melody when each two adjacent notes either differs by  or are congruent modulo .You should write a program which will calculate maximum sum of lengths of such two non-empty non-intersecting subsequences that both of them form a melody.", "input": "The first line contains one integer number  (). The second line contains  integer numbers  () \u2014 notes written on a sheet.", "output": "Print maximum sum of lengths of such two non-empty non-intersecting subsequences that both of them form a melody.", "tutorial": "Let's solve this problem with dynamic programming.Let  be the maximum answer if one melody finishes in note number  and another melody \u2014 in note number .  and  are -indexed; if one of them is , then the melody is empty.How shall we update ? First of all, we will update from previous  values only if . If , then obviously answer is , and if , then we take the answer for .Secondly, to avoid intersections, we will update  only using values of , where  and . Why? Because if we update  from some , and , then it can lead to some intersection (we can't guarantee we didn't use  in the first melody).How can we make fast updates? We will count  from  to . Then, while counting  for some specific , we will maintain two arrays:   \u2014 the maximum value of  encountered so far where ;   \u2014 the maximum value of  encountered so far where . So when we need to count , it will be the maximum of four values:    \u2014 if we add a note which is congruent modulo  with the last one;   \u2014 if we add a note which is less by  than the last note;   \u2014 if we add a note which is greater by  than the last note;   \u2014 if we just start a melody. These values can be calculated in .", "solution": "// eddy1021\n#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef double D;\ntypedef long double LD;\ntypedef long long LL;\ntypedef pair<int,int> PII;\ntypedef pair<LL,LL> PLL;\n#define mod9 1000000009LL\n#define mod7 1000000007LL\n#define INF  1023456789LL\n#define INF16 10000000000000000LL\n#define eps 1e-9\n#define SZ(x) (int)(x).size()\n#define ALL(x) (x).begin(), (x).end()\n#define IOS ios_base::sync_with_stdio(0); cin.tie(0)\n#ifndef ONLINE_JUDGE\n#define debug(...) printf(__VA_ARGS__)\n#else \n#define debug(...)\n#endif\ninline LL getint(){\n  LL _x=0,_tmp=1; char _tc=getchar();    \n  while( (_tc<'0'||_tc>'9')&&_tc!='-' ) _tc=getchar();\n  if( _tc == '-' ) _tc=getchar() , _tmp = -1;\n  while(_tc>='0'&&_tc<='9') _x*=10,_x+=(_tc-'0'),_tc=getchar();\n  return _x*_tmp;\n}\ninline LL add( LL _x , LL _y , LL _mod = mod7 ){\n  _x += _y;\n  return _x >= _mod ? _x - _mod : _x;\n}\ninline LL sub( LL _x , LL _y , LL _mod = mod7 ){\n  _x -= _y;\n  return _x < 0 ? _x + _mod : _x;\n}\ninline LL mul( LL _x , LL _y , LL _mod = mod7 ){\n  _x *= _y;\n  return _x >= _mod ? _x % _mod : _x;\n}\nLL mypow( LL _a , LL _x , LL _mod ){\n  if( _x == 0 ) return 1LL;\n  LL _ret = mypow( mul( _a , _a , _mod ) , _x >> 1 , _mod );\n  if( _x & 1 ) _ret = mul( _ret , _a , _mod );\n  return _ret;\n}\nLL mymul( LL _a , LL _x , LL _mod ){\n  if( _x == 0 ) return 0LL;\n  LL _ret = mymul( add( _a , _a , _mod ) , _x >> 1 , _mod );\n  if( _x & 1 ) _ret = add( _ret , _a , _mod );\n  return _ret;\n}\ninline bool equal( D _x ,  D _y ){\n  return _x > _y - eps && _x < _y + eps;\n}\n#define Bye exit(0)\nint __ = 1 , _cs;\n/*********default*********/\n#define N 5140\nvoid build(){\n\n}\nint n , a[ N ];\nqueue<int> q[ 101010 ] , q2[ 7 ];\nvoid init(){\n  n = getint();\n  for( int i = 1 ; i <= n ; i ++ ){\n    a[ i ] = getint();\n    q[ a[ i ] ].push( i );\n    q2[ a[ i ] % 7 ].push( i );\n  }\n}\nint dp[ N ][ N ] , ans;\nint next( int vl , int rr ){\n  while( q[ vl ].size() and q[ vl ].front() <= rr )\n    q[ vl ].pop();\n  if( q[ vl ].empty() ) return -1;\n  return q[ vl ].front();\n}\nint next2( int vl , int rr ){\n  while( q2[ vl ].size() and q2[ vl ].front() <= rr )\n    q2[ vl ].pop();\n  if( q2[ vl ].empty() ) return -1;\n  return q2[ vl ].front();\n}\nvoid solve(){\n  ans = 2;\n  for( int i = 1 ; i <= n ; i ++ ){\n    for( int j = i + 1 ; j <= n ; j ++ )\n      dp[ i ][ j ] = 2;\n    dp[ 0 ][ i ] = 1;\n  }\n  for( int r = 1 ; r <= n ; r ++ )\n    for( int l = 0 ; l < r ; l ++ ){\n      if( dp[ l ][ r ] == 0 ) continue;\n      ans = max( ans , dp[ l ][ r ] );\n      {\n        if( l == 0 ){\n          for( int nxt = r + 1 ; nxt <= n ; nxt ++ )\n            dp[ r ][ nxt ] = max( dp[ r ][ nxt ] , dp[ l ][ r ] + 1 );\n        }else{\n          for( int dlt = -1 ; dlt <= 1 ; dlt += 2 ){\n            int nxt = next( a[ l ] + dlt , r );\n            if( nxt == -1 ) continue;\n            dp[ r ][ nxt ] = max( dp[ r ][ nxt ] , dp[ l ][ r ] + 1 );\n          }\n          int nxt = next2( a[ l ] % 7 , r );\n          if( nxt != -1 )\n            dp[ r ][ nxt ] = max( dp[ r ][ nxt ] , dp[ l ][ r ] + 1 );\n        }\n      }\n      {\n        for( int dlt = -1 ; dlt <= 1 ; dlt += 2 ){\n          int nxt = next( a[ r ] + dlt , r );\n          if( nxt == -1 ) continue;\n          dp[ l ][ nxt ] = max( dp[ l ][ nxt ] , dp[ l ][ r ] + 1 );\n        }\n        {\n          int nxt = next2( a[ r ] % 7 , r );\n          if( nxt != -1 )\n            dp[ l ][ nxt ] = max( dp[ l ][ nxt ] , dp[ l ][ r ] + 1 );\n        }\n        if( l == 0 ){\n          for( int nxt = r + 1 ; nxt <= n ; nxt ++ ){\n            if( a[ nxt ] % 7 == a[ r ] % 7 or\n                abs( a[ nxt ] - a[ r ] ) == 1 )\n            dp[ l ][ nxt ] = max( dp[ l ][ nxt ] , dp[ l ][ r ] + 1 );\n          }\n        }\n      }\n    }\n  cout << ans << endl;\n}\nint main(){\n  build();\n  //__ = getint();\n  while( __ -- ){\n    init();\n    solve();\n  }\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}