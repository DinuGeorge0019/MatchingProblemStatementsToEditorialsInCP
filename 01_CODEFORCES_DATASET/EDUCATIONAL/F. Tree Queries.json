{"link": "https://codeforces.com//contest/1606/problem/F", "problemId": "1163617", "shortId": "1606F", "contest_number": "1606", "name": "F. Tree Queries", "statement": "You are given a tree consisting of  vertices. Recall that a tree is an undirected connected acyclic graph. The given tree is rooted at the vertex .You have to process  queries. In each query, you are given a vertex of the tree  and an integer .To process a query, you may delete any vertices from the tree in any order, except for the root and the vertex . When a vertex is deleted, its children become the children of its parent. You have to process a query in such a way that maximizes the value of  (where  is the resulting number of children of the vertex , and  is the number of vertices you have deleted). Print the maximum possible value you can obtain.The queries are independent: the changes you make to the tree while processing a query don't affect the tree in other queries.", "input": "The first line contains one integer  ()\u00a0\u2014 the number of vertices in the tree. Then  lines follow, the -th of them contains two integers  and  (; )\u00a0\u2014 the endpoints of the -th edge. These edges form a tree. The next line contains one integer  ()\u00a0\u2014 the number of queries. Then  lines follow, the -th of them contains two integers  and  (; )\u00a0\u2014 the parameters of the -th query.", "output": "For each query, print one integer\u00a0\u2014 the maximum value of  you can achieve.", "tutorial": "A naive solution to this problem would be to implement a recursive function which answers each query: let  be the answer to the query \" \", we can calculate it as , since for each child  of vertex , we either delete it and change the score by , or choose to let it remain, and this increases the score by . Unfortunately, it is too slow.Let's try to optimize it. First of all,  since if we choose the exact same subset of vertices to delete for the query \" \" as we've chosen for the query \" \", our score won't decrease. Using this fact, we can show that if it's optimal to remove some vertex in the query \" \", it's also optimal to remove a vertex in the query \" \" because it's optimal to remove vertex  if , and if this condition holds for some value of , then it holds for each smaller value of .Let  be the maximum value of  when it's optimal to remove the vertex . We will calculate these values for all vertices of the tree using an event processing method: we'll process the values of  from  to  and use a set or a priority queue to store events of the form \"at the value , vertex  becomes optimal to delete\". This set/priority queue should sort the events in descending order of the value of , and in case of ties, in descending order of depths of the vertices (to make sure that vertices with the same value of  are processed from bottom to up). Let's analyze the implementation of this process more in detail. For each vertex, we will store two values \u2014 the number of vertices we should remove from its subtree, and the number of children this vertex will optimally have. Using these two values, we can easily calculate the value of  for a vertex. When a vertex is \"removed\" (that is, the event corresponding to this vertex is processed), these values for this vertex should be added to its current parent (we can use DSU to find the current parent easily, for example; and don't forget that the number of vertices we have to remove for this new parent also increases by ); then we recalculate the value of  for the current parent and change the event corresponding to this current parent (note that the value of  for the current parent shouldn't be greater than the value of  for the vertex we've deleted).Okay, this allows us to calculate when it's optimal to delete each vertex. But how do we answer queries? One of the ways to do this is to process queries in the same event processing algorithm (and for every value of , we first \"remove\" the vertices  with , then process the queries). There is an issue that when we remove a vertex, it can affect the answer not only for its current parent, but also for the vertices that could be its parents, but are already deleted; to handle this, instead of adding the values of the deleted vertex only to the values of its current parent, we perform an addition on the whole path from the vertex to the current parent (excluding the vertex itself). This path addition can be performed with a Fenwick or Segment tree over the Eulerian tour of the tree, and this yields a compexity of , though with a high constant factor. ", "solution": "#include <bits/stdc++.h>     \n\nusing namespace std;\n\nstruct Vertex\n{\n \tint cost;\n \tint depth;\n \tint idx;\n \tVertex() {};\n \tVertex(int cost, int depth, int idx) : cost(cost), depth(depth), idx(idx) {};\n};\n\nbool operator <(const Vertex& a, const Vertex& b)\n{\n \tif(a.cost != b.cost)\n \t\treturn a.cost > b.cost;\n \tif(a.depth != b.depth)\n \t\treturn a.depth > b.depth;\n \treturn a.idx < b.idx;\n}\n\nstruct DSU\n{\n\tint n;\n \tvector<int> p;\n \tvector<int> top;\n\n \tint get(int x)\n \t{\n \t\tif(p[x] == x)\n \t\t\treturn x;\n \t\treturn p[x] = get(p[x]); \t\n \t}\n\n \tint get_top(int x)\n \t{\n \t \treturn top[get(x)];\n \t}\n\n \tvoid merge(int x, int par)\n \t{\n \t \tp[x] = par;\n \t}\n\n \tDSU(int k = 0)\n \t{\n \t \tn = k;\n \t \tp.resize(n);\n \t \tiota(p.begin(), p.end(), 0);\n \t \ttop = p;\n \t};\n};\n\nconst int N = 200043;\n\nint n;\nvector<int> g[N];\nint p[N], d[N], tin[N], tout[N];\nint qv[N];\nint qk[N];\nint T = 0;\n\nvoid dfs(int v = 0, int par = -1)\n{\n \ttin[v] = T++;\n \tp[v] = par;\n \tif(par == -1)\n \t\td[v] = 0;\n \telse\n \t\td[v] = d[par] + 1;\n \tfor(auto x : g[v])\n \t\tif(x != par)\n \t\t\tdfs(x, v);\n \ttout[v] = T;\n}\n\npair<long long, long long> tree[4 * N];\n\npair<long long, long long> operator+(const pair<long long, long long>& a, const pair<long long, long long>& b)\n{\n \treturn make_pair(a.first + b.first, a.second + b.second);\n}\n\npair<long long, long long> get(int v, int l, int r, int L, int R)\n{\n \tif(L >= R) return {0, 0};\n \tif(l == L && r == R) return tree[v];\n \tint m = (l + r) / 2;\n \treturn get(v * 2 + 1, l, m, L, min(R, m)) + get(v * 2 + 2, m, r, max(m, L), R);\n}\n\nvoid add(int v, int l, int r, int pos, pair<long long, long long> val)\n{\n \tif(l == r - 1)\n \t\ttree[v] = tree[v] + val;\n \telse\n \t{\n \t \tint m = (l + r) / 2;\n \t \tif(pos < m) add(v * 2 + 1, l, m, pos, val);\n \t \telse add(v * 2 + 2, m, r, pos, val);\n \t \ttree[v] = tree[v] + val;\n \t}                                                                  \n}\n\npair<long long, long long> get_vertex_value(int v)\n{\n \treturn get(0, 0, n, tin[v], tout[v]);\n}\n\nvoid add_on_path(int x, int y, pair<long long, long long> val)\n{\n \t// x is a descendant of y\n \tadd(0, 0, n, tin[x], val);\n \tif(p[y] != -1)\n \t\tadd(0, 0, n, tin[p[y]], make_pair(-val.first, -val.second));\n}\n\nint calculate_cost(int v, int correction)\n{\n\t//cerr << v << \" \" << correction << endl;\n \tpair<long long, long long> res = get_vertex_value(v);\n \t// first - (second + 1) * k <= 0\n \tlong long k = (res.first + res.second) / (res.second + 1) - 1;\n \tif(correction < k) return correction;\n \treturn k;\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor(int i = 1; i < n; i++)\n\t{\n\t \tint x, y;\n\t \tscanf(\"%d %d\", &x, &y);\n\t \t--x;\n\t \t--y;\n\t \tg[x].push_back(y);\n\t \tg[y].push_back(x);\n\t}\n\tint q;\n\tscanf(\"%d\", &q);\n\tfor(int i = 0; i < q; i++)\n\t{\n\t \tscanf(\"%d %d\", &qv[i], &qk[i]);\n\t \t--qv[i];\n\t}                   \n\n\tdfs();\n\tDSU dsu(n);\n                        \n\tvector<long long> ans(q);\n\tset<Vertex> pq;\n\tvector<Vertex> curv(n);\n\tfor(int i = 0; i < n; i++)\n\t{                     \n\t \tint count_children = g[i].size();\n\t \tif(i != 0) count_children--;               \n\t \tadd_on_path(i, i, make_pair((long long)(count_children), 0ll)); \n\t \tif(i != 0)\n\t \t{\n\t \t\tcurv[i] = Vertex(calculate_cost(i, 200000), d[i], i);\n\t\t\tpq.insert(curv[i]);                                   \n\t \t}\n                          \n\t}\n                        \n\tfor(int i = 0; i < q; i++)\n\t\tpq.insert(Vertex(qk[i], -1, i));\n\n\twhile(!pq.empty())\n\t{\n\t\tVertex z = *pq.begin();\n\t\tpq.erase(pq.begin());\n\t\tif(z.depth == -1)\n\t\t{\n\t\t \tauto res = get_vertex_value(qv[z.idx]);\n\t\t \tans[z.idx] = res.first - res.second * z.cost;\n\t    }\n\t    else\n\t    {\n\t     \tint v = z.idx;\n\t     \tint pv = p[v];\n\t     \tint newtop = dsu.get_top(pv);\n\t     \tpair<long long, long long> val = get_vertex_value(v);\n\t     \tval.second++;\n\t     \tval.first--;\n\t     \tif(newtop != 0)\n\t     \t\tpq.erase(curv[newtop]);\n\t     \tadd_on_path(pv, newtop, val);\n\t     \tif(newtop != 0)\n\t     \t\tcurv[newtop].cost = calculate_cost(newtop, z.cost);\n\t     \tif(newtop != 0)\n\t     \t\tpq.insert(curv[newtop]);\n\t     \tdsu.merge(v, pv);\n\t    }\n\t}\t\n\n\tfor(int i = 0; i < q; i++)\n\t\tprintf(\"%lld\\n\", ans[i]);\n}", "interactive": false, "noSolution": false, "noTutorial": false}