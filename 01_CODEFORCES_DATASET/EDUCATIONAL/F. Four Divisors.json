{"link": "https://codeforces.com//contest/665/problem/F", "problemId": "55556", "shortId": "665F", "contest_number": "665", "name": "F. Four Divisors", "statement": "If an integer  is divisible by another integer , then  is called the divisor of .For example:  has positive  divisors. They are , , , ,  and .Let\u2019s define a function  \u2014 number of integers between  and  (inclusive) which has exactly four positive divisors.Between  and  only the integers ,  and  has exactly four positive divisors. So, .You are given an integer . You have to calculate .", "input": "The only line contains integer  () \u2014 the parameter from the problem statement.", "output": "Print the only integer  \u2014 the number of integers between  and  with exactly four divisors.", "tutorial": "Easy to see that only the numbers of the form  and  (for different prime ) have exactly four positive divisors.\nWe can easily count the numbers of the form  in , where  is the number from the problem statement.\nNow let  and  be the number of primes from  to . Let's iterate over all the values . Easy to see that . So for fixed  we should increase the answer by the value .\nSo the task is ot to find  \u2014 the number of primes not exceeding , for all .\nDenote  the -th prime number. Denote  the number of  such that , and all prime divisors of  are at least  (note that 1 is counted in all , since the set of its prime divisors is empty).  satisfy a simple recurrence:\n    (since  = 2)   , hence  \nLet  be the smallest prime greater than . Then  (by definition, the first summand accounts for all the primes not less than ).\nIf we evaluate the recurrence  straightforwardly, all the reachable states will be of the form . We can also note that if  and  are both greater than , then . Thus, for each  it makes sense to keep only  values of .\nInstead of evaluating all DP states straightforwardly, we perform a two-step process:\n   Choose .   Run recursive evaluation of . If we want to compute a state with , memorize the query ``count the numbers not exceeding  with all prime divisors at least ''.   Answer all the queries off-line: compute the sieve for numbers up to , then sort all numbers by the smallest prime divisor. Now all queries can be answered using RSQ structure. Store all the answers globally.   Run recurisive evaluation of  yet again. If we want to compute a state with , then we must have preprocessed a query for this state, so take it from the global set of answers. \nThe performance of this approach relies heavily on  \u2014 the number of queries we have to preprocess.\nStatement. .\nProof:\nEach state we have to preprocess is obtained by following a  transition from some greater state. It follows that  doesn't exceed the total number of states for .\n\nThe preprocessing of  queries can be done in , and it is the heaviest part of the computation. Choosing optimal , we obtain the complexity .\n", "solution": "li n;\n\nbool read() {\n\treturn !!(cin >> n);\n}\n\nconst int K = 10 * 1000 * 1000;\nconst int N = K;\nconst int P = 700100;\nconst int Q = 25 * 1000 * 1000;\n\nint szp, p[P];\nint mind[N];\n\nvoid prepare() {\n\tszp = 0;\n\tforn(i, N) mind[i] = -1;\n\tfore(i, 2, N) {\n\t\tif (mind[i] == -1) {\n\t\t\tassert(szp < P);\n\t\t\tmind[i] = szp;\n\t\t\tp[szp++] = i;\n\t\t}\n\t\tfor (int j = 0; j < szp && j <= mind[i] && i * p[j] < N; j++)\n\t\t\tmind[i * p[j]] = j;\n\t}\n}\n\ninline int getk(li n) {\n\tint lf = 0, rg = szp - 1;\n\twhile (lf != rg) {\n\t\tint md = (lf + rg) >> 1;\n\t\tif (p[md] * 1ll * p[md] > n) rg = md;\n\t\telse lf = md + 1;\n\t}\n\tassert(p[lf] * 1ll * p[lf] > n);\n\treturn lf;\n}\n\nint t[K];\nvoid inc(int i, int val) {\n\tfor ( ; i < K; i |= i + 1)\n\t\tt[i] += val;\n}\nint sum(int i) {\n\tint ans = 0;\n\tfor ( ; i >= 0; i = (i & (i + 1)) - 1)\n\t\tans += t[i];\n\treturn ans;\n}\n\nint szq;\npti q[Q];\nint ans[Q];\nvector<int> vs[P];\n\nvoid process() {\n\tsort(q, q + szq, greater<pti> ());\n\tmemset(t, 0, sizeof(t));\n\n\tforn(i, szp) vs[i].clear();\n\tfore(i, 2, K)\n\t\tvs[mind[i]].pb(i);\n\n\tinc(1, +1);\n\n\tint p = szp - 1;\n\tfor (int i = 0, j = 0; i < szq; i = j) {\n\t\twhile (p >= q[i].x) {\n\t\t\tfor (auto v : vs[p])\n\t\t\t\tinc(v, +1);\n\t\t\tp--;\n\t\t}\n\n\t\twhile (j < szq && q[j].x == q[i].x) {\n\t\t\tans[j] = sum(q[j].y);\n\t\t\tj++;\n\t\t}\n\t}\n}\n\nmap<pair<li, int>, li> z;\n\nli solve(li n, int jj, bool fs) {\n\tif (!n) return 0;\n\tint j = min(jj, getk(n));\n\tif (!j) return n + j - jj;\n\n\tli ans = 0;\n\tif (n < K) {\n\t\tpti p(j, (int) n);\n\t\tif (fs) {\n\t\t\tassert(szq < Q);\n\t\t\tq[szq++] = p;\n\t\t\tans = 0;\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tint idx = int(lower_bound(q, q + szq, p, greater<pti> ()) - q);\n\t\t\tassert(idx < szq && q[idx] == p);\n\t\t\tans = ::ans[idx];\n\t\t}\n\t} else {\n\t\tif (!z.count(mp(n, j))) {\n\t\t\tans = solve(n, j - 1, fs);\n\t\t\tans -= solve(n / p[j - 1], j - 1, fs);\n\t\t\tz[mp(n, j)] = ans;\n\t\t} else {\n\t\t\tans = z[mp(n, j)];\n\t\t}\n\t}\n\n\tans += j - jj;\n\n\treturn ans;\n}\n\ninline li pi(li n, bool fs) {\n\tint k = szp - 1;\n\treturn solve(n, k, fs) + k - 1;\n}\n\nvoid solve() {\n\tszq = 0;\n\tz.clear();\n\tfor (int j = 0; p[j] * 1ll * p[j] <= n; j++) {\n\t\tli nn = n / p[j];\n\t\tif (nn > p[j]) {\n\t\t\tpi(n / p[j], true);\n\t\t}\n\t}\n\n\tprocess();\n\n\tz.clear();\n\tli ans = 0;\n\tfor (int j = 0; p[j] * 1ll * p[j] <= n; j++) {\n\t\tli nn = n / p[j];\n\t\tif (nn > p[j]) {\n\t\t\tans += pi(n / p[j], false);\n\t\t\tans -= j + 1;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < szp && p[i] * 1ll * p[i] * 1ll * p[i] <= n; i++)\n\t\tans++;\n\n\tcout << ans << endl;\n}", "interactive": false, "noSolution": false, "noTutorial": false}