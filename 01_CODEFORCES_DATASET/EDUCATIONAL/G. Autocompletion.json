{"link": "https://codeforces.com//contest/1312/problem/G", "problemId": "557983", "shortId": "1312G", "contest_number": "1312", "name": "G. Autocompletion", "statement": "You are given a set of strings . Each string consists of lowercase Latin letters.For each string in this set, you want to calculate the minimum number of seconds required to type this string. To type a string, you have to start with an empty string and transform it into the string you want to type using the following actions:  if the current string is , choose some lowercase Latin letter  and append it to the back of , so the current string becomes . This action takes  second;  use autocompletion. When you try to autocomplete the current string , a list of all strings  such that  is a prefix of  is shown to you. , and the strings are ordered lexicographically. You can transform  into the -th string from this list in  seconds. Note that you may choose any string from this list you want, it is not necessarily the string you are trying to type. What is the minimum number of seconds that you have to spend to type each string from ?.", "input": "The first line contains one integer  (). Then  lines follow, the -th line contains one integer  () and one lowercase Latin character . These lines form some set of strings such that  is its subset as follows: there are  strings, numbered from  to ; the -th string is an empty string, and the -th string () is the result of appending the character  to the string . . The next line contains one integer  () \u2014 the number of strings in . The last line contains  integers , , ...,  (, all  are pairwise distinct) denoting the indices of the strings generated by above-mentioned process that form the set  \u2014 formally, if we denote the -th generated string as , then .", "output": "Print  integers, the -th of them should be equal to the minimum number of seconds required to type the string .", "tutorial": "First of all, the information given in the input is the structure of a trie built on  and some other strings \u2014 so we can store this information in the same way as we store a trie.Okay, now let's calculate the number of seconds required to type each string with dynamic programming: let  be the number of seconds required to arrive to the -th vertex of the trie. For regular vertices, , where  is the parent of vertex ; for vertices corresponding to strings from ,  values should be updated with the time required to autocomplete some of the parents to the current vertex.To do these updates, let's calculate the answers for all strings in lexicographical order. We will run DFS on the trie and maintain a segment tree on the path from the root to the current vertex. In the segment tree, we will store the values of , where  is the number of seconds required to autocomplete from  to the current vertex. Obviously, if we are currently in a vertex representing a word from , then we have to find the minimum in this segment tree \u2014 and that will be the cost to get to current vertex using autocompletion.How to maintain ? Recall that we are running DFS on trie in lexicographical order. When we want to compute the answer for the first string, the value of  for all vertices is , since our string will be the first in all autocompletion lists. And here's a trick to maintain these values for other strings: whenever we compute the answer for some string, add  on the whole tree. For vertices that are ancestors of both current string and some next string, this  will stay and increase the cost to autocomplete the next string accordingly; but for vertices which are not on the path to some next string, the values of  will be already deleted from the segment tree and replaced by new values \u2014 so this addition does not affect them.Overall, this works in , but it can be written in  with a vector instead of a segment tree (since all additions and minimum queries affect the whole structure).", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1000043;\n\nmap<char, int> nxt[N];\nbool term[N];\nint n, k;\nchar buf[3];\nint dp[N];\nint dict[N];\n\nint T[4 * N];\nint f[4 * N];\n\nvoid build(int v, int l, int r)\n{\n    T[v] = int(1e9);\n    if(l != r - 1)\n    {\n        int m = (l + r) / 2;\n        build(v * 2 + 1, l, m);\n        build(v * 2 + 2, m, r);\n    }\n}\n\nint getVal(int v)\n{\n    return T[v] + f[v];\n}\n\nvoid push(int v, int l, int r)\n{\n    T[v] += f[v];\n    if(l != r - 1)\n    {\n        f[v * 2 + 1] += f[v];\n        f[v * 2 + 2] += f[v];\n    }\n    f[v] = 0;\n}\n\nvoid upd(int v, int l, int r)\n{\n    if(l != r - 1)\n    {\n        T[v] = min(getVal(v * 2 + 1), getVal(v * 2 + 2));\n    }\n}\n\nint get(int v, int l, int r, int L, int R)\n{\n    if(L >= R)\n        return int(1e9);\n    if(l == L && r == R)\n        return getVal(v);\n    push(v, l, r);\n    int m = (l + r) / 2;\n    int ans = min(get(v * 2 + 1, l, m, L, min(m, R)), get(v * 2 + 2, m, r, max(L, m), R));\n    upd(v, l, r);\n    return ans;\n}\n\nvoid add(int v, int l, int r, int L, int R, int val)\n{\n    if(L >= R)\n        return;\n    if(l == L && r == R)\n    {\n        f[v] += val;\n        return;\n    }\n    push(v, l, r);\n    int m = (l + r) / 2;\n    add(v * 2 + 1, l, m, L, min(m, R), val);\n    add(v * 2 + 2, m, r, max(L, m), R, val);\n    upd(v, l, r);\n}\n\nvoid setVal(int v, int l, int r, int pos, int val)\n{\n    if(l == r - 1)\n    {\n        f[v] = 0;\n        T[v] = val;\n        return;\n    }\n    push(v, l, r);\n    int m = (l + r) / 2;\n    if(pos < m)\n        setVal(v * 2 + 1, l, m, pos, val);\n    else\n        setVal(v * 2 + 2, m, r, pos, val);\n    upd(v, l, r);\n}\n\nvoid dfs(int v, int d, int last)\n{\n    dp[v] = last + 1;\n    if(term[v])\n        dp[v] = min(dp[v], get(0, 0, n + 1, 0, d));\n    setVal(0, 0, n + 1, d, dp[v] + 1);\n    if(term[v])\n        add(0, 0, n + 1, 0, d + 1, 1);\n    for(auto x : nxt[v])\n        dfs(x.second, d + 1, dp[v]);\n    setVal(0, 0, n + 1, d, int(1e9));\n}\n\nint main()\n{\n    scanf(\"%d\", &n);\n    for(int i = 0; i < n; i++)\n    {\n        int p;\n        scanf(\"%d %s\", &p, buf);\n        char c = buf[0];\n        nxt[p][c] = i + 1;\n    }\n    scanf(\"%d\", &k);\n    for(int i = 0; i < k; i++)\n    {\n        scanf(\"%d\", &dict[i]);\n        term[dict[i]] = true;\n    }\n\n    build(0, 0, n + 1);\n    dfs(0, 0, -1);\n    for(int i = 0; i < k; i++)\n        printf(\"%d \", dp[dict[i]]);\n    puts(\"\");\n}", "interactive": false, "noSolution": false, "noTutorial": false}