{"link": "https://codeforces.com//contest/846/problem/B", "problemId": "120998", "shortId": "846B", "contest_number": "846", "name": "B. Math Show", "statement": "Polycarp takes part in a math show. He is given  tasks, each consists of  subtasks, numbered  through . It takes him  minutes to solve the -th subtask of any task. Thus, time required to solve a subtask depends only on its index, but not on the task itself. Polycarp can solve subtasks in any order.By solving subtask of arbitrary problem he earns one point. Thus, the number of points for task is equal to the number of solved subtasks in it. Moreover, if Polycarp  solves the task (solves all  of its subtasks), he recieves one extra point. Thus, total number of points he recieves for the complete solution of the task is .Polycarp has  minutes of time. What is the maximum number of points he can earn?", "input": "The first line contains three integer numbers ,  and  (, , ). The second line contains  integer numbers, values  (), where  is the time in minutes required to solve -th subtask of any task.", "output": "Print the maximum amount of points Polycarp can earn in  minutes.", "tutorial": "Constraints tell us that we can avoid making any weird assumptions for any greedy solutions. You can easily count the answer for some fixed amount of tasks completed. Just sort all left subtasks (but the longest to solve in each uncompleted task) and take the easiest till the time is over. Now you can iterate from  to  tasks completed and take maximum over all options.Overall complexity: .", "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n#define N 55\nconst LL inf = 10000000000000000LL;\nLL n , k , M , dp[ N * N ] , t[ N ];\nint main(){\n  cin >> n >> k >> M;\n  for( int i = 0 ; i < k ; i ++ )\n    cin >> t[ i ];\n  sort( t , t + k );\n  for( int i = 1 ; i < k ; i ++ )\n    t[ i ] += t[ i - 1 ];\n  for( int i = 1 ; i <= n * ( k + 1 ) ; i ++ )\n    dp[ i ] = inf;\n  for( int _ = 0 ; _ < n ; _ ++ ){\n    for( int i = n * ( k + 1 ) ; i >= 0 ; i -- ){\n      if( dp[ i ] == inf ) continue;\n      for( int solved = 1 ; solved <= k ; solved ++ ){\n        LL tdp = dp[ i ] + t[ solved - 1 ];\n        int ii = i + solved + (solved == k);\n        dp[ ii ] = min( dp[ ii ] , tdp );\n      }\n    }\n  }\n  int ans = 0;\n  for( int i = 1 ; i <= n * ( k + 1 ) ; i ++ )\n    if( dp[ i ] <= M )\n      ans = i;\n  cout << ans << endl;\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}