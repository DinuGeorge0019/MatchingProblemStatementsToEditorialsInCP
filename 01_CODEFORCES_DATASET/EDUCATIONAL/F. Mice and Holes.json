{"link": "https://codeforces.com//contest/797/problem/F", "problemId": "103033", "shortId": "797F", "contest_number": "797", "name": "F. Mice and Holes", "statement": "One day Masha came home and noticed  mice in the corridor of her flat. Of course, she shouted loudly, so scared mice started to run to the holes in the corridor.The corridor can be represeted as a numeric axis with  mice and  holes on it. th mouse is at the coordinate , and th hole \u2014 at coordinate . th hole has enough room for  mice, so not more than  mice can enter this hole.What is the minimum sum of distances that mice have to go through so that they all can hide in the holes? If th mouse goes to the hole , then its distance is .Print the minimum sum of distances.", "input": "The first line contains two integer numbers ,  () \u2014 the number of mice and the number of holes, respectively. The second line contains  integers  (), where  is the coordinate of th mouse. Next  lines contain pairs of integer numbers  (), where  is the coordinate of th hole, and  is the maximum number of mice that can hide in the hole .", "output": "Print one integer number \u2014 the minimum sum of distances. If there is no solution, print  instead.", "tutorial": "This problem can be solved using dynamic programming. Let  be the answer for first  holes and  mice.If the constraints were smaller, then we could calculate it in  just trying to update  by all values of  where  and calculating the cost to transport all mice from the segment to th hole.To calculate this in , we will use a deque maintaining the minimum (or a queue implemented on two stacks, for example). We iterate on  and update all the values of  with the help of this deque: for each index  we insert a value in the deque equal to , where  is the total distance required to move first  mice to hole . Updating the value is just extracting the minimum and adding this  to it. Don't forget to delete values from the deque to ensure that we don't send too much mice to the hole.Time complexity: . ", "solution": "// In the name of God\n\n#include <iostream>\n#include <algorithm>\n#include <fstream>\n#include <vector>\n#include <deque>\n#include <assert.h>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <stdio.h>\n#include <string.h>\n#include <utility>\n#include <math.h>\n#include <bitset>\n#include <iomanip>\n#include <complex>\n\nusing namespace std;\n\n#define rep(i, a, b) for (int i = (a), i##_end_ = (b); i < i##_end_; ++i)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n#define x first\n#define y second\n#define pb push_back\n#define SZ(x) (int((x).size()))\n#define ALL(x) (x).begin(), (x).end()\n\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool smin(T &a, const T &b)   { return a > b ? a = b : a;    }\ntemplate<typename T> inline bool smax(T &a, const T &b)   { return a < b ? a = b : a;    }\n\ntypedef long long LL;\nconst int N = (int) 5005, mod = (int) 0;\nint a[N], pos[N], p[N], c[N];\nlong long sum[N];\npair<int, int> sr[N];\nlong long get(int hole, int l, int r) {\n\tint m = pos[hole];\n\tif (l < m && m < r) {\n\t\treturn get(hole, l, m) + get(hole, m, r);\n\t}\n\tif (r <= m) {\n\t\treturn (r - l) * (long long) p[hole] - (sum[r] - sum[l]);\n\t} else if (l >= m) {\n\t\treturn sum[r] - sum[l] - (r - l) * (long long) p[hole];\n\t}\n\tassert(0);\n\n}\nlong long odp[N], dp[N];\nint dq[N];\nvoid solve(int hole, int ul, int ur, int optl, int optr) {\n\tif (ur - ul <= 0) return;\n\tint h = 0;\n\tint t = 0;\n\tdp[0] = 0;\n\tdq[t++] = 0;\n\tfor (int j = 1; j <= ur; ++j) {\n\t\twhile (t - h > 0 && j - dq[h] > c[hole]) ++h;\n\t\twhile (t - h > 0 && odp[j] <= odp[dq[t - 1]] + get(hole, dq[t - 1], j)) --t;\n\t\tdq[t++] = j;\n\t\tdp[j] = odp[dq[h]] + get(hole, dq[h], j);\n\t\t//best = min(odp[j + 1], best + abs(p[hole] - a[j]));\n\t}\n/*\tint m = ul + ur >> 1;\n\tint opt = optl;\n\tdp[m] = 1e18;\n\tfor (int j = optl; j <= min(optr, m); ++j) {\n\t\tif (m - j > c[hole]) continue;\n\t\tlong long nwcost = odp[j] + get(hole, j, m);\n\t\tif (nwcost <= dp[m]) {\n\t\t\tdp[m] = nwcost;\n\t\t\topt = j;\n\t\t}\n\t}\n\tsolve(hole, ul, m, optl, opt);\n\tsolve(hole, m + 1, ur, opt, optr); */\n}\nint32_t main() {\n\tint n, m;\n\tcin >> n >> m;\n\tfor (int j = 0; j < n; ++j) {\n\t\tcin >> a[j];\n\t}\n\tsort(a, a + n);\n\tfor (int j = 0; j < n; ++j)\n\t\tsum[j + 1] = sum[j] + a[j];\n\tint ss = 0;\n\tfor (int j = 0; j < m; ++j) {\n\t\tcin >> sr[j].first >> sr[j].second;\n\t\tss += sr[j].second;\n\t}\n\tsort(sr, sr + m);\n\tfor (int j = 0; j < m; ++j) {\n\t\tp[j] = sr[j].first, c[j] = sr[j].second;\n\t\tint &pt = pos[j];\n\t\twhile (a[pt] <= p[j]) ++pt;\n\t}\n\tif (ss < n) {\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\tmemset(dp, 63, sizeof dp);\n\tdp[0] = 0;\n\tfor (int j = 0; j < m; ++j) {\n\t\tmemcpy(odp, dp, sizeof dp);\n\t\tmemset(dp, 0, sizeof dp);\n\t\tsolve(j, 0, n + 1, 0, n);\n\t}\n\tcout << dp[n] << endl;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "interactive": false, "noSolution": false, "noTutorial": false}