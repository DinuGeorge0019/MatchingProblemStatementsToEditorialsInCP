{"link": "https://codeforces.com//contest/1082/problem/C", "problemId": "64163", "shortId": "1082C", "contest_number": "1082", "name": "C. Multi-Subject Competition", "statement": "A multi-subject competition is coming! The competition has  different subjects participants can choose from. That's why Alex (the coach) should form a competition delegation among his students. He has  candidates. For the -th person he knows subject  the candidate specializes in and  \u2014 a skill level in his specialization (this level can be negative!). The rules of the competition require each delegation to choose some subset of subjects they will participate in. The only restriction is that the  participating in each of the  subjects should be the .Alex decided that each candidate would participate only in the subject he specializes in. Now Alex wonders whom he has to choose to maximize the total sum of skill levels of all delegates, or just skip the competition this year if every valid non-empty delegation has negative sum.(Of course, Alex doesn't have any spare money so each delegate he chooses must participate in the competition).", "input": "The first line contains two integers  and  (, ) \u2014 the number of candidates and the number of subjects. The next  lines contains two integers per line:  and  (, ) \u2014 the subject of specialization and the skill level of the -th candidate.", "output": "Print the single integer \u2014 the maximum total sum of skills of delegates who form a valid delegation (according to rules above) or  if every valid non-empty delegation has negative sum.", "tutorial": "At first, it's optimal to take candidates with maximal levels for a fixed subject.At second, if we fix number of participants in each subject for some delegation, then it's always optimal to choose all subjects with positive sum of levels.It leads us to a following solution. Let's divide all candidates by it's  and sort each group in non-increasing order.In result we can just iterate over all prefix sums for each group and update global answer of current length with current sum if it has a positive value.", "solution": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) int((a).size())\n\nint n, m;\nvector<int> s, r;\n\ninline bool read() {\n\tif(!(cin >> n >> m))\n\t\treturn false;\n\ts.assign(n, 0);\n\tr.assign(n, 0);\n\t\n\tfore(i, 0, n) {\n\t\tassert(cin >> s[i] >> r[i]);\n\t\ts[i]--;\n\t}\n\treturn true;\n}\n\nvector< vector<int> > subs;\n\ninline void solve() {\n\tsubs.assign(m + 1, vector<int>());\n\t\n\tfore(i, 0, n)\n\t\tsubs[s[i]].push_back(r[i]);\n\t\t\n\tfore(id, 0, sz(subs)) {\n\t\tsort(subs[id].begin(), subs[id].end());\n\t\treverse(subs[id].begin(), subs[id].end());\n\t}\n\t\n\tvector<int> mx(n + 5, 0);\n\tfore(id, 0, sz(subs)) {\n\t\tint curSum = 0;\n\t\tfore(i, 0, sz(subs[id])) {\n\t\t\tcurSum += subs[id][i];\n\t\t\tif(curSum < 0)\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tmx[i + 1] += curSum;\n\t\t}\n\t}\n\t\n\tcout << *max_element(mx.begin(), mx.end()) << endl;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint tt = clock();\n#endif\n\tcout << fixed << setprecision(15);\n\t\n\tif(read()) {\n\t\tsolve();\n\t\t\n#ifdef _DEBUG\n\t\tcerr << \"TIME = \" << clock() - tt << endl;\n\t\ttt = clock();\n#endif\n\t}\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}