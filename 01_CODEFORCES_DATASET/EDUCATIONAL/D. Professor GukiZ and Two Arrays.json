{"link": "https://codeforces.com//contest/620/problem/D", "problemId": "45930", "shortId": "620D", "contest_number": "620", "name": "D. Professor GukiZ and Two Arrays", "statement": "Professor GukiZ has two arrays of integers,  and . Professor wants to make the sum of the elements in the array   as close as possible to the sum of the elements in the array  . So he wants to minimize the value .In one operation professor can swap some element from the array  and some element from the array . For example if the array  is  and the array  is  professor can swap the element  from the array  and the element  from the array  and get the new array   and the new array  .Professor doesn't want to make more than two swaps. Find the minimal value  and some sequence of no more than two swaps that will lead to the such value . Professor makes swaps one by one, each new swap he makes with the new arrays  and .", "input": "The first line contains integer  () \u2014 the number of elements in the array . The second line contains  integers  () \u2014 the elements of the array . The third line contains integer  () \u2014 the number of elements in the array . The fourth line contains  integers  () \u2014 the elements of the array .", "output": "In the first line print the minimal value  that can be got with no more than two swaps. The second line should contain the number of swaps  (). Each of the next  lines should contain two integers  () \u2014 the index of the element in the array  and the index of the element in the array  in the -th swap. If there are several optimal solutions print any of them. Print the swaps in order the professor did them.", "tutorial": "We can process the cases of zero or one swap in  time. Consider the case with two swaps. Note we can assume that two swaps will lead to move two elements from  to  and vice versa (in other case it is similar to the case with one swap). Let's iterate over all the pairs of the values in  and store them in some data structure (in C++ we can user map). Now let's iterate over all the pairs  and find in out data structure the value  closest to the value  and update the answer by the value . Required sum we can find using binary search by data structure (*map* in C++ has lower_bound function).\n", "solution": "\n            #include <bits/stdc++.h>\n\u00a0\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n#define ford(i, n) for (int i = int(n) - 1; i >= 0; i--)\n#define fore(i, l, r) for (int i = int(l); i < int(r); i++)\n#define correct(x, y, n, m) (0 <= (x) && (x) < (n) && 0 <= (y) && (y) < (m))\n#define all(a) (a).begin(), (a).end()\n#define sz(a) int((a).size())\n#define pb(a) push_back(a)\n#define mp(x, y) make_pair((x), (y))\n#define x first\n#define y second\n\u00a0\nusing namespace std;\n\u00a0\ntypedef long long li;\ntypedef long double ld;\ntypedef pair<int, int> pt;\n\u00a0\ntemplate<typename X> inline X abs(const X& a) { return a < 0? -a: a; }\ntemplate<typename X> inline X sqr(const X& a) { return a * a; }\n\u00a0\nconst int INF = int(1e9);\nconst li INF64 = li(1e18);\nconst ld EPS = 1e-9, PI = 3.1415926535897932384626433832795;\n\u00a0\nconst int N = 2020;\n\u00a0\nint n, a[N];\nint m, b[N];\n\u00a0\ninline bool read() {\n\u00a0 \u00a0 if (!(cin >> n)) return false;\n\u00a0 \u00a0 forn(i, n) assert(scanf(\"%d\", &a[i]) == 1);\n\u00a0 \u00a0 assert(cin >> m);\n\u00a0 \u00a0 forn(i, m) assert(scanf(\"%d\", &b[i]) == 1);\n\u00a0 \u00a0 return true;\n}\n\u00a0\nli sa, sb;\n\u00a0\ninline void solve() {\n\u00a0 \u00a0 sa = accumulate(a, a + n, 0ll);\n\u00a0 \u00a0 sb = accumulate(b, b + m, 0ll);\n\u00a0\n\u00a0 \u00a0 li ansv = INF64;\n\u00a0 \u00a0 vector<pt> ansp;\n\u00a0\n\u00a0 \u00a0 {\n\u00a0 \u00a0 \u00a0 \u00a0 li curv = abs(sa - sb);\n\u00a0 \u00a0 \u00a0 \u00a0 if (ansv > curv) {\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ansv = curv;\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ansp.clear();\n\u00a0 \u00a0 \u00a0 \u00a0 }\n\u00a0 \u00a0 }\n\u00a0\n\u00a0 \u00a0 forn(i, n)\n\u00a0 \u00a0 \u00a0 \u00a0 forn(j, m) {\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 sa += b[j] - a[i];\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 sb += a[i] - b[j];\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 li curv = abs(sa - sb);\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if (ansv > curv) {\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ansv = curv;\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ansp.clear();\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ansp.pb(mp(i, j));\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 sa -= b[j] - a[i];\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 sb -= a[i] - b[j];\n\u00a0 \u00a0 \u00a0 \u00a0 }\n\u00a0\n\u00a0 \u00a0 map<li, pt> z;\n\u00a0 \u00a0 forn(j, n)\n\u00a0 \u00a0 \u00a0 \u00a0 forn(i, j)\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 z[2ll * (a[i] + a[j])] = mp(i, j);\n\u00a0\n\u00a0 \u00a0 forn(j, m)\n\u00a0 \u00a0 \u00a0 \u00a0 forn(i, j) {\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 li val = sa - sb + 2ll * (b[i] + b[j]);\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 auto it = z.lower_bound(val);\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if (it != z.begin()) it--;\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 forn(k, 2) {\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if (it == z.end()) break;\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 li curv = abs(val - it->x);\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 pt p = it->y;\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 assert(abs(sa - 2ll * (a[p.x] + a[p.y]) - (sb - 2ll * (b[i] + b[j]))) == curv);\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if (ansv > curv) {\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ansv = curv;\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ansp.clear();\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ansp.pb(mp(p.x, i));\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ansp.pb(mp(p.y, j));\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 it++;\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\n\u00a0 \u00a0 \u00a0 \u00a0 }\n\u00a0\n\u00a0 \u00a0 assert(ansv != INF64);\n\u00a0 \u00a0 cout << ansv << endl;\n\u00a0 \u00a0 cout << sz(ansp) << endl;\n\u00a0 \u00a0 forn(i, sz(ansp)) cout << ansp[i].x + 1 << ' ' << ansp[i].y + 1 << endl;\n}\n\u00a0\nint main() {\n#ifdef SU1\n\u00a0 \u00a0 assert(freopen(\"input.txt\", \"rt\", stdin));\n\u00a0 \u00a0 //assert(freopen(\"output.txt\", \"wt\", stdout));\n#endif\n\u00a0 \u00a0 \n\u00a0 \u00a0 cout << setprecision(10) << fixed;\n\u00a0 \u00a0 cerr << setprecision(5) << fixed;\n\u00a0\n\u00a0 \u00a0 while (read()) {\n\u00a0 \u00a0 \u00a0 \u00a0 solve();\n\u00a0 \u00a0 \u00a0 \u00a0 //break;\n\u00a0 \u00a0 }\n\u00a0 \u00a0 \n\u00a0 \u00a0 return 0;\n}\n        ", "interactive": false, "noSolution": false, "noTutorial": false}