{"link": "https://codeforces.com//contest/1279/problem/D", "problemId": "504276", "shortId": "1279D", "contest_number": "1279", "name": "D. Santa's Bot", "statement": "Santa Claus has received letters from  different kids throughout this year. Of course, each kid wants to get some presents from Santa: in particular, the -th kid asked Santa to give them one of  different items as a present. Some items could have been asked by multiple kids.Santa is really busy, so he wants the New Year Bot to choose the presents for all children. Unfortunately, the Bot's algorithm of choosing presents is bugged. To choose a present for some kid, the Bot does the following:  choose one kid  equiprobably among all  kids;  choose some item  equiprobably among all  items kid  wants;  choose a kid  who will receive the present equipropably among all  kids (this choice is independent of choosing  and ); the resulting triple  is called  of the Bot. If kid  listed item  as an item they want to receive, then the decision . Otherwise, the Bot's choice is .Santa is aware of the bug, but he can't estimate if this bug is really severe. To do so, he wants to know the probability that one decision generated according to the aforementioned algorithm is . Can you help him?", "input": "The first line contains one integer  () \u2014 the number of kids who wrote their letters to Santa. Then  lines follow, the -th of them contains a list of items wanted by the -th kid in the following format:    ...  (), where  is the number of items wanted by the -th kid, and  are the items themselves. No item is contained in the same list more than once. It is guaranteed that .", "output": "Print the probatility that the Bot produces a  decision as follows: Let this probability be represented as an irreducible fraction . You have to print , where  is the inverse element of  modulo  (such integer that  has remainder  modulo ). ", "tutorial": "First of all, how to deal with the fractions modulo $$$998244353$$$? According to Fermat's little theorem, $$$x^{\\phi(m)} \\equiv 1 (mod m)$$$ if $$$x$$$ is coprime with $$$m$$$. So, the inverse element for the denominator $$$y$$$ is $$$y^{\\phi(998244353) - 1} = y^{998244351}$$$, taken modulo $$$998244353$$$.A cool property of fractions taken modulo $$$998244353$$$ (or any other number such that denominator is coprime with it) is that if we want to add two fractions together and calculate the result modulo some number, we can convert these fractions beforehand and then just add them as integer numbers. The same works with subtracting, multiplying, dividing and exponentiating fractions.Okay, now for the solution itself. We know that there are at most $$$10^6$$$ possible pairs of $$$(x, y)$$$; we can iterate on these pairs, calculate the probability that the fixed pair is included in the robot's decision (that probability is $$$\\frac{1}{x \\cdot k_x}$$$), and calculate the probability that $$$(x, y)$$$ extends to a valid triple (it is equal to $$$\\frac{cnt_y}{z}$$$, where $$$cnt_y$$$ is the number of kids who want item $$$y$$$). Multiplying these two probabilities, we get the probability that $$$(x, y)$$$ is chosen  produces a valid decision (since these events are independent), and we sum up these values over all possible pairs $$$(x, y)$$$.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n#define pb push_back\n#define mp make_pair\n#define sqr(a) ((a) * (a))\n#define sz(a) int((a).size())\n#define all(a) (a).begin(), (a).end()\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n\nconst int MOD = 998244353;\nconst int N = 1e6 + 7;\n\nint n;\nvector<int> a[N];\nint cnt[N];\nint inv[N];\n\nint add(int a, int b) {\n\ta += b;\n\tif (a >= MOD) a -= MOD;\n\treturn a;\n}\n\nint mul(int a, int b) {\n\treturn a * 1ll * b % MOD;\n}\n\nint binpow(int a, int b) {\n\tint res = 1;\n\twhile (b) {\n\t\tif (b & 1) res = mul(res, a);\n\t\ta = mul(a, a);\n\t\tb >>= 1;\n\t}\n\treturn res;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tforn(i, n) {\n\t\tint k;\n\t\tscanf(\"%d\", &k);\n\t\ta[i].resize(k);\n\t\tforn(j, k) scanf(\"%d\", &a[i][j]);\n\t\tforn(j, k) cnt[a[i][j]]++;\n\t}\n\t\n\tforn(i, N) inv[i] = binpow(i, MOD - 2);\n\t\n\tint ans = 0;\n\tforn(i, n) for (auto x : a[i])\n\t\tans = add(ans, mul(mul(inv[n], inv[sz(a[i])]), mul(cnt[x], inv[n])));\n\t\t\t\n\tprintf(\"%d\\n\", ans);\n}", "interactive": false, "noSolution": false, "noTutorial": false}