{"link": "https://codeforces.com//contest/1400/problem/B", "problemId": "709184", "shortId": "1400B", "contest_number": "1400", "name": "B. RPG Protagonist", "statement": "You are playing one RPG from the 2010s. You are planning to raise your smithing skill, so you need as many resources as possible. So how to get resources? By stealing, of course.You decided to rob a town's blacksmith and you take a follower with you. You can carry at most  units and your follower\u00a0\u2014 at most  units.In the blacksmith shop, you found  swords and  war axes. Each sword weights  units and each war axe\u00a0\u2014  units. You don't care what to take, since each of them will melt into one steel ingot.What is the maximum number of weapons (both swords and war axes) you and your follower can carry out from the shop?", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of test cases. The first line of each test case contains two integers  and  ()\u00a0\u2014 yours and your follower's capacities. The second line of each test case contains two integers  and  ()\u00a0\u2014 the number of swords and war axes in the shop. The third line of each test case contains two integers  and  ()\u00a0\u2014 the weights of each sword and each war axe. It's guaranteed that the total number of swords and the total number of war axes in all test cases don't exceed .", "output": "For each test case, print the maximum number of weapons (both swords and war axes) you and your follower can carry.", "tutorial": "First iterate on the number of swords we will personally take. Then we should greedily take as many war axes as we can until we run out of money. At this point, our follower needs to take as many items as possible. They can do this by greedily taking whichever of swords or war axes are cheaper until they run out, followed by taking the more expensive of the two. Code: 90918673\n", "solution": "#include <algorithm>\n#include <array>\n#include <cassert>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\ntemplate<typename T> ostream& operator<<(ostream &os, const vector<T> &v) { os << '{'; string sep; for (const auto &x : v) os << sep << x, sep = \", \"; return os << '}'; }\ntemplate<typename T, size_t size> ostream& operator<<(ostream &os, const array<T, size> &arr) { os << '{'; string sep; for (const auto &x : arr) os << sep << x, sep = \", \"; return os << '}'; }\ntemplate<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << '(' << p.first << \", \" << p.second << ')'; }\n\nvoid dbg_out() { cerr << endl; }\ntemplate<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cerr << ' ' << H; dbg_out(T...); }\n\n#ifdef NEAL_DEBUG\n#define dbg(...) cerr << \"(\" << #__VA_ARGS__ << \"):\", dbg_out(__VA_ARGS__)\n#else\n#define dbg(...)\n#endif\n\n\nint64_t can_take(int64_t S, int64_t W, int64_t CS, int64_t CW, int64_t P) {\n    if (S > W)\n        return can_take(W, S, CW, CS, P);\n\n    if (S * CS >= P)\n        return P / S;\n\n    return CS + min((P - S * CS) / W, CW);\n}\n\nvoid run_case() {\n    int64_t P, F, CS, CW, S, W;\n    cin >> P >> F >> CS >> CW >> S >> W;\n    int64_t best = 0;\n\n    for (int64_t cs = 0; cs <= CS; cs++)\n        if (cs * S <= P) {\n            int64_t cw = min((P - cs * S) / W, CW);\n            best = max(best, cs + cw + can_take(S, W, CS - cs, CW - cw, F));\n        }\n\n    cout << best << '\\n';\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n#ifndef NEAL_DEBUG\n    cin.tie(nullptr);\n#endif\n\n    int tests;\n    cin >> tests;\n\n    while (tests-- > 0)\n        run_case();\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}