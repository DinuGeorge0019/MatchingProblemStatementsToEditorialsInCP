{"link": "https://codeforces.com//contest/1681/problem/C", "problemId": "1408804", "shortId": "1681C", "contest_number": "1681", "name": "C. Double Sort", "statement": "You are given two arrays  and , both consisting of  integers.In one move, you can choose two indices  and  (; ) and swap  with  and  with . You have to perform the swap in both arrays.You are allowed to perform at most  moves (possibly, zero). Can you make both arrays sorted in a non-decreasing order at the end? If you can, print any sequence of moves that makes both arrays sorted.", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of testcases. The first line of each testcase contains a single integer  ()\u00a0\u2014 the number of elements in both arrays. The second line contains  integers  ()\u00a0\u2014 the first array. The third line contains  integers  ()\u00a0\u2014 the second array.", "output": "For each testcase, print the answer. If it's impossible to make both arrays sorted in a non-decreasing order in at most  moves, print . Otherwise, first, print the number of moves  . Then print  and  for each move ; . If there are multiple answers, then print any of them. You don't have to minimize the number of moves.", "tutorial": "Imagine that all elements of  are distinct. This way, sorting  in increasing order will fix the order of .If  turns out sorted in a non-decreasing order, then the answer exists. Otherwise, it doesn't. To obtain the sequence of swaps, you can sort  with any comparison-based sorting algorithm you want: even bubble sort will not exceed the allowed number of swaps.What changes if  has repeated elements? Distinct elements are still ordered among themselves, but now there are also blocks of equal elements. For each block, look into the corresponding values in . Obviously, these have to be sorted in a non-decreasing order. Rearrange them as they should be.In fact, this is exactly the same as sorting the sequence of pairs  with a default comparator\u00a0\u2014 first by , then by .Since we fixed the wanted order, we can proceed with the same steps we made in a distinct case.Overall complexity:  or  per testcase.", "solution": "for _ in range(int(input())):\n\tn = int(input())\n\ta = list(map(int, input().split()))\n\tb = list(map(int, input().split()))\n\ttmp = [i for i in range(n)]\n\ttmp.sort(key=lambda i: [a[i], b[i]])\n\tfor i in range(n - 1):\n\t\tif a[tmp[i]] > a[tmp[i + 1]] or b[tmp[i]] > b[tmp[i + 1]]:\n\t\t\tprint(\"-1\")\n\t\t\tbreak\n\telse:\n\t\tans = []\n\t\tfor i in range(n - 1):\n\t\t\tfor j in range(n - 1):\n\t\t\t\tif a[j] > a[j + 1] or b[j] > b[j + 1]:\n\t\t\t\t\ta[j], a[j + 1] = a[j + 1], a[j]\n\t\t\t\t\tb[j], b[j + 1] = b[j + 1], b[j]\n\t\t\t\t\tans.append([j + 1, j + 2])\n\t\tprint(len(ans))\n\t\tfor it in ans:\n\t\t\tprint(*it)", "interactive": false, "noSolution": false, "noTutorial": false}