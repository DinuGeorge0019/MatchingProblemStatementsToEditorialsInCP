{"link": "https://codeforces.com//contest/1525/problem/D", "problemId": "987014", "shortId": "1525D", "contest_number": "1525", "name": "D. Armchairs", "statement": "There are  armchairs, numbered from  to  from left to right. Some armchairs are occupied by people (at most one person per armchair), others are not. The number of occupied armchairs is not greater than .For some reason, you would like to tell people to move from their armchairs to some other ones. If the -th armchair is occupied by someone and the -th armchair is not, you can tell the person sitting in the -th armchair to move to the -th armchair. The time it takes a person to move from the -th armchair to the -th one is  minutes. You may perform this operation any number of times, but these operations must be done sequentially, i.\u2009e. you cannot tell a person to move until the person you asked to move in the last operation has finished moving to their destination armchair.You want to achieve the following situation: every seat that was initially occupied must be free. What is the minimum time you need to do it?", "input": "The first line contains one integer  () \u2014 the number of armchairs. The second line contains  integers  ().  means that the -th armchair is initially occupied,  means that it is initially free. The number of occupied armchairs is at most .", "output": "Print one integer \u2014 the minimum number of minutes you have to spend to achieve the following situation: every seat that was initially occupied must be free.", "tutorial": "Let's say that the starting position of people are  (in sorted order) and ending positions of people are  (also in sorted order). It's always optimal to match these starting and ending positions in sorted order: the leftmost starting position is matched with the leftmost ending, the second starting position is matched with the second ending, and so on. To prove it, suppose that position  is matched with , position  is matched with ,  and . If both persons go to the left or to the right, it means that either  or , so nothing changes if we swap the matched positions. If, instead, the person that goes from  to  goes to the right, and the person that goes from  to  goes to the left, the segment  belongs to both paths, and swapping the matched pairs removes this segment from both paths (and decreases the total time). So, if the order of starting positions is sorted and the order of ending positions is sorted, these positions should be matched exactly in those order.Using this fact, we can implement the following dynamic programming: let  be the minimum time if we considered  first positions and picked  of them as the ending ones. Transitions are the following: we either take the current position as the ending one (if it's not a starting one), match it with the -th starting position and go to , or we skip the current position and go to . It works in  since it has up to  states and just up to  transitions from each state.", "solution": "#include <bits/stdc++.h>     \n\nusing namespace std;\n\nconst int INF = int(1e9);\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tvector<int> a(n);\n\tfor(int i = 0; i < n; i++)\n\t\tcin >> a[i];\n\tvector<int> pos;\n\tfor(int i = 0; i < n; i++)\n\t\tif(a[i] == 1)\n\t\t\tpos.push_back(i);\n\tint k = pos.size();\n\tvector<vector<int>> dp(n + 1, vector<int>(k + 1, INF));\n\tdp[0][0] = 0;\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = 0; j <= k; j++)\n\t\t{\n\t\t \tif(dp[i][j] == INF) continue;\n\t\t \tdp[i + 1][j] = min(dp[i + 1][j], dp[i][j]);\n\t\t \tif(j < k && a[i] == 0)\n\t\t \t\tdp[i + 1][j + 1] = min(dp[i + 1][j + 1], dp[i][j] + abs(pos[j] - i));\n\t\t}\n\tcout << dp[n][k] << endl;\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}