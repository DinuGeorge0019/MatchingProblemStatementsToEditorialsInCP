{"link": "https://codeforces.com//contest/911/problem/F", "problemId": "142500", "shortId": "911F", "contest_number": "911", "name": "F. Tree Destruction", "statement": "You are given an unweighted tree with  vertices. Then  following operations are applied to the tree. A single operation consists of the following steps:   choose two leaves;  add the length of the simple path between them to the answer;  remove one of the chosen leaves from the tree. Initial answer (before applying operations) is . Obviously after  such operations the tree will consist of a single vertex. Calculate the maximal possible answer you can achieve, and construct a sequence of operations that allows you to achieve this answer!", "input": "The first line contains one integer number  () \u2014 the number of vertices in the tree.  Next  lines describe the edges of the tree in form  (, , ). It is guaranteed that given graph is a tree.", "output": "In the first line print one integer number \u2014 maximal possible answer.  In the next  lines print the operations in order of their applying in format , where  \u2014 pair of the leaves that are chosen in the current operation (, ),  (,  or ) \u2014 choosen leaf that is removed from the tree in the current operation.  See the examples for better understanding.", "tutorial": "The solution is to choose some diameter of given tree, then delete all the leaves which don't belong to diameter (iteratively), and then delete the diameter. I.e. while tree includes vertices aside from the ones forming diameter we choose some leaf, increase answer by the length of the path between this leaf and farthest endpoint of the diameter (from this leaf) and delete this leaf. Then while tree consists of more than one vertex we choose two endpoints of diameter, increase answer by the length of the path between it and delete any of them.At first we need to prove that we can choose any diameter. It can be proved by next fact: we can find the diameter by two graph traversals (DFS/BFS) (we need to find farthest vertex and then again find farthest vertex from found farthest vertex, given path is a diameter of the tree). It means that for each vertex that doesn't belongs to the diameter we will add maximal possible path length by the algorithm described above.And finally obviously that at some moment we need to delete the diameter and there is no way to do this better than we do it in described solution.", "solution": "#include <bits/stdc++.h>\n#ifndef ONLINE_JUDGE\n# include <sys/time.h>\n# include <sys/resource.h>\n#endif\n\n/*** TEMPLATE CODE STARTS HERE ***/\n\n#ifndef M_PI\n#define M_PI 3.1415926535897932384626433832795028841971693993751\n#endif\n\nusing namespace std;\n\ntypedef vector<string> vs;\ntypedef long long ll;\ntypedef complex<double> pnt;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n#define RA(x) begin(x), end(x)\n#define FE(i, x) for (auto i = begin(x); i != end(x); ++i)\n#define SZ(x) ((ll) (x).size())\n\ntemplate<class T>\nvoid splitstr(const string &s, vector<T> &out)\n{\n    istringstream in(s);\n    out.clear();\n    copy(istream_iterator<T>(in), istream_iterator<T>(), back_inserter(out));\n}\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\n\nstatic void redirect(int argc, const char **argv)\n{\n#ifndef ONLINE_JUDGE\n    struct rlimit rlim;\n    getrlimit(RLIMIT_STACK, &rlim);\n    rlim.rlim_cur = 256 * 1024 * 1024;\n    setrlimit(RLIMIT_STACK, &rlim);\n#ifndef __SANITIZE_ADDRESS__\n    getrlimit(RLIMIT_DATA, &rlim);\n    rlim.rlim_cur = 256 * 1024 * 1024;\n    setrlimit(RLIMIT_DATA, &rlim);\n#endif\n#endif\n\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n    if (argc > 1)\n    {\n        static filebuf f;\n        f.open(argv[1], ios::in);\n        cin.rdbuf(&f);\n        if (!cin)\n        {\n            cerr << \"Failed to open '\" << argv[1] << \"'\" << endl;\n            exit(1);\n        }\n    }\n\n    if (argc > 2)\n    {\n        static filebuf f;\n        f.open(argv[2], ios::out | ios::trunc);\n        cout.rdbuf(&f);\n        if (!cout)\n        {\n            cerr << \"Failed to open '\" << argv[2] << \"'\" << endl;\n        }\n    }\n}\n\n/*** TEMPLATE CODE ENDS HERE */\n\nstatic int N;\nstatic vector<vi> edges;\nstatic vi parent;\nstatic vi depth;\nstatic vector<pii> dist;\nstatic vector<bool> diam;\nstatic int D, root, bot;\nstatic vector<pii> cuts;\n\nstatic void dfs(int cur, int p, int d)\n{\n    parent[cur] = p;\n    depth[cur] = d;\n    for (int v : edges[cur])\n        if (v != p)\n            dfs(v, cur, d + 1);\n}\n\nstatic pii get_dist(int cur)\n{\n    if (dist[cur].first == -1)\n    {\n        if (diam[cur])\n        {\n            if (depth[cur] > D - depth[cur])\n                dist[cur] = pii(depth[cur], root);\n            else\n                dist[cur] = pii(D - depth[cur], bot);\n        }\n        else\n        {\n            auto sub = get_dist(parent[cur]);\n            sub.first++;\n            cuts.emplace_back(sub.second, cur);\n            dist[cur] = sub;\n        }\n    }\n    return dist[cur];\n}\n\nint main(int argc, const char **argv)\n{\n    redirect(argc, argv);\n    cin >> N;\n    edges.resize(N);\n    parent.resize(N);\n    depth.resize(N);\n    diam.resize(N);\n    dist.resize(N, pii(-1, -1));\n    for (int i = 0; i < N - 1; i++)\n    {\n        int a, b;\n        cin >> a >> b;\n        a--;\n        b--;\n        edges[a].push_back(b);\n        edges[b].push_back(a);\n    }\n    dfs(0, -1, 0);\n    root = max_element(RA(depth)) - depth.begin();\n    dfs(root, -1, 0);\n    bot = max_element(RA(depth)) - depth.begin();\n    D = depth[bot];\n    for (int i = bot; i != -1; i = parent[i])\n        diam[i] = true;\n    ll score = ll(D) * ll(D + 1) / 2;\n    for (int i = 0; i < N; i++)\n        if (!diam[i])\n        {\n            auto sub = get_dist(i);\n            score += sub.first;\n        }\n    reverse(RA(cuts));\n    for (int i = bot; i != root; i = parent[i])\n        cuts.emplace_back(root, i);\n    cout << score << '\\n';\n    for (const auto &c : cuts)\n        cout << c.first + 1 << ' ' << c.second + 1 << ' ' << c.second + 1 << '\\n';\n\n    return 0;\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}