{"link": "https://codeforces.com//contest/1721/problem/D", "problemId": "1521727", "shortId": "1721D", "contest_number": "1721", "name": "D. Maximum AND", "statement": "You are given two arrays  and , consisting of  integers each.Let's define a function  as follows:   let's define an array  of size , where  ( denotes bitwise XOR);  the value of the function is  (i.e. bitwise AND of the entire array ). Find the maximum value of the function  if you can reorder the array  in an arbitrary way (leaving the initial order is also an option).", "input": "The first line contains one integer  ()\u00a0\u2014 the number of test cases. The first line of each test case contains one integer  ()\u00a0\u2014 the size of arrays  and . The second line contains  integers  (). The third line contains  integers  (). The sum of  over all test cases does not exceed .", "output": "For each test case print one integer\u00a0\u2014 the maximum value of the function  if you can reorder the array  in an arbitrary way.", "tutorial": "We will build the answer greedily, from the highest significant bit to the lowest one. Let's analyze how to check if the answer can have the highest bit equal to . It means that every value in  should have its highest bit equal to , so for every , exactly one of the numbers  should have this bit equal to . For both of the given arrays, we can calculate how many elements have which value of this bit, and then the number of elements with  in this bit in the array  should be equal to the number of elements with  in the array  (and the same for elements with  in  and elements with  in ). If these values are equal, it means that the elements of  and  can be matched in such a way that in every pair, the XOR of them has  in this bit. If it is so, then the highest bit of the answer is , otherwise it is .Okay, then let's proceed to the next bit. Should we just do the same to check if this bit can be equal to  in the answer? Unfortunately, that's not enough. Let's look at the case: , . We can get the value  in the -th bit or in the -st bit, but not in both . So, for the next bit, we need to make sure that not only we can get  in the result, but we can also do this without transforming some of the -s to -s in the higher bits. If it is impossible, it doesn't matter if we can get  in the current bit since it will be suboptimal, so we have to use an ordering that gets  in this bit.In general case, it means that we have to solve the following subproblem: check if we can obtain  in several bits of the answer; let these bits be  ( to  are the bits that we have already checked;  is the new bit we are trying to check). Let  be the number that has  in every bit  and  in every other bit. The elements should be matched in such a way that . If we group all numbers from  and from  according to the value of  (or ), then for every group of elements from , there is a corresponding group in  such that we can match the elements from the first group  with the elements from the second group. So, if for every such group, its size in  is equal to the size of the corresponding group in , then we can set all bits from  to  simultaneously.Some implementation notes: if the number of bits we need to check is big, the number of groups can become too large to handle all of them (since it is ). So, to store the number of elements in each group, we should use some associative data structure, like, for example,  in C++. If you use a map, splitting elements into groups will be done in , so in total, you will get complexity of , where  is the maximum possible value in the input.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    vector<int> a(n), b(n);\n    for (int& x : a) cin >> x;\n    for (int& x : b) cin >> x;\n    \n    auto check = [&](int ans) {\n      map<int, int> cnt;\n      for (int x : a) ++cnt[x & ans];\n      for (int x : b) --cnt[~x & ans];\n      bool ok = true;\n      for (auto it : cnt) ok &= it.second == 0;\n      return ok;\n    };\n    \n    int ans = 0;\n    for (int bit = 29; bit >= 0; --bit) \n      if (check(ans | (1 << bit)))\n        ans |= 1 << bit;\n    \n    cout << ans << '\\n';\n  }\n}", "interactive": false, "noSolution": false, "noTutorial": false}