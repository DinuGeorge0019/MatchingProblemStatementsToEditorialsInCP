{"link": "https://codeforces.com//contest/1473/problem/G", "problemId": "864975", "shortId": "1473G", "contest_number": "1473", "name": "G. Tiles", "statement": "Consider a road consisting of several rows. Each row is divided into several rectangular tiles, and all tiles in the same row are equal. The first row contains exactly one rectangular tile. Look at the picture below which shows how the tiles are arranged.The road is constructed as follows:   the first row consists of  tile;  then  rows follow; each of these rows contains  tile greater than the previous row;  then  rows follow; each of these rows contains  tile less than the previous row;  then  rows follow; each of these rows contains  tile greater than the previous row;  then  rows follow; each of these rows contains  tile less than the previous row;  ...  then  rows follow; each of these rows contains  tile greater than the previous row;  then  rows follow; each of these rows contains  tile less than the previous row.   An example of the road with , , , , . Rows are arranged from left to right. You start from the only tile in the first row and want to reach the last row (any tile of it). From your current tile, you can move to any tile in the next row which touches your current tile.Calculate the number of different paths from the first row to the last row. Since it can be large, print it modulo .", "input": "The first line contains one integer  (). Then  lines follow. The -th of them contains two integers  and  (; ). Additional constraint on the input: the sequence of  and  never results in a row with non-positive number of tiles.", "output": "Print one integer \u2014 the number of paths from the first row to the last row, taken modulo .", "tutorial": "The group of the rows where the number of rectangular tiles increases  times and then decreases  times can be represented as a rectangular table, with  diagonals, where the size of the first diagonal is equal to the number of rectangular tiles before the operations are applied (let their number be ), and the size of the last diagonal is . In such a rectangular table, one can move from the cell  to the cells  and  (if they exist), which lie on the next diagonal (next row in terms of the original problem). It's a well-known fact that the number of different paths from one cell to another is some binomial coefficient.Let's define  as the number of paths from the -st row to the -th tile in the ()-th row (i.e. row after the -th group of operations).Now we want to find the values of  using the values of  (let its size be ). Using the fact described in the first paragraphs we know that  depends on  with some binomial coefficient. In fact  for . But this solution is too slow. To speed up this solution we have to notice that the given formula is a convolution of  and some binomial coefficients. So we can use NTT to multiply them in  instead of  time.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define fore(i, l, r) for (int i = int(l); i < int(r); ++i)\n#define sz(a) int((a).size())\n\ntemplate<const int &MOD>\nstruct _m_int {\n  int val;\n \n  _m_int(int64_t v = 0) {\n    if (v < 0) v = v % MOD + MOD;\n    if (v >= MOD) v %= MOD;\n    val = int(v);\n  }\n \n  _m_int(uint64_t v) {\n    if (v >= MOD) v %= MOD;\n    val = int(v);\n  }\n \n  _m_int(int v) : _m_int(int64_t(v)) {}\n  _m_int(unsigned v) : _m_int(uint64_t(v)) {}\n \n  static int inv_mod(int a, int m = MOD) {\n    int g = m, r = a, x = 0, y = 1;\n \n    while (r != 0) {\n      int q = g / r;\n      g %= r; swap(g, r);\n      x -= q * y; swap(x, y);\n    }\n \n    return x < 0 ? x + m : x;\n  }\n \n  explicit operator int() const { return val; }\n  explicit operator unsigned() const { return val; }\n  explicit operator int64_t() const { return val; }\n  explicit operator uint64_t() const { return val; }\n  explicit operator double() const { return val; }\n  explicit operator long double() const { return val; }\n \n  _m_int& operator+=(const _m_int &other) {\n    val -= MOD - other.val;\n    if (val < 0) val += MOD;\n    return *this;\n  }\n \n  _m_int& operator-=(const _m_int &other) {\n    val -= other.val;\n    if (val < 0) val += MOD;\n    return *this;\n  }\n \n  static unsigned fast_mod(uint64_t x, unsigned m = MOD) {\n#if !defined(_WIN32) || defined(_WIN64)\n    return unsigned(x % m);\n#endif\n    // Optimized mod for Codeforces 32-bit machines.\n    // x must be less than 2^32 * m for this to work, so that x / m fits in an unsigned 32-bit int.\n    unsigned x_high = unsigned(x >> 32), x_low = unsigned(x);\n    unsigned quot, rem;\n    asm(\"divl %4\\n\"\n      : \"=a\" (quot), \"=d\" (rem)\n      : \"d\" (x_high), \"a\" (x_low), \"r\" (m));\n    return rem;\n  }\n \n  _m_int& operator*=(const _m_int &other) {\n    val = fast_mod(uint64_t(val) * other.val);\n    return *this;\n  }\n \n  _m_int& operator/=(const _m_int &other) {\n    return *this *= other.inv();\n  }\n \n  friend _m_int operator+(const _m_int &a, const _m_int &b) { return _m_int(a) += b; }\n  friend _m_int operator-(const _m_int &a, const _m_int &b) { return _m_int(a) -= b; }\n  friend _m_int operator*(const _m_int &a, const _m_int &b) { return _m_int(a) *= b; }\n  friend _m_int operator/(const _m_int &a, const _m_int &b) { return _m_int(a) /= b; }\n \n  _m_int& operator++() {\n    val = val == MOD - 1 ? 0 : val + 1;\n    return *this;\n  }\n \n  _m_int& operator--() {\n    val = val == 0 ? MOD - 1 : val - 1;\n    return *this;\n  }\n \n  _m_int operator++(int) { _m_int before = *this; ++*this; return before; }\n  _m_int operator--(int) { _m_int before = *this; --*this; return before; }\n \n  _m_int operator-() const {\n    return val == 0 ? 0 : MOD - val;\n  }\n \n  friend bool operator==(const _m_int &a, const _m_int &b) { return a.val == b.val; }\n  friend bool operator!=(const _m_int &a, const _m_int &b) { return a.val != b.val; }\n  friend bool operator<(const _m_int &a, const _m_int &b) { return a.val < b.val; }\n  friend bool operator>(const _m_int &a, const _m_int &b) { return a.val > b.val; }\n  friend bool operator<=(const _m_int &a, const _m_int &b) { return a.val <= b.val; }\n  friend bool operator>=(const _m_int &a, const _m_int &b) { return a.val >= b.val; }\n \n  _m_int inv() const {\n    return inv_mod(val);\n  }\n \n  _m_int pow(int64_t p) const {\n    if (p < 0)\n      return inv().pow(-p);\n \n    _m_int a = *this, result = 1;\n \n    while (p > 0) {\n      if (p & 1)\n        result *= a;\n      a *= a;\n      p >>= 1;\n    }\n \n    return result;\n  }\n  \n  friend string to_string(_m_int<MOD> x) {\n    return to_string(x.val);\n  }\n \n  friend ostream& operator<<(ostream &os, const _m_int &m) {\n    return os << m.val;\n  }\n};\n\nextern const int MOD = 998244353;\nusing Mint = _m_int<MOD>;\n\nconst int g = 3;\nconst int LOGN = 15;\n\nvector<Mint> w[LOGN];\nvector<int> rv[LOGN];\n\nvoid prepare() {\n  Mint wb = Mint(g).pow((MOD - 1) / (1 << LOGN));\n  forn(st, LOGN - 1) {\n    w[st].assign(1 << st, 1);\n    Mint bw = wb.pow(1 << (LOGN - st - 1));\n    Mint cw = 1;\n    forn(k, 1 << st) {\n      w[st][k] = cw;\n      cw *= bw;\n    }\n  }\n  forn(st, LOGN) {\n    rv[st].assign(1 << st, 0);\n    if (st == 0) {\n      rv[st][0] = 0;\n      continue;\n    }\n    int h = (1 << (st - 1));\n    forn(k, 1 << st)\n      rv[st][k] = (rv[st - 1][k & (h - 1)] << 1) | (k >= h);\n  }\n}\n\nvoid ntt(vector<Mint> &a, bool inv) {\n  int n = sz(a);\n  int ln = __builtin_ctz(n);\n  forn(i, n) {\n    int ni = rv[ln][i];\n    if (i < ni) swap(a[i], a[ni]);\n  }\n  forn(st, ln) {\n    int len = 1 << st;\n    for (int k = 0; k < n; k += (len << 1)) {\n      fore(pos, k, k + len){\n        Mint l = a[pos];\n        Mint r = a[pos + len] * w[st][pos - k];\n        a[pos] = l + r;\n        a[pos + len] = l - r;\n      }\n    }\n  }\n  if (inv) {\n    Mint rn = Mint(n).inv();\n    forn(i, n) a[i] *= rn;\n    reverse(a.begin() + 1, a.end());\n  }\n}\n\nvector<Mint> mul(vector<Mint> a, vector<Mint> b) {\n  int cnt = 1 << (32 - __builtin_clz(sz(a) + sz(b) - 1));\n  a.resize(cnt);\n  b.resize(cnt);\n  ntt(a, false);\n  ntt(b, false);\n  vector<Mint> c(cnt);\n  forn(i, cnt) c[i] = a[i] * b[i];\n  ntt(c, true);\n  return c;\n}\n\nint main() {\n  prepare();\n  \n  vector<Mint> fact(1, 1), ifact(1, 1);\n  auto C = [&](int n, int k) -> Mint {\n    if (k < 0 || k > n) return 0;\n    while (sz(fact) <= n) {\n      fact.push_back(fact.back() * sz(fact));\n      ifact.push_back(fact.back().inv());\n    }\n    return fact[n] * ifact[k] * ifact[n - k];\n  };\n  \n  int n;\n  cin >> n;\n  vector<int> a(n), b(n);\n  forn(i, n) cin >> a[i] >> b[i];\n  \n  vector<Mint> ans(1, 1);\n  forn(i, n) {\n    vector<Mint> Cs;\n    for (int j = b[i] - sz(ans) + 1; j < sz(ans) + a[i]; ++j)\n      Cs.push_back(C(a[i] + b[i], j));\n    auto res = mul(ans, Cs);\n    int cnt = sz(ans);\n    ans.resize(cnt + a[i] - b[i]);\n    forn(j, sz(ans)) ans[j] = res[cnt + j - 1];\n  }\n  \n  cout << accumulate(ans.begin(), ans.end(), Mint(0)) << endl;\n}", "interactive": false, "noSolution": false, "noTutorial": false}