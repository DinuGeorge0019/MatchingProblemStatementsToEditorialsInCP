{"link": "https://codeforces.com//contest/1398/problem/B", "problemId": "699502", "shortId": "1398B", "contest_number": "1398", "name": "B. Substring Removal Game", "statement": "Alice and Bob play a game. They have a binary string  (a string such that each character in it is either  or ). Alice moves first, then Bob, then Alice again, and so on.During their move, the player can choose any number (not less than one) of  in  and delete them.For example, if the string is , there are  possible moves (deleted characters are bold):  ;  ;  ;  ;  ;  . After the characters are removed, the characters to the left and to the right of the removed block become adjacent. I.\u2009e. the following sequence of moves is valid: .The game ends when the string becomes empty, and the score of each player is .Each player wants to maximize their score. Calculate the resulting score of Alice.", "input": "The first line contains one integer  () \u2014 the number of test cases. Each test case contains exactly one line containing a binary string  ().", "output": "For each test case, print one integer \u2014 the resulting score of Alice (the number of -characters deleted by her).", "tutorial": "The following greedy strategy works: during each turn, delete the largest possible substring consisting of -characters. So we have to find all blocks of -characters, sort them according to their length and model which blocks are taken by Alice, and which \u2014 by Bob.Why does the greedy strategy work? It's never optimal to delete some part of the block of ones \u2014 because we either have to spend an additional turn to delete the remaining part, or allow our opponent to take it (which is never good). Why don't we need to delete zeroes? If we delete a whole block of zeroes, our opponent can take the newly formed block of 's during their turn, and it is obviously worse than taking a part of that block. And deleting some part of a block of zeroes doesn't do anything \u2014 our opponent will never delete the remaining part because it's suboptimal.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define sz(a) int((a).size())\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n\nvoid solve() {\n\tstring s;\n\tcin >> s;\n\tvector<int> a;\n\tforn(i, sz(s)) if (s[i] == '1') {\n\t\tint j = i;\n\t\twhile (j + 1 < sz(s) && s[j + 1] == '1')\n\t\t\t++j;\n\t\ta.push_back(j - i + 1);\n\t\ti = j;\n\t}\n\tsort(a.rbegin(), a.rend());\n\tint ans = 0;\n\tfor (int i = 0; i < sz(a); i += 2)\n\t\tans += a[i];\n\tcout << ans << endl;\n}\n\nint main() {\n\tint T;\n\tcin >> T;\n\twhile (T--) solve();\n}", "interactive": false, "noSolution": false, "noTutorial": false}