{"link": "https://codeforces.com//contest/818/problem/C", "problemId": "112247", "shortId": "818C", "contest_number": "818", "name": "C. Sofa Thief", "statement": "Yet another round on DecoForces is coming! Grandpa Maks wanted to participate in it but someone has stolen his precious sofa! And how can one perform well with such a major loss?Fortunately, the thief had left a note for Grandpa Maks. This note got Maks to the sofa storehouse. Still he had no idea which sofa belongs to him as they all looked the same!The storehouse is represented as matrix . Every sofa takes two neighbouring by some side cells. No cell is covered by more than one sofa. There can be empty cells.Sofa  is standing to the left of sofa  if there exist two such cells  and  that ,  is covered by  and  is covered by . Sofa  is standing to the top of sofa  if there exist two such cells  and  that ,  is covered by  and  is covered by . Right and bottom conditions are declared the same way.  Also some sofa  can be both to the top of another sofa  and to the bottom of it. The same is for left and right conditions.The note also stated that there are  sofas to the left of Grandpa Maks's sofa,  \u2014 to the right,  \u2014 to the top and  \u2014 to the bottom.Grandpa Maks asks you to help him to identify his sofa. It is guaranteed that there is no more than one sofa of given conditions.Output the number of Grandpa Maks's sofa. If there is no such sofa that all the conditions are met for it then output .", "input": "The first line contains one integer number  () \u2014 the number of sofas in the storehouse. The second line contains two integer numbers ,  () \u2014 the size of the storehouse. Next  lines contains four integer numbers , , ,  (, ) \u2014 coordinates of the -th sofa. It is guaranteed that cells () and () have common side, ()  () and no cell is covered by more than one sofa. The last line contains four integer numbers , , ,  ().", "output": "Print the number of the sofa for which all the conditions are met. Sofas are numbered  through  as given in input. If there is no such sofa then print .", "tutorial": "Coordinates don't exceed  so it's possible to use sweep line method to solve the problem.Let's calculate  value separately for each side. I will show the algorithm for left side and all the others will be done similarly.Let  be the number of sofas which has smaller of their  coordinates less than or equal to . To count that let's firstly increment by one  for all sofas and then proceed from left to right and do .Now  will represent number of sofas to the left of the current one but the sofa itself can also be counted. You need to decrement the result by one if .The same is for top value but with  coordinates insted of .For the right and bottom values you should calculate  and . Then take  and .The only thing left is to compare values of each sofa with given ones and find the suitable sofa.Overall complexity: .", "solution": "#include <bits/stdc++.h>\nusing namespace std;\n#define N 101010\n#define x1 fjkljklx1\n#define y1 fjkljkly1\n#define x2 fjkljklx2\n#define y2 fjkljkly2\nint d , n , m;\nint x1[ N ] , x2[ N ] , y1[ N ] , y2[ N ];\nint cntl , cntr , cntt , cntb;\nvoid init(){\n  cin >> d >> n >> m;\n  for( int i = 0 ; i < d ; i ++ )\n    cin >> x1[ i ] >> y1[ i ] >> x2[ i ] >> y2[ i ];\n  cin >> cntl;\n  cin >> cntr;\n  cin >> cntt;\n  cin >> cntb;\n}\nint cl[ N ] , cr[ N ] , ct[ N ] , cb[ N ];\nvoid solve(){\n  {\n    vector< pair<int,int> > v;\n    for( int i = 0 ; i < d ; i ++ ){\n      v.push_back( { x1[ i ] , i } );\n      v.push_back( { x2[ i ] , i } );\n    }\n    {\n      sort( v.begin() , v.end() );\n      // left xa < xb\n      set<int> S;\n      for( size_t l = 0 , r = 0 ; l < v.size() ; l = r ){\n        while( r < v.size() and v[ l ].first == v[ r ].first ) r ++;\n        for( size_t i = l ; i < r ; i ++ ){\n          cl[ v[ i ].second ] = S.size();\n          if( S.count( v[ i ].second ) )\n            cl[ v[ i ].second ] --;\n        }\n        for( size_t i = l ; i < r ; i ++ )\n          S.insert( v[ i ].second );\n      }\n    }\n    {\n      reverse( v.begin() , v.end() );\n      // right xa > xb\n      set<int> S;\n      for( size_t l = 0 , r = 0 ; l < v.size() ; l = r ){\n        while( r < v.size() and v[ l ].first == v[ r ].first ) r ++;\n        for( size_t i = l ; i < r ; i ++ ){\n          cr[ v[ i ].second ] = S.size();\n          if( S.count( v[ i ].second ) )\n            cr[ v[ i ].second ] --;\n        }\n        for( size_t i = l ; i < r ; i ++ )\n          S.insert( v[ i ].second );\n      }\n    }\n  }\n  {\n    vector< pair<int,int> > v;\n    for( int i = 0 ; i < d ; i ++ ){\n      v.push_back( { y1[ i ] , i } );\n      v.push_back( { y2[ i ] , i } );\n    }\n    {\n      sort( v.begin() , v.end() );\n      // top ya < yb\n      set<int> S;\n      for( size_t l = 0 , r = 0 ; l < v.size() ; l = r ){\n        while( r < v.size() and v[ l ].first == v[ r ].first ) r ++;\n        for( size_t i = l ; i < r ; i ++ ){\n          ct[ v[ i ].second ] = S.size();\n          if( S.count( v[ i ].second ) )\n            ct[ v[ i ].second ] --;\n        }\n        for( size_t i = l ; i < r ; i ++ )\n          S.insert( v[ i ].second );\n      }\n    }\n    {\n      reverse( v.begin() , v.end() );\n      // right xa > xb\n      set<int> S;\n      for( size_t l = 0 , r = 0 ; l < v.size() ; l = r ){\n        while( r < v.size() and v[ l ].first == v[ r ].first ) r ++;\n        for( size_t i = l ; i < r ; i ++ ){\n          cb[ v[ i ].second ] = S.size();\n          if( S.count( v[ i ].second ) )\n            cb[ v[ i ].second ] --;\n        }\n        for( size_t i = l ; i < r ; i ++ )\n          S.insert( v[ i ].second );\n      }\n    }\n  }\n  for( int i = 0 ; i < d ; i ++ )\n    if( cl[ i ] == cntl and\n        cr[ i ] == cntr and\n        ct[ i ] == cntt and\n        cb[ i ] == cntb ){\n      cout << i + 1 << endl;\n      return;\n    }\n  cout << -1 << endl;\n}\nint main(){\n  init();\n  solve();\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}