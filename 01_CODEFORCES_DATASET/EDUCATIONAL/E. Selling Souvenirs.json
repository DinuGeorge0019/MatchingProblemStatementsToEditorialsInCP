{"link": "https://codeforces.com//contest/808/problem/E", "problemId": "106401", "shortId": "808E", "contest_number": "808", "name": "E. Selling Souvenirs", "statement": "After several latest reforms many tourists are planning to visit Berland, and Berland people understood that it's an opportunity to earn money and changed their jobs to attract tourists. Petya, for example, left the IT corporation he had been working for and started to sell souvenirs at the market.This morning, as usual, Petya will come to the market. Petya has  different souvenirs to sell; th souvenir is characterised by its weight  and cost . Petya knows that he might not be able to carry all the souvenirs to the market. So Petya wants to choose a subset of souvenirs such that its total weight is not greater than , and total cost is maximum possible.Help Petya to determine maximum possible total cost.", "input": "The first line contains two integers  and  (, ) \u2014 the number of Petya's souvenirs and total weight that he can carry to the market. Then  lines follow. th line contains two integers  and  (, ) \u2014 the weight and the cost of th souvenir.", "output": "Print one number \u2014 maximum possible total cost of souvenirs that Petya can carry to the market.", "tutorial": "There are lots of different solutions for this problem.We can iterate on the number of -elements we will take (in this editorial -element is a souvenir with weight ). When fixing the number of -elements (let it be ), we want to know the best possible answer for the weight , while taking into account only -elements and -elements.To answer these queries, we can precalculate the values  \u2014 triples , where  is the best possible answer for the weight , and  and  is the number of -elements and -elements we are taking to get this answer. Of course, , and we can update  and  using value of . After precalculating  for each possible  we can iterate on the number of -elements.There are also several binary/ternary search solutions.", "solution": "import java.io.*;\nimport java.util.*;\n\npublic class ER21qE\n{\n\n  public static void main(String[] args) {\n    InputReader in = new InputReader(System.in);\n    PrintWriter w = new PrintWriter(System.out);\n\n    int n = in.nextInt();\n    int m = in.nextInt();\n    \n    @SuppressWarnings(\"unchecked\")\n\tArrayList<Integer> c[] = new ArrayList[4];\n    for (int i = 1; i <= 3; i++)\n    \tc[i] = new ArrayList<Integer>();\n    \n    for (int i = 0; i < n; i++)\n    \tc[in.nextInt()].add(in.nextInt());\n    \n    for (int i = 1; i <= 3; i++) {\n    \twhile (c[i].size() < m + 3)\n    \t\tc[i].add(0);\n    }\n    \n    for (int i = 1; i <= 3; i++)\n    \tCollections.sort(c[i], Collections.reverseOrder());\n    \n    long dp[] = new long[m + 1];\n    int _2 = 0, _1 = 0;\n    \n    for (int i = 2; i <= m; i += 2) {\n    \tif (c[2].get(_2) >= c[1].get(_1) + c[1].get(_1 + 1)) {\n    \t\tdp[i] = dp[i - 2] + c[2].get(_2);\n    \t\t_2++;\n    \t} else {\n    \t\tdp[i] = dp[i - 2] + c[1].get(_1) + c[1].get(_1 + 1);\n    \t\t_1 += 2;\n    \t}\n    }\n    \n    dp[1] = c[1].get(0);\n    _2 = 0;\n    _1 = 1;\n    \n    for (int i = 3; i <= m; i += 2) {\n    \tif (c[2].get(_2) >= c[1].get(_1) + c[1].get(_1 + 1)) {\n    \t\tdp[i] = dp[i - 2] + c[2].get(_2);\n    \t\t_2++;\n    \t} else {\n    \t\tdp[i] = dp[i - 2] + c[1].get(_1) + c[1].get(_1 + 1);\n    \t\t_1 += 2;\n    \t}\n    }\n    \n    long tot = 0, ans = 0;\n    for (int i = 0; i <= c[3].size() && 3*i <= m; i++) {\n    \tans = Math.max(ans, tot + dp[m - 3 * i]);\n    \tif (i < c[3].size())\n    \t\ttot += c[3].get(i);\n    }\n    \n    w.println(ans);\n    w.close();\n  }\n\n  static class InputReader {\n\n    private final InputStream stream;\n    private final byte[] buf = new byte[8192];\n    private int curChar, snumChars;\n\n    public InputReader(InputStream st) {\n      this.stream = st;\n    }\n\n    public int read() {\n      if (snumChars == -1)\n        throw new InputMismatchException();\n      if (curChar >= snumChars) {\n        curChar = 0;\n        try {\n          snumChars = stream.read(buf);\n        } catch (IOException e) {\n          throw new InputMismatchException();\n        }\n        if (snumChars <= 0)\n          return -1;\n      }\n      return buf[curChar++];\n    }\n\n    public int nextInt() {\n      int c = read();\n      while (isSpaceChar(c)) {\n        c = read();\n      }\n      int sgn = 1;\n      if (c == '-') {\n        sgn = -1;\n        c = read();\n      }\n      int res = 0;\n      do {\n        res *= 10;\n        res += c - '0';\n        c = read();\n      } while (!isSpaceChar(c));\n      return res * sgn;\n    }\n\n    public long nextLong() {\n      int c = read();\n      while (isSpaceChar(c)) {\n        c = read();\n      }\n      int sgn = 1;\n      if (c == '-') {\n        sgn = -1;\n        c = read();\n      }\n      long res = 0;\n      do {\n        res *= 10;\n        res += c - '0';\n        c = read();\n      } while (!isSpaceChar(c));\n      return res * sgn;\n    }\n\n    public int[] nextIntArray(int n) {\n      int a[] = new int[n];\n      for (int i = 0; i < n; i++) {\n        a[i] = nextInt();\n      }\n      return a;\n    }\n\n    public String readString() {\n      int c = read();\n      while (isSpaceChar(c)) {\n        c = read();\n      }\n      StringBuilder res = new StringBuilder();\n      do {\n        res.appendCodePoint(c);\n        c = read();\n      } while (!isSpaceChar(c));\n      return res.toString();\n    }\n\n    public String nextLine() {\n      int c = read();\n      while (isSpaceChar(c))\n        c = read();\n      StringBuilder res = new StringBuilder();\n      do {\n        res.appendCodePoint(c);\n        c = read();\n      } while (!isEndOfLine(c));\n      return res.toString();\n    }\n\n    public boolean isSpaceChar(int c) {\n      return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n\n    private boolean isEndOfLine(int c) {\n      return c == '\\n' || c == '\\r' || c == -1;\n    }\n\n  }\n\n}", "interactive": false, "noSolution": false, "noTutorial": false}