{"link": "https://codeforces.com//contest/1739/problem/E", "problemId": "1559867", "shortId": "1739E", "contest_number": "1739", "name": "E. Cleaning Robot", "statement": "Consider a hallway, which can be represented as the matrix with  rows and  columns. Let's denote the cell on the intersection of the -th row and the -th column as . The distance between the cells  and  is .There is a cleaning robot in the cell . Some cells of the hallway are clean, other cells are dirty (the cell with the robot is clean). You want to clean the hallway, so you are going to launch the robot to do this.After the robot is launched, it works as follows. While at least one cell is dirty, the robot chooses  among those which are dirty, moves there and cleans it (so the cell is no longer dirty). After cleaning a cell, the robot again finds the closest dirty cell , and so on. This process repeats until the whole hallway is clean.However, there is a critical bug in the robot's program. If at some moment, there are multiple closest (to the robot's current position) dirty cells, the robot malfunctions.You want to clean the hallway in such a way that the robot doesn't malfunction. , you can clean some (possibly zero) of the dirty cells yourself. However, you don't want to do too much dirty work yourself while you have this nice, smart (yet buggy) robot to do this. Note that you cannot make a clean cell dirty.Calculate the maximum possible number of cells you can leave dirty before launching the robot, so that it doesn't malfunction.", "input": "The first line contains one integer  ()\u00a0\u2014 the number of columns in the hallway. Then two lines follow, denoting the -st and the -nd row of the hallway. These lines contain  characters each, where  denotes a clean cell and  denotes a dirty cell. The starting cell of the robot  is clean.", "output": "Print one integer\u00a0\u2014 the maximum possible number of cells you can leave dirty before launching the robot, so that it doesn't malfunction.", "tutorial": "Why did the author choose the width of the hallway to be only ? Well, in that case you can show that the robot will never move to the left while cleaning. That is not true on width  already.When does the robot break? Let the robot currently be in the cell  (-indexed) and the next column with a dirty cell be  (possibly, ). The robot breaks only if both  and  are dirty.That helps us to do a dynamic programming solution. Since we can only care about  next columns, we would want to have some \u00a0\u2014 the largest number of dirty cells we can leave to the robot if we processed the first  columns of the hallway and are currently standing in the -th row of the -th column. Maybe with some additional states of the current or the next columns.We want the dp to maintain the invariant that everything to the left of the -th column is cleaned in such a way the robot can reach the cell . We can choose when to fix the -th column: either maintain it being correct prior to entering the state or handling it in the transition to the next one. I chose the former option. There probably exists a million different dps that work, I'll describe the one I did.Let  be the largest number of dirty cells that we can leave to the robot if:   we fixed which of the dirty cells in the first  columns, inclusive, are cleaned by hand;  the robot reaches the cell  from the left;   is true if the cell in the opposite row of the -th column is dirty. The transitions handle what to do with the dirty cells in the -st column and where the robot goes based on that.In particular, there are the following transitions:   if  is true, then we have to clean the cell , and the robot will move into \u00a0\u2014 otherwise the robot breaks from having two options;  if  is false, then let's say that the robot doesn't break immediately but moves into the next column in a unique way: it moves horizontally first, then possibly vertically;    we can leave the next column as is, and the robot will move into  if the cell  is clean, or  if it's dirty;   if  is false, then we can clean the cell , and the robot will move into .  Since we maintained the invariant that the -th column is valid, we can update the answer from all four states in the last column.Overall complexity: .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define forn(i, n) for(int i = 0; i < int(n); i++) \n\nconst int INF = 1e9;\n\nint main(){\n\tint n;\n\tcin >> n;\n\tvector<string> s(2);\n\tforn(i, 2) cin >> s[i];\n\tvector<array<array<int, 2>, 2>> dp(n + 1);\n\tforn(i, n + 1) forn(j, 2) forn(k, 2) dp[i][j][k] = -INF;\n\tdp[0][0][s[1][0] == '1'] = s[1][0] == '1';\n\tdp[0][0][0] = 0;\n\tforn(i, n - 1) forn(j, 2){\n\t\tint nxtj = s[j][i + 1] == '1';\n\t\tint nxtj1 = s[j ^ 1][i + 1] == '1';\n\t\tdp[i + 1][j ^ 1][0] = max(dp[i + 1][j ^ 1][0], dp[i][j][1] + nxtj1);\n\t\tdp[i + 1][j][nxtj1] = max(dp[i + 1][j][nxtj1], dp[i][j][0] + nxtj1 + nxtj);\n\t\tdp[i + 1][j][0] = max(dp[i + 1][j][0], dp[i][j][0] + nxtj);\n\t}\n\tcout << max({dp[n - 1][0][0], dp[n - 1][0][1], dp[n - 1][1][0], dp[n - 1][1][1]}) << '\\n';\n}", "interactive": false, "noSolution": false, "noTutorial": false}