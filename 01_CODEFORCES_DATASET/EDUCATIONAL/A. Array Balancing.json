{"link": "https://codeforces.com//contest/1661/problem/A", "problemId": "1361827", "shortId": "1661A", "contest_number": "1661", "name": "A. Array Balancing", "statement": "You are given two arrays of length :  and .You can perform the following operation any number of times:   Choose integer index  ();  Swap  and . What is the minimum possible sum    (in other words, ) you can achieve after performing several (possibly, zero) operations?", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of test cases. Then,  test cases follow. The first line of each test case contains the single integer  ()\u00a0\u2014 the length of arrays  and . The second line of each test case contains  integers  ()\u00a0\u2014 the array . The third line of each test case contains  integers  ()\u00a0\u2014 the array .", "output": "For each test case, print one integer\u00a0\u2014 the minimum possible sum .", "tutorial": "Let's look at our arrays  and . Note that for any position  such that  we can always \"fix it\" by swapping  positions  from  to . In that case, contribution from all  won't change, contribution of pair  will decrease and contribution from all  won't change again, since we swapped all of them.It means that we already can use the following algorithm: while exists such  that  just swap all  from  to . This solution works for  per test, that should be enough.But we can optimize our approach by realizing that we can (instead of searching  each time) just go from  to  and fix pairs one by one: if  then swap  with ; next, if  then swap  with  and so on. In such way, solution works in .", "solution": "import kotlin.math.abs\n\nfun sum(a1: Int, a2: Int, b1: Int, b2: Int) = abs(a1 - a2) + abs(b1 - b2)\n\nfun main() {\n    repeat(readLine()!!.toInt()) {\n        val n = readLine()!!.toInt()\n        val a = readLine()!!.split(' ').map { it.toInt() }.toIntArray()\n        val b = readLine()!!.split(' ').map { it.toInt() }.toIntArray()\n\n        var sum = 0L\n        for (i in 1 until n) {\n            if (sum(a[i - 1], a[i], b[i - 1], b[i]) > sum(a[i - 1], b[i], b[i - 1], a[i]))\n                a[i] = b[i].also { b[i] = a[i] }\n            sum += sum(a[i - 1], a[i], b[i - 1], b[i])\n        }\n        println(sum)\n    }\n}", "interactive": false, "noSolution": false, "noTutorial": false}