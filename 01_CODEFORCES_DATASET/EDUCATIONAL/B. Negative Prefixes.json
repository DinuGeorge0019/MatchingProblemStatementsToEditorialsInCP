{"link": "https://codeforces.com//contest/1418/problem/B", "problemId": "727424", "shortId": "1418B", "contest_number": "1418", "name": "B. Negative Prefixes", "statement": "You are given an array , consisting of  integers.Each position  () of the array is either locked or unlocked. You can take the values on the unlocked positions, rearrange them in any order and place them back into the unlocked positions. You are not allowed to remove any values, add the new ones or rearrange the values on the locked positions. You are allowed to leave the values in the same order as they were.For example, let , the underlined positions are locked. You can obtain the following arrays:   ;  ;  ;  ;  and some others. Let  be a sequence of prefix sums of the array  after the rearrangement. So , , , , .Let  be the maximum  () such that . If there are no  such that , then .Your goal is to rearrange the values in such a way that  is minimum possible.Output the array  after the rearrangement such that the value  for it is minimum possible. If there are multiple answers then print any of them.", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of testcases. Then  testcases follow. The first line of each testcase contains a single integer  ()\u00a0\u2014 the number of elements in the array . The second line of each testcase contains  integers  ()\u00a0\u2014 the initial array . The third line of each testcase contains  integers  (), where  means that the position  is unlocked and  means that the position  is locked.", "output": "Print  integers\u00a0\u2014 the array  after the rearrangement. Value  (the maximum  such that  (or  if there are no such )) should be minimum possible. For each locked position the printed value should be equal to the initial one. The values on the unlocked positions should be an arrangement of the initial ones. If there are multiple answers then print any of them.", "tutorial": "Let's collect the prefix sums of the initial array . How do they change if you swap two values in the array? Let's swap values on positions  and  (). Prefix sums from  to  aren't changed. Prefix sums from  to  are increased by  (note that if  then these sums become smaller). Finally, prefix sums from  to  aren't changed as well.Thus, swapping two values  will only increase some prefix sums but never decrease any of them.That helps us see that the array such that all values on the unlocked positions are sorted in a non-increasing order is the most optimal one. Overall complexity:  per testcase.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define sz(a) int((a).size())\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n\nvoid solve() {\n    int n;\n    cin >> n;\n    vector<int> a(n), b(n), c;\n    forn(i, n) cin >> a[i];\n    forn(i, n) cin >> b[i];\n    forn(i, n) if (!b[i])\n        c.push_back(a[i]);\n    sort(c.rbegin(), c.rend());\n    int j = 0;\n    forn(i, n) {\n        if (b[i]) cout << a[i] << ' ';\n        else cout << c[j++] << ' ';\n    }\n    cout << '\\n';\n}\n\nint main() {\n    int T;\n    cin >> T;\n    while (T--) solve();\n}", "interactive": false, "noSolution": false, "noTutorial": false}