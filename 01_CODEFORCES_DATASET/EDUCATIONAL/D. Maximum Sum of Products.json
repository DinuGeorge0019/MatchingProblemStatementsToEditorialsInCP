{"link": "https://codeforces.com//contest/1519/problem/D", "problemId": "971589", "shortId": "1519D", "contest_number": "1519", "name": "D. Maximum Sum of Products", "statement": "You are given two integer arrays  and  of length .You can reverse  subarray (continuous subsegment) of the array . Your task is to reverse such a subarray that the sum  is .", "input": "The first line contains one integer  (). The second line contains  integers  (). The third line contains  integers  ().", "output": "Print single integer \u2014 maximum possible sum after reversing  subarray (continuous subsegment) of .", "tutorial": "The naive approach is to iterate over  and , reverse the subsegment of the array  and calculate the answer. But this solution is too slow and works in .Instead, we can iterate over the center of the reversed segment and its length. If the current segment is , and we want to go to , then the answer for the subsegment will increase by . It remains to add the answer for  and , but without reversion, this is easy to do if you pre-calculate the prefix sums of the values .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing li = long long;\n\nint main() {\n  int n;\n  cin >> n;\n  vector<li> a(n), b(n);\n  for (auto& x : a) cin >> x;\n  for (auto& x : b) cin >> x;\n  vector<li> pr(n + 1, 0);\n  for (int i = 0; i < n; ++i)\n    pr[i + 1] = pr[i] + a[i] * b[i];\n  li ans = pr[n];\n  for (int c = 0; c < n; ++c) {\n    li cur = a[c] * b[c];\n    for (int l = c - 1, r = c + 1; l >= 0 && r < n; --l, ++r) {\n      cur += a[l] * b[r];\n      cur += a[r] * b[l];\n      ans = max(ans, cur + pr[l] + (pr[n] - pr[r + 1]));\n    }\n    cur = 0;\n    for (int l = c, r = c + 1; l >= 0 && r < n; --l, ++r) {\n      cur += a[l] * b[r];\n      cur += a[r] * b[l];\n      ans = max(ans, cur + pr[l] + (pr[n] - pr[r + 1]));\n    }\n  }\n  cout << ans << endl;\n}", "interactive": false, "noSolution": false, "noTutorial": false}