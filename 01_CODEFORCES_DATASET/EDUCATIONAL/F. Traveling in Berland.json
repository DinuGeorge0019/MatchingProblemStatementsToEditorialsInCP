{"link": "https://codeforces.com//contest/1809/problem/F", "problemId": "1839366", "shortId": "1809F", "contest_number": "1809", "name": "F. Traveling in Berland", "statement": "There are  cities in Berland, arranged in a circle and numbered from  to  in clockwise order.You want to travel all over Berland, starting in some city, visiting all the other cities and returning to the starting city. Unfortunately, you can only drive along the Berland Ring Highway, which connects all  cities. The road was designed by a very titled and respectable minister, so it is one-directional\u00a0\u2014 it can only be traversed clockwise, only from the city  to the city  (i.e. from  to , from  in , ..., from  to ).The fuel tank of your car holds up to  liters of fuel. To drive from the -th city to the next one,  liters of fuel are needed (and are consumed in the process).Every city has a fuel station; a liter of fuel in the -th city costs  burles. Refueling between cities is not allowed; if fuel has run out between cities, then your journey is considered incomplete.For each city, calculate the minimum cost of the journey if you start and finish it in that city.", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of test cases. The first line of each test case contains two integers  and  (; )\u00a0\u2014 the number of cities and the volume of fuel tank, respectively. The second line contains  integers  (). The third line contains  integers  (). The sum of  over all test cases doesn't exceed .", "output": "For each test case, print  integers, where the -th of them is equal to the minimum cost of the journey if you start and finish in the -th city.", "tutorial": "The problem has a rather obvious naive solution in  for each starting city, but it's too slow. So we have to speed up this solution somehow. Binary lifting is one of the options, but here we have a problem that it is difficult to connect two consecutive groups of steps, because after the first group there is a certain amount of fuel left. Therefore, one of the solutions is to switch to such steps that  liters of fuel remains after it.Let's consider one of such \"greedy\" steps. Suppose we are in the city  with  fuel, then the following situations are possible:   , let's buy exactly  liters of fuel to reach the next city, then the step length is  and the cost is ;   and  (where  is the maximum number such that , , ..., , i.e. the number of consecutive cities with the cost ), let's buy exactly  liters of fuel to reach the next city, then the step length is  and the cost is ;   and , let's find a minimum  such that  and  (i.e. such  that you can reach it by spending all  of liters):   , let's buy exactly  liters with the cost  in the city , then the step length is  and the cost is ;  , let's buy  liters with the cost  in the city , and the remainder of  liters with the cost  in the city , then the step length is  and the cost is .  Now using these types of steps, we maintain an important invariant\u00a0\u2014 after each step, the amount of fuel is . So we can easily calculate the total distance and cost for several consecutive steps. Which leads us to a solution using binary lifting: for each city  calculate the length and cost of the path with  (for all  up to ) greedy steps. And then, using this data, we can calculate the answer for each starting city in .", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n\nvoid solve(){\n\tint n, k;\n\tscanf(\"%d%d\", &n, &k);\n\tvector<int> a(n);\n\tforn(i, n) scanf(\"%d\", &a[i]);\n\tvector<int> b(n);\n\tforn(i, n) scanf(\"%d\", &b[i]);\n\t\n\tvector<long long> pr(2 * n + 1);\n\tforn(i, 2 * n) pr[i + 1] = pr[i] + a[i % n];\n\t\n\tvector<long long> dist(n);\n\tvector<long long> cost(n);\n\tint cnt = 0;\n\tfor (int i = 2 * n - 1; i >= 0; --i){\n\t\tif (i < n){\n\t\t\tif (b[i] == 2){\n\t\t\t\tdist[i] = 1;\n\t\t\t\tcost[i] = a[i] * 2;\n\t\t\t}\n\t\t\telse if (cnt == 0){\n\t\t\t\tdist[i] = 1;\n\t\t\t\tcost[i] = a[i];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint j = lower_bound(pr.begin() + i, pr.begin() + i + cnt + 1, pr[i] + k) - pr.begin();\n\t\t\t\tassert(j > i);\n\t\t\t\tdist[i] = j - i;\n\t\t\t\tif (pr[j] - pr[i] <= k)\n\t\t\t\t\tcost[i] = pr[j] - pr[i];\n\t\t\t\telse\n\t\t\t\t\tcost[i] = 2 * (pr[j] - pr[i]) - k;\n\t\t\t}\n\t\t}\n\t\tif (b[i % n] == 2) ++cnt;\n\t\telse cnt = 0;\n\t}\n\t\n\tint pw = 0;\n\twhile ((1 << pw) <= n) ++pw;\n\t\n\tvector<vector<long long>> distk(pw, dist);\n\tvector<vector<long long>> costk(pw, cost);\n\tfor (int j = 1; j < pw; ++j) forn(i, n){\n\t\tdistk[j][i] = distk[j - 1][i] + distk[j - 1][(i + distk[j - 1][i]) % n];\n\t\tcostk[j][i] = costk[j - 1][i] + costk[j - 1][(i + distk[j - 1][i]) % n];\n\t}\n\t\n\tforn(i, n){\n\t\tint pos = i;\n\t\tlong long tot = 0;\n\t\tlong long ans = 0;\n\t\tfor (int j = pw - 1; j >= 0; --j) if (tot + distk[j][pos] <= n){\n\t\t\ttot += distk[j][pos];\n\t\t\tans += costk[j][pos];\n\t\t\tpos = (pos + distk[j][pos]) % n;\n\t\t}\n\t\tif (tot < n) ans += pr[i + n] - pr[i + tot];\n\t\tprintf(\"%lld \", ans);\n\t}\n\tputs(\"\");\n}\n\nint main(){\n\tint tc;\n\tscanf(\"%d\", &tc);\n\twhile (tc--) solve();\n}", "interactive": false, "noSolution": false, "noTutorial": false}