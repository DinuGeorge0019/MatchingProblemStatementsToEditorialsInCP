{"link": "https://codeforces.com//contest/1354/problem/F", "problemId": "623449", "shortId": "1354F", "contest_number": "1354", "name": "F. Summoning Minions", "statement": "Polycarp plays a computer game. In this game, the players summon armies of magical minions, which then fight each other.Polycarp can summon  different minions. The initial power level of the -th minion is , and when it is summoned, all previously summoned minions' power levels are increased by . The minions can be summoned in any order.Unfortunately, Polycarp cannot have more than  minions under his control. To get rid of unwanted minions after summoning them, he may destroy them. Each minion can be summoned (and destroyed) only once.Polycarp's goal is to summon the strongest possible army. Formally, he wants to maximize the sum of power levels of all minions under his control (those which are summoned and not destroyed).Help Polycarp to make up a plan of actions to summon the strongest possible army!", "input": "The first line contains one integer  () \u2014 the number of test cases. Each test case begins with a line containing two integers  and  () \u2014 the number of minions availible for summoning, and the maximum number of minions that can be controlled by Polycarp, respectively. Then  lines follow, the -th line contains  integers  and  (, ) \u2014 the parameters of the -th minion.", "output": "For each test case print the optimal sequence of actions as follows: Firstly, print  \u2014 the number of actions which Polycarp has to perform (). Then print  integers , , ..., , where  denotes the -th action as follows: if the -th action is to summon the minion , then , and if the -th action is to destroy the minion , then . Each minion can be summoned at most once and cannot be destroyed before being summoned (and, obviously, cannot be destroyed more than once). The number of minions in Polycarp's army should be not greater than  after every action. If there are multiple optimal sequences, print any of them.", "tutorial": "First of all, let's try to find the best strategy to play minions. All minions should be summoned (if someone is not summoned, summoning and deleting it won't make the answer worse), the resulting number of minions should be exactly  (if it is less, then we didn't need to delete the last deleted minion). Furthermore, if some minion should be deleted, we can delete it just after it is summoned. All these greedy ideas lead to the following structure of the answer:  we choose  minions and summon them in some order;  we choose  minions which will be summoned and instantly deleted;  we summon the remaining minion. Let's analyze how these minions affect the answer. The first minion has power  and does not give bonus to anyone, the second one has power  and gives bonus to one minion, and so on \u2014 the -th minion from the first group adds  to the answer. Minions from the second group buff  minions each, so they add  to the answer; and the last minion adds . Let's unite the first group and the last minion; then we will have two groups of minions \u2014 those which are destroyed (the second group) and those which are not destroyed (the first group).From there, we will have two possible ways to finish the solution:  there are  minions and  positions for them, and for each pair (minion, position) we may calculate the value this pair adds to the answer. After that, we should assign each monster a position in such a way that each position is chosen exactly once, and the sum of values is maximized. It can be done with mincost flows or Hungarian algorithm;  the minions from the first group should be played in non-descending order of their . Let's sort all minions by  and write the following dynamic programming:  is the maximum answer if we considered  first minions, and  of them were assigned to the first group. Since the minions are sorted by , whenever we add a minion to the first group, it should add exactly  to the answer (and increase  by ); and if a minion is added to the second group, the answer is increased by . ", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 243;\n\nstruct edge\n{\n    int y, c, f, cost;\n    edge() {};\n    edge(int y, int c, int f, int cost) : y(y), c(c), f(f), cost(cost) {};\n};\n\nint s, t, V;\nvector<int> g[N];\nvector<edge> e;\n\nvoid add(int x, int y, int c, int cost)\n{\n    g[x].push_back(e.size());\n    e.push_back(edge(y, c, 0, cost));\n    g[y].push_back(e.size());\n    e.push_back(edge(x, 0, 0, -cost));\n}\n\nint rem(int num)\n{\n    return e[num].c - e[num].f;\n}   \n\nint p[N];\nint d[N];\nint pe[N];\nint inq[N];\n\nbool enlarge()\n{\n    for(int i = 0; i < V; i++)\n    {\n        d[i] = int(1e9);\n        p[i] = -1;\n        pe[i] = -1;\n        inq[i] = 0;\n    }\n    d[s] = 0;\n    queue<int> q;\n    q.push(s);\n    inq[s] = 1;\n    while(!q.empty())\n    {\n        int k = q.front();\n        q.pop();\n        inq[k] = 0;\n        for(auto z : g[k])\n        {\n            if(!rem(z)) continue;\n            if(d[e[z].y] > d[k] + e[z].cost)\n            {\n                p[e[z].y] = k;\n                pe[e[z].y] = z;\n                d[e[z].y] = d[k] + e[z].cost;\n                if(!inq[e[z].y])\n                {\n                    q.push(e[z].y);\n                    inq[e[z].y] = 1;\n                }\n            }\n        }\n    }\n    if(p[t] == -1)\n        return false;\n    int cur = t;\n    while(cur != s)\n    {\n        e[pe[cur]].f++;\n        e[pe[cur] ^ 1].f--;\n        cur = p[cur];\n    }\n    return true;\n}\n\nvoid process_test()\n{\n\tint n, k;\n\tcin >> n >> k;\n\tvector<int> a(n), b(n);\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tcin >> a[i] >> b[i];\n\t}\n\ts = 2 * n;\n\tt = 2 * n + 1;\n\tV = 2 * n + 2;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tadd(s, i, 1, 0);\n\t\tadd(i + n, t, 1, 0);\n\t}\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = 0; j < n; j++)\n\t\t{\n\t\t\tif(j < k - 1)\n\t\t\t\tadd(i, j + n, 1, -(a[i] + b[i] * j));\n\t\t\telse if(j == n - 1)\n\t\t\t\tadd(i, j + n, 1, -(a[i] + b[i] * (k - 1)));\n\t\t\telse\n\t\t\t\tadd(i, j + n, 1, -(b[i] * (k - 1)));\n\t\t}\n\tfor(int i = 0; i < n; i++)\n\t\tenlarge();\n\tvector<int> order(n);\n\tfor(int i = 0; i < n; i++)\n\t\tfor(auto x : g[i])\n\t\t{\n\t\t\tint to = e[x].y;\n\t\t\tif(to >= n && to < 2 * n && e[x].f == 1)\n\t\t\t\torder[to - n] = i;\n\t\t}\n\tcout << k + (n - k) * 2 << endl;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tcout << order[i] + 1 << \" \";\n\t\tif(i >= k - 1 && i < n - 1)\n\t\t\tcout << -(order[i] + 1) << \" \";\n\t}\n\tcout << endl;\n\te.clear();\n\tfor(int i = 0; i < V; i++)\n\t\tg[i].clear();\n}\n\nint main()\n{                       \n    int t;\n\tcin >> t;\n\tfor(int i = 0; i < t; i++)\n\t\tprocess_test();\n}", "interactive": false, "noSolution": false, "noTutorial": false}