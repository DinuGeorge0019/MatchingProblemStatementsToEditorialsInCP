{"link": "https://codeforces.com//contest/846/problem/D", "problemId": "121000", "shortId": "846D", "contest_number": "846", "name": "D. Monitor", "statement": "Recently Luba bought a monitor. Monitor is a rectangular matrix of size . But then she started to notice that some pixels cease to work properly. Luba thinks that the monitor will become broken the first moment when it contains a square  consisting entirely of broken pixels. She knows that  pixels are already broken, and for each of them she knows the moment when it stopped working. Help Luba to determine when the monitor became broken (or tell that it's still not broken even after all  pixels stopped working).", "input": "The first line contains four integer numbers  \u2014 the length and width of the monitor, the size of a rectangle such that the monitor is broken if there is a broken rectangle with this size, and the number of broken pixels. Each of next  lines contain three integer numbers  \u2014 coordinates of -th broken pixel (its row and column in matrix) and the moment it stopped working. Each pixel is listed at most once. We consider that pixel is already broken at moment .", "output": "Print one number \u2014 the minimum moment the monitor became broken, or \"-1\" if it's still not broken after these  pixels stopped working.", "tutorial": "At first let's sort broken pixels in non-descending order by times they appear.Obviously, if the first  broken pixels make monitor broken,  pixel won't fix it.Thus, binary search on answer will work. Let's search for the first moment in time when the monitor becomes broken. The function to check if in some moment  monitor is broken looks the following way.As we want to check if there is a submatrix of size , which consists only of broken pixels, let's precalc the array of partial sums ,  is the number of broken pixels on submatrix from  to . is calculated as ( if  is broken pixel,  otherwise) . Sum on submatrix of size  then looks like .Check all possible  and  from  to  and find out if there exists submatrix with sum equal to .Overall complexity: .", "solution": "#include <bits/stdc++.h>\nusing namespace std;\n#define N 514\n#define Q (N * N)\nint n , m , k , q , x[ Q ] , y[ Q ] , t[ Q ];\nint s[ N ][ N ] , c[ N ][ N ];\nbool broken( int cur ){\n  for( int i = 0 ; i <= n ; i ++ )\n    for( int j = 0 ; j <= m ; j ++ )\n      c[ i ][ j ] = 0;\n  for( int i = 0 ; i < q ; i ++ )\n    if( t[ i ] <= cur )\n      c[ x[ i ] ][ y[ i ] ] = 1;\n  for( int i = 1 ; i <= n ; i ++ )\n    for( int j = 1 ; j <= m ; j ++ )\n      if( c[ i ][ j ] ){\n        s[ i ][ j ] = min( s[ i - 1 ][ j ] ,\n                           min( s[ i ][ j - 1 ] , s[ i - 1 ][ j - 1 ] ) ) + 1;\n        if( s[ i ][ j ] >= k )\n          return true;\n      }else\n        s[ i ][ j ] = 0;\n  return false;\n}\nint main(){\n  cin >> n >> m >> k >> q;\n  for( int i = 0 ; i < q ; i ++ )\n    cin >> x[ i ] >> y[ i ] >> t[ i ];\n  int bl = 0 , br = 1000000000 , ba = -1;\n  while( bl <= br ){\n    int bmid = (bl + br) >> 1;\n    if( broken( bmid ) ) ba = bmid , br = bmid - 1;\n    else bl = bmid + 1;\n  }\n  cout << ba << endl;\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}