{"link": "https://codeforces.com//contest/1288/problem/D", "problemId": "516090", "shortId": "1288D", "contest_number": "1288", "name": "D. Minimax Problem", "statement": "You are given  arrays , , ..., ; each array consists of exactly  integers. We denote the -th element of the -th array as .You have to choose two arrays  and  (, it is possible that ). After that, you will obtain a new array  consisting of  integers, such that for every  .Your goal is to choose  and  so that the value of  is maximum possible.", "input": "The first line contains two integers  and  (, ) \u2014 the number of arrays and the number of elements in each array, respectively. Then  lines follow, the -th line contains the array  represented by  integers , , ...,  ().", "output": "Print two integers  and  (, ) \u2014 the indices of the two arrays you have to choose so that the value of  is maximum possible. If there are multiple answers, print any of them.", "tutorial": "We will use binary search to solve the problem. Suppose we want to know if the answer is not less than .Each array can be represented by a -bit mask, where the -th bit is  if the -th element of the array is not less than , or  if the -th element is less than . If we want to verify that the answer is not less than , we have to choose two arrays such that bitwise OR of their masks is .Checking all pairs of arrays is too slow. Instead, we can treat the arrays represented by the same masks as equal \u2014 so we will have no more than  distinct arrays, and we can iterate over  pairs. Overall, the solution works in .", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint n, m;\nvector<vector<int> > a;\nint a1, a2;\n\nbool can(int mid)\n{\n    vector<int> msk(1 << m, -1);\n    for(int i = 0; i < n; i++)\n    {\n        int cur = 0;\n        for(int j = 0; j < m; j++)\n            if(a[i][j] >= mid)\n                cur ^= (1 << j);\n        msk[cur] = i;\n    }\n    if(msk[(1 << m) - 1] != -1)\n    {\n        a1 = a2 = msk[(1 << m) - 1];\n        return true;\n    }\n    for(int i = 0; i < (1 << m); i++)\n        for(int j = 0; j < (1 << m); j++)\n            if(msk[i] != -1 && msk[j] != -1 && (i | j) == (1 << m) - 1)\n            {\n                a1 = msk[i];\n                a2 = msk[j];\n                return true;\n            }\n    return false;\n}\n\nint main()\n{\n    scanf(\"%d %d\", &n, &m);\n    a.resize(n, vector<int>(m));\n    for(int i = 0; i < n; i++)\n        for(int j = 0; j < m; j++)\n            scanf(\"%d\", &a[i][j]);\n    int lf = 0;\n    int rg = int(1e9) + 43;\n    while(rg - lf > 1)\n    {\n        int m = (lf + rg) / 2;\n        if(can(m))\n            lf = m;\n        else\n            rg = m;            \n    }\n    assert(can(lf));\n    printf(\"%d %d\\n\", a1 + 1, a2 + 1);\n}", "interactive": false, "noSolution": false, "noTutorial": false}