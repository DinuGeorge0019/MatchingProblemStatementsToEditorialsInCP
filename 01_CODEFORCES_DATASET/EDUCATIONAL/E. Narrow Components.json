{"link": "https://codeforces.com//contest/1661/problem/E", "problemId": "1361831", "shortId": "1661E", "contest_number": "1661", "name": "E. Narrow Components", "statement": "You are given a matrix , consisting of  rows and  columns. Each cell of the matrix is either free or taken.A free cell  is reachable from a free cell  if at least one of these conditions hold:    and  share a side;  there exists a free cell  such that  is reachable from  and  is reachable from . A connected component is a set of free cells of the matrix such that all cells in it are reachable from one another, but adding any other free cell to the set violates this rule.You are asked  queries about the matrix. Each query is the following:    \u00a0\u2014 count the number of connected components of the matrix, consisting of columns from  to  of the matrix , inclusive. Print the answers to all queries.", "input": "The first line contains an integer  ()\u00a0\u2014 the number of columns of matrix . The -th of the next three lines contains a description of the -th row of the matrix \u00a0\u2014 a string, consisting of  characters. Each character is either  (denoting a free cell) or  (denoting a taken cell). The next line contains an integer  ()\u00a0\u2014 the number of queries. The -th of the next  lines contains two integers  and  ()\u00a0\u2014 the description of the -th query.", "output": "Print  integers\u00a0\u2014 the -th value should be equal to the number of the connected components of the matrix, consisting of columns from  to  of the matrix , inclusive.", "tutorial": "Consider the naive approach to the problem.Cut off the columns directly and count the connected components. There are two main solutions to this problem: either DFS (or BFS) or DSU. I personally found the DSU method easier to adjust to the full problem.So, to count connected components with DSU, you should do the following. Initialize the structure without edges: every free cell is its own connected component. Then add edges one by one. Each edge connects two cells either vertically or horizontally. When an edge connects different components, they merge, and the number of components decreases by one.Thus, the number of components on a range of columns is the number of free cells on it minus the number of meaningful edges on it (the ones that will merge components if the algorithm is performed only on these columns\u00a0\u2014 the spanning forest edges).Let's try to adjust this algorithm to the full problem. It would be great if we could just calculate the spanning forest of the entire matrix, and then print the number of free cells minus the number of its edges on the segment. Unfortunately, it's not as easy as that. For components that lie fully in the segment, it works. However, if a component is split by a border of a segment, it can both stay connected or fall apart. If we determine its outcome, we can fix the answer.There are probably a lot of ways to adjust for that, but I'll tell you the one I found the neatest to code. Let's add the edges into DSU in the following order. Go column by column left to right. First add all vertical edges in any order, then all horizontal edges to the previous column in any order.If you start this algorithm at the first column, you will be able to answer all queries with . Since the algorithm adds columns iteratively, the spanning forest it's building is correct after every column. So the answer for each query is indeed the number of cells minus the number of edges on the range.Let's investigate the difference between starting at the first column and an arbitrary column .Look at the column . If it contains  or  free cells or  that are adjacent, then the cells are always in the same component, regardless of what has been before column . If there are no free cells, nothing to the left matters, too. This tells us that the spanning forest that the first algorithm has built, is correct for any queries that start in this .The only non-trivial case is when only rows  and  of the -th column contain a free cell. Then we can't tell if the algorithm is correct or not, because these two cells can be in the same component already or not. Let's call this a \"\" column.Imagine you started processing from the leftmost column of the query, left to right to the rightmost column. Our previous observations tell us that once we encounter a column that is not a \"\", the algorithm onwards will be correct. Until then, we only have some \"\" columns to deal with.We can add the part from the first non-\"\" column onwards to the answer (the number of cells minus the number of edges). And then handle the prefix with some easy casework:  if the leftmost column is not \"\", then add nothing;  if all columns in the query are \"\", then the answer is ;  if the first non-\"\" column is \"\", then add nothing (since the \"\"s get merged into the component of this column);  if the first non-\"\" column is \"\" or \"\", then add  components (since neither row  nor row  is merged anywhere);  otherwise, add  component. The number of free cells and edges on a segment can be precalculated with some prefix sums. The closest non-\"\" column can also be precalculated with a linear algorithm.Overall complexity: .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define forn(i, n) for(int i = 0; i < int(n); i++) \n\nint main(){\n    cin.tie(0);\n\tiostream::sync_with_stdio(false);\n\tint n;\n\tcin >> n;\n\tvector<string> s(3);\n\tforn(i, 3) cin >> s[i];\n\tvector<int> pr(n + 1);\n\tforn(i, n){\n\t\tpr[i + 1] += pr[i];\n\t\tforn(j, 3) pr[i + 1] += (s[j][i] == '1');\n\t}\n\t\n\tvector<int> p(3 * n), rk(3 * n, 1);\n\tiota(p.begin(), p.end(), 0);\n\tfunction<int(int)> getp;\n\tgetp = [&](int a) -> int {\n\t\treturn a == p[a] ? a : p[a] = getp(p[a]);\n\t};\n\tauto unite = [&](int a, int b) -> bool {\n\t\ta = getp(a), b = getp(b);\n\t\tif (a == b) return false;\n\t\tif (rk[a] < rk[b]) swap(a, b);\n\t\tp[b] = a;\n\t\trk[a] += rk[b];\n\t\treturn true;\n\t};\n\t\n\tvector<int> prhe(n + 1), prve(n + 1);\n\t\n\tforn(j, n){\n\t\tforn(i, 2) if (s[i][j] == '1' && s[i + 1][j] == '1' && unite(i * n + j, (i + 1) * n + j))\n\t\t\t++prve[j + 1];\n\t\tforn(i, 3) if (j > 0 && s[i][j] == '1' && s[i][j - 1] == '1' && unite(i * n + j, i * n + (j - 1)))\n\t\t\t++prhe[j];\n\t}\n\tforn(i, n) prve[i + 1] += prve[i];\n\tforn(i, n) prhe[i + 1] += prhe[i];\n\t\n\tvector<int> nxt(n + 1, 0);\n\tfor (int i = n - 1; i >= 0; --i)\n\t\tnxt[i] = (s[0][i] == '1' && s[1][i] == '0' && s[2][i] == '1' ? (nxt[i + 1] + 1) : 0);\n\t\n\tint m;\n\tcin >> m;\n\tforn(_, m){\n\t\tint l, r;\n\t\tcin >> l >> r;\n\t\t--l, --r;\n\t\tint non101 = l + nxt[l];\n\t\tif (non101 > r){\n\t\t    cout << \"2\\n\";\n\t\t    continue;\n\t\t}\n\t\tint tot = pr[r + 1] - pr[non101];\n\t\tint in = (prve[r + 1] - prve[non101]) + (prhe[r] - prhe[non101]);\n\t\tint res = tot - in;\n\t\tif (non101 != l){\n\t\t\tif (s[0][non101] == '1' && s[1][non101] == '1' && s[2][non101] == '1');\n\t\t\telse if (s[0][non101] == '0' && s[2][non101] == '0') res += 2;\n\t\t\telse ++res;\n\t\t}\n\t\tcout << res << \"\\n\";\n\t}\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}