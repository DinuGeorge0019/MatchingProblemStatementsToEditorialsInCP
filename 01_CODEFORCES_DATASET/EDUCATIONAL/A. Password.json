{"link": "https://codeforces.com//contest/1743/problem/A", "problemId": "1590316", "shortId": "1743A", "contest_number": "1743", "name": "A. Password", "statement": "Monocarp has forgotten the password to his mobile phone. The password consists of  digits from  to  (note that it can start with the digit ).Monocarp remembers that his password had exactly two different digits, and each of these digits appeared exactly two times in the password. Monocarp also remembers some digits which were definitely not used in the password.You have to calculate the number of different sequences of  digits that could be the password for Monocarp's mobile phone (i.\u2009e. these sequences should meet all constraints on Monocarp's password).", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of testcases. The first line of each testcase contains a single integer  ()\u00a0\u2014 the number of digits for which Monocarp remembers that they were not used in the password. The second line contains  different integers  () representing the digits that were not used in the password. Note that the digits  are given in ascending order.", "output": "For each testcase, print one integer\u00a0\u2014 the number of different -digit sequences that meet the constraints.", "tutorial": "There are two possible solutions for the problem.The first solution is basically brute force. Each password can be obtained from an integer from  to . If the number is from  to , then it's already a password of length . Otherwise, you have to prepend it with enough zeros so that it becomes length .Then you have to check if the password is valid. First, check if it consists of exactly two different digits: make a set of all its characters (set<char> in case of C++, for example) and check its size. Then check if the first digit of the password appears exactly twice. It would mean that the other digits appears exactly twice as well. Finally, check if neither of the found digits are forbidden.The second solution is based on combinatorics. First, choose the two digits that will appear in the password: . Since  digits are prohibited, the remaining  are allowed. Second, choose the positions that will be taken by the first one: . The answer is the product of these two values.", "solution": "for _ in range(int(input())):\n\tn = int(input())\n\ta = set(map(int, input().split()))\n\tans = 0\n\tfor i in range(10000):\n\t\tnum = str(i)\n\t\tnum = (4 - len(num)) * '0' + num\n\t\tused = set(num)\n\t\tif len(used) != 2:\n\t\t\tcontinue\n\t\td1 = int(used.pop())\n\t\td2 = int(used.pop())\n\t\tif (not d1 in a) and (not d2 in a) and num.count(num[0]) == 2:\n\t\t\tans += 1\n\tprint(ans)", "interactive": false, "noSolution": false, "noTutorial": false}