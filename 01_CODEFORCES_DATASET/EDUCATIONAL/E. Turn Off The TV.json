{"link": "https://codeforces.com//contest/863/problem/E", "problemId": "123495", "shortId": "863E", "contest_number": "863", "name": "E. Turn Off The TV", "statement": "Luba needs your help again! Luba has  TV sets. She knows that -th TV set will be working from moment of time  till moment , inclusive.Luba wants to switch off one of TV sets in order to free the socket. Let's call some TV set  if after switching it off the number of  moments of time when at least one of TV sets is working won't decrease. Luba will be very upset if she has to switch off a non- TV set.Help Luba by telling her the index of some  TV set. If there is no any, print .", "input": "The first line contains one integer number  \u2014 the number of TV sets. Then  lines follow, each of them containing two integer numbers  denoting the working time of -th TV set.", "output": "If there is no any redundant TV set, print . Otherwise print the index of any redundant TV set (TV sets are indexed from 1 to ). If there are multiple answers, print any of them.", "tutorial": "Firstly let's compress the moments of time. Note that storing only  and  isn't enough (consider pairs () and ()), you also should take .Now moments of time are up to . For every moment calculate the number of segments to cover it (make  and  for each segment and take prefix sums over this array). Then let  be the number of moments of time covered by only one segment on some prefix up to -th moment. And finally if for some segment  from the input  is  then you can safely delete this segment.Overall complexity: .", "solution": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))\n#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))\nstatic const int INF = 0x3f3f3f3f; static const long long INFL = 0x3f3f3f3f3f3f3f3fLL;\ntypedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;\ntemplate<typename T, typename U> static void amin(T &x, U y) { if (y < x) x = y; }\ntemplate<typename T, typename U> static void amax(T &x, U y) { if (x < y) x = y; }\n\nint main() {\n\tint n;\n\twhile (~scanf(\"%d\", &n)) {\n\t\tvector<int> L(n);\n\t\tvector<int> R(n);\n\t\tfor (int i = 0; i < n; ++ i)\n\t\t\tscanf(\"%d%d\", &L[i], &R[i]), -- L[i];\n\t\tvector<int> values;\n\t\trep(i, n) {\n\t\t\tvalues.push_back(L[i]);\n\t\t\tvalues.push_back(R[i]);\n\t\t}\n\t\tsort(values.begin(), values.end());\n\t\tvalues.erase(unique(values.begin(), values.end()), values.end());\n\t\tint X = (int)values.size();\n\t\tvector<int> add(X + 1);\n\t\trep(i, n) {\n\t\t\tint l = (int)(lower_bound(values.begin(), values.end(), L[i]) - values.begin());\n\t\t\tint r = (int)(lower_bound(values.begin(), values.end(), R[i]) - values.begin());\n\t\t\t++ add[l], -- add[r];\n\t\t}\n\t\trep(i, X)\n\t\t\tadd[i + 1] += add[i];\n\t\tvector<int> sum(X + 1);\n\t\trep(i, X)\n\t\t\tsum[i + 1] = sum[i] + (add[i] >= 2);\n\t\tint ans = -1;\n\t\trep(i, n) {\n\t\t\tint l = (int)(lower_bound(values.begin(), values.end(), L[i]) - values.begin());\n\t\t\tint r = (int)(lower_bound(values.begin(), values.end(), R[i]) - values.begin());\n\t\t\tif (sum[r] - sum[l] == r - l) {\n\t\t\t\tans = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans == -1 ? ans : ans + 1);\n\t}\n\treturn 0;\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}