{"link": "https://codeforces.com//contest/1766/problem/D", "problemId": "1690149", "shortId": "1766D", "contest_number": "1766", "name": "D. Lucky Chains", "statement": "Let's name a pair of positive integers   if the greatest common divisor of them is equal to  ().Let's define a  induced by  as a sequence of pairs , , , ,  for some integer . The  of the chain is the number of pairs it consists of, or .Let's name such chain  if all pairs in the chain are lucky.You are given  pairs . Calculate for each pair the length of the longest lucky chain induced by this pair. Note that if  is not lucky itself, the chain will have the length . ", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of pairs. Next  lines contains  pairs\u00a0\u2014 one per line. The -th line contains two integers  and  ()\u00a0\u2014 the corresponding pair.", "output": "Print  integers, where the -th integer is the length of the longest lucky chain induced by  or  if the chain can be infinitely long.", "tutorial": "Suppose, . It means that  is also divisible by , or  is divisible by . And backward: if , then  is also divisible by , or  is divisible by . Since  is divisible by  and  is divisible by , so . In other words, we proved that .Now, knowing the equivalence above, we can understand that we are looking for the smallest  such that . In other words, we are searching  such that  is divisible by some , where  is some divisor of .The problem is that there are a handful of divisors for some . But we can note that we can consider only  divisors of : if  and  is composite then there is some prime , thus .It's easy to prove that there are no more than  prime divisors of some . Now the question is how to find all these prime divisors.Note that if you know only one prime divisor for each value from  to , then you can find all prime divisors for all  in . The prime divisors  are next:   , ;  , ;  , ;  and so on until . The final step is to calculate a prime divisor  for each value from  to , where  or . We can do it by slight modifications of Sieve of Eratosthenes: at the step, where you have some prime  and want to \"throw out\" all values , set  for each  (plus set ).As a result, we, firstly, calculate Sieve in  and, secondly, calculate answer for each pair  in .Note that the input and output is large, so you should you tricks to speed up your input and output.", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) int((a).size())\n\ntypedef long long li;\n\nconst int INF = int(1e9);\nconst int N = int(1e7) + 5;\n\nint mind[N];\n\nvoid precalc() {\n\tfore (i, 0, N)\n\t\tmind[i] = i;\n\t\n\tfor (int p = 2; p < N; p++) {\n\t\tif (mind[p] != p)\n\t\t\tcontinue;\n\t\tfor (int d = 2 * p; d < N; d += p)\n\t\t\tmind[d] = min(mind[d], p);\n\t}\n}\n\nint x, y;\n\ninline bool read() {\n\tif(!(cin >> x >> y))\n\t\treturn false;\n\treturn true;\n}\n\nvector<int> getPrimes(int v) {\n\tvector<int> ps;\n\twhile (v > 1) {\n\t\tif (ps.empty() || ps.back() != mind[v])\n\t\t\tps.push_back(mind[v]);\n\t\tv /= mind[v];\n\t}\n\treturn ps;\n}\n\ninline void solve() {\n\tint d = y - x;\n\tif (d == 1) {\n\t\tcout << -1 << '\\n';\n\t\treturn;\n\t}\n\t\n\tint r = INF;\n\tfor (int p : getPrimes(d))\n\t\tr = min(r, ((x + p - 1) / p) * p);\n\tcout << r - x << '\\n';\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint tt = clock();\n#endif\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0), cout.tie(0);\n\tcout << fixed << setprecision(15);\n\t\n\tprecalc();\n\t\n\tint t; cin >> t;\n\twhile (t--) {\n\t\tread();\n\t\tsolve();\n\t\t\n#ifdef _DEBUG\n\t\tcerr << \"TIME = \" << clock() - tt << endl;\n\t\ttt = clock();\n#endif\n\t}\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}