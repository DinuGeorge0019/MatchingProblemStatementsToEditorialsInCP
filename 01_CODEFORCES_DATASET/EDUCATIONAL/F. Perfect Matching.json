{"link": "https://codeforces.com//contest/1633/problem/F", "problemId": "1280038", "shortId": "1633F", "contest_number": "1633", "name": "F. Perfect Matching", "statement": "You are given a tree consisting of  vertices (numbered from  to ) and  edges (numbered from  to ). Initially, all vertices except vertex  are inactive.You have to process queries of three types:    \u2014 activate the vertex . It is guaranteed that the vertex  is inactive before this query, and one of its neighbors is active. After activating the vertex, you have to choose a subset of edges of the tree such that each  vertex is incident to  chosen edge, and each  vertex is not incident to any of the chosen edges \u2014 in other words, this subset should represent a perfect matching on the active part of the tree. If any such subset of edges exists, print the sum of indices of edges in it; otherwise, print .   \u2014 queries of this type will be asked only right after a query of type , and there will be  such queries. If your answer to the previous query was , simply print ; otherwise, print the subset of edges for the previous query as follows: first, print the number of edges in the subset, then print the indices of the chosen edges . The sum of indices should be equal to your answer to the previous query.   \u2014 terminate the program. Note that you should solve the problem in  mode. It means that you can't read the whole input at once. You can read each query only after writing the answer for the last query. Use functions  in  and  in  languages after each writing in your program.", "input": "The first line contains one integer  () \u2014 the number of vertices of the tree. Then  lines follow. The -th line contains two integers  and  (; ) \u2014 the endpoints of the -th edge. These edges form a tree. Then the queries follow in the format described in the statement, one line per query. There will be at least  and at most  queries. The last query (and only the last one) will be of type . Note that you can read the -th query only if you have already given the answer for the query  (except for ). If your answer for one of the queries is incorrect and the judging program recognizes it, instead of the next query, you may receive the integer  on a separate line. After receiving it, your program should terminate gracefully, and you will receive \"Wrong Answer\" verdict. If your program doesn't terminate, your solution may receive some other verdict, like \"Time Limit Exceeded\", \"Idleness Limit Exceeded\", etc. Note that the fact that your solution doesn't receive the integer , it , some of them will be checked only after your program is terminated.", "output": "For each query of type  or , print the answer on a separate line as described in the statement. Don't forget to flush the output.", "tutorial": "Let's root the tree at vertex  and try to analyze when a tree contains a perfect matching. If we want to find the maximum matching in a tree, we can use some greedy approaches like \"take a leaf of the tree, match it with its parent and remove both vertices, repeat this process until only isolated vertices remain\". If we are interested in a perfect matching, then this process should eliminate all of the vertices.Let's modify this process a bit by always picking the deepest leaf. If there exists a perfect matching, picking the deepest leaf will ensure that the tree always remains a tree and doesn't fall apart, i.\u2009e. there will always be one connected component. It means that when we remove the leaf with its parent, this leaf is the only descendant of its parent.It's easy to see that whenever we remove a pair of vertices in this process, for each remaining vertex, the number of its descendants is either left unchanged or decreased by . It means that if a vertex has an even number of descendants, it will have an even number of descendants until it is removed, and the same for odd number of descendants.Let's call the vertices with even number of descendants (including the vertex itself) , and all the other vertices \u2014 . A vertex cannot change its status in the process of building the perfect matching. Each leaf is and odd vertex, and if its parent has only one child, this parent is an even vertex. So, when we remove a pair of vertices, one of them (the child) is odd, and the other of them (the parent) is even.This leads us to another way of building the perfect matching: match each odd vertex with its parent, and make sure that everything is correct. Unfortunately, implementing it is  per query, so we need something faster. We can see that each even vertex has at least one odd child (because if all children of a vertex are even, then the number of its descendants, including the vertex itself is odd). In order to find a perfect matching, we have to make sure that:  each even vertex has  one odd child;  each odd vertex has an even vertex as its parent. All this means is that : it cannot be greater since each even vertex has at least one odd child, and if it is smaller, it's impossible to match the vertices. The perfect matching itself consists of edges that connect odd vertices with their parents.Okay, now we need some sort of data structure to maintain the status of each vertex (and the sum of edges that lead to an odd vertex if directed from top to bottom). In our problem, we have to add new leaves to the tree (it happens when a vertex is activated), and this increases the number of descendants for every vertex on the path from the root to this new leaf. So, we need some sort of data structure that supports the operations \"add a new leaf\" and \"flip the status of all vertices on a path\". One of the structures that allow this is the Link/Cut Tree, but we can use the fact that the whole tree is given in advance to build a Heavy-Light Decomposition on it, which is much easier to code. Operations on segments of paths can be done with a lazy segment tree, and each vertex then will be added in .", "solution": "#include <bits/stdc++.h>     \n\nusing namespace std;\n\ntypedef pair<long long, int> val;\n\n#define x first \n#define y second\n\nconst int N = 200043;\n\nval operator +(const val& a, const val& b)\n{\n    return make_pair(a.x + b.x, a.y + b.y);\n}\n\nval operator -(const val& a, const val& b)\n{\n    return make_pair(a.x - b.x, a.y - b.y);\n}\n\nval T[4 * N];\nval Tfull[4 * N];\nint f[4 * N];\n\nval getVal(int v)\n{\n    if(f[v] == 1)\n        return Tfull[v] - T[v];\n    return T[v];\n}\n\nvoid push(int v)\n{\n    if(f[v] == 1)\n    {\n        f[v] = 0;\n        T[v] = Tfull[v] - T[v];\n        f[v * 2 + 1] ^= 1;\n        f[v * 2 + 2] ^= 1;\n    }   \n}                \n\nvoid upd(int v)\n{\n    Tfull[v] = Tfull[v * 2 + 1] + Tfull[v * 2 + 2];\n    T[v] = getVal(v * 2 + 1) + getVal(v * 2 + 2);\n}\n\nvoid setVal(int v, int l, int r, int pos, val cur)\n{                                                           \n    if(l == r - 1)\n    {\n        f[v] = 0;\n        Tfull[v] = cur;\n        T[v] = cur;\n    }\n    else\n    {\n        push(v);\n        int m = (l + r) / 2;\n        if(pos < m)\n            setVal(v * 2 + 1, l, m, pos, cur);\n        else\n            setVal(v * 2 + 2, m, r, pos, cur);\n        upd(v);\n    }\n}\n\nvoid flipColor(int v, int l, int r, int L, int R)\n{\n    if(L >= R) return;\n    if(l == L && r == R)\n        f[v] ^= 1;\n    else\n    {\n        push(v);\n        int m = (l + r) / 2;\n        flipColor(v * 2 + 1, l, m, L, min(m, R));\n        flipColor(v * 2 + 2, m, r, max(L, m), R);\n        upd(v);\n    }\n}\n\nval getVal(int v, int l, int r, int L, int R)\n{\n    if(L >= R) return make_pair(0ll, 0);\n    if(l == L && r == R) return getVal(v);\n    int m = (l + r) / 2;\n    val ans = make_pair(0ll, 0);\n    push(v);\n    ans = ans + getVal(v * 2 + 1, l, m, L, min(R, m));\n    ans = ans + getVal(v * 2 + 2, m, r, max(L, m), R);\n    upd(v);\n    return ans;\n}\n\nint n;\nvector<int> g[N];\n\nint p[N], siz[N], d[N], nxt[N];\nint tin[N], timer;\nmap<pair<int, int>, int> idx;\nlong long sum;\nint cnt;\nint active[N];\nint active_cnt;\n\nvoid dfs_sz(int v) \n{\n    if (p[v] != -1) \n    {\n        auto it = find(g[v].begin(), g[v].end(), p[v]);\n        if (it != g[v].end())\n            g[v].erase(it);\n    }\n    siz[v] = 1;\n    for (int &u : g[v]) \n    {\n        p[u] = v;\n        d[u] = d[v] + 1;\n        dfs_sz(u);\n        siz[v] += siz[u];\n        if (siz[u] > siz[g[v][0]])\n            swap(u, g[v][0]);\n    }\n}\n\nvoid dfs_hld(int v) \n{\n    tin[v] = timer++;\n    for (int u : g[v]) \n    {\n        nxt[u] = (u == g[v][0] ? nxt[v] : u);\n        dfs_hld(u);\n    }\n}\n\n// [l; r] inclusive\nvoid flipSegment(int l, int r) \n{\n    flipColor(0, 0, n, l, r + 1);        \n}\n\n// [l; r] inclusive\nval get(int l, int r) \n{\n    return getVal(0, 0, n, l, r + 1);   \n}\n\nvoid flipPath(int v, int u) \n{\n    for (; nxt[v] != nxt[u]; u = p[nxt[u]]) \n    {\n        if (d[nxt[v]] > d[nxt[u]]) swap(v, u);\n        flipSegment(tin[nxt[u]], tin[u]);\n    }\n    if (d[v] > d[u]) swap(v, u);\n    flipSegment(tin[v], tin[u]);\n}\n\nval getPath(int v, int u) \n{\n    val res = make_pair(0ll, 0);\n    for (; nxt[v] != nxt[u]; u = p[nxt[u]]) \n    {\n        if (d[nxt[v]] > d[nxt[u]]) swap(v, u);\n        // update res with the result of get()\n        res = res + get(tin[nxt[u]], tin[u]);\n    }\n    if (d[v] > d[u]) swap(v, u);\n    res = res + get(tin[v], tin[u]);\n    return res;\n}\n\nvoid activate_vertex(int x)\n{\n    int id = 0;\n    if(p[x] != -1)\n    {                       \n        id = idx[make_pair(x, p[x])];\n        val v = getPath(0, p[x]);\n        flipPath(0, p[x]);\n        sum -= v.x;\n        cnt -= v.y;\n        v = getPath(0, p[x]);\n        sum += v.x;\n        cnt += v.y;\n    }                   \n    cnt++;\n    sum += id;\n    setVal(0, 0, n, tin[x], make_pair((long long)(id), 1));\n    active[x] = 1;\n    active_cnt++;   \n}          \n\nvoid init_hld(int root = 0) \n{\n    d[root] = 0;\n    nxt[root] = root;\n    p[root] = -1;\n    timer = 0;\n    dfs_sz(root);\n    dfs_hld(root);\n}\n\nint currentSize[N];\n\nint dfsSolution(int x, vector<int>& edges)\n{\n    if(!active[x]) return 0;\n    currentSize[x] = 1;\n    for(auto y : g[x])\n        if(y != p[x])\n            currentSize[x] += dfsSolution(y, edges);\n    if(currentSize[x] % 2 == 1)\n        edges.push_back(idx[make_pair(x, p[x])]);\n    return currentSize[x];   \n}\n\nvoid outputSolution()\n{\n    vector<int> edges;\n    if(cnt * 2 == active_cnt)\n    {\n        dfsSolution(0, edges);\n        sort(edges.begin(), edges.end());\n    }\n    printf(\"%d\", int(edges.size()));\n    for(auto x : edges) printf(\" %d\", x);\n    puts(\"\");\n    fflush(stdout);\n}\n\nvoid processQuery(int v)\n{\n    activate_vertex(v);\n    if(cnt * 2 == active_cnt)\n        printf(\"%lld\\n\", sum);\n    else\n        puts(\"0\");\n    fflush(stdout);\n}\n\nint main()\n{\n    scanf(\"%d\", &n);\n    for(int i = 1; i < n; i++)\n    {\n        int x, y;\n        scanf(\"%d %d\", &x, &y);\n        --x;\n        --y;\n        g[x].push_back(y);\n        g[y].push_back(x);\n        idx[make_pair(x, y)] = i;\n        idx[make_pair(y, x)] = i;\n    }   \n    \n    init_hld();         \n    activate_vertex(0); \n    while(true)\n    {\n        int t;\n        scanf(\"%d\", &t);       \n        if(t == 3)\n            break;\n        if(t == 2)\n            outputSolution();\n        if(t == 1)\n        {\n            int v;          \n            scanf(\"%d\", &v);\n            --v;\n            processQuery(v);\n        } \n    }\n}", "interactive": false, "noSolution": false, "noTutorial": false}