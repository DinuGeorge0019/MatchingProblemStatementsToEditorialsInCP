{"link": "https://codeforces.com//contest/1380/problem/C", "problemId": "670985", "shortId": "1380C", "contest_number": "1380", "name": "C. Create The Teams", "statement": "There are  programmers that you want to split into several non-empty teams. The skill of the -th programmer is . You want to assemble the maximum number of teams from them. There is a restriction for each team: the number of programmers in the team multiplied by the minimum skill among all programmers in the team must be at least .Each programmer should belong to at most one team. Some programmers may be left without a team.Calculate the maximum number of teams that you can assemble.", "input": "The first line contains the integer  ()\u00a0\u2014 the number of test cases. The first line of each test case contains two integers  and  ()\u00a0\u2014 the number of programmers and the restriction of team skill respectively. The second line of each test case contains  integers  (), where  is the skill of the -th programmer. The sum of  over all inputs does not exceed .", "output": "For each test case print one integer \u2014 the maximum number of teams that you can assemble. ", "tutorial": "At first, notice that if only  programmers are taken, then the same or even better answer can be achieved if  strongest programmers are taken.Now let's sort the programmers in a non-increasing order and choose some assignment into the teams. For each team only the rightmost taken programmer of that team matters (the sorted sequence implies that the rightmost is the weakest).Take a look at the team with the strongest weakest member. If the number of programmers in it is less than the position of the weakest member, then you can safely rearrange the programmers before him in such a way that none of parameters of later teams change and the weakest member in the first one only becomes stronger. After that you can get rid of the first team (as it takes exactly the prefix of all the programmers) and proceed to fix the later teams.Thus, we can see that there is an optimal solution such that each team is a segment and all the teams together take some prefix of the programmers. So we can finally run a greedy solution that takes programmers from left to right and increases the answer if the conditions for the latest team hold.Overall complexity: .", "solution": "for _ in range(int(input())):\n    n, x = map(int, input().split())\n    a = sorted(list(map(int, input().split())), reverse=True)\n    res, cur = 0, 1\n    for s in a:\n        if s * cur >= x:\n            res += 1\n            cur = 0\n        cur += 1\n    print(res)\n    ", "interactive": false, "noSolution": false, "noTutorial": false}