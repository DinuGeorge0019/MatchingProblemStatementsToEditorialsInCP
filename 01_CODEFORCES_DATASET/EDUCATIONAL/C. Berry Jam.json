{"link": "https://codeforces.com//contest/1278/problem/C", "problemId": "498932", "shortId": "1278C", "contest_number": "1278", "name": "C. Berry Jam", "statement": "Karlsson has recently discovered a huge stock of berry jam jars in the basement of the house. More specifically, there were  jars of strawberry and blueberry jam.All the  jars are arranged in a row. The stairs to the basement are exactly in the middle of that row. So when Karlsson enters the basement, he sees exactly  jars to his left and  jars to his right.For example, the basement might look like this:  Being the starightforward man he is, he immediately starts eating the jam. In one minute he chooses to empty either the first non-empty jar to his left or the first non-empty jar to his right.Finally, Karlsson decided that at the end the amount of full strawberry and blueberry jam jars should become the same.For example, this might be the result:    Jars are numbered from  to  from left to right, so Karlsson initially stands between jars  and .What is the minimum number of jars Karlsson is required to empty so that an equal number of full strawberry and blueberry jam jars is left?Your program should answer  independent test cases.", "input": "The first line contains one integer  () \u2014 the number of test cases. The first line of each test case contains a single integer  (). The second line of each test case contains  integers  () \u2014  means that the -th jar from the left is a strawberry jam jar and  means that it is a blueberry jam jar. It is guaranteed that the sum of  over all test cases does not exceed .", "output": "For each test case print the answer to it \u2014 the minimum number of jars Karlsson is required to empty so that an equal number of full strawberry and blueberry jam jars is left.", "tutorial": "Let's transit from counting strawberry and blueberry jam jars separately to their difference. Let  be equal to . Then eating one strawberry jar decreases  by  and eating one blueberry jar increases  by . The goal is to make  equal to .Let there be some initial difference . Let's eat first  jars from the left and first  jars from the right. Difference of the jars on the left is , on the right it's . So the goal becomes to find such  and  that . Rewrite that as . Now for each unique value of  save the smallest  to reach that value in a map. Finally, iterate over the  and find the minimum answer.Overall complexity: .", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nint n;\nvector<int> a;\n\nbool read(){\n\tif (scanf(\"%d\", &n) != 1)\n\t\treturn false;\n\ta.resize(2 * n);\n\tforn(i, 2 * n)\n\t\tscanf(\"%d\", &a[i]);\n\treturn true;\n}\n\nvoid solve(){\n\tint cur = 0;\n\tmap<int, int> difr;\n\t\n\tdifr[0] = 0;\n\tcur = 0;\n\tfor (int i = n; i < 2 * n; ++i){\n\t\tif (a[i] == 1)\n\t\t\t++cur;\n\t\telse\n\t\t\t--cur;\n\t\tif (!difr.count(cur))\n\t\t\tdifr[cur] = i - (n - 1);\n\t}\n\t\n\tint ans = 2 * n;\n\tint dif = count(a.begin(), a.end(), 1) - count(a.begin(), a.end(), 2);\n\t\n\tcur = 0;\n\tfor (int i = n - 1; i >= 0; --i){\n\t\tif (a[i] == 1)\n\t\t\t++cur;\n\t\telse\n\t\t\t--cur;\n\t\tif (difr.count(dif - cur))\n\t\t\tans = min(ans, n - i + difr[dif - cur]);\n\t}\n\tif (difr.count(dif)){\n\t\tans = min(ans, difr[dif]);\n\t}\n\t\n\tprintf(\"%d\\n\", ans);\n}\n\nint main() {\n\tint tc;\n\tscanf(\"%d\", &tc);\n\tforn(_, tc){\n\t\tread();\n\t\tsolve();\n\t}\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}