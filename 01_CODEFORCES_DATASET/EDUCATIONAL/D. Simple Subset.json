{"link": "https://codeforces.com//contest/665/problem/D", "problemId": "55554", "shortId": "665D", "contest_number": "665", "name": "D. Simple Subset", "statement": "A tuple of positive integers  is called simple if for all pairs of positive integers  (),  is a prime.You are given an array  with  positive integers  (not necessary distinct). You want to find a simple subset of the array  with the maximum size.A prime number (or a prime) is a natural number greater than  that has no positive divisors other than  and itself.Let's define a subset of the array  as a tuple that can be obtained from  by removing some (possibly all) elements of it.", "input": "The first line contains integer  () \u2014 the number of integers in the array . The second line contains  integers  () \u2014 the elements of the array .", "output": "On the first line print integer  \u2014 the maximum possible size of simple subset of . On the second line print  integers  \u2014 the elements of the simple subset of the array  with the maximum size. If there is more than one solution you can print any of them. You can print the elements of the subset in any order.", "tutorial": "Consider the subset  that is the answer to the problem. Let  be the arbitrary three elements from  and let no more than one of them is equal to . By the pigeonhole principle two of three elements from  have the same parity. So we have two integers with even sum and only one of them is equal to , so their sum is also greater than . So the subset  is not simple. In this way  consists of only two numbers greater than one (with a prime sum) or consists of some number of ones and also maybe other value , so that  is a prime.\nWe can simply process the first case in  time. The second case can be processed in linear time. Also we should choose the best answer from that two.\nTo check the value of order  for primality in  time we can use the simple or the linear Eratosthenes sieve.\n", "solution": "const int N = 1010, X = 2100300;\n\nint n, a[N];\n\nbool read() {\n\tif (!(cin >> n)) return false;\n\tforn(i, n) assert(scanf(\"%d\", &a[i]) == 1);\n\treturn true;\n}\n\nint szp, p[X];\nint mind[X];\n\nvoid prepare() {\n\tfore(i, 2, X) {\n\t\tif (!mind[i]) {\n\t\t\tp[szp++] = i;\n\t\t\tmind[i] = i;\n\t\t}\n\t\tfor (int j = 0; j < szp && p[j] <= mind[i] && i * p[j] < X; j++)\n\t\t\tmind[i * p[j]] = p[j];\n\t}\n}\n\nvoid printAns(int cnt1, int a = -1, int b = -1) {\n\tvector<int> ans;\n\tforn(i, cnt1) ans.pb(1);\n\tif (a != -1) ans.pb(a);\n\tif (b != -1) ans.pb(b);\n\tassert(!ans.empty());\n\trandom_shuffle(all(ans));\n\n\tcout << sz(ans) << endl;\n\tforn(i, sz(ans)) {\n\t\tif (i) putchar(' ');\n\t\tprintf(\"%d\", ans[i]);\n\t}\n\tputs(\"\");\n}\n\nvoid solve() {\n\tint cnt1 = (int) count(a, a + n, 1);\n\n\tfunction<bool(int)> isPrime = [](int p) { return mind[p] == p; };\n\n\tif (cnt1 > 0)\n\t\tforn(i, n)\n\t\t\tif (a[i] != 1 && isPrime(a[i] + 1)) {\n\t\t\t\tprintAns(cnt1, a[i]);\n\t\t\t\treturn;\n\t\t\t}\n\n\tif (cnt1 > 1) {\n\t\tprintAns(cnt1);\n\t\treturn;\n\t}\n\n\tforn(i, n)\n\t\tforn(j, i)\n\t\t\tif (isPrime(a[i] + a[j])) {\n\t\t\t\tprintAns(0, a[i], a[j]);\n\t\t\t\treturn;\n\t\t\t}\n\n\tprintAns(0, a[0]);\n}", "interactive": false, "noSolution": false, "noTutorial": false}