{"link": "https://codeforces.com//contest/1288/problem/F", "problemId": "516092", "shortId": "1288F", "contest_number": "1288", "name": "F. Red-Blue Graph", "statement": "You are given a bipartite graph: the first part of this graph contains  vertices, the second part contains  vertices, and there are  edges. .Initially, each edge is colorless. For each edge, you may either leave it uncolored (it is free), paint it red (it costs  coins) or paint it blue (it costs  coins). No edge can be painted red and blue simultaneously.There are three types of vertices in this graph \u2014 colorless, red and blue. Colored vertices impose additional constraints on edges' colours:  for each red vertex, the number of red edges indicent to it should be  than the number of blue edges incident to it;  for each blue vertex, the number of blue edges indicent to it should be  than the number of red edges incident to it. Colorless vertices impose no additional constraints.Your goal is to paint some (possibly none) edges so that all constraints are met, and among all ways to do so, you should choose the one with minimum total cost. ", "input": "The first line contains five integers , , ,  and  () \u2014 the number of vertices in the first part, the number of vertices in the second part, the number of edges, the amount of coins you have to pay to paint an edge red, and the amount of coins you have to pay to paint an edge blue, respectively. The second line contains one string consisting of  characters. Each character is either ,  or . If the -th character is , then the -th vertex of the first part is uncolored;  corresponds to a red vertex, and  corresponds to a blue vertex. The third line contains one string consisting of  characters. Each character is either ,  or . This string represents the colors of vertices of the second part in the same way. Then  lines follow, the -th line contains two integers  and  (, ) denoting an edge connecting the vertex  from the first part and the vertex  from the second part. The graph may contain multiple edges.", "output": "If there is no coloring that meets all the constraints, print one integer . Otherwise, print an integer  denoting the total cost of coloring, and a string consisting of  characters. The -th character should be  if the -th edge should be left uncolored,  if the -th edge should be painted red, or  if the -th edge should be painted blue. If there are multiple colorings with minimum possible cost, print any of them.", "tutorial": "A lot of things in this problem may tell us that we should try thinking about a flow solution. Okay, let's try to model the problem as a flow network.First of all, our network will consist of vertices and edges of the original graph. We somehow have to denote \"red\", \"blue\" and \"colorless\" edges; we will do it as follows: each edge of the original graph corresponds to a bidirectional edge with capacity  in the network; if the flow goes from the left part to the right part along the edge, it is red; if the flow goes from right to left, it is a blue edge; and if there is no flow along the edge, it is colorless.Okay, we need to impose some constraints on the vertices. Consider some vertex  from the left part. Each red edge incident to it transfers one unit of flow from it to some other vertex, and each blue edge incident to it does the opposite. So, the difference between the number of blue and red edges incident to  is the amount of excess flow that has to be transfered somewhere else. If  is colorless, there are no constraints on the colors of edges, so this amount of excess flow does not matter \u2014 to model it, we can add a directed edge from source to  with infinite capacity, and a directed edge from  to sink with infinite capacity. What if  is red? At least one unit of flow should be transfered to it; so we add a directed edge from the source to  with infinite capacity . And if  is blue, we need to transfer at least one unit of excess flow from it \u2014 so we add a directed edge from  to the sink with infinite capacity such that there is at least one unit of flow along it. The colors of the vertices in the right part can be modeled symmetrically.How to deal with edges such that there should be some flow along them? You may use classic \"flows with demands\" approach from here: https://cp-algorithms.com/graph/flow_with_demands.html. Or you can model it with the help of the costs: if the flow along the edge should be between  and , we can add two edges: one with capacity  and cost  (where  is a negative number with sufficiently large absolute value, for example, ), and another with capacity  and cost .Okay, now we know how to find at least one painting. How about finding the cheapest painting that meets all the constraints? One of the simplest ways to do it is to impose costs on the edges of the original graph: we can treat each edge of the original graph as a pair of directed edges, one going from left to right with capacity  and cost , and another going from right to left with capacity  and cost .", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 443;\n\nint n1, n2, m, r, b;\nstring s1, s2;\nint u[N];\nint v[N];\n\nstruct edge\n{\n    int y, c, f, cost;\n    edge() {};\n    edge(int y, int c, int f, int cost) : y(y), c(c), f(f), cost(cost) {};\n};\n\nint bal[N][N];\nint s, t, oldS, oldT, V;\nvector<int> g[N];\nvector<edge> e;\n\nvoid add(int x, int y, int c, int cost)\n{\n    g[x].push_back(e.size());\n    e.push_back(edge(y, c, 0, cost));\n    g[y].push_back(e.size());\n    e.push_back(edge(x, 0, 0, -cost));\n}\n\nint rem(int num)\n{\n    return e[num].c - e[num].f;\n}   \n\nvoid add_LR(int x, int y, int l, int r, int cost)\n{\n    int c = r - l;\n    if(l > 0)\n    {\n        add(s, y, l, cost);\n        add(x, t, l, cost);\n    }\n    if(c > 0)\n    {\n        add(x, y, c, cost);\n    }\n}\n\nint p[N];\nint d[N];\nint pe[N];\nint inq[N];\n\nbool enlarge()\n{\n    for(int i = 0; i < V; i++)\n    {\n        d[i] = int(1e9);\n        p[i] = -1;\n        pe[i] = -1;\n        inq[i] = 0;\n    }\n    d[s] = 0;\n    queue<int> q;\n    q.push(s);\n    inq[s] = 1;\n    while(!q.empty())\n    {\n        int k = q.front();\n        q.pop();\n        inq[k] = 0;\n        for(auto z : g[k])\n        {\n            if(!rem(z)) continue;\n            if(d[e[z].y] > d[k] + e[z].cost)\n            {\n                p[e[z].y] = k;\n                pe[e[z].y] = z;\n                d[e[z].y] = d[k] + e[z].cost;\n                if(!inq[e[z].y])\n                {\n                    q.push(e[z].y);\n                    inq[e[z].y] = 1;\n                }\n            }\n        }\n    }\n    if(p[t] == -1)\n        return false;\n    int cur = t;\n    while(cur != s)\n    {\n        e[pe[cur]].f++;\n        e[pe[cur] ^ 1].f--;\n        cur = p[cur];\n    }\n    return true;\n}\n\nvoid add_edge(int x, int y)\n{\n    add(x, y + n1, 1, r);\n    add(y + n1, x, 1, b);\n}\n\nvoid impose_left(int x)\n{\n    if(s1[x] == 'R')\n    {\n        add_LR(oldS, x, 1, m, 0);\n    }\n    else if(s1[x] == 'B')\n    {\n        add_LR(x, oldT, 1, m, 0);\n    }\n    else\n    {\n        add(oldS, x, m, 0);\n        add(x, oldT, m, 0);\n    }\n}\n\nvoid impose_right(int x)\n{\n    if(s2[x] == 'R')\n    {\n        add_LR(x + n1, oldT, 1, m, 0);\n    }\n    else if(s2[x] == 'B')\n    {\n        add_LR(oldS, x + n1, 1, m, 0);\n    }\n    else\n    {\n        add(oldS, x + n1, m, 0);\n        add(x + n1, oldT, m, 0);\n    }\n}\n\nvoid construct_bal()\n{\n    for(int i = 0; i < n1; i++)\n    {\n        for(auto z : g[i])\n        {\n            if(e[z].y >= n1 && e[z].y < n1 + n2)\n                bal[i][e[z].y - n1] += e[z].f;\n        }\n    }\n}\n\nvoid find_ans()\n{\n    int res = 0;\n    string w = \"\";\n    for(auto x : g[s])\n        if(rem(x))\n        {\n            cout << -1 << endl;\n            return;\n        }\n    for(int i = 0; i < m; i++)\n    {\n        if(bal[u[i]][v[i]] > 0)\n        {\n            bal[u[i]][v[i]]--;\n            res += r;\n            w += \"R\";\n        }\n        else if(bal[u[i]][v[i]] < 0)\n        {\n            bal[u[i]][v[i]]++;\n            res += b;\n            w += \"B\";\n        }\n        else w += \"U\";\n    }\n    cout << res << endl << w << endl;\n}\n\nint main()\n{                       \n    cin >> n1 >> n2 >> m >> r >> b;\n    cin >> s1;\n    cin >> s2;\n    for(int i = 0; i < m; i++)\n    {\n        cin >> u[i] >> v[i];\n        u[i]--;\n        v[i]--;\n    }\n\n    oldS = n1 + n2;\n    oldT = oldS + 1;\n    s = oldT + 1;\n    t = s + 1;\n    V = t + 1;\n\n    for(int i = 0; i < n1; i++)\n        impose_left(i);\n    for(int i = 0; i < n2; i++)\n        impose_right(i);\n    for(int i = 0; i < m; i++)\n        add_edge(u[i], v[i]);\n    add(oldT, oldS, 100000, 0);\n    while(enlarge());\n    construct_bal();\n    find_ans();\n}", "interactive": false, "noSolution": false, "noTutorial": false}