{"link": "https://codeforces.com//contest/1511/problem/F", "problemId": "955217", "shortId": "1511F", "contest_number": "1511", "name": "F. Chainword", "statement": "A chainword is a special type of crossword. As most of the crosswords do, it has cells that you put the letters in and some sort of hints to what these letters should be.The letter cells in a chainword are put in a single row. We will consider chainwords of length  in this task.A hint to a chainword is a sequence of segments such that the segments don't intersect with each other and cover all  letter cells. Each segment contains a description of the word in the corresponding cells.The twist is that there are actually two hints: one sequence is the row above the letter cells and the other sequence is the row below the letter cells. When the sequences are different, they provide a way to resolve the ambiguity in the answers.You are provided with a dictionary of  words, each word consists of lowercase Latin letters. All words are pairwise distinct.An instance of a chainword is the following triple:   a string of  lowercase Latin letters;  the first hint: a sequence of segments such that the letters that correspond to each segment spell a word from the dictionary;  the second hint: another sequence of segments such that the letters that correspond to each segment spell a word from the dictionary. Note that the sequences of segments don't necessarily have to be distinct.Two instances of chainwords are considered different if they have different strings, different first hints  different second hints.Count the number of different instances of chainwords. Since the number might be pretty large, output it modulo .", "input": "The first line contains two integers  and  (, )\u00a0\u2014 the number of words in the dictionary and the number of letter cells. Each of the next  lines contains a word\u00a0\u2014 a non-empty string of no more than  lowercase Latin letters. All words are pairwise distinct. ", "output": "Print a single integer\u00a0\u2014 the number of different instances of chainwords of length  for the given dictionary modulo .", "tutorial": "Let's use a trie to store the given words. Now let's imagine a procedure that checks if some string of length  can be represented as a concatenation of some of these words. If the words were prefix-independent\u00a0\u2014 no word was a prefix of another word, that task would be solvable with a greedy algorithm.We could iterate over a string and maintain the current vertex of the trie we are in. Append a current letter. If there is no such transition in a trie, it can't be represented. If the vertex we go to is a terminal, jump to the root of the trie. Otherwise, just go to that vertex. However, since the words aren't prefix-independent, we have a terminal on a path to other terminals. Thus, we can't immediately decide if we should jump to the root or just go.Let's handle this with dynamic programming. \u00a0\u2014 can we put  letters in such a way that the vertex of a trie we are in is .Is building a chainword letter by letter that different from this process? Apparently, it isn't. Consider \u00a0\u2014 how many ways are there to put  letters in a string so that the first hint is in a vertex  and the second hint is in a vertex . For the transition we can try all  letters to put and jump to the corresponding vertices.That obviously, is too slow. The intuition tells us that this dp should be calculated with some kind of matrix exponentiation (since ). That dp can be rewritten as a matrix pretty easily. However, its size is up to  (the maximum number of vertices in a trie squared).Some say that there is a way to compute the -th power of such a huge matrix fast enough with Berlekamp\u2013Massey, but I unfortunately am not familiar with it.Thus, we'll have to reduce the size of our matrix. First, notice that the only reachable states  are such that the word that is written on a path from the root to  is a suffix of a word that is written on a path from the root to  or vice versa.Look at it the other way: if we build a trie on the reversed words, then one of the vertices will be an ancestor of another one. Now it's easy to estimate the number of states as the sum of depths of all vertices. However, since we look at ordered pairs of , we should more or less double that amount. That should be  states at max.This can probably pass with an optimal enough implementation. We can do better, though. Let's merge the states  and  into one state. The intuition is basically that you can swap the hints at will. That makes the pairs unordered: now there are up to  pairs. That surely will work fast enough.The way to generate all the possible states is the following: run a dfs/bfs, starting from  that makes all valid transition and record all the states that can be visited.While preparing the tests, I only managed to get up to  states and I would really love to hear an approach to either prove a tighter bound or to generate a test closer to the bound of .", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int MOD = 998244353;\nconst int K = 161;\nconst int AL = 26;\n\nstruct node{\n\tint nxt[AL];\n\tbool term;\n\tnode(){\n\t\tmemset(nxt, -1, sizeof(nxt));\n\t\tterm = false;\n\t};\n\tint& operator [](const int x){\n\t\treturn nxt[x];\n\t}\n};\n\nvector<node> trie;\n\nint tot;\n\nvoid add(const string &s){\n\tint cur = 0;\n\tint d = 1;\n\tfor (const char &c : s){\n\t\t++d;\n\t\tif (trie[cur][c - 'a'] == -1){\n\t\t\ttrie[cur][c - 'a'] = trie.size();\n\t\t\ttrie.push_back(node());\n\t\t\ttot += d;\n\t\t}\n\t\tcur = trie[cur][c - 'a'];\n\t}\n\ttrie[cur].term = true;\n}\n\nint add(int a, int b){\n\ta += b;\n\tif (a >= MOD)\n\t\ta -= MOD;\n\treturn a;\n}\n\nint mul(int a, int b){\n\treturn a * 1ll * b % MOD;\n}\n\ntypedef array<array<int, K>, K> mat;\n\nmat operator *(const mat &a, const mat &b){\n\tmat c;\n\tforn(i, K) forn(j, K) c[i][j] = 0;\n\tforn(i, K) forn(j, K) forn(k, K)\n\t\tc[i][j] = add(c[i][j], mul(a[i][k], b[k][j]));\n\treturn c;\n}\n\nmat binpow(mat a, long long b){\n\tmat res;\n\tforn(i, K) forn(j, K) res[i][j] = i == j;\n\twhile (b){\n\t\tif (b & 1)\n\t\t\tres = res * a;\n\t\ta = a * a;\n\t\tb >>= 1;\n\t}\n\treturn res;\n}\n\nmap<pair<int, int>, int> num;\nqueue<pair<int, int>> q;\n\nint get(int v, int u){\n\tif (v > u) swap(v, u);\n\tif (!num.count({v, u})){\n\t\tint k = num.size();\n\t\tassert(k < K);\n\t\tnum[{v, u}] = k;\n\t\tq.push({v, u});\n\t}\n\treturn num[{v, u}];\n}\n\nint main() {\n\tint n;\n\tlong long m;\n\tcin >> n >> m;\n\ttrie = vector<node>(1, node());\n\ttot = 1;\n\tforn(i, n){\n\t\tstring s;\n\t\tcin >> s;\n\t\tadd(s);\n\t}\n\tq.push({0, 0});\n\tnum[q.front()] = 0;\n\tmat init;\n\tforn(i, K) forn(j, K) init[i][j] = 0;\n\twhile (!q.empty()){\n\t\tint v = q.front().first;\n\t\tint u = q.front().second;\n\t\tq.pop();\n\t\tint x = get(v, u);\n\t\tforn(c, AL){\n\t\t\tint tov = trie[v][c];\n\t\t\tint tou = trie[u][c];\n\t\t\tif (tov == -1 || tou == -1) continue;\n\t\t\t++init[x][get(tov, tou)];\n\t\t\tif (trie[tov].term) ++init[x][get(0, tou)];\n\t\t\tif (trie[tou].term) ++init[x][get(tov, 0)];\n\t\t\tif (trie[tov].term && trie[tou].term) ++init[x][0];\n\t\t}\n\t}\n\tinit = binpow(init, m);\n\tprintf(\"%d\\n\", init[0][0]);\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}