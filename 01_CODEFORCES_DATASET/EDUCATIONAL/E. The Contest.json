{"link": "https://codeforces.com//contest/1257/problem/E", "problemId": "470640", "shortId": "1257E", "contest_number": "1257", "name": "E. The Contest", "statement": "A team of three programmers is going to play a contest. The contest consists of  problems, numbered from  to . Each problem is printed on a separate sheet of paper. The participants have decided to divide the problem statements into three parts: the first programmer took some prefix of the statements (some number of first paper sheets), the third contestant took some suffix of the statements (some number of last paper sheets), and the second contestant took all remaining problems. But something went wrong \u2014 the statements were printed in the wrong order, so the contestants have received the problems in some random order.The first contestant has received problems . The second one has received problems . The third one has received all remaining problems ().The contestants don't want to play the contest before they redistribute the statements. They want to redistribute them so that the first contestant receives some prefix of the problemset, the third contestant receives some suffix of the problemset, and the second contestant receives all the remaining problems.During one move, some contestant may give one of their problems to other contestant. What is the minimum number of moves required to redistribute the problems?.", "input": "The first line contains three integers  and  () \u2014 the number of problems initially taken by the first, the second and the third participant, respectively. The second line contains  integers  \u2014 the problems initially taken by the first participant. The third line contains  integers  \u2014 the problems initially taken by the second participant. The fourth line contains  integers  \u2014 the problems initially taken by the third participant. It is guaranteed that no problem has been taken by two (or three) participants, and each integer  meets the condition , where .", "output": "Print one integer \u2014 the minimum number of moves required to redistribute the problems so that the first participant gets the prefix of the problemset, the third participant gets the suffix of the problemset, and the second participant gets all of the remaining problems.", "tutorial": "Suppose we want to divide  first problems of the contest between the first contestant and the second contestant (the first contestant will get  first problems, and the second contestant will get  problems in the middle), and then give all the remaining problems to the third contestant. We are going to iterate on  from  to  and, for each possible , find the best value of .Okay. Now suppose we fixed  and , and now we want to calculate the number of problems that should be redistributed. Let's denote  as the number of problems among  first ones given to the -th contestant,  as the number of problems among  last ones given to the -th contestant, and  as the number of problems in the middle given to the -th contestant.Obviously, the answer for fixed  and  is , but we don't like this expression because we don't know how to minimize it for fixed . We know that, for fixed , the values of  and  are constant. Using that, we may arrive at the fact that minimizing  is the same as minimizing  for fixed  \u2014 and now we have a way to quickly find best possible  for fixed .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() \n{\n\tint k1, k2, k3;\n\tscanf(\"%d %d %d\", &k1, &k2, &k3);\n\tint n = k1 + k2 + k3;\n\tvector<int> a(n);\n\tfor(int i = 0; i < k1; i++)\n\t{\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\ta[x - 1] = 0;\n\t}\n\tfor(int i = 0; i < k2; i++)\n\t{\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\ta[x - 1] = 1;\n\t}\n\tfor(int i = 0; i < k3; i++)\n\t{\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\ta[x - 1] = 2;\n\t}\n\t\n\tint ans = 0;\n\tint bestp = 0;\n\tfor(int i = 0; i < n; i++)\n\t\tif(a[i] != 2)\n\t\t\tans++;\n\tvector<int> cntl(3);\n\tvector<int> cntr(3);\n\tfor(int i = 0; i < n; i++)\n\t\tcntr[a[i]]++;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tcntl[a[i]]++;\n\t\tcntr[a[i]]--;\n\t\tbestp = max(bestp, cntl[0] - cntl[1]);\n\t\tint curans = cntr[0] + cntr[1] + cntl[2] + cntl[0] - bestp;\n\t\tans = min(ans, curans);\n\t}\n\t\n\tcout << ans << endl;\n}                    \t", "interactive": false, "noSolution": false, "noTutorial": false}