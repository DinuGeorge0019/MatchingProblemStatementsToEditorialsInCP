{"link": "https://codeforces.com//contest/1303/problem/E", "problemId": "538604", "shortId": "1303E", "contest_number": "1303", "name": "E. Erase Subsequences", "statement": "You are given a string . You can build new string  from  using the following operation :   choose any subsequence  where ;  erase the chosen subsequence from  ( can become empty);  concatenate chosen subsequence to the right of the string  (in other words, ). Of course, initially the string  is empty. For example, let . At first, let's choose subsequence  \u2014 we will get  and . At second, let's choose  \u2014 we will get  and . So we can build  from .Can you build a given string  using the algorithm above?", "input": "The first line contains the single integer  () \u2014 the number of test cases. Next  lines contain test cases \u2014 two per test case. The first line contains string  consisting of lowercase Latin letters () \u2014 the initial string. The second line contains string  consisting of lowercase Latin letters () \u2014 the string you'd like to build. ", "output": "Print  answers \u2014 one per test case. Print  (case insensitive) if it's possible to build  and  (case insensitive) otherwise.", "tutorial": "Let's look at string . Since we should get it using no more than two subsequences, then  where  is the first subsequence and  is the second one. In the general case,  can be empty. Let iterate all possible lengths of  (), so we can check the existence of solution for each pair  and .If we'd fix  and  we need to check the following: is it true that  contains  and  as subsequences and these subsequences don't intersect. Initially, we can invent the following dp: let  be  if the prefix of  of length  contains prefixes of  and  of length  and  as non-intersecting subsequences. The transitions are straingforward: if  we can either skip  (-indexed) and update . If  (-indexed) then we can update  and if  then we can update . But this dp has complexity  in general case.But we can transform it in the next way: instead of the boolean value, we will make  as a value of dp. In other words, we will maintain  as minimal appropriate prefix . But the problem now is to define transitions.Let's note the next fact: suppose we have  and we'd like to add next character to  which is equal to . The idea is next: it's always optimal to choose the first occurrence of  in . It can be proved by contradiction: if the first occurrence is free then it's better to take it, or if the first occurrence will be occupied by  then this will be handled by the other state  with . The logic for increasing  is analogical. In result, we need to precalculate array  with the next occurrence of character  in suffix  of  one time before choosing  and  and use it each time to acquire  complexity.The total complexity if  for each test case.", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) int((a).size())\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef pair<int, int> pt;\n\nconst int INF = int(1e9);\nconst li INF64 = li(1e18);\n\nstring s, t;\n\ninline bool read() {\n    if(!(cin >> s >> t))\n        return false;\n    for(auto &c : s)\n        c -= 'a';\n    for(auto &c : t)\n        c -= 'a';\n    return true;\n}\n\nvector< vector<int> > nxt;\n\nbool calc(const string &a, const string &b) {\n    vector< vector<int> > dp(sz(a) + 1, vector<int>(sz(b) + 1, INF));\n    dp[0][0] = 0;\n    fore(i, 0, sz(a) + 1) fore(j, 0, sz(b) + 1) {\n        if(dp[i][j] > sz(s))\n            continue;\n        \n        int len = dp[i][j];\n        if(i < sz(a) && nxt[len][a[i]] < INF) {\n            dp[i + 1][j] = min(dp[i + 1][j], nxt[len][a[i]] + 1);\n        }\n        if(j < sz(b) && nxt[len][b[j]] < INF) {\n            dp[i][j + 1] = min(dp[i][j + 1], nxt[len][b[j]] + 1);\n        }\n    }\n    return dp[sz(a)][sz(b)] < INF;\n}\n\ninline void solve() {\n    nxt.assign(sz(s) + 1, vector<int>(26, INF));\n    for(int i = sz(s) - 1; i >= 0; i--) {\n        nxt[i] = nxt[i + 1];\n        nxt[i][s[i]] = i;\n    }\n    \n    for(int i = 0; i < sz(t); i++) {\n        if(calc(t.substr(0, i), t.substr(i, sz(t)))) {\n            cout << \"YES\" << endl;\n            return;\n        }\n    }\n    cout << \"NO\" << endl;\n}\n\nint main() {\n#ifdef _DEBUG\n    freopen(\"input.txt\", \"r\", stdin);\n    int tt = clock();\n#endif\n    ios_base::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n    cout << fixed << setprecision(15);\n    \n    int tc; cin >> tc;\n    \n    while(tc--) {\n        read();\n        solve();\n        \n#ifdef _DEBUG\n        cerr << \"TIME = \" << clock() - tt << endl;\n        tt = clock();\n#endif\n    }\n    return 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}