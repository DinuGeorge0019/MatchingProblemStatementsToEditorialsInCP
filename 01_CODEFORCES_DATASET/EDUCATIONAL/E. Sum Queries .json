{"link": "https://codeforces.com//contest/1217/problem/E", "problemId": "404647", "shortId": "1217E", "contest_number": "1217", "name": "E. Sum Queries ", "statement": "Let's define a  multiset the following way. Write down the sum of all elements of the multiset in its decimal representation. For each position of that number check if the multiset includes at least one element such that the digit of the element and the digit of the sum at that position are the same. If that holds for every position, then the multiset is . Otherwise it's .For example, multiset  is  and multiset  is :   The red digits mark the elements and the positions for which these elements have the same digit as the sum. The sum of the first multiset is , every position has the digit required. The sum of the second multiset is  and the second-to-last digit doesn't appear in any number, thus making the multiset .You are given an array , consisting of  integers.You are asked to perform some queries on it. The queries can be of two types:   \u2014 replace  with the value ;   \u2014 find the  subset of the multiset of the numbers  with the minimum sum, or report that no  subset exists. Note that the empty multiset is .For each query of the second type print the lowest sum of the  subset. Print  if no  subset exists.", "input": "The first line contains two integers  and  () \u2014 the number of elements in the array and the number of queries, respectively. The second line contains  integers  (). Each of the following  lines contains a query of one of two types:    (, ) \u2014 replace  with the value ;   () \u2014 find the  subset of the multiset of the numbers  with the lowest sum, or report that no  subset exists.  It is guaranteed that there is at least one query of the second type.", "output": "For each query of the second type print the lowest sum of the  subset. Print  if no  subset exists.", "tutorial": "We are given the definition of the balanced multiset but let's instead fix the criteria to determine if the multiset is unbalanced.Take an empty multiset and start adding numbers to it until it becomes unbalanced. Empty set to the set of one number is trivial. Now for the second number. If there is some position such that both numbers have non-zero digits in it, then the multiset becomes unbalanced (let these be non-zero digits  and , then  can be neither , nor ).After that let's prove that you can never make an unbalanced multiset balanced again by adding numbers to it. Let there be such multisets  and  such  is unbalanced,  is balanced and . Take a look at the lowest position which has non-zero digits in several numbers from . The sum of these digits should be equal to at least one of them modulo  (to satisfy the condition of balance). That can only mean their sum is greater or equal to , thus is make a carry to the next position. The sum of digits on the next position plus carry should also be equal to some digit of them, thus pushing some other carry value to the next one. And so on until the carry makes it to the position greater than any position in any of the numbers. But the carry is non-zero and there is no number with any non-zero digit in this position. That makes our assumption incorrect.After all, it implies that any unbalanced multiset of size greater than two has an unbalanced multiset of size two.The problem now got reduced to: find a pair of numbers  and  such that , there is at least one position such that both  and  have non-zero digits on it and  is minimal possible.That can be easily maintained in a segment tree. Let a node corresponding to the interval  keep the best answer on an interval (the sum of such a pair) and an array  \u2014 the smallest number on an interval  which has a non-zero digit at position  or  if none exists.The update is easy. Iterate over the digits of a new number and update the values in the array  in the corresponding nodes.The merge is done the following way: push the best answers from children to the parent and then iterate over the positions and try to combine the smallest numbers at each one from the left child and the right child.Idea-wise this is the same as storing a segtree and calculating the answer by each position separately.However, these approaches differ by a huge constant factor performance-wise. The former one accesses the memory in a much more cache-friendly way. You might want to take that as a general advice on implementing multiple segtrees.Overall complexity: .", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int N = 200 * 1000 + 13;\nconst int INF = 2e9;\nconst int LOGN = 9;\n\nstruct node{\n\tint best;\n\tint mn[LOGN];\n\tnode(){\n\t\tbest = INF;\n\t\tforn(i, LOGN)\n\t\t\tmn[i] = INF;\n\t}\n\tint& operator [](int x){\n\t\treturn mn[x];\n\t}\n};\n\nint a[N];\nnode t[4 * N];\n\nvoid upd(node &t, int val){\n\tint x = val;\n\tforn(i, LOGN){\n\t\tif (x % 10 != 0)\n\t\t\tt[i] = min(t[i], val);\n\t\tx /= 10;\n\t}\n}\n\nnode merge(node &a, node &b){\n\tnode c;\n\tc.best = min(a.best, b.best);\n\tforn(i, LOGN){\n\t\tc[i] = min(a[i], b[i]);\n\t\tif (a[i] < INF && b[i] < INF)\n\t\t\tc.best = min(c.best, a[i] + b[i]);\n\t}\n\treturn c;\n}\n\nvoid build(int v, int l, int r){\n\tif (l == r - 1){\n\t\tt[v] = node();\n\t\tupd(t[v], a[l]);\n\t\treturn;\n\t}\n\tint m = (l + r) / 2;\n\tbuild(v * 2, l, m);\n\tbuild(v * 2 + 1, m, r);\n\tt[v] = merge(t[v * 2], t[v * 2 + 1]);\n}\n\nvoid upd(int v, int l, int r, int pos, int val){\n\tif (l == r - 1){\n\t\tt[v] = node();\n\t\tupd(t[v], val);\n\t\treturn;\n\t}\n\tint m = (l + r) / 2;\n\tif (pos < m)\n\t\tupd(v * 2, l, m, pos, val);\n\telse\n\t\tupd(v * 2 + 1, m, r, pos, val);\n\tt[v] = merge(t[v * 2], t[v * 2 + 1]);\n}\n\nnode get(int v, int l, int r, int L, int R){\n\tif (l == L && r == R)\n\t\treturn t[v];\n\tint m = (l + r) / 2;\n\tif (R <= m)\n\t\treturn get(v * 2, l, m, L, R);\n\tif (L >= m)\n\t\treturn get(v * 2 + 1, m, r, L, R);\n\tnode ln = get(v * 2, l, m, L, m);\n\tnode rn = get(v * 2 + 1, m, r, m, R);\n\treturn merge(ln, rn);\n}\n\nint main() {\n\tint n, m;\n\tscanf(\"%d%d\", &n, &m);\n\tforn(i, n)\n\t\tscanf(\"%d\", &a[i]);\n\tbuild(1, 0, n);\n\tforn(i, m){\n\t\tint t, x, y;\n\t\tscanf(\"%d%d%d\", &t, &x, &y);\n\t\t--x;\n\t\tif (t == 1)\n\t\t\tupd(1, 0, n, x, y);\n\t\telse{\n\t\t\tnode res = get(1, 0, n, x, y);\n\t\t\tprintf(\"%d\\n\", res.best == INF ? -1 : res.best);\n\t\t}\n\t}\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}