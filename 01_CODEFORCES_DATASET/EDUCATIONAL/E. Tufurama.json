{"link": "https://codeforces.com//contest/961/problem/E", "problemId": "171416", "shortId": "961E", "contest_number": "961", "name": "E. Tufurama", "statement": "One day Polycarp decided to rewatch his absolute favourite episode of well-known TV series \"Tufurama\". He was pretty surprised when he got results only for season 7 episode 3 with his search query of \"Watch Tufurama season 3 episode 7 online full hd free\". This got Polycarp confused \u2014 what if he decides to rewatch the entire series someday and won't be able to find the right episodes to watch? Polycarp now wants to count the number of times he will be forced to search for an episode using some different method.TV series have  seasons (numbered  through ), the -th season has  episodes (numbered  through ). Polycarp thinks that if for some pair of integers  and  () exist both season  episode  and season  episode  then one of these search queries will include the wrong results. Help Polycarp to calculate the number of such pairs!", "input": "The first line contains one integer   \u2014 the number of seasons. The second line contains  integers separated by space   \u2014 number of episodes in each season.", "output": "Print one integer \u2014 the number of pairs  and  () such that there exist both season  episode  and season  episode .", "tutorial": "At first, it doesn't matter if some season has more than  episodes, so we can set .Let's maintain next invariant: when we proceed -th season we will have only seasons containing the episodes with indices . Then the number of pairs  is just number of seasons with index . One of the ways to maintain this invariant is the following: for each number of episodes  store a list with indices of seasons with exactly  episodes. Then after proceeding of -th season just erase all seasons with exactly  episodes.Maintaining seasons and counting them can be done by BIT with zeros and ones.Finally, notice, that we counted each pair  twice, and also counted the pairs , so we must subtract the number of pairs  (where ) and divide the result by two.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 200 * 1000 + 9;\n\nint n;\nint a[N];\nint f[N];\nvector <int> v[N];\n\nvoid upd(int pos, int d){\n\tfor(; pos < N; pos |= pos + 1)\n\t\tf[pos] += d;\n}\n\nint get(int pos){\n\tint res = 0;\n\tfor(; pos >= 0; pos = (pos & (pos + 1)) - 1)\n\t\tres += f[pos];\n\treturn res;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n; ++i){\n\t\tscanf(\"%d\", a + i);\n\t\t--a[i];\n\t}\n\t\t\n\tfor(int i = 0; i < n; ++i){\n\t\tif(a[i] < N)\n\t\t\tv[a[i]].push_back(i);\n\t\tupd(i, 1);\n\t}\n\t\n\tlong long res = 0;\n\tfor(int i = 0; i < n; ++i){\n\t\tint to = min(N - 1, a[i]);\n\t\tres += get(to);\n\t\tfor(auto x : v[i])\n\t\t\tupd(x, -1);\n\t}\n\t\n\tfor(int i = 0; i < n; ++i)\n\t    if(i <= a[i])\n\t        --res;\n    assert(res % 2 == 0);\n    \n\tcout << res / 2 << endl;\n}", "interactive": false, "noSolution": false, "noTutorial": false}