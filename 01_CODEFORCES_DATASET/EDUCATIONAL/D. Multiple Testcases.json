{"link": "https://codeforces.com//contest/1342/problem/D", "problemId": "604759", "shortId": "1342D", "contest_number": "1342", "name": "D. Multiple Testcases", "statement": "So you decided to hold a contest on Codeforces. You prepared the problems: statements, solutions, checkers, validators, tests... Suddenly, your coordinator asks you to change all your tests to multiple testcases in the easiest problem!Initially, each test in that problem is just an array. The maximum size of an array is . For simplicity, the contents of arrays don't matter. You have  tests \u2014 the -th test is an array of size  ().Your coordinator asks you to distribute all of your arrays into multiple testcases. Each testcase can include multiple arrays. However, each testcase should include no more than  arrays of size  (), no more than  arrays of size , , no more than  arrays of size . Also, .So now your goal is to create the new testcases in such a way that:   each of the initial arrays appears in  testcase;  for each testcase the given conditions hold;  the number of testcases is minimum possible. Print the minimum possible number of testcases you can achieve and the sizes of arrays included in each testcase.", "input": "The first line contains two integers  and  ()\u00a0\u2014 the number of initial tests and the limit for the size of each array. The second line contains  integers  ()\u00a0\u2014 the sizes of the arrays in the original tests. The third line contains  integers  ();  is the maximum number of arrays of size greater than or equal to  you can have in a single testcase.", "output": "In the first line print a single integer  ()\u00a0\u2014 the minimum number of testcases you can achieve. Each of the next  lines should contain the description of a testcase in the following format:      ()\u00a0\u2014 the testcase includes  arrays,  is the size of the -th array in that testcase. Each of the initial arrays should appear in  testcase. In particular, it implies that the sum of  over all  testcases should be equal to . Note that the answer always exists due to  (and therefore ). If there are multiple answers, you can output any one of them.", "tutorial": "Let's estimate the smallest possible achievable answer. Let the number of the arrays of size greater than or equal to $$$i$$$ be $$$g_i$$$. The answer is maximum $$$\\lceil \\frac{g_i}{c_i} \\rceil$$$ over all $$$i$$$ from $$$1$$$ to $$$k$$$. You can prove that you can't fit $$$g_i$$$ arrays in less than $$$\\lceil \\frac{g_i}{c_i} \\rceil$$$ testcases with the pigeonhole principle. Let that be called $$$ans$$$.Ok, let's now construct the solution for that estimate. Sort arrays in the increasing or decreasing order and assign the $$$i$$$-th array ($$$0$$$-indexed) in that order to the $$$i~mod~ans$$$ testcase. It's easy to see that for any $$$i$$$ the number of arrays of size greater than or equal to $$$i$$$ is always restricted by $$$\\lceil \\frac{g_i}{c_i} \\rceil$$$.Overall complexity: $$$O(n \\log n + k)$$$ or $$$O(n + k)$$$ if you care enough to do counting sort.", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\n\nint main() {\n\tint n, k;\n\tscanf(\"%d%d\", &n, &k);\n\tvector<int> a(n);\n\tforn(i, n) scanf(\"%d\", &a[i]);\n\tvector<int> c(k + 1);\n\tforn(i, k) scanf(\"%d\", &c[i + 1]);\n\t\n\tsort(a.begin(), a.end(), greater<int>());\n\tint ans = 0;\n\tfor (int i = k, g = 0; i >= 1; --i){\n\t\twhile (g < n && a[g] == i) ++g;\n\t\tans = max(ans, (g + c[i] - 1) / c[i]);\n\t}\n\tvector<vector<int>> res(ans);\n\tforn(i, n) res[i % ans].push_back(a[i]);\n\t\n\tprintf(\"%d\\n\", ans);\n\tforn(i, ans){\n\t\tprintf(\"%d\", int(res[i].size()));\n\t\tfor (auto it : res[i])\n\t\t\tprintf(\" %d\", it);\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}