{"link": "https://codeforces.com//contest/632/problem/F", "problemId": "50148", "shortId": "632F", "contest_number": "632", "name": "F. Magic Matrix", "statement": "You're given a matrix  of size .Let's call the matrix with nonnegative elements magic if it is symmetric (so ),  and  for all triples . Note that  do not need to be distinct.Determine if the matrix is magic.As the input/output can reach very huge size it is recommended to use fast input/output methods: for example, prefer to use  instead of  in C++, prefer to use  instead of  in .", "input": "The first line contains integer  () \u2014 the size of the matrix . Each of the next  lines contains  integers  () \u2014 the elements of the matrix . Note that the given matrix not necessarily is symmetric and can be arbitrary.", "output": "Print ''\" (without quotes) if the given matrix  is magic. Otherwise print ''\".", "tutorial": "Consider the undirected complete graph with  nodes, with an edge between nodes  with cost . Let  denote the minimum possible value of the max edge of a path from  to . We know that  by definition.\nIf the matrix is magic, we can choose arbitrary  such that  by repeating invocations of the inequality given. Also, you can show that if this inequality is satisfied, then the matrix is magic (by choosing an  and  arbitrary).\nSo, this shows that the matrix is magic if and only if . Thus, combining with , we have .\nWe need a fast way to compute  for all pairs . This can be computed as the MST, as the path in the MST minimizes the max edge between all pairs of nodes. So, the algorithm works as follows. First, find the MST on the complete graph. Then, the matrix is magic if and only if the max edge on the path between  in the MST is exactly equal to . Also you shouldn't forget to check symmetry of the matrix and diagonal for zeros.\nP.S.: Unfortunately we couldn't increase the value  in this problem: the tests already had the size about 67MB and they couldn't be given with generator. So most of the users who solved this problem uses bitset-s. The complexity of their solution is , where  or .\n", "solution": "\n            #include <bits/stdc++.h>\n\u00a0\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n#define nfor(i, n) for (int i = int(n) - 1; i >= 0; i--)\n#define fore(i, l, r) for (int i = int(l); i < int(r); i++)\n#define correct(x, y, n, m) (0 <= (x) && (x) < (n) && 0 <= (y) && (y) < (m))\n#define all(a) (a).begin(), (a).end()\n#define sz(a) int((a).size())\n#define pb(a) push_back(a)\n#define mp(x, y) make_pair((x), (y))\n#define x first\n#define y second\n\u00a0\nusing namespace std;\n\u00a0\ntypedef long long li;\ntypedef long double ld;\ntypedef pair<int, int> pt;\n\u00a0\ntemplate<typename X> inline X abs(const X& a) { return a < 0? -a: a; }\ntemplate<typename X> inline X sqr(const X& a) { return a * a; }\n\u00a0\ntemplate<typename A, typename B> inline ostream& operator<< (ostream& out, const pair<A, B>& p) { return out << \"(\" << p.x << \", \" << p.y << \")\"; }\ntemplate<typename T> inline ostream& operator<< (ostream& out, const vector<T>& a) { out << \"[\"; forn(i, sz(a)) { if (i) out << ','; out << ' ' << a[i]; } return out << \" ]\"; } \ntemplate<typename T> inline ostream& operator<< (ostream& out, const set<T>& a) { return out << vector<T>(all(a)); }\ntemplate<typename T> inline ostream& operator<< (ostream& out, pair<T*, int> a) { return out << vector<T>(a.x, a.x + a.y); }\n\u00a0\ninline ld gett() { return clock() / ld(CLOCKS_PER_SEC); }\n\u00a0\nconst int INF = int(1e9);\nconst li INF64 = li(1e18);\nconst ld EPS = 1e-9, PI = 3.1415926535897932384626433832795;\n\u00a0\nconst int N = 2525, LOGN = 15;\n\u00a0\nint n, a[N][N];\n\u00a0\nbool read() {\n\u00a0 \u00a0 if (!(cin >> n)) return false;\n\u00a0 \u00a0 forn(i, n) forn(j, n) assert(scanf(\"%d\", &a[i][j]) == 1);\n\u00a0 \u00a0 return true;\n}\n\u00a0\nint tt, tin[N], tout[N];\nvector<int> g[N];\n\u00a0\nvoid dfs(int v) {\n\u00a0 \u00a0 tin[v] = tt++;\n\u00a0 \u00a0 forn(i, sz(g[v])) dfs(g[v][i]);\n\u00a0 \u00a0 tout[v] = tt;\n}\n\u00a0\ninline bool parent(int a, int b) { return tin[a] <= tin[b] && tout[b] <= tout[a]; }\n\u00a0\nint p[LOGN][N], pd[LOGN][N];\n\u00a0\nint d[N], pr[N];\nbool used[N];\n\u00a0\nint calc(int a, int b) {\n\u00a0 \u00a0 int ans = 0;\n\u00a0 \u00a0 nfor(i, LOGN) {\n\u00a0 \u00a0 \u00a0 \u00a0 if (!parent(p[i][a], b)) {\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ans = max(ans, pd[i][a]);\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 a = p[i][a];\n\u00a0 \u00a0 \u00a0 \u00a0 }\n\u00a0 \u00a0 \u00a0 \u00a0 if (!parent(p[i][b], a)) {\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ans = max(ans, pd[i][b]);\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 b = p[i][b];\n\u00a0 \u00a0 \u00a0 \u00a0 }\n\u00a0 \u00a0 }\n\u00a0 \u00a0 if (!parent(a, b)) ans = max(ans, pd[0][a]);\n\u00a0 \u00a0 if (!parent(b, a)) ans = max(ans, pd[0][b]);\n\u00a0 \u00a0 return ans;\n}\n\u00a0\nvoid solve() {\n\u00a0 \u00a0 forn(i, n)\n\u00a0 \u00a0 \u00a0 \u00a0 forn(j, n)\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if (a[i][j] != a[j][i] || (i == j && a[i][j])) {\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 puts(\"NOT MAGIC\");\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 return;\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\n\u00a0\n\u00a0 \u00a0 forn(i, n) {\n\u00a0 \u00a0 \u00a0 \u00a0 used[i] = false;\n\u00a0 \u00a0 \u00a0 \u00a0 d[i] = INT_MAX;\n\u00a0 \u00a0 \u00a0 \u00a0 g[i].clear();\n\u00a0 \u00a0 }\n\u00a0\n\u00a0 \u00a0 d[0] = 0;\n\u00a0 \u00a0 pr[0] = -1;\n\u00a0 \u00a0 forn(i, n) {\n\u00a0 \u00a0 \u00a0 \u00a0 int v = -1;\n\u00a0 \u00a0 \u00a0 \u00a0 forn(j, n)\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if (!used[j] && (v == -1 || d[v] > d[j]))\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 v = j;\n\u00a0\n\u00a0 \u00a0 \u00a0 \u00a0 assert(v != -1);\n\u00a0 \u00a0 \u00a0 \u00a0 used[v] = true;\n\u00a0 \u00a0 \u00a0 \u00a0 //cerr << \"v=\" << v << \" p[v]=\" << pr[v] << endl;\n\u00a0\n\u00a0 \u00a0 \u00a0 \u00a0 if (pr[v] != -1) {\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 p[0][v] = pr[v];\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 pd[0][v] = a[pr[v]][v];\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 g[pr[v]].pb(v);\n\u00a0 \u00a0 \u00a0 \u00a0 } else {\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 p[0][v] = v;\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 pd[0][v] = 0;\n\u00a0 \u00a0 \u00a0 \u00a0 }\n\u00a0\n\u00a0 \u00a0 \u00a0 \u00a0 forn(j, n)\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if (!used[j] && d[j] > a[v][j]) {\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 d[j] = a[v][j];\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 pr[j] = v;\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\n\u00a0 \u00a0 }\n\u00a0\n\u00a0 \u00a0 //cerr << mp(pr, n) << endl;\n\u00a0\n\u00a0 \u00a0 tt = 0;\n\u00a0 \u00a0 dfs(0);\n\u00a0\n\u00a0 \u00a0 fore(i, 1, LOGN)\n\u00a0 \u00a0 \u00a0 \u00a0 forn(j, n) {\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 p[i][j] = p[i - 1][p[i - 1][j]];\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 pd[i][j] = max(pd[i - 1][j], pd[i - 1][p[i - 1][j]]);\n\u00a0 \u00a0 \u00a0 \u00a0 }\n\u00a0\n\u00a0 \u00a0 forn(i, n)\n\u00a0 \u00a0 \u00a0 \u00a0 forn(j, n)\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if (a[i][j] != calc(i, j)) {\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 puts(\"NOT MAGIC\");\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 return;\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\n\u00a0 \u00a0 puts(\"MAGIC\");\n}\n\u00a0\nint main() {\n#ifdef SU1\n\u00a0 \u00a0 assert(freopen(\"input.txt\", \"rt\", stdin));\n\u00a0 \u00a0 //assert(freopen(\"output.txt\", \"wt\", stdout));\n#endif\n\u00a0 \u00a0 \n\u00a0 \u00a0 cout << setprecision(10) << fixed;\n\u00a0 \u00a0 cerr << setprecision(5) << fixed;\n\u00a0\n\u00a0 \u00a0 while (read()) {\n\u00a0 \u00a0 \u00a0 \u00a0 ld stime = gett();\n\u00a0 \u00a0 \u00a0 \u00a0 solve();\n\u00a0 \u00a0 \u00a0 \u00a0 cerr << \"Time: \" << gett() - stime << endl;\n\u00a0 \u00a0 \u00a0 \u00a0 //break;\n\u00a0 \u00a0 }\n\u00a0 \u00a0 \n\u00a0 \u00a0 return 0;\n}\n        ", "interactive": false, "noSolution": false, "noTutorial": false}