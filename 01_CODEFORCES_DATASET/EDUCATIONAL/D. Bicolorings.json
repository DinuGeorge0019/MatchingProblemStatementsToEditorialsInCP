{"link": "https://codeforces.com//contest/1051/problem/D", "problemId": "222360", "shortId": "1051D", "contest_number": "1051", "name": "D. Bicolorings", "statement": "You are given a grid, consisting of  rows and  columns. Each cell of this grid should be colored either black or white.Two cells are considered neighbours if they have a  and share the same color. Two cells  and  belong to the same component if they are neighbours, or if there is a neighbour of  that belongs to the same component with .Let's call some bicoloring  if it has exactly  components.Count the number of  bicolorings. The number can be big enough, so print the answer modulo .", "input": "The only line contains two integers  and  (, ) \u2014 the number of columns in a grid and the number of components required.", "output": "Print a single integer \u2014 the number of  bicolorings modulo .", "tutorial": "The problem is about counting the number of some combinatoric objects. Thus, dynamic programming is always the answer.Let  be the number of  bicolorings of the first  columns such that  components are already created and can't be modified and the colors of the -th column are determined by  (its first bit is the color of the lower cell and its second bit the color of the upper cell). Component can be modified if the cell from the -th column belongs to it.The initial states are  for each  and  for any other state.You should iterate over the possible  for the next column and recalculate the number of components. You can easily show that the current number of components and the last column is actually enough to get the new number of components. In my code I have some function  to determine the added number of components while transitioning from  to . These are just the couple of cases to handle carefully.Then all the transitions are: += .However, the last column won't contain the answer as it is, the number of components will be incorrect. Let's add some dummy column  equal to  for each . This will add all the real component to the total number. So the answer is the sum of  over all .Overall complexity: , where  is the number of rows (2 for this problem).", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define forn(i, n) for(int i = 0; i < int(n); i++) \n\nconst int N = 1000 + 7;\nconst int MOD = 998244353;\n\nint dp[N][2 * N][4];\n\nint add(int a, int b){\n\treturn (a + b) % MOD;\n}\n\nbool full(int mask){\n\treturn (mask == 0 || mask == 3);\n}\n\nint get(int mask, int nmask){\n\tint cnt = __builtin_popcount(mask ^ nmask);\n\tif (cnt == 0) return 0;\n\tif (cnt == 2) return (full(mask) ? 1 : 2);\n\treturn (full(mask) ? 0 : 1);\n}\n\nint main() {\n\tint n, k;\n\tscanf(\"%d%d\", &n, &k);\n\tforn(i, 4)\n\t\tdp[1][0][i] = 1;\n\t\n\tfor (int i = 1; i < n; ++i){\n\t\tforn(j, k + 1){\n\t\t\tforn(mask, 4){\n\t\t\t\tforn(nmask, 4){\n\t\t\t\t\tdp[i + 1][j + get(mask, nmask)][nmask] = add(dp[i + 1][j + get(mask, nmask)][nmask], dp[i][j][mask]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\tforn(mask, 4){\n\t\tint nw = get(mask, mask ^ 3);\n\t\tif (k >= nw)\n\t\t\tans = add(ans, dp[n][k - nw][mask]);\n\t}\n\t\n\tprintf(\"%d\\n\", ans);\n}        \t", "interactive": false, "noSolution": false, "noTutorial": false}