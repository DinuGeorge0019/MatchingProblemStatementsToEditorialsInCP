{"link": "https://codeforces.com//contest/1194/problem/G", "problemId": "372221", "shortId": "1194G", "contest_number": "1194", "name": "G. Another Meme Problem", "statement": "Let's call a fraction  good if there exists at least one another fraction  such that , , the digit denoting  is contained in the decimal representation of , and the digit denoting  is contained in the decimal representation of . For example,  is a good fraction, because .You are given an integer number . Please calculate the number of good fractions  such that  and . The answer may be really large, so print it modulo .", "input": "The only line of the input contains one integer  ().", "output": "Print the number of good fractions  such that  and . The answer may be really large, so print it modulo .", "tutorial": "Let's fix an  fraction  such that . Obviously, each good fraction is equal to exactly one of such irreducible fractions. So if we iterate on  and , check that  and find the number of good fractions that are equal to , we will solve the problem.Okay, suppose we fixed  and . Any good fraction can be represented as , where  is some positive integer. Let's try all possible values of , and for them check whether they correspond to a good fraction.How do we try all values of  without iterating on them? Let's construct the decimal representation of  from the least significant digit to the most. As soon as we fix  least significant digits of , we know  least significant digits of  and . So let's try to use digit DP to try all possible values of .Which states do we have to consider? Of course, we need to know the number of digits we already placed, so that will be the first state. After we placed  digits, we know first  digits of the numerator of the fraction; but to get the value of digit , knowing only the value of the corresponding digit in  is not enough: there could be some value carried over after multiplying already placed digits by . For example, if , and we placed the first digit of  and it is , we know that the first (least significant) digit of  is , and we know that after fixing the second digit of  we should add  to it to get the value of this digit in , since  is carried over from the first digit. So, the second state of DP should represent the number that is carried over from the previous digit in the numerator, and the third state should do the same for the denominator.Okay, in order to know whether the fraction is good, we have to keep track of some digits in the numerator and denominator. If ,  and , then we have to keep track of the digit representing  in the numerator and the digit representing  in the denominator. So we have two additional states that represent the masks of \"interesting\" digits we met in the numerator and in the denominator.The only thing that's left to check is that both  and  are not greater than . Let's construct the decimal representation of  and prepend it with some leading zeroes; and keep constructing the numerator and the denominator until they have the same number of digits as the decimal representation as . Then we can compare the representation of, for example, numerator with the representation of  as strings. Comparing can be done with the following technique: let's keep a flag denoting whether the number represented by the least significant digits of the numerator is less or equal than the number represented by the same digits from . When we place another digit of the numerator, we can get the new value of this flag as follows: if new digit of the numerator is not equal to the corresponding digit of , then the value of the flag is defined by comparing this pair of digits; otherwise the value of the flag is the same as it was without this new digit. Of course, we should do the same for the denominator.Okay, now we can actually start coding this DP:  is the number of possible ways to put  least significant digits in  in such a way that:  the value carried over to the next digit of the numerator is  (and  for the denominator);   denotes whether the current numerator is less or equal to the number represented by  least significant digits of  ( does the same for the denominator);   denotes which \"interesting\" digits we already met in the numerator (of course,  does the same for the denominator). If you are feeling confident in your programming abilities, you can just start implementing this DP on a seven-dimensional array. I was too afraid to do it (but, looking at participants' solutions, I realize that it sounds much more scary than it looks in the code), so I decided to write the model solution using a structure representing each state, and a map to store all these structures. This is a common technique: when a dynamic programming solution you come up with has some really complex states and transitions, it is sometimes better to use some self-implemented structures to define these states and store them in a map or a hashmap. Some advantages of this technique are:  it's sometimes much easier to code (the code may be longer than the same solution with regular DP stored in a multi-dimensional array, but it's easier to write and understand this code);  if most states are unreachable, they won't even appear in our map, so we skip them altogether;  it is easy to add some optimizations related to reducing the number of states. For example, the number of different values for  and  may be too much, so we can use the following optimization: as soon as we find some pair of numbers in  and  that can represent  and , we can change these masks to some values that will mark that they are \"finished\" and stop updating them at all. ", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 105;\n\nint a[N];\nint n;\nint numPos[10], denPos[10];\nint num, den;\nconst int MOD = 998244353;\n\nstruct halfState\n{\n\tint carry;\n\tint mask;\n\tbool comp;\n\t\n\thalfState() {};\n\thalfState(int carry, int mask, bool comp) : carry(carry), mask(mask), comp(comp) {};\n};\n\nbool operator <(const halfState& x, const halfState& y)\n{\n\tif(x.carry != y.carry) return x.carry < y.carry;\n\tif(x.mask != y.mask) return x.mask < y.mask;\n\treturn x.comp < y.comp;\n}\n\nbool operator ==(const halfState& x, const halfState& y)\n{\n\treturn x.carry == y.carry && x.mask == y.mask && x.comp == y.comp;\n}\n\nbool operator !=(const halfState& x, const halfState& y)\n{\n\treturn x.carry != y.carry || x.mask != y.mask || x.comp != y.comp;\n}\n\nhalfState go(const halfState& s, int pos, int digit, bool isNum)\n{\n\tint newDigit = digit * (isNum ? num : den) + s.carry;\n\tint newCarry = newDigit / 10;\n\tnewDigit %= 10;\n\tint newMask = s.mask;\n\tint maskPos = (isNum ? numPos[newDigit] : denPos[newDigit]);\n\tif(maskPos != -1) newMask |= (1 << maskPos);\n\tbool newComp = (newDigit < a[pos]) || (newDigit == a[pos] && s.comp);\n\treturn halfState(newCarry, newMask, newComp);\n}\n\nstruct state\n{\n\thalfState numState;\n\thalfState denState;\n\t\n\tstate() {};\n\tstate(halfState numState, halfState denState) : numState(numState), denState(denState) {};\n\t\n\tvoid norm()\n\t{\n\t\tif(numState.mask & denState.mask)\n\t\t\tnumState.mask = denState.mask = 1;\n\t};\n\t\n\tbool valid()\n\t{\n\t\treturn bool(numState.mask & denState.mask) && numState.comp && denState.comp && (numState.carry == 0) && (denState.carry == 0);\n\t};\n};\n\nbool operator <(const state& x, const state& y)\n{\n\tif(x.numState != y.numState) return x.numState < y.numState;\n\treturn x.denState < y.denState;\n}\n\nstate go(const state& s, int pos, int digit)\n{\n\thalfState newNum = go(s.numState, pos, digit, true);\n\thalfState denNum = go(s.denState, pos, digit, false);\n\tstate res(newNum, denNum);\n\tres.norm();\n\treturn res;\n}\n\nint add(int x, int y)\n{\n\treturn (x + y) % MOD;\n}\n\nint ans = 0;\n\nvoid calcFixed(int x, int y)\n{\n\tnum = x;\n\tden = y;\n\tfor(int i = 0; i <= 9; i++)\n\t\tnumPos[i] = denPos[i] = -1;\n\tint cnt = 0;\n\tfor(int i = 1; i <= 9; i++)\n\t\tfor(int j = 1; j <= 9; j++)\n\t\t\tif(i * y == j * x)\n\t\t\t{\n\t\t\t\tnumPos[i] = denPos[j] = cnt++;\n\t\t\t}\n\tvector<map<state, int> > dp(102);\n\tdp[0][state(halfState(0, 0, true), halfState(0, 0, true))] = 1;\n\tfor(int i = 0; i <= 100; i++)\n\t\tfor(auto x : dp[i])\n\t\t{\n\t\t\tstate curState = x.first;\n\t\t\tint curCount = x.second;\n\t\t\tfor(int j = 0; j <= 9; j++)\n\t\t\t{\n\t\t\t\tstate newState = go(curState, i, j);\n\t\t\t\tdp[i + 1][newState] = add(dp[i + 1][newState], curCount);\n\t\t\t}\n\t\t}\n\tfor(auto x : dp[101])\n\t{\n\t\tstate curState = x.first;\n\t\tint curCount = x.second;\n\t\tif(curState.valid())\n\t\t\tans = add(ans, curCount);\n\t}\n}\n\nint main()\n{\n\tstring s;\n\tcin >> s;\n\tint len = s.size();\n\treverse(s.begin(), s.end());\n\tfor(int i = 0; i < len; i++)\n\t{\n\t\ta[i] = s[i] - '0';\n \t}\n \tfor(int i = 1; i <= 9; i++)\n \t\tfor(int j = 1; j <= 9; j++)\n \t\t\tif(__gcd(i, j) == 1)\n \t\t\t\tcalcFixed(i, j);\n \tcout << ans << endl;\n}", "interactive": false, "noSolution": false, "noTutorial": false}