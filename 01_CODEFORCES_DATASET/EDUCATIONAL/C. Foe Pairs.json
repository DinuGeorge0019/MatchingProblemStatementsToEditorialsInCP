{"link": "https://codeforces.com//contest/652/problem/C", "problemId": "52870", "shortId": "652C", "contest_number": "652", "name": "C. Foe Pairs", "statement": "You are given a permutation  of length . Also you are given  foe pairs  (). Your task is to count the number of different intervals  () that do not contain any foe pairs. So you shouldn't count intervals  that contain at least one foe pair in it (the positions and order of the values from the foe pair are not important).Consider some example:  and foe pairs are . The interval  is incorrect because it contains a foe pair . The interval  is also incorrect because it contains two foe pairs  and . But the interval  is correct because it doesn't contain any foe pair.", "input": "The first line contains two integers  and  () \u2014 the length of the permutation  and the number of foe pairs. The second line contains  distinct integers  () \u2014 the elements of the permutation . Each of the next  lines contains two integers  () \u2014 the -th foe pair. Note a foe pair can appear multiple times in the given list.", "output": "Print the only integer  \u2014 the number of different intervals  that does not contain any foe pairs. Note that the answer can be too large, so you should use -bit integer type to store it. In  you can use the  integer type and in  you can use  integer type.", "tutorial": "Let's precompute for each value  its position in permutation . It's easy to do in linear time. Consider some foe pair  (we may assume ). Let's store for each value  the leftmost position  such that  is a foe pair. Denote that value as . Now let's iterate over the array  from right to left and maintain the position  of the maximal correct interval with the left end in the current position . To maintain the value  we should simply take the minimum with the value : . And finally we should increment the answer by the value .\n", "solution": "const int N = 300300;\n\nint n, m;\nint p[N];\npt b[N];\n\nbool read() {\n\tif (!(cin >> n >> m)) return false;\n\tforn(i, n) {\n\t\tassert(scanf(\"%d\", &p[i]) == 1);\n\t\tp[i]--;\n\t}\n\tforn(i, m) {\n\t\tint x, y;\n\t\tassert(scanf(\"%d%d\", &x, &y) == 2);\n\t\tx--, y--;\n\t\tb[i] = pt(x, y);\n\t}\n\treturn true;\n}\n\nint pos[N];\nvector<int> z[N];\n\nvoid solve() {\n\tforn(i, n) pos[p[i]] = i;\n\tforn(i, n) z[i].clear();\n\tforn(i, m) {\n\t\tint x = pos[b[i].x], y = pos[b[i].y];\n\t\tif (x > y) swap(x, y);\n\t\tz[x].pb(y);\n\t}\n\n\tli ans = 0;\n\tint rg = n;\n\tnfor(i, n) {\n\t\tforn(j, sz(z[i])) rg = min(rg, z[i][j]);\n\t\tans += rg - i;\n\t}\n\tcout << ans << endl;\n}", "interactive": false, "noSolution": false, "noTutorial": false}