{"link": "https://codeforces.com//contest/1709/problem/C", "problemId": "1473246", "shortId": "1709C", "contest_number": "1709", "name": "C. Recover an RBS", "statement": "A bracket sequence is a string containing only characters \"\" and \"\". A regular bracket sequence (or, shortly, an RBS) is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters \"\" and \"\" between the original characters of the sequence. For example:  bracket sequences \"\" and \"\" are regular (the resulting expressions are: \"\" and \"\");  bracket sequences \"\", \"\" and \"\" are not. There was an RBS. Some brackets have been replaced with question marks. Is it true that there is a  way to replace question marks with brackets, so that the resulting sequence is an RBS?", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of testcases. The only line of each testcase contains an RBS with some brackets replaced with question marks. Each character is either '', '' or ''. At least one RBS can be recovered from the given sequence. The total length of the sequences over all testcases doesn't exceed .", "output": "For each testcase, print \"\" if the way to replace question marks with brackets, so that the resulting sequence is an RBS, is . If there is more than one way, then print \"\".", "tutorial": "There are many different approaches to this problem, but I think the model solution has the most elegant one.First of all, let's construct an RBS from the given string (it always exists, so it is always possible). By calculating the number of opening brackets, closing brackets and questions in the given string, we can compute the number of question marks that should be replaced with opening brackets (it is easy since exactly half of the characters in each RBS are opening brackets). Then, let's form the RBS greedily: replace the first several question marks with opening brackets, and all remaining ones with closed brackets.Okay, then what about finding a second RBS? Recall that a bracket sequence is an RBS when for each of its positions, the number of closing brackets before it is not greater than the number of opening brackets before it (and these two values should be equal at the end of the sequence, but it is less important now). Consider the segment between the last question mark replaced with an opening bracket, and the first question mark replaced by the closing bracket. If we try to change the order of characters corresponding to question marks, the balance on this segment will decrease at least by  (since at least one opening bracket to the left of it will become a closing bracket). Is there a way to affect only this segment, and change the balance on it only by ? Yes \u2014 just swap the endpoints of this segment (i.\u2009e. the last opening bracket that was a question mark and the first closing bracket that was also a question mark). If it yields an RBS, then the answer is . Otherwise, the answer is  since any other permutation of characters that were replacing question marks will also decrease the balance on this segment by at least .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  auto check = [](const string& s) {\n    int bal = 0;\n    for (char c : s) {\n      if (c == '(') ++bal;\n      if (c == ')') --bal;\n      if (bal < 0) return false;\n    }\n    return bal == 0;\n  };\n  \n  ios::sync_with_stdio(false); cin.tie(0);\n  int t;\n  cin >> t;\n  while (t--) {\n    string s;\n    cin >> s;\n    vector<int> pos;\n    int op = s.size() / 2, cl = s.size() / 2;\n    for (int i = 0; i < s.size(); ++i) {\n      if (s[i] == '?') pos.push_back(i);\n      if (s[i] == '(') --op;\n      if (s[i] == ')') --cl;\n    }\n    for (int i = 0; i < pos.size(); ++i) {\n      if (i < op) s[pos[i]] = '(';\n      else s[pos[i]] = ')';\n    }\n    bool ok = true;\n    if (op > 0 && cl > 0) {\n      swap(s[pos[op - 1]], s[pos[op]]);\n      if (check(s)) ok = false;\n    }\n    cout << (ok ? \"YES\\n\" : \"NO\\n\");\n  }\n} ", "interactive": false, "noSolution": false, "noTutorial": false}