{"link": "https://codeforces.com//contest/1398/problem/F", "problemId": "699506", "shortId": "1398F", "contest_number": "1398", "name": "F. Controversial Rounds", "statement": "Alice and Bob play a game. The game consists of several sets, and each set consists of several rounds. Each round is won either by Alice or by Bob, and the set ends when one of the players has won  rounds in a row. For example, if Bob won five rounds in a row and , then two sets ends.You know that Alice and Bob have already played  rounds, and you know the results of some rounds. For each  from  to , calculate the maximum possible number of sets that could have already finished if each set lasts until one of the players wins  rounds in a row. It is possible that the last set is still not finished \u2014 in that case, you should not count it in the answer.", "input": "The first line contains one integer  ()\u00a0\u2014 the number of rounds. The second line contains one string  of length  \u2014 the descriptions of rounds. If the -th element of the string is , then Alice won the -th round; if it is , then Bob won the -th round, and if it is , then you don't know who won the -th round.", "output": "In the only line print  integers. The -th integer should be equal to the maximum possible number of sets that could have already finished if each set lasts until one of the players wins  rounds in a row.", "tutorial": "Let's consider the following function : minimum index  such that there is a substring of string  of length  consisting of only characters  and  or  and . If this function has asymptotic  then we can solve problem for .Now, let's precalculate two array  and ;  is equal the maximum integer  such that substring  consist only characters  and .  is equal the maximum integer  such that substring  consist only characters  and . Also let's precalculate the arrays  and  of size ;  contain all positions  such that substring  consist only characters  and  and  or ;  contain all positions  such that substring  consist only characters  and  and  or . After that let's solve problem for some . Suppose, that now we already processed first  elements of . If  or  then we increase the answer and change . Otherwise we have to find the minimum element (denote this element as ) in  or  such that . If there is no such element then we found the final answer . Otherwise let's increase answer and change  and continue this algorithm.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(1e6) + 99;\nconst int INF = int(1e9) + 99;\n\nint n;\nstring s;\nvector <int> p[2][N];\nint nxt[2][N];\nint ptr[2];\nchar buf[N];\n\nint main(){\n    cin >> n >> s;\n    \n    for (int i = n - 1; i >= 0; --i) {\n        if (s[i] != '0') nxt[0][i] = 1 + nxt[0][i + 1];\n        if (s[i] != '1') nxt[1][i] = 1 + nxt[1][i + 1];\n    }\n    \n    for (int b = 0; b <= 1; ++b) {\n        int l = 0;\n        while (l < n) {\n            if (s[l] == char('0' + b)) {\n                ++l;\n                continue;\n            }\n            int r = l + 1;\n            while (r < n && s[r] != char('0' + b)) ++r;\n            for (int len = 1; len <= r - l; ++len)\n                p[b][len].push_back(l);\n            l = r;\n        }\n    }\n\n    for (int len = 1; len <= n; ++len) {\n        int pos = 0, res = 0;\n        ptr[0] = ptr[1] = 0;\n        \n        while (pos < n) {\n            int npos = INF;\n            for (int b = 0; b <= 1; ++b) {\n                if (nxt[b][pos] >= len) \n                    npos = min(npos, pos + len);\n                while (ptr[b] < p[b][len].size() && pos > p[b][len][ ptr[b] ]) \n                    ++ptr[b];\n                if (ptr[b] < p[b][len].size()) \n                    npos = min(npos, p[b][len][ ptr[b] ] + len);\n            }\n            if (npos != INF) \n                ++res;\n            pos = npos;\n        }\n        \n        cout << res << ' ';\n    }\n    cout << endl;\n    \n    return 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}