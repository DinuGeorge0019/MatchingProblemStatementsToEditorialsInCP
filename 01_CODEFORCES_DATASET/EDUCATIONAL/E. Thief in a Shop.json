{"link": "https://codeforces.com//contest/632/problem/E", "problemId": "50147", "shortId": "632E", "contest_number": "632", "name": "E. Thief in a Shop", "statement": "A thief made his way to a shop.As usual he has his lucky knapsack with him. The knapsack can contain  objects. There are  kinds of products in the shop and an infinite number of products of each kind. The cost of one product of kind  is .The thief is greedy, so he will take exactly  products (it's possible for some kinds to take several products of that kind).Find all the possible total costs of products the thief can nick into his knapsack.", "input": "The first line contains two integers  and  () \u2014 the number of kinds of products and the number of products the thief will take. The second line contains  integers  () \u2014 the costs of products for kinds from  to .", "output": "Print the only line with all the possible total costs of stolen products, separated by a space. The numbers should be printed in the ascending order.", "tutorial": "Let , then it is the standard problem which can be solved by FFT (Fast Fourier Transform). The solution is the following: consider the polynomial which the -th coefficient equals to one if and only if there is the number  in the given array. Let's multiply that polynomial by itself and find  for which the coefficient in square not equals to . Those values  will be in the answer. Easy to modificate the solution for the arbitrary . We should simply calculate the -th degree of the polynomial. The complexity will be , where  is the maximal sum.\nWe can improve that solution. Instead of calculating the -th degree of the polynomial we can calculate the -th degree of the DFT of the polynomial. The only problem is the large values of the -th degrees. We can't use FFT with complex numbers, because of the precision problems. But we can do that with NTT (Number-theoretic transform). But that solution also has a problem. It can happen that some coefficients became equals to zero modulo , but actually they are not equal to zero. To get round that problem we can choose two-three random modules and get the complexity .\nThe main author solution has the complexity  (FFT with complex numbers), the second solution has the same complexity, but uses NTT and the third solution has the improved complexity (but it was already hacked by halyavin).\n", "solution": "\n            #include <bits/stdc++.h>\n\u00a0\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n#define nfor(i, n) for (int i = int(n) - 1; i >= 0; i--)\n#define fore(i, l, r) for (int i = int(l); i < int(r); i++)\n#define correct(x, y, n, m) (0 <= (x) && (x) < (n) && 0 <= (y) && (y) < (m))\n#define all(a) (a).begin(), (a).end()\n#define sz(a) int((a).size())\n#define pb(a) push_back(a)\n#define mp(x, y) make_pair((x), (y))\n#define x first\n#define y second\n\u00a0\nusing namespace std;\n\u00a0\ntypedef long long li;\ntypedef double ld;\ntypedef pair<int, int> pt;\n\u00a0\ntemplate<typename X> inline X abs(const X& a) { return a < 0? -a: a; }\ntemplate<typename X> inline X sqr(const X& a) { return a * a; }\n\u00a0\ntemplate<typename A, typename B> inline ostream& operator<< (ostream& out, const pair<A, B>& p) { return out << \"(\" << p.x << \", \" << p.y << \")\"; }\ntemplate<typename T> inline ostream& operator<< (ostream& out, const vector<T>& a) { out << \"[\"; forn(i, sz(a)) { if (i) out << ','; out << ' ' << a[i]; } return out << \" ]\"; } \ntemplate<typename T> inline ostream& operator<< (ostream& out, const set<T>& a) { return out << vector<T>(all(a)); }\n\u00a0\ninline ld gett() { return ld(clock()) / CLOCKS_PER_SEC; }\n\u00a0\nconst int INF = int(1e9);\nconst li INF64 = li(1e18);\nconst ld EPS = 1e-9, PI = 3.1415926535897932384626433832795;\n\u00a0\nint n, k;\nvector<int> a;\n\u00a0\nbool read() {\n\u00a0 \u00a0 if (!(cin >> n >> k)) return false;\n\u00a0 \u00a0 a.resize(n);\n\u00a0 \u00a0 forn(i, n) assert(scanf(\"%d\", &a[i]) == 1);\n\u00a0 \u00a0 return true;\n}\n\u00a0\nstruct base {\n\u00a0 \u00a0 ld re, im;\n\u00a0 \u00a0 base() { }\n\u00a0 \u00a0 base(ld re, ld im): re(re), im(im) { }\n\u00a0 \u00a0 ld slen() const { return sqr(re) + sqr(im); }\n\u00a0 \u00a0 ld real() { return re; }\n};\n\u00a0\ninline base conj(const base& a) { return base(a.re, -a.im); }\ninline base operator+ (const base& a, const base& b) { return base(a.re + b.re, a.im + b.im); }\ninline base operator- (const base& a, const base& b) { return base(a.re - b.re, a.im - b.im); }\ninline base operator* (const base& a, const base& b) { return base(a.re * b.re - a.im * b.im, a.re * b.im + a.im * b.re); }\ninline base operator/ (const base& a, const ld& b) { return base(a.re / b, a.im / b); }\ninline base operator/ (const base& a, const base& b) { return base(a.re * b.re + a.im * b.im, a.im * b.re - a.re * b.im) / b.slen(); }\ninline base& operator/= (base& a, const ld& b) { a.re /= b, a.im /= b; return a; }\n\u00a0\nint reverse(int x, int logn) {\n\u00a0 \u00a0 int ans = 0;\n\u00a0 \u00a0 forn(i, logn) if (x & (1 << i)) ans |= 1 << (logn - 1 - i);\n\u00a0 \u00a0 return ans;\n}\n\u00a0\nconst int LOGN = 20, N = (1 << LOGN) + 3;\nvoid fft(base a[N], int n, bool inv) {\n\u00a0 \u00a0 static base vv[LOGN][N];\n\u00a0 \u00a0 static bool prepared = false;\n\u00a0 \u00a0 if (!prepared) {\n\u00a0 \u00a0 \u00a0 \u00a0 prepared = true;\n\u00a0 \u00a0 \u00a0 \u00a0 forn(i, LOGN) {\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ld ang = 2 * PI / (1 << (i + 1));\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 forn(j, 1 << i) vv[i][j] = base(cos(ang * j), sin(ang * j));\n\u00a0 \u00a0 \u00a0 \u00a0 }\n\u00a0 \u00a0 }\n\u00a0 \u00a0 int logn = 0; while ((1 << logn) < n) logn++;\n\u00a0 \u00a0 forn(i, n) {\n\u00a0 \u00a0 \u00a0 \u00a0 int ni = reverse(i, logn);\n\u00a0 \u00a0 \u00a0 \u00a0 if (i < ni) swap(a[i], a[ni]);\n\u00a0 \u00a0 }\n\u00a0 \u00a0 for (int i = 0; (1 << i) < n; i++)\n\u00a0 \u00a0 \u00a0 \u00a0 for (int j = 0; j < n; j += (1 << (i + 1)))\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 for (int k = j; k < j + (1 << i); k++) {\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 base cur = inv ? conj(vv[i][k - j]) : vv[i][k - j];\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 base l = a[k], r = cur * a[k + (1 << i)];\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 a[k] = l + r;\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 a[k + (1 << i)] = l - r;\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\n\u00a0 \u00a0 if (inv) forn(i, n) a[i] /= ld(n);\n}\n\u00a0\nvoid mul(int a[N], int b[N], int ans[N]) {\n\u00a0 \u00a0 static base fp[N], p1[N], p2[N];\n\u00a0 \u00a0 int n = 1 << LOGN, m = 1 << LOGN;\n\u00a0 \u00a0 while (n && !a[n - 1]) n--;\n\u00a0 \u00a0 while (m && !b[m - 1]) m--;\n\u00a0 \u00a0 int cnt = n + m;\n\u00a0 \u00a0 while (cnt & (cnt - 1)) cnt++;\n\u00a0 \u00a0 if (cnt > (1 << LOGN)) return;\n\u00a0 \u00a0 \n\u00a0 \u00a0 forn(i, cnt) fp[i] = base(a[i], b[i]);\n\u00a0 \u00a0 fft(fp, cnt, false);\n\u00a0 \u00a0 forn(i, cnt) {\n\u00a0 \u00a0 \u00a0 \u00a0 p1[i] = (fp[i] + conj(fp[(cnt - i) % cnt])) / base(2, 0);\n\u00a0 \u00a0 \u00a0 \u00a0 p2[i] = (fp[i] - conj(fp[(cnt - i) % cnt])) / base(0, 2);\n\u00a0 \u00a0 }\n\u00a0 \u00a0 forn(i, cnt) fp[i] = p1[i] * p2[i];\n\u00a0 \u00a0 fft(fp, cnt, true);\n\u00a0\n\u00a0 \u00a0 forn(i, cnt) ans[i] = int(fp[i].real() + 0.5);\n}\n\u00a0\nvoid mul(int* a, int* b) {\n\u00a0 \u00a0 forn(i, 1 << LOGN) {\n\u00a0 \u00a0 \u00a0 \u00a0 a[i] = !!a[i];\n\u00a0 \u00a0 \u00a0 \u00a0 b[i] = !!b[i];\n\u00a0 \u00a0 }\n\u00a0 \u00a0 mul(a, b, a);\n}\n\u00a0\nvoid binPow(int* a, int b) {\n\u00a0 \u00a0 static int ans[N];\n\u00a0 \u00a0 forn(i, 1 << LOGN) ans[i] = !i;\n\u00a0 \u00a0 while (b) {\n\u00a0 \u00a0 \u00a0 \u00a0 if (b & 1) mul(ans, a);\n\u00a0 \u00a0 \u00a0 \u00a0 mul(a, a);\n\u00a0 \u00a0 \u00a0 \u00a0 b >>= 1;\n\u00a0 \u00a0 }\n\u00a0 \u00a0 forn(i, 1 << LOGN) a[i] = ans[i];\n}\n\u00a0\nvoid solve() {\n\u00a0 \u00a0 static int ans[N];\n\u00a0 \u00a0 memset(ans, 0, sizeof(ans));\n\u00a0 \u00a0 forn(i, sz(a)) ans[a[i]] = 1;\n\u00a0\n\u00a0 \u00a0 binPow(ans, k);\n\u00a0\n\u00a0 \u00a0 bool f = true;\n\u00a0 \u00a0 forn(i, 1 << LOGN)\n\u00a0 \u00a0 \u00a0 \u00a0 if (ans[i]) {\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if (f) f = false;\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 else putchar(' ');\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 printf(\"%d\", i);\n\u00a0 \u00a0 \u00a0 \u00a0 }\n\u00a0 \u00a0 puts(\"\");\n}\n\u00a0\nint main() {\n#ifdef SU1\n\u00a0 \u00a0 assert(freopen(\"input.txt\", \"rt\", stdin));\n\u00a0 \u00a0 //assert(freopen(\"output.txt\", \"wt\", stdout));\n#endif\n\u00a0 \u00a0 \n\u00a0 \u00a0 cout << setprecision(10) << fixed;\n\u00a0 \u00a0 cerr << setprecision(5) << fixed;\n\u00a0\n\u00a0 \u00a0 while (read()) {\n\u00a0 \u00a0 \u00a0 \u00a0 ld stime = gett();\n\u00a0 \u00a0 \u00a0 \u00a0 solve();\n\u00a0 \u00a0 \u00a0 \u00a0 cerr << \"Time: \" << gett() - stime << endl;\n\u00a0 \u00a0 \u00a0 \u00a0 //break;\n\u00a0 \u00a0 }\n\u00a0 \u00a0 \n\u00a0 \u00a0 return 0;\n}\n        ", "interactive": false, "noSolution": false, "noTutorial": false}