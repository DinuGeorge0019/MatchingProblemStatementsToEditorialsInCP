{"link": "https://codeforces.com//contest/1792/problem/C", "problemId": "1749561", "shortId": "1792C", "contest_number": "1792", "name": "C. Min Max Sort", "statement": "You are given a permutation  of length  (a permutation of length  is an array of length  in which each integer from  to  occurs exactly once).You can perform the following operation any number of times (possibly zero):   choose two different elements  and  and erase them from the permutation;  insert the minimum of  and  into the permutation in such a way that it becomes the first element;  insert the maximum of  and  into the permutation in such a way that it becomes the last element. For example, if  and we want to apply the operation to the elements  and , then after the first step of the operation, the permutation becomes ; and after we insert the elements, it becomes .Your task is to calculate the minimum number of operations described above to sort the permutation  in ascending order (i.\u2009e. transform  so that ).", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of test cases. The first line of the test case contains a single integer  ()\u00a0\u2014 the number of elements in the permutation. The second line of the test case contains  distinct integers from  to \u00a0\u2014 the given permutation . The sum of  over all test cases doesn't exceed .", "output": "For each test case, output a single integer\u00a0\u2014 the minimum number of operations described above to sort the array  in ascending order.", "tutorial": "If the array is already sorted, then the answer is . Otherwise, there is a last operation, after which the permutation takes the form . Which means that the elements  and  are selected as the last operation (because they are at the first and last positions after the operation). Now we know that the last operation is  and it doesn't matter where exactly these numbers are in the permutation, i.\u2009e. we can assume that the answer has increased by , and consider only the numbers 1. Similarly, for the \"remaining\" permutation, there are two options, either it is sorted, and then the answer is , or there is a last operation and the numbers  and  are used in it. And so on until the \"remaining\" permutation is sorted or empty.It remains to find out how to quickly check whether the numbers in the segment  are sorted (they go in the correct order in the initial permutation). Note that this segment corresponds to values of elements, not to positions in the permutation. If this segment is sorted for some , then the answer does not exceed .There are several ways to check, let's consider one of them. Note that if the segment  is sorted for some value , then it will be sorted for large values as well. So we can start with the maximum value of  (which is equal to ) and decrease it until the segment remains sorted. Now for each  we need only two checks that  <  and  > , where  is the position of the element  in the permutation.Thus, we got the solution in linear time.Another way is to run binary search on  since if the numbers in  appear in the permutation in sorted order, the same holds for . This approach yields a solution in .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    vector<int> pos(n + 1);\n    for (int i = 0; i < n; ++i) {\n      int x;\n      cin >> x;\n      pos[x] = i;\n    }\n    int l = (n + 1) / 2, r = (n + 2) / 2;\n    while (l > 0 && (l == r || (pos[l] < pos[l + 1] && pos[r - 1] < pos[r]))) {\n      --l;\n      ++r;\n    }\n    cout << (n - r + l + 1) / 2 << '\\n';\n  }\n}", "interactive": false, "noSolution": false, "noTutorial": false}