{"link": "https://codeforces.com//contest/1569/problem/F", "problemId": "1103184", "shortId": "1569F", "contest_number": "1569", "name": "F. Palindromic Hamiltonian Path", "statement": "You are given a simple undirected graph with  vertices,  is even. You are going to write a letter on each vertex. Each letter should be one of the first  letters of the Latin alphabet.A path in the graph is called Hamiltonian if it visits each vertex exactly once. A string is called palindromic if it reads the same from left to right and from right to left. A path in the graph is called palindromic if the letters on the vertices in it spell a palindromic string without changing the order.A string of length  is good if:   each letter is one of the first  lowercase Latin letters;  if you write the -th letter of the string on the -th vertex of the graph, there will exist a palindromic Hamiltonian path in the graph. Note that the path doesn't necesserily go through the vertices in order .Count the number of good strings.", "input": "The first line contains three integers ,  and  (;  is even; ; )\u00a0\u2014 the number of vertices in the graph, the number of edges in the graph and the number of first letters of the Latin alphabet that can be used. Each of the next  lines contains two integers  and  (; )\u00a0\u2014 the edges of the graph. The graph doesn't contain multiple edges and self-loops.", "output": "Print a single integer\u00a0\u2014 number of good strings.", "tutorial": "Let's start with making some implications from the low constraints.What's the upper estimate on the number of answers? . Too high, let's think of a better one. Using some combinatorics, we can normalize the answers in such a way that there are at most -th Bell's number of them. The method basically defines the components of equal letters. Given a string, we write down the letters in it in the order they appear for the first time in the string and rename the first of them to '', the second one to '' and so on. Only  possible answers already. Hmm, but we should also have an even amount of each letter. That is the absolute lowest estimate, and it's equal to about .What does it exactly mean for a string to be good? There exists a path such that: there's a pair of equal letters that occupy the -st and the -th vertex in the path, a pair on the -nd and -th and so on.So for each of  possible answers, we want to determine if there's a way to split the groups of equal letters into pairs of equal letters such that there exists a path through these pairs. Such a path would mean building a palindrome from inside out.A quick estimation on a number of splittings into pairs. The first letter can be matched against  other letters, the first among the unmatched ones\u00a0\u2014 against  other letters and so on. Thus, it's equal to .For each splitting into pairs, we can determine if there exists a path. That is a straightforward dynamic programming similar to a usual hamiltonian path search. It stores a mask of visited  and the last visited pair. For a transition, you want to either go from the first vertex of one pair to the first vertex of another one and from the second to the second, or the other way around. That would take  for each splitting.The only thing left is to propagate the results from the splitting into pairs to splitting into even sized components of equal letters. A splitting into pairs is a splitting into components of size . Let that be a base case for the dp. For every splitting into components, find a component of size at least  (we still have to split it into pairs) and separate it into a component of size  (a pair) and the rest of the component. Moreover, a pair can always be chosen in such a way that one of its elements is the first element of the component. So there are  states and at most  transitions from each of them.Maybe there's a more convenient way to store the states, but the one I found to be fast enough is hashing the state into a base- integer (since there are no more than  components, numbered  through ) and storing it in a map/hashmap.", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nvector<vector<char>> g;\nmap<long long, bool> dp;\n\nvoid brute(int n, vector<int> &p){\n\tint x = find(p.begin(), p.end(), -1) - p.begin();\n\tif (x == int(p.size())){\n\t\tvector<vector<char>> dp2(1 << n, vector<char>(n));\n\t\tvector<int> pos1(n), pos2(n);\n\t\tforn(i, p.size()){\n\t\t\tpos1[p[i]] = pos2[p[i]];\n\t\t\tpos2[p[i]] = i;\n\t\t}\n\t\tforn(i, n) if (g[pos1[i]][pos2[i]]) dp2[1 << i][i] = true;\n\t\tforn(mask, 1 << n) forn(i, n) if (dp2[mask][i]){\n\t\t\tforn(j, n) if (!((mask >> j) & 1)){\n\t\t\t\tdp2[mask | (1 << j)][j] |= (g[pos1[i]][pos1[j]] && g[pos2[i]][pos2[j]]);\n\t\t\t\tdp2[mask | (1 << j)][j] |= (g[pos1[i]][pos2[j]] && g[pos2[i]][pos1[j]]);\n\t\t\t}\n\t\t}\n\t\tforn(i, n) if (dp2[(1 << n) - 1][i]){\n\t\t\tlong long num = 0;\n\t\t\tfor (int x : p) num = num * 6 + x;\n\t\t\tdp[num] = true;\n\t\t\tbreak;\n\t\t}\n\t\treturn;\n\t}\n\tfor (int y = x + 1; y < int(p.size()); ++y) if (p[y] == -1){\n\t\tp[x] = p[y] = n;\n\t\tbrute(n + 1, p);\n\t\tp[x] = p[y] = -1;\n\t}\n}\n\nbool dfs(vector<int> p){\n\tvector<int> used(int(p.size()), -1);\n\tint cnt = 0;\n\tforn(i, p.size()) if (used[p[i]] == -1)\n\t\tused[p[i]] = cnt++;\n\tlong long num = 0;\n\tfor (int& x : p){\n\t\tx = used[x];\n\t\tnum = num * 6 + x;\n\t}\n\tif (dp.count(num)) return dp[num];\n\tbool res = false;\n\tvector<int> cur(cnt);\n\tforn(i, p.size()) ++cur[p[i]];\n\tforn(i, p.size()) if (cur[p[i]] > 2){\n\t\tint x = p[i];\n\t\tfor (int j = i + 1; j < int(p.size()); ++j) if (p[j] == p[i]){\n\t\t\tp[i] = p[j] = cnt;\n\t\t\tif (dfs(p)){\n\t\t\t\tres = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tp[i] = p[j] = x;\n\t\t}\n\t\tbreak;\n\t}\n\treturn dp[num] = res;\n}\n\nvoid brute2(int n, vector<int> &p){\n\tint x = find(p.begin(), p.end(), -1) - p.begin();\n\tif (x == int(p.size())){\n\t\tdfs(p);\n\t\treturn;\n\t}\n\tforn(i, n + 1){\n\t\tfor (int y = x + 1; y < int(p.size()); ++y) if (p[y] == -1){\n\t\t\tp[x] = p[y] = i;\n\t\t\tbrute2(max(n, i + 1), p);\n\t\t\tp[x] = p[y] = -1;\n\t\t}\n\t}\n}\n\nint main() {\n\tint n, m, k;\n\tscanf(\"%d%d%d\", &n, &m, &k);\n\tg.resize(n, vector<char>(n));\n\tforn(_, m){\n\t\tint v, u;\n\t\tscanf(\"%d%d\", &v, &u);\n\t\t--v, --u;\n\t\tg[v][u] = g[u][v] = 1;\n\t}\n\tvector<int> cur(n, -1);\n\tbrute(0, cur);\n\tbrute2(0, cur);\n\tvector<long long> fact(k + 1);\n\tfact[0] = 1;\n\tfor (int i = 1; i <= k; ++i) fact[i] = fact[i - 1] * i;\n\tlong long ans = 0;\n\tfor (auto it : dp) if (it.second){\n\t\tlong long num = it.first;\n\t\tlong long mx = 1;\n\t\twhile (num){\n\t\t\tmx = max(mx, num % 6 + 1);\n\t\t\tnum /= 6;\n\t\t}\n\t\tif (mx <= k){\n\t\t\tans += fact[k] / fact[k - mx];\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}