{"link": "https://codeforces.com//contest/1709/problem/D", "problemId": "1473247", "shortId": "1709D", "contest_number": "1709", "name": "D. Rorororobot", "statement": "There is a grid, consisting of  rows and  columns. The rows are numbered from  to  from bottom to top. The columns are numbered from  to  from left to right. The -th column has the bottom  cells blocked (the cells in rows ), the remaining  cells are unblocked.A robot is travelling across this grid. You can send it commands\u00a0\u2014 move up, right, down or left. If a robot attempts to move into a blocked cell or outside the grid, it explodes.However, the robot is broken\u00a0\u2014 it executes each received command  times. So if you tell it to move up, for example, it will move up  times ( cells). You can't send it commands while the robot executes the current one.You are asked  queries about the robot. Each query has a start cell, a finish cell and a value . Can you send the robot an arbitrary number of commands (possibly, zero) so that it reaches the finish cell from the start cell, given that it executes each command  times?The robot must stop in the finish cell. If it visits the finish cell while still executing commands, it doesn't count.", "input": "The first line contains two integers  and  (; )\u00a0\u2014 the number of rows and columns of the grid. The second line contains  integers  ()\u00a0\u2014 the number of blocked cells on the bottom of the -th column. The third line contains a single integer  ()\u00a0\u2014 the number of queries. Each of the next  lines contain five integers  and  (; ; ; ; )\u00a0\u2014 the row and the column of the start cell, the row and the column of the finish cell and the number of times each your command is executed. The start and the finish cell of each query are unblocked.", "output": "For each query, print \"\" if you can send the robot an arbitrary number of commands (possibly, zero) so that it reaches the finish cell from the start cell, given that it executes each command  times. Otherwise, print \"\".", "tutorial": "What if there were no blocked cells? Then the movement is easy. From cell  we can go to cells , ,  or . Thus, we can visit all cells that have the same remainder modulo  over both dimensions. The answer would be \"\" if  and .Let's choose the following path from start to finish. Let  be less or equal to . If that isn't the case, swap the cells. First, move up until the row is the same, then move to the side until the column is the same.What stops us from doing the same on a grid with blocked cells? The first part of the part can remain the same\u00a0\u2014 we can always move up from the cell. Only cells below the start cell can be blocked. The second part is trickier. If there is a column with too many blocked cells between the start and the finish column, then we won't be able to pass through it.Let's adjust the path for that. Move up as high as possible\u00a0\u2014 to the highest cell with the same remainder modulo  in this column. Then move to the finish column and go down to the finish cell.If there still exists a column with too many blocked cells, then the answer is \"\". No matter what we do, we won't be able to go around that column. Otherwise, the answer is \"\".Thus, the solution is to check for remainders, then find the largest number of blocked cells between the query columns and compare it to the highest row with the same remainder modulo  as the start or the finish. You can use any RMQ data structure you want.Overall complexity:  with sparse table for RMQ, for example.", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nint main() {\n\tint n, m;\n\tscanf(\"%d%d\", &n, &m);\n\tvector<int> a(m);\n\tforn(i, m) scanf(\"%d\", &a[i]);\n\t\n\tint l = 0;\n\twhile ((1 << l) <= m) ++l;\n\tvector<vector<int>> st(l, vector<int>(m));\n\tforn(i, m) st[0][i] = a[i];\n\tfor (int j = 1; j < l; ++j) forn(i, m){\n\t\tst[j][i] = st[j - 1][i];\n\t\tif (i + (1 << (j - 1)) < m)\n\t\t\tst[j][i] = max(st[j][i], st[j - 1][i + (1 << (j - 1))]);\n\t}\n\tvector<int> pw(m + 1, 0);\n\tfor (int i = 2; i <= m; ++i) pw[i] = pw[i / 2] + 1;\n\tauto get = [&](int l, int r){\n\t\tif (l > r) swap(l, r);\n\t\t++r;\n\t\tint len = pw[r - l];\n\t\treturn max(st[len][l], st[len][r - (1 << len)]);\n\t};\n\t\n\tint q;\n\tscanf(\"%d\", &q);\n\tforn(_, q){\n\t\tint xs, ys, xf, yf, k;\n\t\tscanf(\"%d%d%d%d%d\", &xs, &ys, &xf, &yf, &k);\n\t\t--xs, --ys, --xf, --yf;\n\t\tif (ys % k != yf % k || xs % k != xf % k){\n\t\t\tputs(\"NO\");\n\t\t\tcontinue;\n\t\t}\n\t\tint mx = (n - xs - 1) / k * k + xs;\n\t\tputs(get(ys, yf) <= mx ? \"YES\" : \"NO\");\n\t}\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}