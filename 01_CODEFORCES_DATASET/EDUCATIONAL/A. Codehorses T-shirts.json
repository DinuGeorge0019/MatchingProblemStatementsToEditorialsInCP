{"link": "https://codeforces.com//contest/1000/problem/A", "problemId": "193654", "shortId": "1000A", "contest_number": "1000", "name": "A. Codehorses T-shirts", "statement": "Codehorses has just hosted the second Codehorses Cup. This year, the same as the previous one, organizers are giving T-shirts for the winners.The valid sizes of T-shirts are either  or from  to   followed by  or . For example, sizes , , ,  are valid and , ,  are not.There are  winners to the cup for both the previous year and the current year. Ksenia has a list with the T-shirt sizes printed for the last year cup and is yet to send the new list to the printing office. Organizers want to distribute the prizes as soon as possible, so now Ksenia is required not to write the whole list from the scratch but just make some changes to the list of the previous year. In one second she can choose arbitrary position in any word and replace its character with some uppercase Latin letter. Ksenia can't remove or add letters in any of the words.What is the minimal number of seconds Ksenia is required to spend to change the last year list to the current one?. That means, two lists are considered equal if and only if the number of occurrences of any string is the same in both lists.", "input": "The first line contains one integer  () \u2014 the number of T-shirts. The -th of the next  lines contains  \u2014 the size of the -th T-shirt of the list for the previous year. The -th of the next  lines contains  \u2014 the size of the -th T-shirt of the list for the current year. It is guaranteed that all the sizes in the input are valid. It is also guaranteed that Ksenia can produce list  from the list .", "output": "Print the minimal number of seconds Ksenia is required to spend to change the last year list to the current one. If the lists are already equal, print .", "tutorial": "At first, let's remove all coinciding entries of both lists. The most convinient way is to use map/hashmap but it's not the only option. Now divide entries into categories by their length. You can notice that it takes exactly one second to remove an entry in each category (to make it equal to an entry of the opposing list). Thus the answer is .Overall complexity:  or .", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\n\nint main() {\n\tint n;\n\tcin >> n;\n\t\n\tvector<string> a(n), b(n);\n\tforn(i, n) cin >> a[i];\n\tforn(i, n) cin >> b[i];\n\t\n\tmap<string, int> cnta, cntb;\n\tforn(i, n) ++cnta[a[i]];\n\tforn(i, n) ++cntb[b[i]];\n\t\n\tint ans = n;\n\tfor (auto it : cnta) ans -= min(it.second, cntb[it.first]);\n\t\n\tcout << ans << endl;\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}