{"link": "https://codeforces.com//contest/1728/problem/G", "problemId": "1534228", "shortId": "1728G", "contest_number": "1728", "name": "G. Illumination", "statement": "Consider a segment  of the coordinate line. There are  lanterns and  points of interest in this segment.For each lantern, you can choose its power \u2014 an integer between  and  (inclusive). A lantern with coordinate  illuminates the point of interest with coordinate  if  is less than or equal to the power of the lantern.A way to choose the power values for all lanterns is considered  if every point of interest is illuminated by at least one lantern.You have to process  queries. Each query is represented by one integer . To answer the -th query, you have to:  add a lantern on coordinate ;  calculate the number of valid ways to assign power values to all lanterns, and print it modulo ;  remove the lantern you just added. ", "input": "The first line contains three integers ,  and  (; ; ) \u2014 the size of the segment, the number of lanterns and the number of points of interest, respectively. The second line contains  integers  (), where  is the coordinate of the -th lantern. The third line contains  integers  (), where  is the coordinate of the -th point of interest. The fourth line contains one integer  () \u2014 the number of queries. The fifth line contains  integers  (), where  is the integer representing the -th query. Additional constraint on the input: during the processing of each query, no coordinate contains more than one object (i.\u2009e. there cannot be two or more lanterns with the same coordinate, two or more points of interest with the same coordinate, or a lantern and a point of interest with the same coordinate).", "output": "For each query, print one integer \u2014 the answer to it, taken modulo .", "tutorial": "Let's start without the queries. How to calculate the number of ways for the given  lanterns?First, it's much easier to calculate the number of bad ways\u00a0\u2014 some point of interest is not illuminated. If at least one point of interest is not illuminated, then all lanterns have power lower than the distance from them to this point of interest. More importantly, it's less than . Thus, the number of good ways is  minus the number of bad ways.Let's use inclusion-exclusion. For a mask of non-illuminated points of interest, let's calculate the number of ways to assign the powers to the lanterns in such a way that at least these points of interest are not illuminated. All other points can be either illuminated or not. Let's call it . With the values for all masks, the answer is the sum of  over all masks.How to calculate the value for the mask? First, let's do it in  for each mask. Each lantern can have any power from  to the distance to the closest point of interest inside the mask non-inclusive. Thus, we can iterate over the lanterns and find the closest point to each of them, then multiply the number of ways for all lanterns.Let's calculate it the other way around. Initialize the answers for the masks with . Then iterate over the lantern and the point of interest that will be the closest non-illuminated one to this lantern. Let the distance between them be some value . Which masks will this pair affect? Let the lantern be to the right of that point of interest. The opposite can be handled similarly.All points to the left of the chosen point can be in either state. All points between the chosen one and the lantern must be illuminated. All points to the right of the lantern and with distance smaller than  must also be illumunated. All point to the right of these can be in either state. Thus, the masks look like \"**..**1000..000**..**\", where 1 denotes the chosen non-illuminated point.All masks that correspond to this template will be multiplied by . You have to be careful when there are two points of interest with the same distance  to some lantern\u00a0\u2014 one to the left of it and one to the right of it. In particular, in one case, you should force illumination on all points with distance . In another case, you should force illumination on all points with distance .How to multiply fast enough? We'll use a technique called sum-over-subsets. Let's express the template in terms of submasks. For a template \"***100000***\", all submasks of \"111100000111\" will be multiplied by . However, we accidentally multiplied masks of form \"***000000***\" too. Let's cancel them by dividing the submasks of \"111000000111\" by . Record all multiplications for all pairs, them force push them into submasks with sum-over-subsets (well, product-over-subsets in this case :)).Now we have the values of  for all masks in basically , give or take the time to find the points that must be forced illuminated (extra  from lower_bound or two pointers, which is not really faster).Now for the queries. How does the answer change after an extra lantern is added? Again, let's iterate over the closest point of interest and find the mask template. All masks corresponding to this template will get multiplied by . Thus, the answer will change by the sum of values of these masks, multiplied by , including the inclusion-exclusion coefficient. How to handle that? Well, yet another sum-over-subsets. Just collect the sum of values over the submasks beforehand and use these during the query. That gives us an  per query.Overall complexity: .", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int MOD = 998244353;\n\nint add(int a, int b){\n\ta += b;\n\tif (a >= MOD)\n\t\ta -= MOD;\n\tif (a < 0)\n\t\ta += MOD;\n\treturn a;\n}\n\nint mul(int a, int b){\n\treturn a * 1ll * b % MOD;\n}\n\nint binpow(int a, int b){\n\tint res = 1;\n\twhile (b){\n\t\tif (b & 1)\n\t\t\tres = mul(res, a);\n\t\ta = mul(a, a);\n\t\tb >>= 1;\n\t}\n\treturn res;\n}\n\nint main() {\n\tint D, n, m;\n\t\n\tscanf(\"%d%d%d\", &D, &n, &m);\n\t\n\tvector<int> inv(D + 1);\n\tforn(i, D + 1) inv[i] = binpow(i, MOD - 2);\n\t\n\tvector<int> b(n);\n\tforn(i, n) scanf(\"%d\", &b[i]);\n\t\n\tvector<int> a(m);\n\tforn(i, m) scanf(\"%d\", &a[i]);\n\tsort(a.begin(), a.end());\n\t\n\tint fl = (1 << m) - 1;\n\tvector<int> ways(1 << m, 1);\n\tforn(i, m) forn(j, n){\n\t\tint d = abs(b[j] - a[i]);\n\t\tint mask;\n\t\tif (b[j] > a[i]){\n\t\t\tint r = lower_bound(a.begin(), a.end(), b[j] + d) - a.begin();\n\t\t\tmask = fl ^ ((1 << r) - 1) ^ ((1 << (i + 1)) - 1);\n\t\t}\n\t\telse{\n\t\t\tint l = lower_bound(a.begin(), a.end(), b[j] - d) - a.begin();\n\t\t\tmask = fl ^ ((1 << i) - 1) ^ ((1 << l) - 1);\n\t\t}\n\t\tways[mask] = mul(ways[mask], d);\n\t\tmask ^= (1 << i);\n\t\tways[mask] = mul(ways[mask], inv[d]);\n\t}\n\t\n\tforn(i, m) for (int mask = fl; mask >= 0; --mask) if ((mask >> i) & 1){\n\t\tways[mask ^ (1 << i)] = mul(ways[mask ^ (1 << i)], ways[mask]);\n\t}\n\t\n\tways[0] = binpow(D + 1, n);\n\tforn(mask, 1 << m){\n\t\tways[mask] = mul(ways[mask], __builtin_popcount(mask) & 1 ? MOD - 1 : 1);\n\t}\n\tforn(i, m) forn(mask, 1 << m) if (!((mask >> i) & 1)){\n\t\tways[mask ^ (1 << i)] = add(ways[mask ^ (1 << i)], ways[mask]);\n\t}\n\t\n\tint q;\n\tscanf(\"%d\", &q);\n\tforn(_, q){\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tint ans = binpow(D + 1, n + 1);\n\t\tforn(i, m){\n\t\t\tint d = abs(x - a[i]);\n\t\t\tint mask;\n\t\t\tif (x > a[i]){\n\t\t\t\tint r = lower_bound(a.begin(), a.end(), x + d) - a.begin();\n\t\t\t\tmask = fl ^ ((1 << r) - 1) ^ ((1 << (i + 1)) - 1);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint l = lower_bound(a.begin(), a.end(), x - d) - a.begin();\n\t\t\t\tmask = fl ^ ((1 << i) - 1) ^ ((1 << l) - 1);\n\t\t\t}\n\t\t\tans = add(ans, mul(add(ways[mask], -ways[mask ^ (1 << i)]), d));\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}