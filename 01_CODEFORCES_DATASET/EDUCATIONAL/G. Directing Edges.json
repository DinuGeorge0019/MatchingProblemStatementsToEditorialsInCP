{"link": "https://codeforces.com//contest/1389/problem/G", "problemId": "686128", "shortId": "1389G", "contest_number": "1389", "name": "G. Directing Edges", "statement": "You are given an undirected connected graph consisting of  vertices and  edges.  vertices of this graph are special.You have to direct each edge of this graph or leave it undirected. If you leave the -th edge undirected, you pay  coins, and if you direct it, you don't have to pay for it.Let's call a vertex  if it is reachable from each special vertex along the edges of the graph (if an edge is undirected, it can be traversed in both directions). After you direct the edges of the graph (possibly leaving some of them undirected), you receive  coins for each saturated vertex . Thus, your total profit can be calculated as , where  is the set of saturated vertices, and  is the set of edges you leave undirected.For each vertex , calculate the maximum possible profit you can get if you have to make the vertex  saturated.", "input": "The first line contains three integers ,  and  (, , ). The second line contains  pairwise distinct integers , , ...,  () \u2014 the indices of the special vertices. The third line contains  integers , , ...,  (). The fourth line contains  integers , , ...,  (). Then  lines follow, the -th line contains two integers  and  (, ) \u2014 the endpoints of the -th edge. There is at most one edge between each pair of vertices.", "output": "Print  integers, where the -th integer is the maximum profit you can get if you have to make the vertex  saturated.", "tutorial": "Suppose we want to calculate the maximum profit for some vertex in . Let's try to find out how it can be done, and then optimize this process so we don't have to run it  times.First of all, we have to find the bridges and biconnected components in our graph. Why do we need them? Edges in each biconnected component can be directed in such a way that it becomes a strongly connected component, so we don't have to leave these edges undirected (it is never optimal). Furthermore, for each such component, either all vertices are saturated or no vertex is saturated. Let's build a tree where each vertex represents a biconnected component of the original graph, and each edge represents a bridge. We can solve the problem for this tree, and then the answer for some vertex of the original graph is equal to the answer for the biconnected component this vertex belongs to.Okay, now we have a problem on tree. Let's implement the following dynamic programming solution: root the tree at the vertex we want to find the answer for, and for each vertex, calculate the value of  \u2014 the maximum profit we can get for the subtree of vertex , if it should be reachable by all special vertices from its subtree.Let's analyze how we can calculate these  values. Suppose we have a vertex  with children , , ..., , we have already calculated the  values for the children, and we want to calculate . First of all, since the vertex  is going to be saturated, we will get the profit from it, so we initialize  with . Then we should decide whether we want to get the profit from the children of vertex . Suppose the edge leading from  to  has weight . If we want to take the profit from the subtree of , we (usually) have to make this edge undirected, so both vertices are saturated, thus we get  as profit \u2014 or we could leave this edge directed from  to , so the vertex  is saturated, and  is not, and get  as the profit. But sometimes we can gain the profit from the vertex  and its subtree without leaving the edge undirected: if all special vertices belong to the subtree of , we can just direct this edge from  to , and there is no reason to choose the opposite direction or leave the edge undirected. Similarly, if all special vertices are outside of this subtree, there's no reason to direct the edge from  to . So, if one of this conditions is met, we can get the full profit from the subtree of  without leaving the edge undirected.Okay, let's summarize it. We can calculate  as , where  is either  if one of the aforementioned conditions is met (we don't have to leave the edge undirected if we want to saturate both vertices), or  otherwise. Now we have an  solution.Let's optimize it to . Root the tree at vertex  and calculate the dynamic programming as if  is the root. Then, we shall use  technique to recalculate the dynamic programming for all other vertices: we will try each vertex as the root of the tree, and  is the answer for the vertex  if it is the root. The rerooting technique works as follows: let's run DFS from the initial root of the tree, and when we traverse an edge by starting or finishing a recursive call of DFS, we move the root along the edge; so, if we call ,  is the current root; if it has some child , we move the root to  the same moment when we call , and when the call of  ends, the root moves back to .Okay, the only thing that's left is to describe how we move the root. If the current root is , and we want to move it to  (a vertex adjacent to ), then we have to change only the values of  and : first of all, since  is no longer a child of , we have to subtract the value that was added to  while we considered vertex ; then, we have to make  the child of vertex , so we add the profit we can get from the vertex  to . It can be done in , so our solution runs in , though with a very heavy constant factor.", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long li;\n\nconst int N = 300043;\n\nbool is_bridge[N];\nint w[N];\nint c[N];\nint v[N];\nvector<pair<int, int> > g[N];\n\nvector<pair<int, int> > g2[N];\nint comp[N];\nli sum[N];\nli dp[N];\nint cnt[N];\nint fup[N];\nint tin[N];\nint T = 0;\nli ans[N];\nint v1[N], v2[N];\n\nint n, m, k;\n\nint dfs1(int x, int e)\n{\n\ttin[x] = T++;\n\tfup[x] = tin[x];\n\tfor(auto p : g[x])\n\t{\n\t\tint y = p.first;\n\t\tint i = p.second;\n\t\tif(i == e)\n\t\t\tcontinue;\n\t\tif(tin[y] != -1)\n\t\t\tfup[x] = min(fup[x], tin[y]);\n\t\telse\n\t\t{\n\t\t\tfup[x] = min(fup[x], dfs1(y, i));\n\t\t\tif(fup[y] > tin[x])\n\t\t\t\tis_bridge[i] = true;\n\t\t}\n\t}\n\treturn fup[x];\n}\n\nvoid dfs2(int x, int cc)\n{\n\tif(comp[x] != -1)\n\t\treturn;\n\tcomp[x] = cc;\n\tcnt[cc] += v[x];\n\tsum[cc] += c[x];\n\tfor(auto y : g[x])\n\t\tif(!is_bridge[y.second])\n\t\t\tdfs2(y.first, cc);\n}\n\nvoid process_edge(int x, int y, int m, int weight)\n{\n\tli add_dp = dp[y];\n\tif(cnt[y] > 0 && cnt[y] < k)\n\t\tadd_dp = max(0ll, add_dp - weight);\n\t\n\tcnt[x] += m * cnt[y];\n\tdp[x] += m * add_dp;\n}\n\nvoid link(int x, int y, int weight)\n{\n\tprocess_edge(x, y, 1, weight);\n}\n\nvoid cut(int x, int y, int weight)\n{\n\tprocess_edge(x, y, -1, weight);\n}\n\nvoid dfs3(int x, int p)\n{\n    dp[x] = sum[x];\n\tfor(auto e : g2[x])\n\t{\n\t\tint i = e.second;\n\t\tint y = e.first;\n\t\tif(y == p)\n\t\t\tcontinue;\n\t\tdfs3(y, x);\n\t\tlink(x, y, w[i]);\n\t}\n}\n\nvoid dfs4(int x, int p)\n{\n\tans[x] = dp[x];\n\tfor(auto e : g2[x])\n\t{\n\t\tint i = e.second;\n\t\tint y = e.first;\n\t\tif(y == p)\n\t\t\tcontinue;\n\t\tcut(x, y, w[i]);\n\t\tlink(y, x, w[i]);\n\t\tdfs4(y, x);\n\t\tcut(y, x, w[i]);\n\t\tlink(x, y, w[i]);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\tfor(int  i = 0; i < k; i++)\n\t{\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\t--x;\n\t\tv[x] = 1;\n\t}\n\tfor(int i = 0; i < n; i++)\n\t\tscanf(\"%d\", &c[i]);\n\tfor(int i = 0; i < m; i++)\n\t\tscanf(\"%d\", &w[i]);\n\tfor(int i = 0; i < m; i++)\n\t{\n\t\tscanf(\"%d %d\", &v1[i], &v2[i]);\n\t\t--v1[i];\n\t\t--v2[i];\n\t\tg[v1[i]].push_back(make_pair(v2[i], i));\n\t\tg[v2[i]].push_back(make_pair(v1[i], i));\n\t}\n\t\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\ttin[i] = -1;\n\t\tcomp[i] = -1;\n\t}\n\tdfs1(0, -1);\n\tint cc = 0;\n\tfor(int i = 0; i < n; i++)\n\t\tif(comp[i] == -1)\n\t\t\tdfs2(i, cc++);\n\tfor(int i = 0; i < m; i++)\n\t\tif(is_bridge[i])\n\t\t{\n\t\t\tg2[comp[v1[i]]].push_back(make_pair(comp[v2[i]], i));\n\t\t\tg2[comp[v2[i]]].push_back(make_pair(comp[v1[i]], i));\n\t\t}\n\tdfs3(0, 0);\n\tdfs4(0, 0);\n\tfor(int i = 0; i < n; i++)\n\t\tprintf(\"%lld \", ans[comp[i]]);\n\tputs(\"\");\n}", "interactive": false, "noSolution": false, "noTutorial": false}