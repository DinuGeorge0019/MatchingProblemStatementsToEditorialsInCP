{"link": "https://codeforces.com//contest/652/problem/D", "problemId": "52871", "shortId": "652D", "contest_number": "652", "name": "D. Nested Segments", "statement": "You are given  segments on a line. There are no ends of some segments that coincide. For each segment find the number of segments it contains.", "input": "The first line contains a single integer  () \u2014 the number of segments on a line. Each of the next  lines contains two integers  and  () \u2014 the coordinates of the left and the right ends of the -th segment. It is guaranteed that there are no ends of some segments that coincide.", "output": "Print  lines. The -th of them should contain the only integer  \u2014 the number of segments contained in the -th segment.", "tutorial": "This problem is a standard two-dimensional problem that can be solved with one-dimensional data structure. In the same way a lot of other problems can be solved (for example the of finding the maximal weighted chain of points so that both coordinates of each point are greater than the coordinates of the predecessing point). Rewrite the problem formally: for each  we should count the number of indices  so that the following conditions are hold:  and . Let's sort all segments by the left ends from right to left and maintain some data structure (Fenwick tree will be the best choice) with the right ends of the processed segments. To calculate the answer for the current segment we should simple take the prefix sum for the right end of the current segment.\nSo the condition  is hold by sorting and iterating over the segments from the right to the left (the first dimension of the problem). The condition  is hold by taking the prefix sum in data structure (the second dimension).\n", "solution": "const int N = 1200300;\n\nint n;\npair<pti, int> a[N];\n\nbool read() {\n\tif (!(cin >> n)) return false;\n\tforn(i, n) assert(scanf(\"%d%d\", &a[i].x.x, &a[i].x.y) == 2), a[i].y = i;\n\treturn true;\n}\n\nint t[N];\nvector<int> ys;\n\ninline void inc(int i, int val) {\n\tfor ( ; i < sz(ys); i |= i + 1)\n\t\tt[i] += val;\n}\n\ninline int sum(int i) {\n\tint ans = 0;\n\tfor ( ; i >= 0; i = (i & (i + 1)) - 1)\n\t\tans += t[i];\n\treturn ans;\n}\n\nint ans[N];\n\nvoid solve() {\n\tys.clear();\n\tforn(i, n) ys.pb(a[i].x.y);\n\tsort(all(ys));\n\tys.erase(unique(all(ys)), ys.end());\n\tforn(i, sz(ys)) t[i] = 0;\n\n\tsort(a, a + n);\n\tnfor(i, n) {\n\t\tint idx = int(lower_bound(all(ys), a[i].x.y) - ys.begin());\n\t\tans[a[i].y] = sum(idx);\n\t\tinc(idx, +1);\n\t}\n\n\tforn(i, n) printf(\"%dn\", ans[i]);\n}", "interactive": false, "noSolution": false, "noTutorial": false}