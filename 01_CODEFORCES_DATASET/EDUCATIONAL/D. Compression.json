{"link": "https://codeforces.com//contest/1107/problem/D", "problemId": "288737", "shortId": "1107D", "contest_number": "1107", "name": "D. Compression", "statement": "You are given a binary matrix  of size . Let's denote an -compression of the given matrix as a matrix  of size  such that for every  the condition  is met.Obviously, -compression is possible only if  divides , but this condition is not enough. For example, the following matrix of size  does not have any -compression:     For the given matrix , find maximum  such that an -compression of this matrix is possible.", "input": "The first line contains one number  () \u2014 the number of rows and columns in the matrix . It is guaranteed that  is divisible by . Then the representation of matrix follows. Each of  next lines contains  one-digit hexadecimal numbers (that is, these numbers can be represented either as digits from  to  or as uppercase Latin letters from  to ). Binary representation of each of these numbers denotes next  elements of the matrix in the corresponding row. For example, if the number  is given, then the corresponding elements are , and if the number is , then the corresponding elements are . Elements are not separated by whitespaces.", "output": "Print one number: maximum  such that an -compression of the given matrix is possible.", "tutorial": "After some tinkering with the given condition, we notice that an -compression is possible iff  divides  and the  matrix is divisible into  matrices such that each matrix is either all 1 or all 0. We can loop over all such  and check the condition in  time per , but this is potentially too slow.\nTo speed this up, we can precompute rectangle sums for every rectangle containing the upper-left corner, which enables us to compute the sum of any rectangle in . This improves our time complexity to . Since  (really!), this means our solution is . Code: 49028814\n", "solution": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int N_MAX = 5205;\n\nint N;\nbitset<N_MAX> matrix[N_MAX];\nint rect_sum[N_MAX][N_MAX];\n\nint hex_to_int(char hex) {\n    return isdigit(hex) ? hex - '0' : hex - 'A' + 10;\n}\n\nint get_rect_sum(int r1, int r2, int c1, int c2) {\n    return rect_sum[r2][c2] - rect_sum[r2][c1] - rect_sum[r1][c2] + rect_sum[r1][c1];\n}\n\nint main() {\n    scanf(\"%d\", &N);\n    char str[N_MAX];\n\n    for (int i = 0; i < N; i++) {\n        scanf(\"%s\", str);\n        reverse(str, str + N / 4);\n\n        for (int j = 0; j < N; j++)\n            matrix[i][j] = (hex_to_int(str[j / 4]) >> j % 4) & 1;\n    }\n\n    for (int i = 0; i < N; i++)\n        for (int j = 0; j < N; j++)\n            rect_sum[i + 1][j + 1] = rect_sum[i + 1][j] + rect_sum[i][j + 1] - rect_sum[i][j] + matrix[i][j];\n\n    for (int x = N; x > 0; x--)\n        if (N % x == 0) {\n            bool good = true;\n\n            for (int i = 0; i < N && good; i += x)\n                for (int j = 0; j < N && good; j += x) {\n                    int sum = get_rect_sum(i, i + x, j, j + x);\n\n                    if (sum != x * x && sum != 0)\n                        good = false;\n                }\n\n            if (good) {\n                cout << x << '\\n';\n                return 0;\n            }\n        }\n\n    assert(false);\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}