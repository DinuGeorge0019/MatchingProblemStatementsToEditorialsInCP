{"link": "https://codeforces.com//contest/1620/problem/D", "problemId": "1233291", "shortId": "1620D", "contest_number": "1620", "name": "D. Exact Change", "statement": "One day, early in the morning, you decided to buy yourself a bag of chips in the nearby store. The store has chips of  different flavors. A bag of the -th flavor costs  burles.The store may run out of some flavors, so you'll decide which one to buy after arriving there. But there are two major flaws in this plan:   you have only coins of ,  and  burles;  since it's morning, the store will ask you to pay in exact change, i.\u00a0e. if you choose the -th flavor, you'll have to pay   burles. Coins are heavy, so you'd like to take the least possible number of coins in total. That's why you are wondering: what is the minimum total number of coins you should take with you, so you can buy a bag of chips of any flavor in exact change?", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of test cases. The first line of each test case contains the single integer  ()\u00a0\u2014 the number of flavors in the store. The second line of each test case contains  integers  ()\u00a0\u2014 the cost of one bag of each flavor.", "output": "For each test case, print one integer\u00a0\u2014 the minimum number of coins you need to buy one bag of any flavor you'll choose in exact change.", "tutorial": "Let's define , then it should be obvious that we need at least  coins to buy a bag of chips of cost . Now, it's not hard to prove that  coins is always enough to buy a bag of chips of any cost . Proof:   if , we'll take  coins of value , coin  and coin ;  if , we'll take  coins  and two coins ;  if , we'll take  coins , one coin  and two coins . So the question is how to decide, is  coins enough. The solution is to note that there is no need to take more than  coins  and more than  coins , so we can just brute force the number of coins  we'll take  and the number of coins  we'll take . Then, the number of coins  , and we can check: is it possible to pay exactly  using at most ,  and  coins respectively. There exists casework solution as well, but it's quite tricky, so brute force is preferable. The main problem for case work is the case , since there are two different ways to take  coins: either  coins  and coin  or  coins  and two coins . In the first way, you can't gather exactly  and in the second one, you can gather neither  nor .", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) int((a).size())\n\ntemplate<class A, class B> ostream& operator <<(ostream& out, const pair<A, B> &p) {\n  return out << \"(\" << p.x << \", \" << p.y << \")\";\n}\ntemplate<class A> ostream& operator <<(ostream& out, const vector<A> &v) {\n  fore(i, 0, sz(v)) {\n    if(i) out << \" \";\n    out << v[i];\n  }\n  return out;\n}\n\nint n;\nvector<int> a;\n\ninline bool read() {\n  if(!(cin >> n))\n    return false;\n  a.resize(n);\n  fore (i, 0, n)\n    cin >> a[i];\n  return true;\n}\n\nbool p(int val, int c1, int c2, int c3) {\n  fore (cur1, 0, c1 + 1) fore (cur2, 0, c2 + 1) {\n    if (cur1 + 2 * cur2 > val)\n      continue;\n    if ((val - cur1 - 2 * cur2) % 3 != 0)\n      continue;\n    if ((val - cur1 - 2 * cur2) / 3 <= c3)\n      return true;\n  }\n  return false;\n}\n\nbool possible(int c1, int c2, int c3) {\n  for (int v : a) {\n    if (!p(v, c1, c2, c3))\n      return false;\n  }\n  return true;\n}\n\ninline void solve() {\n  int m = *max_element(a.begin(), a.end());\n  int ans = int(1e9);\n  \n  const int MAG = 3;\n  fore (c1, 0, MAG) fore (c2, 0, MAG) {\n    int c3 = max(0, (m - c1 - 2 * c2 + 2) / 3);\n    assert(c1 + 2 * c2 + 3 * c3 >= m);\n    \n    if (possible(c1, c2, c3))\n      ans = min(ans, c1 + c2 + c3);\n  }\n  cout << ans << endl;\n}\n\nint main() {\n#ifdef _DEBUG\n  freopen(\"input.txt\", \"r\", stdin);\n#endif\n  int t; cin >> t;\n  while(t--) {\n    read();\n    solve();\n  }\n  return 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}