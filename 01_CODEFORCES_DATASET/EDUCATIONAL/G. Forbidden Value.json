{"link": "https://codeforces.com//contest/1455/problem/G", "problemId": "815720", "shortId": "1455G", "contest_number": "1455", "name": "G. Forbidden Value", "statement": "Polycarp is editing a complicated computer program. First, variable  is declared and assigned to . Then there are instructions of two types:   \u00a0\u2014 assign  a value  or spend  burles to remove that instruction (thus, not reassign );   block\u00a0\u2014 execute instructions inside the  block if the value of  is  and ignore the block otherwise.  blocks can contain  instructions and other  blocks inside them.However, when the value of  gets assigned to , the computer breaks and immediately catches fire. Polycarp wants to prevent that from happening and spend as few burles as possible.What is the minimum amount of burles he can spend on removing  instructions to never assign  to ?", "input": "The first line contains two integers  and  (, )\u00a0\u2014 the number of lines in the program and the forbidden value of . The following  lines describe the program. Each line is one of three types:     ;   ;  .  Each  instruction is matched by an  instruction. Each  instruction has an  instruction to match.", "output": "Print a single integer\u00a0\u2014 the minimum amount of burles Polycarp can spend on removing  instructions to never assign  to .", "tutorial": "Consider the following dynamic programming. \u00a0\u2014 the minimum cost to make  have value  after the -th line. The transitions here are pretty easy: on set you just consider two options of skipping or not skipping the instructions and on if you either go to the next line or to the end of the block depending on the value.There are a lot of possible values, so that dp works in . First, let's notice that all the values that don't appear in the input won't matter, so you can keep only the existing values in the dp.Next, let's consider the following modification to it. What happens when you enter an if block? It's actually the same dp but the only starting value is not  with cost  as in the beginning of the whole program but some value  with some cost . So let's calculate this dp separately from the outer one and just merge the values together. Notice that if some value doesn't appear inside the if block then its cost can not decrease exiting out of it. Thus, it's enough to calculate the inner dp only for values that appear inside the if block.Okay, the transitions for if became easier. The set transitions are still slow, though. Examine the nature of them. All the values besides the  written on the set instruction increase their cost by . As for the , its cost becomes equal to the cost of the cheapest value before the instruction.Thus, let's maintain the dp in some data structure that allows to add the same integer to all elements and take the minimum of its elements. That can be done with a set and a single integer that stores the current shift that should be applied to all elements. Surely, you'll also need a map to retrieve the current cost of particular values.The final part is fast merging of the if block dp and the outer one. It might not appear obvious but if you do that in a straightforward manner of adding all the costs from if one by one it can become  in total. So we can apply small-to-large and swap these dp's based on their sizes.Overall complexity: .", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n#define x first\n#define y second\n\nusing namespace std;\n\nconst long long INF = 1e18;\n\nstruct op{\n\tstring tp;\n\tint y, v, to;\n};\n\nstruct addmap{\n\tlong long add;\n\tmap<int, long long> val;\n\tmultiset<long long> mn;\n};\n\nvoid reset(addmap &a, int x, long long val){\n\tif (a.val.count(x))\n\t\ta.mn.erase(a.mn.find(a.val[x]));\n\ta.val[x] = val - a.add;\n\ta.mn.insert(val - a.add);\n}\n\nint main() {\n\tint n, s;\n\tscanf(\"%d%d\", &n, &s);\n\tstatic char buf[10];\n\top a;\n\tvector<addmap> st;\n\tst.push_back({});\n\tst.back().val[0] = 0;\n\tst.back().add = 0;\n\tst.back().mn.insert(0);\n\tforn(i, n){\n\t\tscanf(\"%s\", buf);\n\t\ta.tp = buf;\n\t\tif (a.tp == \"set\"){\n\t\t\tscanf(\"%d%d\", &a.y, &a.v);\n\t\t\tassert(!st.back().mn.empty());\n\t\t\tlong long mn = st.back().add + *st.back().mn.begin();\n\t\t\tst.back().add += a.v;\n\t\t\tif (a.y != s) reset(st.back(), a.y, mn);\n\t\t}\n\t\telse if (a.tp == \"if\"){\n\t\t\tscanf(\"%d\", &a.y);\n\t\t\tlong long val = INF;\n\t\t\tif (st.back().val.count(a.y)){\n\t\t\t\tval = st.back().val[a.y] + st.back().add;\n\t\t\t\tst.back().mn.erase(st.back().mn.find(st.back().val[a.y]));\n\t\t\t\tst.back().val.erase(a.y);\n\t\t\t}\n\t\t\tst.push_back({});\n\t\t\treset(st.back(), a.y, val);\n\t\t\tst.back().add = 0;\n\t\t}\n\t\telse{\n\t\t\tif (st[int(st.size()) - 1].val.size() > st[int(st.size()) - 2].val.size())\n\t\t\t\tswap(st[int(st.size()) - 1], st[int(st.size()) - 2]);\n\t\t\taddmap& v = st[int(st.size()) - 2];\n\t\t\tfor (auto it : st.back().val){\n\t\t\t\tif (!v.val.count(it.x) || v.val[it.x] + v.add > it.y + st.back().add){\n\t\t\t\t\tif (v.val.count(it.x))\n\t\t\t\t\t\tv.mn.erase(v.mn.find(v.val[it.x]));\n\t\t\t\t\tv.val[it.x] = it.y + st.back().add - v.add;\n\t\t\t\t\tv.mn.insert(it.y + st.back().add - v.add);\n\t\t\t\t}\n\t\t\t}\n\t\t\tst.pop_back();\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", *st.back().mn.begin() + st.back().add);\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}