{"link": "https://codeforces.com//contest/1680/problem/D", "problemId": "1398258", "shortId": "1680D", "contest_number": "1680", "name": "D. Dog Walking", "statement": "You are walking with your dog, and now you are at the promenade. The promenade can be represented as an infinite line. Initially, you are in the point  with your dog. You decided to give some freedom to your dog, so you untied her and let her run for a while. Also, you watched what your dog is doing, so you have some writings about how she ran. During the -th minute, the dog position changed from her previous position by the value  (it means, that the dog ran for  meters during the -th minute). If  is positive, the dog ran  meters to the right, otherwise (if  is negative) she ran  meters to the left.During some minutes, you were chatting with your friend, so you don't have writings about your dog movement during these minutes. These values  equal zero.You want your dog to return to you after the end of the walk, so the destination point of the dog after  minutes  .Now you are wondering: what is the maximum possible number of different  of the line your dog could visit on her way, if you replace every  with some integer from  to  (and your dog  return to  after the walk)? The dog visits an integer point if she runs through that point or reaches in it at the end of any minute. Point  is always visited by the dog, since she is initially there.If the dog cannot return to the point  after  minutes regardless of the integers you place, print .", "input": "The first line of the input contains two integers  and  () \u2014 the number of minutes and the maximum possible speed of your dog during the minutes without records. The second line of the input contains  integers  (), where  is the number of meters your dog ran during the -th minutes (to the left if  is negative, to the right otherwise). If  then this value is  and can be replaced with any integer from the range .", "output": "If the dog cannot return to the point  after  minutes regardless of the set of integers you place, print . Otherwise, print one integer \u2014 the maximum number of  integer points your dog could visit if you fill all the unknown values optimally and the dog will return to the point  at the end of the walk.", "tutorial": "Consider every cyclic shift of the array . Suppose that now the array  starts from the position  (the first element is  and the last element is ). Assume that before the position  our dog reached her minimum possible position and now the minimum position will not change. So our problem is to fill all zeros in the array  in such a way that the maximum prefix sum of  is the maximum possible and the total sum of  is zero.For simplicity, consider the array  which is the -th cyclic shift of  (i.\u2009e. the first element  is , the second element  is , and so on). Let's iterate from left to right and maintain the current sum of the array . Let this variable be . Now, when we meet , we should replace it with the maximum possible value we can (because in such a way we will increase the maximum number of prefix sums). Let  be the number of zeros in  starting from the position . This value can be calculated in advance in  for every cyclic shift using suffix sums. Then the segment of positions we can have at the end is  and we want to place the maximum possible value in  in such a way that this remaining segment (with addition of our current element) will cover . This maximum value equals . If  becomes less than  then this cyclic shift is invalid, and we should skip it. Otherwise, let's add  to  and proceed. If there are no values , then we placed anything correctly.Now can just simulate the movements of our dog to find the answer for the current cyclic shift. But there are cases when  do not contain zeros, so these cases should be handled somehow (I just checked that after simulation we returned to ). If we returned to , we can update the answer as the difference between the maximum and the minimum positions plus one. If there is no valid cyclic shift, then the answer is .Time complexity: .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n    freopen(\"input.txt\", \"r\", stdin);\n//  freopen(\"output.txt\", \"w\", stdout);\n#endif\n    \n    int n;\n    long long k;\n    cin >> n >> k;\n    vector<long long> a(n);\n    for (auto &it : a) {\n        cin >> it;\n    }\n    \n    long long ans = 0;\n    for (int it = 0; it < n; ++it) {\n        vector<int> cnt(n);\n        for (int i = n - 1; i >= 0; --i) {\n            cnt[i] = (a[i] == 0);\n            if (i + 1 < n) {\n                cnt[i] += cnt[i + 1];\n            }\n        }\n        vector<long long> b = a;\n        long long s = accumulate(b.begin(), b.end(), 0ll);\n        bool ok = true;\n        for (int i = 0; i < n; ++i) {\n            if (b[i] == 0) {\n                long long x = (i + 1 < n ? cnt[i + 1] : 0);\n                b[i] = min(k, x * k - s);\n                if (b[i] < -k) {\n                    ok = false;\n                }\n                s += b[i];\n            }\n        }\n        if (ok) {\n            long long pos = 0, mn = 0, mx = 0;\n            for (int i = 0; i < n; ++i) {\n                pos += b[i];\n                mn = min(mn, pos);\n                mx = max(mx, pos);\n            }\n            if (pos == 0) {\n                ans = max(ans, mx - mn + 1);\n            }\n        }\n        rotate(a.begin(), a.begin() + 1, a.end());\n    }\n    \n    if (ans == 0) {\n        ans = -1;\n    }\n    \n    cout << ans << endl;\n    \n    return 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}