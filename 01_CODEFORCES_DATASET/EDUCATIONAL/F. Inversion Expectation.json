{"link": "https://codeforces.com//contest/1096/problem/F", "problemId": "275413", "shortId": "1096F", "contest_number": "1096", "name": "F. Inversion Expectation", "statement": "A permutation of size  is an array of size  such that each integer from  to  occurs exactly once in this array. An inversion in a permutation  is a pair of indices  such that  and . For example, a permutation  contains  inversions: , , , .You are given a permutation  of size . However, the numbers on some positions are replaced by . Let the valid permutation be such a replacement of  in this sequence back to numbers from  to  in such a way that the resulting sequence is a permutation of size .The given sequence was turned into a valid permutation randomly with the equal probability of getting each valid permutation.Calculate the expected total number of inversions in the resulting valid permutation.It can be shown that it is in the form of  where  and  are non-negative integers and . Report the value of .", "input": "The first line contains a single integer  () \u2014 the length of the sequence. The second line contains  integers  (, ) \u2014 the initial sequence. It is guaranteed that all elements not equal to  are pairwise distinct.", "output": "Print a single integer \u2014 the expected total number of inversions in the resulting valid permutation. It can be shown that it is in the form of  where  and  are non-negative integers and . Report the value of .", "tutorial": "Let's break the problem into four general cases.  Case 1. Inversions between two unknown numbers. Each pair of numbers can either be or inversion or not and the number of permutations for both cases is the same. Thus, the expected value of that is .  Case 2 and 3. Inversions between the known and unknown number. Let's check the case with left number being unknown and right being known. The opposite will be done similarly. For each known number calculate the number of unknowns to the left of it  and the total number of unknowns greater than it . Then you'll need to put a greater number out of all possible to make an inversion. Add  to the answer.  Case 4. Inversions between two known numbers. Just calculate that number ignoring all  and add it to answer. Overall complexity:  (for the lase case, all others are done in ).", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int N = 200 * 1000 + 13;\nconst int MOD = 998244353;\n\nint n;\nint p[N];\nbool used[N];\nint gt[N];\n\nint add(int a, int b){\n\ta += b;\n\tif (a >= MOD)\n\t\ta -= MOD;\n\treturn a;\n}\n\nint mul(int a, int b){\n\treturn (a * 1ll * b) % MOD;\n}\n\nint binpow(int a, int b){\n\tint res = 1;\n\twhile (b){\n\t\tif (b & 1)\n\t\t\tres = mul(res, a);\n\t\ta = mul(a, a);\n\t\tb >>= 1;\n\t}\n\treturn res;\n}\n\nint f[N];\n\nvoid upd(int x){\n\tfor (int i = x; i < N; i |= i + 1)\n\t\t++f[i];\n}\n\nint get(int x){\n\tint sum = 0;\n\tfor (int i = x; i >= 0; i = (i & (i + 1)) - 1)\n\t\tsum += f[i];\n\treturn sum;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tforn(i, n){\n\t\tscanf(\"%d\", &p[i]);\n\t\tif (p[i] != -1)\n\t\t\tused[p[i]] = true;\n\t}\n\t\n\tint cur = 0;\n\tfor (int i = n; i >= 1; --i){\n\t\tgt[i] = cur;\n\t\tcur += !used[i];\n\t}\n\t\n\t// case 1\n\tint ans = mul(mul(cur, cur - 1), binpow(4, MOD - 2));\n\t\n\tint inv = binpow(cur, MOD - 2);\n\t\n\t// case 2\n\tint lft = 0;\n\tforn(i, n){\n\t\tif (p[i] == -1)\n\t\t\t++lft;\n\t\telse\n\t\t\tans = add(ans, mul(lft, mul(gt[p[i]], inv)));\n\t}\n\t\n\t// case 3\n\tint rgh = 0;\n\tfor (int i = n - 1; i >= 0; --i){\n\t\tif (p[i] == -1)\n\t\t\t++rgh;\n\t\telse\n\t\t\tans = add(ans, mul(rgh, mul(cur - gt[p[i]], inv)));\n\t}\n\t\n\t// case 4\t\n\tint tmp = 0;\n\tforn(i, n) if (p[i] != -1){\n\t\tans = add(ans, tmp - get(p[i]));\n\t\tupd(p[i]);\n\t\t++tmp;\n\t}\n\t\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}