{"link": "https://codeforces.com//contest/813/problem/F", "problemId": "108593", "shortId": "813F", "contest_number": "813", "name": "F. Bipartite Checking", "statement": "You are given an undirected graph consisting of  vertices. Initially there are no edges in the graph. Also you are given  queries, each query either adds one undirected edge to the graph or removes it. After each query you have to check if the resulting graph is bipartite (that is, you can paint all vertices of the graph into two colors so that there is no edge connecting two vertices of the same color).", "input": "The first line contains two integers  and  (). Then  lines follow. th line contains two numbers  and  (). These numbers describe th query: if there is an edge between vertices  and , then remove it, otherwise add it.", "output": "Print  lines. th line must contain  if the graph is bipartite after th query, and  otherwise.", "tutorial": "If the edges were only added and not deleted, it would be a common problem that is solved with disjoint set union. All you need to do in that problem is implement a DSU which maintains not only the leader in the class of some vertex, but also the distance to this leader. Then, if we try to connect two vertices that have the same leader in DSU and the sum of distances to this leader is even, then we get a cycle with odd length, and graph is no longer bipartite.But in this problem we need to somehow process removing edges from the graph.In the algorithm I will describe below we will need to somehow remove the last added edge from DSU (or even some number of last added edges). How can we process that? Each time we change some variable in DSU, we can store an address of this variable and its previous value somewhere (for example, in a stack). Then to remove last added edge, we rollback these changes \u2014 we rewrite the previous values of the variables we changed by adding the last edge.Now we can add a new edge and remove last added edge. All these operations cost  because  \u2014 path compression doesn't work in intended time if we have to rollback. Let's actually start solving the problem.For convinience, we change all information to queries like \"edge  exists from query number  till query number \". It's obvious that there are no more than  such queries. Let's use divide-and-conquer technique to make a function that answers whether the graph is bipartite or not after every query from some segment of queries . First of all, we add to DSU all the edges that are present in the whole segment (and not added yet); then we solve it recursively for  and ; then we remove edges from DSU using the rollback technique described above. When we arrive to some segment , then after adding the edges present in this segment we can answer if the graph is bipartite after query . Remember to get rid of the edges that are already added and the edges that are not present at all in the segment when you make a recursive call. Of course, to solve the whole problem, we need to call our function from segment .Time complexity is , because every edge will be added only in  calls of the function.", "solution": "// eddy1021\n#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef double D;\ntypedef long double LD;\ntypedef long long LL;\ntypedef pair<int,int> PII;\ntypedef pair<LL,LL> PLL;\n#define mod9 1000000009LL\n#define mod7 1000000007LL\n#define INF  1023456789LL\n#define INF16 10000000000000000LL\n#define eps 1e-9\n#define SZ(x) (int)(x).size()\n#define ALL(x) (x).begin(), (x).end()\n#define IOS ios_base::sync_with_stdio(0); cin.tie(0)\n#ifndef ONLINE_JUDGE\n#define debug(...) printf(__VA_ARGS__)\n#else \n#define debug(...)\n#endif\ninline LL getint(){\n  LL _x=0,_tmp=1; char _tc=getchar();    \n  while( (_tc<'0'||_tc>'9')&&_tc!='-' ) _tc=getchar();\n  if( _tc == '-' ) _tc=getchar() , _tmp = -1;\n  while(_tc>='0'&&_tc<='9') _x*=10,_x+=(_tc-'0'),_tc=getchar();\n  return _x*_tmp;\n}\ninline LL add( LL _x , LL _y , LL _mod = mod7 ){\n  _x += _y;\n  return _x >= _mod ? _x - _mod : _x;\n}\ninline LL sub( LL _x , LL _y , LL _mod = mod7 ){\n  _x -= _y;\n  return _x < 0 ? _x + _mod : _x;\n}\ninline LL mul( LL _x , LL _y , LL _mod = mod7 ){\n  _x *= _y;\n  return _x >= _mod ? _x % _mod : _x;\n}\nLL mypow( LL _a , LL _x , LL _mod ){\n  if( _x == 0 ) return 1LL;\n  LL _ret = mypow( mul( _a , _a , _mod ) , _x >> 1 , _mod );\n  if( _x & 1 ) _ret = mul( _ret , _a , _mod );\n  return _ret;\n}\nLL mymul( LL _a , LL _x , LL _mod ){\n  if( _x == 0 ) return 0LL;\n  LL _ret = mymul( add( _a , _a , _mod ) , _x >> 1 , _mod );\n  if( _x & 1 ) _ret = add( _ret , _a , _mod );\n  return _ret;\n}\ninline bool equal( D _x ,  D _y ){\n  return _x > _y - eps && _x < _y + eps;\n}\n#define Bye exit(0)\nint __ = 1 , _cs;\n/*********default*********/\n#define N 202020\nstruct edge {\n  int u, v, l, r;\n  bool operator<(const edge &a) const{\n    return l == a.l ? r < a.r : l < a.l;\n  }\n};\ntypedef vector<edge> ve;\nint n , top;\nnamespace ufs {\n  struct node {int fa, val, size;} t[N];\n  struct info {int x, y; node a, b;} st[N];\n  inline void pre() {for(int i=1; i<=n; i++) t[i] = (node){i, 0, 1};}\n  inline int find(int x) {while(t[x].fa != x) x = t[x].fa; return x;}\n  inline int dis(int x) {\n    int ans=0; \n    while(t[x].fa != x) ans ^= t[x].val, x = t[x].fa;\n    return ans;\n  }\n  inline void link(int x, int y) {\n    int val = dis(x) ^ dis(y) ^ 1;\n    x = find(x); y = find(y);\n    st[++top] = (info) {x, y, t[x], t[y]};\n    if(t[x].size > t[y].size) swap(x, y);\n    t[x].fa = y; t[x].val = val; t[y].size += t[x].size;\n  }\n  inline void recov(int bot) {\n    while(top != bot) {\n      info &now = st[top--];\n      t[now.x] = now.a; t[now.y] = now.b;\n    }\n  }\n} using namespace ufs;\n\nvoid cdq(int l, int r, ve &a) {\n  int mid = (l+r)>>1, bot = top;\n  ve b, c;\n  for(int i=0; i<(int)a.size(); i++) {\n    edge &now = a[i];\n    int x = now.u, y = now.v;\n    if(now.l == l && now.r == r) {\n      int p = find(x), q = find(y);\n      if(p == q) {\n        int val = dis(x) ^ dis(y);\n        if(val == 0) {\n          for(int j=l; j<=r; j++) puts(\"NO\");\n          recov(bot); return;\n        }\n      } else link(x, y);\n    } \n    else if(now.r <= mid) b.push_back(now);\n    else if(mid < now.l) c.push_back(now);\n    else b.push_back( (edge){now.u, now.v, now.l, mid} ), c.push_back( (edge){now.u, now.v, mid+1, now.r} );\n  }\n  if(l == r) puts(\"YES\");\n  else cdq(l, mid, b), cdq(mid+1, r, c);\n  recov(bot);\n}\nvoid build(){\n\n}\nmap< pair<int,int> , int > M;\nint q;\nve a;\nvoid init(){\n  n = getint();\n  q = getint();\n  for( int i = 1 ; i <= q ; i ++ ){\n    int ai = getint();\n    int bi = getint();\n    if( M.count( {ai, bi} ) ){\n      a.push_back((edge){ai, bi, M[ {ai, bi} ], i-1});\n      M.erase( {ai, bi} );\n    }else\n      M[ {ai, bi} ] = i;\n  }\n  for( auto i : M )\n    a.push_back((edge){i.first.first, i.first.second, i.second, q});\n}\nvoid solve(){\n  pre();\n  cdq( 1 , q , a );\n}\nint main(){\n  build();\n  //__ = getint();\n  while( __ -- ){\n    init();\n    solve();\n  }\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}