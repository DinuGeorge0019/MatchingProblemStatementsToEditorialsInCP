{"link": "https://codeforces.com//contest/911/problem/D", "problemId": "142498", "shortId": "911D", "contest_number": "911", "name": "D. Inversion Counting", "statement": "A permutation of size  is an array of size  such that each integer from  to  occurs exactly once in this array. An inversion in a permutation  is a pair of indices  such that  and . For example, a permutation  contains  inversions: , , , .You are given a permutation  of size  and  queries to it. Each query is represented by two indices  and  denoting that you have to reverse the segment  of the permutation. For example, if  and a query ,  is applied, then the resulting permutation is .After each query you have to determine whether the number of inversions is odd or even.", "input": "The first line contains one integer  () \u2014 the size of the permutation.  The second line contains  integers , , ...,  () \u2014 the elements of the permutation. These integers are pairwise distinct. The third line contains one integer  () \u2014 the number of queries to process. Then  lines follow, -th line containing two integers ,  () denoting that -th query is to reverse a segment  of the permutation. All queries are performed one after another.", "output": "Print  lines. -th of them must be equal to  if the number of inversions in the permutation after -th query is odd, and  otherwise.", "tutorial": "Permutaion with one swap is called transposition. Any permutation can be expressed as the composition (product) of transpositions. Simpler, you can get any permutation from any other one of the same length by doing some number of swaps. The sign of the permutation is the number of transpositions needed to get it from the identity permutation. Luckily (not really, this is pure math, check out all proofs at wiki, e.g) the sign can also tell us the parity of inversion count. Now you can start with computing parity of inversion count of the original permutation (naively, check all pairs of indices). Finally you can decompose queries into swaps, any method will be ok. Like, you can swap  and , then  and  and so on (this is  swaps). Then parity of inversion count of the resulting permutation will change if you applied odd number of swaps.Overall complexity: .", "solution": "#include <bits/stdc++.h>\n#ifndef ONLINE_JUDGE\n# include <sys/time.h>\n# include <sys/resource.h>\n#endif\n\n/*** TEMPLATE CODE STARTS HERE ***/\n\n#ifndef M_PI\n#define M_PI 3.1415926535897932384626433832795028841971693993751\n#endif\n\nusing namespace std;\n\ntypedef vector<string> vs;\ntypedef long long ll;\ntypedef complex<double> pnt;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n#define RA(x) begin(x), end(x)\n#define FE(i, x) for (auto i = begin(x); i != end(x); ++i)\n#define SZ(x) ((ll) (x).size())\n\ntemplate<class T>\nvoid splitstr(const string &s, vector<T> &out)\n{\n    istringstream in(s);\n    out.clear();\n    copy(istream_iterator<T>(in), istream_iterator<T>(), back_inserter(out));\n}\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\n\nstatic void redirect(int argc, const char **argv)\n{\n#ifndef ONLINE_JUDGE\n    struct rlimit rlim;\n    getrlimit(RLIMIT_STACK, &rlim);\n    rlim.rlim_cur = 256 * 1024 * 1024;\n    setrlimit(RLIMIT_STACK, &rlim);\n#ifndef __SANITIZE_ADDRESS__\n    getrlimit(RLIMIT_DATA, &rlim);\n    rlim.rlim_cur = 256 * 1024 * 1024;\n    setrlimit(RLIMIT_DATA, &rlim);\n#endif\n#endif\n\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n    if (argc > 1)\n    {\n        static filebuf f;\n        f.open(argv[1], ios::in);\n        cin.rdbuf(&f);\n        if (!cin)\n        {\n            cerr << \"Failed to open '\" << argv[1] << \"'\" << endl;\n            exit(1);\n        }\n    }\n\n    if (argc > 2)\n    {\n        static filebuf f;\n        f.open(argv[2], ios::out | ios::trunc);\n        cout.rdbuf(&f);\n        if (!cout)\n        {\n            cerr << \"Failed to open '\" << argv[2] << \"'\" << endl;\n        }\n    }\n}\n\n/*** TEMPLATE CODE ENDS HERE */\n\nint main(int argc, const char **argv)\n{\n    redirect(argc, argv);\n    int N;\n    cin >> N;\n    vi a(N);\n    for (int i = 0; i < N; i++)\n        cin >> a[i];\n    int swap = 0;\n    for (int i = 0; i < N; i++)\n        for (int j = i + 1; j < N; j++)\n            if (a[i] > a[j])\n                swap++;\n    swap &= 1;\n    int M;\n    cin >> M;\n    for (int i = 0; i < M; i++)\n    {\n        int l, r;\n        cin >> l >> r;\n        ll s = r - l + 1;\n        ll c = s * (s - 1) / 2;\n        swap ^= c & 1;\n        cout << (swap ? \"odd\\n\" : \"even\\n\");\n    }\n\n    return 0;\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}