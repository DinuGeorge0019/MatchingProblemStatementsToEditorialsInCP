{"link": "https://codeforces.com//contest/920/problem/F", "problemId": "152866", "shortId": "920F", "contest_number": "920", "name": "F. SUM and REPLACE", "statement": "Let  be the number of positive divisors of a positive integer . For example,  ( is divisible by  and ),  ( is divisible by , ,  and ).You are given an array  of  integers. You have to process two types of queries:     \u2014 for every  replace  with ;     \u2014 calculate . Print the answer for each  query.", "input": "The first line contains two integers  and  () \u2014 the number of elements in the array and the number of queries to process, respectively. The second line contains  integers , , ...,  () \u2014 the elements of the array. Then  lines follow, each containing  integers , ,  denoting -th query. If , then -th query is   , otherwise it's    (, ). There is at least one  query.", "output": "For each  query print the answer to it.", "tutorial": "At first let's notice that this function converges very quickly, for values up to  it's at most  steps. Now we should learn how to skip updates on the numbers  and .The function values can be calculated from the factorization of numbers in  with Eratosthenes sieve.Let's write two segment trees \u2014 one will store maximum value on segment, the other will store the sum. When updating some segment, check if its maximum is greater than . Updates are done in the manner one can usually write build function, you go down to the node corresponding to the segment of length  and update the value directly.Overall complexity:  as we access any segment no more than  times.", "solution": "#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, \"/STACK:336777216\")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 19;\nll MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define Se second\n#define Fi first\n\nll indt[1100000];\nvoid update(int p, ll v) {\n\tp += IT_MAX - 1;\n\tindt[p] = v;\n\tfor (p /= 2; p; p /= 2) indt[p] = indt[2 * p] + indt[2 * p + 1];\n}\nll getsum(int p1, int p2) {\n\tp1 += IT_MAX - 1;\n\tp2 += IT_MAX - 1;\n\tll rv = 0;\n\tfor (; p1 <= p2; p1 /= 2, p2 /= 2) {\n\t\tif (p1 % 2 == 1) rv = rv + indt[p1++];\n\t\tif (p2 % 2 == 0) rv = rv + indt[p2--];\n\t}\n\treturn rv;\n}\n\nset <int> Sx;\nint in[300050];\nint D[1000050];\n\nvector <int> Vl;\nint main() {\n\tint N, M, i, j;\n\tscanf(\"%d %d\", &N, &M);\n\tfor (i = 1; i <= N; i++) scanf(\"%d\", &in[i]);\n\tfor (i = 1; i <= N; i++) update(i, in[i]);\n\tfor (i = 1; i <= N; i++) if (in[i] >= 3) Sx.insert(i);\n\n\tfor (i = 1; i <= 1000000; i++) for (j = i; j <= 1000000; j += i) D[j]++;\n\twhile (M--) {\n\t\tint t1, t2, t3;\n\t\tscanf(\"%d %d %d\", &t1, &t2, &t3);\n\t\tif (t1 == 1) {\n\t\t\twhile (1) {\n\t\t\t\tauto it = Sx.lower_bound(t2);\n\t\t\t\tif (it == Sx.end() || *it > t3) break;\n\t\t\t\tVl.push_back(*it);\n\t\t\t\tSx.erase(it);\n\t\t\t}\n\t\t\tfor (auto it : Vl) {\n\t\t\t\tin[it] = D[in[it]];\n\t\t\t\tupdate(it, in[it]);\n\t\t\t\tif (in[it] >= 3) Sx.insert(it);\n\t\t\t}\n\t\t\tVl.clear();\n\t\t}\n\t\telse printf(\"%lld\\n\", getsum(t2, t3));\n\t}\n\treturn 0;\n}\n//*/", "interactive": false, "noSolution": false, "noTutorial": false}