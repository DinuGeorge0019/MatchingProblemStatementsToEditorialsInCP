{"link": "https://codeforces.com//contest/818/problem/F", "problemId": "112250", "shortId": "818F", "contest_number": "818", "name": "F. Level Generation", "statement": "Ivan is developing his own computer game. Now he tries to create some levels for his game. But firstly for each level he needs to draw a graph representing the structure of the level.Ivan decided that there should be exactly  vertices in the graph representing level , and the edges have to be bidirectional. When constructing the graph, Ivan is interested in special edges called . An edge between two vertices  and  is called a  if this edge belongs to every path between  and  (and these vertices will belong to different connected components if we delete this edge). For each level Ivan wants to construct a graph where at least half of the edges are . He also wants to maximize the number of edges in each constructed graph.So the task Ivan gave you is: given  numbers , for each  tell the maximum number of edges in a graph with  vertices, if at least half of the edges are . .", "input": "The first line of input file contains a positive integer  () \u2014 the number of graphs Ivan needs to construct. Then  lines follow, -th line contains one positive integer  () \u2014 the number of vertices in -th graph. ", "output": "Output  numbers, -th of them must be equal to the maximum number of edges in -th graph.", "tutorial": "The best way to build a graph is to make a -edge-connected component with  vertices and connect each of the remaining  vertices to it with a single edge. Then we will have  bridges outside the component and  edges in the component. So the answer for some fixed  and  is ; let's denote is at .Now since  is increasing, and  is decreasing, there exists some  such that if , then , and if , then .Then  is strictly increasing on the segment , and strictly decreasing on the segment ; and this proves that we can use ternary search to find its maximum. ", "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nLL C2( LL x ){ return x * ( x - 1 ) / 2; }\nint main(){\n  int q; cin >> q; while( q -- ){\n    LL n , a = 0; cin >> n;\n    LL bl = 1 , br = n - 1;\n    while( bl <= br ){\n      LL mid = (bl + br) >> 1;\n      LL res = C2( n - mid );\n      if( res < mid ){\n        a = max( a , mid + res );\n        br = mid - 1;\n      }else{\n        a = max( a , mid + mid );\n        bl = mid + 1;\n      }\n    }\n    cout << a << endl;\n  }\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}