{"link": "https://codeforces.com//contest/665/problem/C", "problemId": "55550", "shortId": "665C", "contest_number": "665", "name": "C. Simple Strings", "statement": " loves simple strings! A string  is called simple if every pair of adjacent characters are distinct. For example , ,  are simple whereas ,  are not simple. is given a string . He wants to change a minimum number of characters so that the string  becomes simple. Help him with this task!", "input": "The only line contains the string  () \u2014 the string given to . The string  consists of only lowercase English letters.", "output": "Print the simple string  \u2014 the string  after the minimal number of changes. If there are multiple solutions, you may output any of them. Note that the string  should also consist of only lowercase English letters.", "tutorial": "There are two ways to solve this problem: greedy approach and dynamic programming.\nThe first apprroach: Considerr some segment of consecutive equal characters. Let  be the length of that segment. Easy to see that we should change at least  characters in the segment to remove all the pairs of equal consecutive letters. On the other hand we can simply change the second, the fourth etc. symbols to letter that is not equal to the letters before and after the segment.\n", "solution": "const int N = 200200;\n\nint n;\nchar s[N];\n\nbool read() {\n\tif (!gets(s)) return false;\n\tn = int(strlen(s));\n\treturn true;\n}\n\nvoid solve() {\n\tfor (int i = 0, j = 0; i < n; i = j) {\n\t\twhile (j < n && s[j] == s[i]) j++;\n\t\tchar c = 'a';\n\t\twhile (c == s[i] || (i > 0 && c == s[i - 1]) || (j < n && c == s[j]))\n\t\t\tc++;\n\t\tfore(k, i, j)\n\t\t\tif ((i + k) & 1)\n\t\t\t\ts[k] = c;\n\t}\n\tputs(s);\n}", "interactive": false, "noSolution": false, "noTutorial": false}