{"link": "https://codeforces.com//contest/1359/problem/F", "problemId": "634677", "shortId": "1359F", "contest_number": "1359", "name": "F. RC Kaboom Show", "statement": "You know, it's hard to conduct a show with lots of participants and spectators at the same place nowadays. Still, you are not giving up on your dream to make a car crash showcase! You decided to replace the real cars with remote controlled ones, call the event \"Remote Control Kaboom Show\" and stream everything online.For the preparation you arranged an arena\u00a0\u2014 an infinite 2D-field. You also bought  remote controlled cars and set them up on the arena. Unfortunately, the cars you bought can only go forward without turning left, right or around. So you additionally put the cars in the direction you want them to go.To be formal, for each car  () you chose its initial position () and a direction vector (). Moreover, each car has a constant speed  units per second. So after car  is launched, it stars moving from () in the direction () with constant speed .The goal of the show is to create a car collision as fast as possible! You noted that launching every car at the beginning of the show often fails to produce any collisions at all. Thus, you plan to launch the -th car at some moment .  Note that it's not necessary for  to be integer and  is allowed to be equal to  for any .The show starts at time . The show ends when two cars  and  () collide (i.\u2009e. come to the same coordinate at the same time). The duration of the show is the time between the start and the end.What's the fastest crash you can arrange by choosing all ? If it's possible to arrange a crash then print the shortest possible duration of the show. Otherwise, report that it's impossible.", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of cars. Each of the next  lines contains five integers , , , ,  (; ; ; )\u00a0\u2014 the initial position of the -th car, its direction vector and its speed, respectively. ", "output": "Print the shortest possible duration of the show if it's possible to arrange a crash by choosing all . Otherwise, print \"\". Your answer is considered correct if its absolute or relative error does not exceed . Formally, let your answer be , and the jury's answer be . Your answer is accepted if and only if .", "tutorial": "Let  be true if it's possible to have a collision before time . That function is monotonous, thus let's binary search for .For some fixed  car  can end up in any point from  to  units along the ray . That makes it a segment.So the collision can happen if some pair of segments intersects. Let's learn how to find that out.The general idea is to use sweep line. So let's add the events that the -th segment  such that  opens at  and closes at . There were no vertical segments, so  and  are always different. At every moment of time  we want to maintain the segments ordered by their intersection with the line . Note that if two segments change their order moving along the sweep line, then they intersect.So we can maintain a set with a custom comparator that returns if one segment intersects the current line lower than the other one.When adding a segment to set, you want to check it's intersections with the next segment in the order and the previous one. When removing a segment, you want to check the intersection between the next and the previous segment in the order. If any check triggers, then return true immediately. It's easy to show that if the intersection happens between some pair of segments, then the intersection between only these pairs of segment also happens.Now for the implementation details. Precision errors play a huge role here since we use binary search and also store some stuff dependant on floats in the set.The solution I want to tell requires no epsilon comparisons, thus it calculates the answer only with the precision of binary search.So the first issue rises when we have to erase elements from the set. Notice that we can make a mistake when we are adding the segment and there is a segment with almost the same intersection point. That will not make the answer incorrect (that's not trivial to show but it's possible if you consider some cases). If you can find it later to remove, then it's not an issue at all. However, that will probably mess up the lower_bound in the set. Thus, let's save the pointer to each element in the set and remove it later by that pointer.The second issue comes when you have to check the intersection of two segments. The error might appear when one segment  (let the first point be the original  and the second point be calculated depending on ) has it's intersection point with segment  at exactly . So the slightest miscalculations could matter a lot.Let's learn to intersect in such a way that no epsilon comparisons are required. Firstly, we can store lines in the set instead of segments. Second, we can check the intersection of rays first and only then proceed to check the intersection of segments.So two rays intersect if:   their lines intersect\u00a0\u2014 easy to check in integers;  the intersection point lies in the correct direction of both rays\u00a0\u2014 the intersection point is always a pair of fractions  and you want to compare the signs of  and . Finally, if all the checks hold, then you can compare maximum of distances from  and  to the intersection point and . If  is greater or equal then they intersect in time. There is no way to make that comparison in integers. However, it's precision only depends on the precision of  as in the error here can't affect the answer greatly.Overall complexity: .", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n#define x first\n#define y second\n\nusing namespace std;\n\nconst double INF = 1e13;\n\nstruct line{\n\tint A, B, C;\n\tline(){}\n\tline(int x1, int y1, int x2, int y2){\n\t\tA = y1 - y2;\n\t\tB = x2 - x1;\n\t\tC = -A * x1 - B * y1;\n\t\t// A is guaranteed to be non-zero\n\t\tif (A < 0) A = -A, B = -B, C = -C;\n\t\tint g = __gcd(A, __gcd(abs(B), abs(C)));\n\t\tA /= g, B /= g, C /= g;\n\t}\n};\n\nbool operator ==(const line &a, const line &b){\n\treturn a.A == b.A && a.B == b.B && a.C == b.C;\n}\n\ndouble x;\n\nbool operator <(const line &a, const line &b){\n\tdouble val1 = (-a.A * x - a.C) / a.B;\n\tdouble val2 = (-b.A * x - b.C) / b.B;\n\treturn val1 < val2;\n}\n\nstruct car{\n\tint x, y, dx, dy, s;\n\tline l;\n\tdouble vx, vy;\n};\n\nint n;\nvector<car> a(n);\n\nlong long det(int a, int b, int c, int d){\n\treturn a * 1ll * d - b * 1ll * c;\n}\n\nbool inter(const line &a, const line &b, long long &D, long long &Dx, long long &Dy){\n\tD = det(a.A, a.B, b.A, b.B);\n\tif (D == 0) return false;\n\tDx = -det(a.C, a.B, b.C, b.B);\n\tDy = -det(a.A, a.C, b.A, b.C);\n\treturn true;\n}\n\nint sg(int x){\n\treturn x < 0 ? -1 : 1;\n}\n\nint sg(long long a, long long b, int c){\n\t// sign of a/b-c\n\tif (b < 0) a = -a, b = -b;\n\treturn a - c * b < 0 ? -1 : (a - c * b > 0);\n}\n\nbool inter(int i, int j, double &len){\n\tif (i == -1 || j == -1)\n\t\treturn false;\n\tlong long D, Dx, Dy;\n\tif (!inter(a[i].l, a[j].l, D, Dx, Dy))\n\t\treturn false;\n\tif (sg(Dx, D, a[i].x) != 0 && sg(a[i].dx) != sg(Dx, D, a[i].x))\n\t\treturn false;\n\tif (sg(Dx, D, a[j].x) != 0 && sg(a[j].dx) != sg(Dx, D, a[j].x))\n\t\treturn false;\n\tdouble x = Dx / double(D);\n\tdouble y = Dy / double(D);\n\tdouble di = (a[i].x - x) * (a[i].x - x) + (a[i].y - y) * (a[i].y - y);\n\tdouble dj = (a[j].x - x) * (a[j].x - x) + (a[j].y - y) * (a[j].y - y);\n\treturn len * len >= di / a[i].s && len * len >= dj / a[j].s;\n}\n\nvector<set<pair<line, int>>::iterator> del;\nset<pair<line, int>> q;\n\nvoid get_neighbours(int i, int &l, int &r){\n\tl = r = -1;\n\tauto it = q.lower_bound({a[i].l, -1});\n\tif (it != q.end())\n\t\tr = it->y;\n\tif (!q.empty() && it != q.begin()){\n\t\t--it;\n\t\tl = it->y;\n\t}\n}\n\nbool check(double t){\n\tvector<pair<double, pair<int, int>>> cur;\n\tdel.resize(n);\n\tforn(i, n){\n\t\tdouble x1 = a[i].x;\n\t\tdouble x2 = a[i].x + a[i].vx * t;\n\t\tif (x1 > x2) swap(x1, x2);\n\t\tcur.push_back({x1, {i, 0}});\n\t\tcur.push_back({x2, {i, 1}});\n\t}\n\tq.clear();\n\t\n\tsort(cur.begin(), cur.end());\n\tfor (auto &qr : cur){\t\t\n\t\tx = qr.x;\n\t\tint i = qr.y.x;\n\t\tint l, r;\n\t\t\n\t\tif (qr.y.y == 0){\n\t\t\tget_neighbours(i, l, r);\n\t\t\t\n\t\t\tif (r != -1 && a[i].l == a[r].l)\n\t\t\t\treturn true;\n\t\t\tif (inter(i, l, t))\n\t\t\t\treturn true;\n\t\t\tif (inter(i, r, t))\n\t\t\t\treturn true;\n\t\t\t\n\t\t\tdel[i] = q.insert({a[i].l, i}).x;\n\t\t}\n\t\telse{\t\t\t\n\t\t\tq.erase(del[i]);\n\t\t\tget_neighbours(i, l, r);\n\t\t\t\n\t\t\tif (inter(l, r, t))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\ta.resize(n);\n\tforn(i, n){\n\t\tscanf(\"%d%d%d%d%d\", &a[i].x, &a[i].y, &a[i].dx, &a[i].dy, &a[i].s);\n\t\ta[i].l = line(a[i].x, a[i].y, a[i].x + a[i].dx, a[i].y + a[i].dy);\n\t\tdouble d = sqrt(a[i].dx * a[i].dx + a[i].dy * a[i].dy);\n\t\ta[i].vx = a[i].dx / d * a[i].s;\n\t\ta[i].vy = a[i].dy / d * a[i].s;\n\t\ta[i].s *= a[i].s;\n\t}\n\tdouble l = 0, r = INF;\n\tbool ok = false;\n\tforn(_, 100){\n\t\tdouble m = (l + r) / 2;\n\t\tif (check(m)){\n\t\t\tok = true;\n\t\t\tr = m;\n\t\t}\n\t\telse{\n\t\t\tl = m;\n\t\t}\n\t}\n\tif (!ok)\n\t\tputs(\"No show :(\");\n\telse\n\t\tprintf(\"%.15lf\\n\", l);\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}