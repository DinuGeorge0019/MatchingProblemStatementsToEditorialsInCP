{"link": "https://codeforces.com//contest/1574/problem/D", "problemId": "1115677", "shortId": "1574D", "contest_number": "1574", "name": "D. The Strongest Build", "statement": "Ivan is playing yet another roguelike computer game. He controls a single hero in the game. The hero has  equipment slots. There is a list of  items for the -th slot, the -th of them increases the hero strength by . The items for each slot are pairwise distinct and are listed in the increasing order of their strength increase. So, .For each slot Ivan chooses exactly one item. Let the chosen item for the -th slot be the -th item in the corresponding list. The sequence of choices  is called .The strength of a build is the sum of the strength increases of the items in it. Some builds are banned from the game. There is a list of  pairwise distinct banned builds. It's guaranteed that there's at least one build that's not banned.What is the build with the maximum strength that is not banned from the game? If there are multiple builds with maximum strength, print any of them.", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of equipment slots. The -th of the next  lines contains the description of the items for the -th slot. First, one integer  ()\u00a0\u2014 the number of items for the -th slot. Then  integers  (). The sum of  doesn't exceed . The next line contains a single integer  ()\u00a0\u2014 the number of banned builds. Each of the next  lines contains a description of a banned build\u00a0\u2014 a sequence of  integers  (). The builds are pairwise distinct, and there's at least one build that's not banned.", "output": "Print the build with the maximum strength that is not banned from the game. If there are multiple builds with maximum strength, print any of them.", "tutorial": "Consider the bruteforce solution. You start with a build that contains the most powerful item for each slot. In one move, you swap an item in some slot for the one that is the previous one by power. If a build is not banned, update the answer with its total power (banned builds can be stored in a set, maybe hashset if you hash carefully enough).Notice that if you reach some unbanned build in this bruteforce, it never makes sense to go further. The answer is already updated with this one, and all the lower ones have smaller power.If you code that bruteforce in a smart way (or just add memorization), you won't visit any build twice. How many states will you visit, though? Since you can only proceed if you are standing in a banned build, you will check around  builds.You can code it like that and get accepted. However, there's another way that's easier to code, in my opinion.The optimal answer can be one of only two types. Either it contains the last item of each slot. Or it's some banned build with one item swapped with the previous one. It's easy to see from the solution above. So you can check the first type, then iterate over the banned build and try swapping each slot in it, checking if the resulting build is banned or not.Overall complexity:  or .", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nint n;\nvector<vector<int>> a;\nint m;\nvector<vector<int>> b;\n\nint main() {\n\tscanf(\"%d\", &n);\n\ta.resize(n);\n\tforn(i, n){\n\t\tint c;\n\t\tscanf(\"%d\", &c);\n\t\ta[i].resize(c);\n\t\tforn(j, c) scanf(\"%d\", &a[i][j]);\n\t}\n\tscanf(\"%d\", &m);\n\tb.resize(m);\n\tforn(i, m){\n\t\tb[i].resize(n);\n\t\tforn(j, n){\n\t\t\tscanf(\"%d\", &b[i][j]);\n\t\t\t--b[i][j];\n\t\t}\n\t}\n\tsort(b.begin(), b.end());\n\tvector<int> ult(n);\n\tforn(i, n) ult[i] = int(a[i].size()) - 1;\n\tif (!binary_search(b.begin(), b.end(), ult)){\n\t\tforn(i, n) printf(\"%d \", ult[i] + 1);\n\t\tputs(\"\");\n\t\treturn 0;\n\t}\n\tint mx = 0;\n\tvector<int> ans(n, -1);\n\tforn(i, m){\n\t\tvector<int> tmp = b[i];\n\t\tint sum = 0;\n\t\tforn(j, n) sum += a[j][tmp[j]];\n\t\tforn(j, n) if (tmp[j] != 0){\n\t\t\t--tmp[j];\n\t\t\tif (!binary_search(b.begin(), b.end(), tmp) && sum - a[j][tmp[j] + 1] + a[j][tmp[j]] > mx){\n\t\t\t\tmx = sum - a[j][tmp[j] + 1] + a[j][tmp[j]];\n\t\t\t\tans = tmp;\n\t\t\t}\n\t\t\t++tmp[j];\n\t\t}\n\t}\n\tforn(i, n){\n\t\tprintf(\"%d \", ans[i] + 1);\n\t}\n\tputs(\"\");\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}