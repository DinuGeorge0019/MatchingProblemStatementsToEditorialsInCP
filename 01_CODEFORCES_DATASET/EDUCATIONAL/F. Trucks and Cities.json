{"link": "https://codeforces.com//contest/1101/problem/F", "problemId": "281059", "shortId": "1101F", "contest_number": "1101", "name": "F. Trucks and Cities", "statement": "There are  cities along the road, which can be represented as a straight line. The -th city is situated at the distance of  kilometers from the origin. All cities are situated in the same direction from the origin. There are  trucks travelling from one city to another. Each truck can be described by  integers: starting city , finishing city , fuel consumption  and number of possible refuelings . The -th truck will spend  litres of fuel per one kilometer. When a truck arrives in some city, it can be refueled (but refueling is impossible in the middle of nowhere). The -th truck can be refueled at most  times. Each refueling makes truck's gas-tank full. All trucks start with full gas-tank.All trucks will have gas-tanks of the same size  litres. You should find minimum possible  such that all trucks can reach their destinations without refueling more times than allowed.", "input": "First line contains two integers  and  (, ) \u2014 the number of cities and trucks. The second line contains  integers  (, ) \u2014 positions of cities in the ascending order. Next  lines contains  integers each. The -th line contains integers , , ,  (, , ) \u2014 the description of the -th truck.", "output": "Print the only integer \u2014 minimum possible size of gas-tanks  such that all trucks can reach their destinations.", "tutorial": "First (bonus) solution: implement idea from Blogewoosh #6. Time complexity will be somewhat  and space complexity is .Honest solution: Note, that for each truck lower bound on the answer is , where  is optimal partition of  on  segments (partition which minimize maximum length of segment) and doesn't depend on  of truck.So, it enough to calculate  \u2014 optimal partition of segment  on  segments.Let  be position, where last segment starts in partition with value . Note, that .On the other hand, . But  and , then  is somewhat \"convex\".Finally, best  is no more than , And we can look at  as second pointer (along with  as first pointer). So we can for each  move  while answer \"relaxes\" (while answer is decreasing or staying same). In result, for each  and  there will be  operations in total.Optimizing memory consumption is easy, if we notice that we can iterate over  but not save it as state of dp.In the end, time complexity is  and space complexity is .", "solution": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n\n#define sz(a) int((a).size())\n#define all(a) (a).begin(), (a).end()\n\n#define mp make_pair\n#define pb push_back\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef pair<int, int> pt;\n\nconst int INF = int(1e9);\nconst int N = 411;\n\nint n, m;\nint a[N];\nvector< pair<pt, pt> > qs;\n\ninline bool read() {\n\tif(!(cin >> n >> m))\n\t\treturn false;\n\tfore(i, 0, n)\n\t\tcin >> a[i];\n\tqs.resize(m);\n\tfore(i, 0, m) {\n\t\tcin >> qs[i].x.x >> qs[i].x.y >> qs[i].y.x >> qs[i].y.y;\n\t\tqs[i].x.x--; qs[i].x.y--;\n\t}\n\treturn true;\n}\n\nvector<int> ids[N];\nint d[N][N];\n\ninline void solve() {\n\tfore(i, 0, m)\n\t\tids[qs[i].x.x].push_back(i);\n\tli ans = -1;\n\t\n\tfore(l, 0, n) {\n\t\tfore(r, l, n)\n\t\t\td[0][r] = a[r] - a[l];\n\t\t\n\t\tfore(k, 1, n + 1) {\n\t\t\tint opt = l;\n\t\t\tfore(r, l, n) {\n\t\t\t\twhile(opt < r && max(d[k - 1][opt], a[r] - a[opt]) >= max(d[k - 1][opt + 1], a[r] - a[opt + 1]))\n\t\t\t\t\topt++;\n\t\t\t\t\n\t\t\t\td[k][r] = max(d[k - 1][opt], a[r] - a[opt]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int id : ids[l])\n\t\t\tans = max(ans, d[qs[id].y.y][qs[id].x.y] * 1ll * qs[id].y.x);\n\t}\n\t\n\tcout << ans << endl;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint tt = clock();\n#endif\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0), cout.tie(0);\n\tcout << fixed << setprecision(15);\n\t\n\tif(read()) {\n\t\tsolve();\n\t\t\n#ifdef _DEBUG\n\t\tcerr << \"TIME = \" << clock() - tt << endl;\n\t\ttt = clock();\n#endif\n\t}\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}