{"link": "https://codeforces.com//contest/1175/problem/E", "problemId": "354217", "shortId": "1175E", "contest_number": "1175", "name": "E. Minimal Segment Cover", "statement": "You are given  intervals in form  on a number line.You are also given  queries in form . What is the minimal number of intervals you have to take so that every point () from  to  is covered by at least one of them? If you can't choose intervals so that every point from  to  is covered, then print  for that query.", "input": "The first line contains two integers  and  () \u2014 the number of intervals and the number of queries, respectively. Each of the next  lines contains two integer numbers  and  () \u2014 the given intervals. Each of the next  lines contains two integer numbers  and  () \u2014 the queries.", "output": "Print  integer numbers. The -th number should be the answer to the -th query: either the minimal number of intervals you have to take so that every point () from  to  is covered by at least one of them or  if you can't choose intervals so that every point from  to  is covered.", "tutorial": "Let's take a look at a naive approach at first.That approach is greedy. Let's find such an interval which starts to the left or at  and ends as much to the right as possible. Set  to its right border. Continue until either no interval can be found or  is reached.The proof basically goes like this. Let there be some smaller set of intervals which cover the query, these can be sorted by left border (obviously their left borders are pairwise distinct). Compare that set to the greedy one, take a look at the first position where best set's interval has his  less than the greedy set's . You can see that choosing interval greedily will still allow to have the rest of best set intervals, making the greedy choice optimal.Let's implement it in . For each position from  to  you can precalculate the index of such an interval that it starts to the left or at this position and ends as much to the right as possible. To do this sort all intervals by their left border, then iterate over positions, while maintaining the maximum right border achieved by intervals starting to the left or at the current position. The query is now straightforward.Now there are two main ways to optimize it.You can do it binary lifting style: for each interval (or position) precalculate the index of the interval taken last after taking  intervals greedily and use this data to answer queries in .You can also do it path compression style. Let's process the queries in the increasing order of their right borders. Now do greedy algorithm but for each interval you use remember the index of the last reached interval. Now the part with answering queries is  in total because each interval will be jumped from no more than once.Overall complexity:  / .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n#define forn(i, n) for(int i = 0; i < int(n); i++) \n\nconst int N = 500 * 1000 + 13;\nconst int LOGN = 18;\n\nint n, m;\npair<int, int> a[N], q[N];\n\nint nxt[N];\nint up[LOGN][N];\n\nint main(){\n\tscanf(\"%d%d\", &n, &m);\n\tforn(i, n)\n\t\tscanf(\"%d%d\", &a[i].x, &a[i].y);\n\tforn(i, m)\n\t\tscanf(\"%d%d\", &q[i].x, &q[i].y);\n\t\n\tsort(a, a + n);\n\t\n\tint lst = 0;\n\tpair<int, int> mx(0, -1);\n\tforn(i, N){\n\t\twhile (lst < n && a[lst].x == i){\n\t\t\tmx = max(mx, make_pair(a[lst].y, lst));\n\t\t\t++lst;\n\t\t}\n\t\tnxt[i] = (mx.x <= i ? -1 : mx.y);\n\t}\n\t\n\tforn(i, n)\n\t\tup[0][i] = nxt[a[i].y];\n\tfor (int j = 1; j < LOGN; ++j) forn(i, n){\n\t\tif (up[j - 1][i] == -1)\n\t\t\tup[j][i] = -1;\n\t\telse\n\t\t\tup[j][i] = up[j - 1][up[j - 1][i]];\n\t}\n\t\n\tforn(i, m){\n\t\tint x = nxt[q[i].x];\n\t\t\n\t\tif (x == -1){\n\t\t\tputs(\"-1\");\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tint res = 1;\n\t\tfor (int j = LOGN - 1; j >= 0; --j){\n\t\t\tint y = up[j][x];\n\t\t\tif (y == -1)\n\t\t\t\tcontinue;\n\t\t\tif (a[y].y < q[i].y){\n\t\t\t\tres += (1 << j);\n\t\t\t\tx = y;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (a[x].y >= q[i].y)\n\t\t\tprintf(\"%d\\n\", res);\n\t\telse if (up[0][x] == -1)\n\t\t\tputs(\"-1\");\n\t\telse\n\t\t\tprintf(\"%d\\n\", res + 1);\n\t}\n}", "interactive": false, "noSolution": false, "noTutorial": false}