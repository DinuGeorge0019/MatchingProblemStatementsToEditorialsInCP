{"link": "https://codeforces.com//contest/1494/problem/D", "problemId": "913253", "shortId": "1494D", "contest_number": "1494", "name": "D. Dogeforces", "statement": "The Dogeforces company has  employees. Each employee, except for lower-level employees, has at least  subordinates. Lower-level employees have no subordinates. Each employee, except for the head of the company, has exactly one direct supervisor. The head of the company is a direct or indirect supervisor of all employees. It is known that in Dogeforces, each supervisor receives a salary strictly more than all his subordinates.The full structure of the company is a secret, but you know the number of lower-level employees and for each pair of lower-level employees, the salary of their common supervisor is known (if there are several such supervisors, then the supervisor with the minimum salary). You have to restore the structure of the company.", "input": "The first line contains a single integer  () \u2014 the number of lower-level employees. This is followed by  lines, where -th line contains  integers  () \u2014 salary of the common supervisor of employees with numbers  and . It is guaranteed that . Note that  is equal to the salary of the -th employee.", "output": "In the first line, print a single integer  \u2014 the number of employees in the company. In the second line, print  integers , where  is the salary of the employee with the number . In the third line, print a single integer  \u2014 the number of the employee who is the head of the company. In the following  lines, print two integers  and  () \u2014 the number of the employee and his direct supervisor. Note that the lower-level employees have numbers from  to , and for the rest of the employees, you have to assign numbers from  to . If there are several correct company structures, you can print any of them.", "tutorial": "We can solve the problem recursively from the root to the leaves. Let's maintain a list of leaf indices for the current subtree. If the list size is equal to , then we can stop our recursion. Otherwise, we have to find the value of the root of the current subtree and split all leaves between child nodes. The root value is the maximum value of  among all pairs  belonging to a subtree (since the current root has at least  child nodes, there is a pair of leaves for which the current root is the least common ancestor). If the value of the least common ancestor of the leaves  and  () is less than the value of the current root then  and  belong to the same child of the root. Using this fact, we can split all the leaves between the child nodes and then restore the subtrees for them recursively.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define sz(a) int((a).size())\n\nconst int N = 505;\n\nint n;\nint a[N][N];\nint c[2 * N];\nvector<pair<int, int>> e;\n\nint calc(vector<int> ls) {\n  if (sz(ls) == 1)\n    return ls[0];\n  \n  int res = -1;\n  for (int u : ls)\n    res = max(res, a[ls[0]][u]);\n  \n  vector<vector<int>> ch;\n  ch.push_back({ls[0]});\n  for (int i = 1; i < sz(ls); ++i) {\n    int v = ls[i];\n    int group = -1;\n    for (int j = 0; j < sz(ch); ++j) {\n      if (a[v][ch[j][0]] != res) {\n        group = j;\n        break;\n      }\n    }\n    if (group == -1) {\n      group = sz(ch);\n      ch.push_back({});\n    }\n    ch[group].push_back(v);\n  }\n  \n  int v = n++;\n  c[v] = res;\n  for (int i = 0; i < sz(ch); ++i) {\n    int u = calc(ch[i]);\n    e.emplace_back(u, v);\n  }\n  return v;\n}\n\nint main() {\n  cin >> n;\n  for (int i = 0; i < n; ++i)\n    for (int j = 0; j < n; ++j)\n      cin >> a[i][j];\n  for (int i = 0; i < n; ++i)\n    c[i] = a[i][i];\n  vector<int> ls(n);\n  iota(ls.begin(), ls.end(), 0);\n  int root = calc(ls);\n  cout << n << '\\n';\n  for (int i = 0; i < n; ++i)\n    cout << c[i] << ' ';\n  cout << '\\n' << root + 1 << '\\n';\n  for (auto it : e)\n    cout << it.first + 1 << ' ' << it.second + 1 << '\\n';\n}", "interactive": false, "noSolution": false, "noTutorial": false}