{"link": "https://codeforces.com//contest/1334/problem/F", "problemId": "590686", "shortId": "1334F", "contest_number": "1334", "name": "F. Strange Function", "statement": "Let's denote the following function . This function takes an array  of length  and returns an array. Initially the result is an empty array. For each integer  from  to  we add element  to the end of the resulting array if it is greater than all previous elements (more formally, if ). Some examples of the function :  if  then ;  if  then ;  if  then ;  if  then . You are given two arrays: array  and array . You can delete some elements of array  (possibly zero). To delete the element , you have to pay  coins (the value of  can be negative, then you get  coins, if you delete this element). Calculate the minimum number of coins (possibly negative) you have to spend for fulfilling equality .", "input": "The first line contains one integer   \u2014 the length of array . The second line contains  integers   \u2014 the array . The third line contains  integers   \u2014 the array . The fourth line contains one integer   \u2014 the length of array . The fifth line contains  integers   \u2014 the array .", "output": "If the answer exists, in the first line print . In the second line, print the minimum number of coins you have to spend for fulfilling equality . Otherwise in only line print .", "tutorial": "The \"naive\" version of the solution is just dynamic programming: let  be the minimum cost of removed elements (or the maximum cost of remaining elements) if we considered first  elements of , and the resulting sequence maps to the first  elements of . There are two versions of this solution, both working in :  calculate this dp \"as it is\", so there are  states and  transitions from each state;  ensure that the -th element is taken into , so there are  states (since each element appears in  exactly once, the second state can be deduces from the first one), but up to  transitions from each state. It turns out that we can optimize the second approach. Let's calculate the values of  in ascending order of : first of all, we calculate the values of  such that , then transition into states such that , and so on.Calculating  for  is easy: since the first element of  is always the first element of , we should delete all elements before the -th if we want it to be the first element in . So, if  is the maximum possible sum of costs of remaining elements, if we considered the first  elements of  (and the -th element gets included in ), then  for indices  such that .Okay, now let's consider advancing from  to . If we want to go from  to  such that  and , we should leave the element  in the array and delete some elements between indices  and . Which ones should be deleted? First of all, they are all elements with negative deletion cost; but we should also get rid of all elements which could replace  in  \u2014 that is, all elements that are greater than . So the remaining elements are  which have ,  and , and we should be able to compute the sum of such elements.Even if we manage to do it in , which is possible, there may be up to  possible pairs of  and  to consider. The easiest way to get rid of that is to sort all occurences of  and , and process them in ascending order, maintaining the best  that was already met. That way, each of the elements of  will be considered at most twice, so this solution runs in .We know how to calculate the  values now, but how to determine the answer? We should consider all values of  such that  and delete all elements with negative costs and all elements that are greater than  from the suffix  \u2014 so this is another query of the form \"compute the sum of  over  which have ,  and \". The most straightforward way to process them in  is to use a persistent segment tree, but since  does not decrease in these queries as we process them, we may maintain the elements we are interested in with a much simpler data structure, for example, Fenwick tree.", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long li;\nconst li INF64 = li(1e18);\nconst int N = 500043;\n\nli f[N];\n\nli get(int x)\n{\n    li ans = 0;    \n    for (; x >= 0; x = (x & (x + 1)) - 1)\n        ans += f[x];\n    return ans;\n}\n\nvoid inc(int x, li d)\n{\n    for (; x < N; x = (x | (x + 1)))\n        f[x] += d;    \n}\n\nli get(int l, int r)\n{\n    return get(r) - get(l - 1);\n}\n\nli dp[N];\nint a[N], b[N], p[N];\nint n, m;\n\nint main()\n{\n    scanf(\"%d\", &n);\n    for(int i = 0; i < n; i++)\n        scanf(\"%d\", &a[i]);\n    for(int i = 0; i < n; i++)\n        scanf(\"%d\", &p[i]);\n    scanf(\"%d\", &m);\n    for(int i = 0; i < m; i++)\n        scanf(\"%d\", &b[i]);\n\n    for(int i = 0; i < n; i++)\n        dp[i] = -INF64;\n    map<int, vector<int> > pos;\n    for(int i = 0; i < n; i++)\n        pos[a[i]].push_back(i);\n    set<pair<int, int> > q;\n    for(int i = 0; i < n; i++)\n        q.insert(make_pair(a[i], i));\n    \n    for(auto x : pos[b[0]])\n        dp[x] = p[x];\n    while(!q.empty() && q.begin()->first <= b[0])\n    {\n        int k = q.begin()->second;\n        q.erase(q.begin());\n        if(p[k] > 0)\n            inc(k, p[k]);\n    }  \n\n    for(int i = 1; i < m; i++)\n    {\n        int i1 = b[i - 1], i2 = b[i];\n        vector<int> both_pos;\n        for(auto x : pos[i1])\n            both_pos.push_back(x);\n        for(auto x : pos[i2])\n            both_pos.push_back(x);\n        li best = -INF64;\n        int last = -1;\n        sort(both_pos.begin(), both_pos.end());\n        for(auto x : both_pos)\n        {\n            best += get(last + 1, x);\n            last = x;\n            if(a[x] == i1)\n                best = max(best, dp[x]);\n            else\n                dp[x] = best + p[x];\n        }\n        while(!q.empty() && q.begin()->first <= i2)\n        {\n            int k = q.begin()->second;\n            q.erase(q.begin());\n            if(p[k] > 0)\n                inc(k, p[k]);\n        }\n    }\n\n    li best_dp = -INF64;\n    for(int i = 0; i < n; i++)\n        if(a[i] == b[m - 1])\n            best_dp = max(best_dp, dp[i] + get(i + 1, n - 1));\n    li ans = 0;\n    for(int i = 0; i < n; i++)\n        ans += p[i];\n    ans -= best_dp;\n    if(ans > li(1e15))\n        puts(\"NO\");\n    else     \n        printf(\"YES\\n%lld\\n\", ans);\n    \n}", "interactive": false, "noSolution": false, "noTutorial": false}