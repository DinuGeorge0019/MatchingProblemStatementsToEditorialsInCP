{"link": "https://codeforces.com//contest/620/problem/F", "problemId": "45932", "shortId": "620F", "contest_number": "620", "name": "F. Xors on Segments", "statement": "You are given an array with  integers  and  queries. Each query is described by two integers .Let's define the function . The function is defined for only .For each query print the maximal value of the function  over all .", "input": "The first line contains two integers  () \u2014 the size of the array and the number of the queries. The second line contains  integers  () \u2014 the elements of the array . Each of the next  lines contains two integers  () \u2013 the parameters of the -th query.", "output": "For each query print the value  on a separate line \u2014 the maximal value of the function  over all .", "tutorial": "We gave bad constraints to this problem so some participants solved it in  time.\nNote that . The values  can be simply precomputed. Also you can notice that the value  is equal to  depending on the value  modulo .\nLet's use Mo's algorithm: we should group all the queries to  blocks by the left end and sort all the queries in each block by the right end. Let  be the maximal left end inside the current group then all left ends will be in distance not greater than  from  and right ends will be in nondecreasing order, so we can move the right end by one (total we will made no more than  movements in each block). During moving of the right end inside some group from the value  to the value of the current right end we will maintain two tries: the first for the values  and the second for the values , in the first we will maintain the minimal value of , in the second \u2014 the maximal. After adding some values to the trie we should find the maximal value that can be formed by the current value . To do that we should go down in the first trie maintaining the invariant that in the current subtree the minimal value is not greater than . Each time we should go by the bit that is not equal to the corresponding bit in  (if we can do that, otherwise we should go by the other bit). In the second trie we should do the same thing with the difference that we should maintain the invariant that the maximal value in the current subtree is not less than the value . After moving the right end we should iterate from the left end of the query to  and update the answer (without adding the current value to the tries). Also after that all we should iterate over all the queries and with new empty tries iterate from the left end to , add the current values to the tries and update the answer.\n", "solution": "\n            #include <bits/stdc++.h>\n\u00a0\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n#define ford(i, n) for (int i = int(n) - 1; i >= 0; i--)\n#define fore(i, l, r) for (int i = int(l); i < int(r); i++)\n#define correct(x, y, n, m) (0 <= (x) && (x) < (n) && 0 <= (y) && (y) < (m))\n#define all(a) (a).begin(), (a).end()\n#define sz(a) int((a).size())\n#define pb(a) push_back(a)\n#define mp(x, y) make_pair((x), (y))\n#define x first\n#define y second\n\u00a0\nusing namespace std;\n\u00a0\ntypedef long long li;\ntypedef long double ld;\ntypedef pair<int, int> pt;\n\u00a0\ntemplate<typename X> inline X abs(const X& a) { return a < 0? -a: a; }\ntemplate<typename X> inline X sqr(const X& a) { return a * a; }\n\u00a0\nconst int INF = int(1e9);\nconst li INF64 = li(1e18);\nconst ld EPS = 1e-9, PI = 3.1415926535897932384626433832795;\n\u00a0\nconst int N = 100100, LOGN = 20;\n\u00a0\nint n, m;\nint a[N];\npair<pt, int> q[N];\n\u00a0\ninline bool read() {\n\u00a0 \u00a0 if (!(cin >> n >> m)) return false;\n\u00a0 \u00a0 forn(i, n) assert(scanf(\"%d\", &a[i]) == 1);\n\u00a0 \u00a0 forn(i, m) {\n\u00a0 \u00a0 \u00a0 \u00a0 assert(scanf(\"%d%d\", &q[i].x.x, &q[i].x.y) == 2);\n\u00a0 \u00a0 \u00a0 \u00a0 q[i].x.x--;\n\u00a0 \u00a0 \u00a0 \u00a0 q[i].y = i;\n\u00a0 \u00a0 }\n\u00a0 \u00a0 return true;\n}\n\u00a0\ninline int getXor(int a) {\n\u00a0 \u00a0 switch (a % 4) {\n\u00a0 \u00a0 \u00a0 \u00a0 case 0: return a;\n\u00a0 \u00a0 \u00a0 \u00a0 case 1: return 1;\n\u00a0 \u00a0 \u00a0 \u00a0 case 2: return a + 1;\n\u00a0 \u00a0 \u00a0 \u00a0 case 3: return 0;\n\u00a0 \u00a0 }\n\u00a0 \u00a0 throw;\n}\n\u00a0\nstruct node {\n\u00a0 \u00a0 int nt[2];\n\u00a0 \u00a0 int maxv;\n\u00a0 \u00a0 node() {\n\u00a0 \u00a0 \u00a0 \u00a0 nt[0] = nt[1] = -1;\n\u00a0 \u00a0 \u00a0 \u00a0 maxv = INT_MIN;\n\u00a0 \u00a0 }\n};\n\u00a0\nint szt[2], root[2];\nnode t[2][N * LOGN];\n\u00a0\ninline int newNode(int i) {\n\u00a0 \u00a0 t[i][szt[i]] = node();\n\u00a0 \u00a0 return szt[i]++;\n}\n\u00a0\ninline void clear() {\n\u00a0 \u00a0 forn(i, 2) {\n\u00a0 \u00a0 \u00a0 \u00a0 szt[i] = 0;\n\u00a0 \u00a0 \u00a0 \u00a0 root[i] = newNode(i);\n\u00a0 \u00a0 }\n}\n\u00a0\ninline void lift(int ti, int v) {\n\u00a0 \u00a0 node *t = ::t[ti];\n\u00a0 \u00a0 t[v].maxv = INT_MIN;\n\u00a0 \u00a0 forn(i, 2) {\n\u00a0 \u00a0 \u00a0 \u00a0 int nv = t[v].nt[i];\n\u00a0 \u00a0 \u00a0 \u00a0 if (nv != -1) {\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 t[v].maxv = max(t[v].maxv, t[nv].maxv);\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 //cerr << \"vvv=\" << t[nv].maxv << endl;\n\u00a0 \u00a0 \u00a0 \u00a0 }\n\u00a0 \u00a0 }\n\u00a0 \u00a0 //cerr << t[v].maxv << endl;\n}\n\u00a0\nint calc(int ti, int x, int minv) {\n\u00a0 \u00a0 int v = root[ti];\n\u00a0 \u00a0 node *t = ::t[ti];\n\u00a0\n\u00a0 \u00a0 if (minv > t[v].maxv) return 0;\n\u00a0 \u00a0 int ans = 0;\n\u00a0 \u00a0 ford(i, LOGN) {\n\u00a0 \u00a0 \u00a0 \u00a0 int d = (x >> i) & 1;\n\u00a0 \u00a0 \u00a0 \u00a0 bool f = false;\n\u00a0 \u00a0 \u00a0 \u00a0 ford(jj, 2) {\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 int j = jj ^ d;\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 int vv = t[v].nt[j];\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if (vv != -1 && minv <= t[vv].maxv) {\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 v = t[v].nt[j];\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 f = true;\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if (jj) ans |= 1 << i;\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 break;\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\n\u00a0 \u00a0 \u00a0 \u00a0 }\n\u00a0 \u00a0 \u00a0 \u00a0 assert(f && minv <= t[v].maxv);\n\u00a0 \u00a0 }\n\u00a0 \u00a0 return ans;\n}\n\u00a0\nvoid add(int ti, int x, int curv) {\n\u00a0 \u00a0 int v = root[ti];\n\u00a0 \u00a0 node *t = ::t[ti];\n\u00a0\n\u00a0 \u00a0 static int szvs, vs[LOGN];\n\u00a0 \u00a0 szvs = 0;\n\u00a0\n\u00a0 \u00a0 ford(i, LOGN) {\n\u00a0 \u00a0 \u00a0 \u00a0 vs[szvs++] = v;\n\u00a0 \u00a0 \u00a0 \u00a0 int d = (x >> i) & 1;\n\u00a0 \u00a0 \u00a0 \u00a0 int& nt = t[v].nt[d];\n\u00a0 \u00a0 \u00a0 \u00a0 if (nt == -1) nt = newNode(ti);\n\u00a0 \u00a0 \u00a0 \u00a0 assert(nt != -1);\n\u00a0 \u00a0 \u00a0 \u00a0 v = nt;\n\u00a0 \u00a0 }\n\u00a0\n\u00a0 \u00a0 t[v].maxv = max(t[v].maxv, curv);\n\u00a0 \u00a0 ford(i, szvs) lift(ti, vs[i]);\n}\n\u00a0\nint ans[N];\n\u00a0\nvoid solve(int l, int r, int rx) {\n\u00a0 \u00a0 sort(q + l, q + r, [](const pair<pt, int>& a, const pair<pt, int>& b) { return a.x.y < b.x.y; });\n\u00a0\n\u00a0 \u00a0 clear();\n\u00a0 \u00a0 int px = rx;\n\u00a0 \u00a0 int cmax = 0;\n\u00a0 \u00a0 fore(i, l, r) {\n\u00a0 \u00a0 \u00a0 \u00a0 int lf = q[i].x.x, rg = q[i].x.y, id = q[i].y;\n\u00a0\n\u00a0 \u00a0 \u00a0 \u00a0 while (px < rg) {\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 int x = a[px++];\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 add(0, getXor(x), x);\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 cmax = max(cmax, calc(0, getXor(x - 1), x));\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 add(1, getXor(x - 1), -x);\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 cmax = max(cmax, calc(1, getXor(x), -x));\n\u00a0 \u00a0 \u00a0 \u00a0 }\n\u00a0\n\u00a0 \u00a0 \u00a0 \u00a0 int vmax = cmax;\n\u00a0 \u00a0 \u00a0 \u00a0 fore(j, lf, min(rg, rx)) {\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 int x = a[j];\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 vmax = max(vmax, calc(0, getXor(x - 1), x));\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 vmax = max(vmax, calc(1, getXor(x), -x));\n\u00a0 \u00a0 \u00a0 \u00a0 }\n\u00a0\n\u00a0 \u00a0 \u00a0 \u00a0 ans[id] = max(ans[id], vmax);\n\u00a0 \u00a0 }\n\u00a0\n\u00a0 \u00a0 fore(i, l, r) {\n\u00a0 \u00a0 \u00a0 \u00a0 int lf = q[i].x.x, rg = min(q[i].x.y, rx), id = q[i].y;\n\u00a0\n\u00a0 \u00a0 \u00a0 \u00a0 clear();\n\u00a0 \u00a0 \u00a0 \u00a0 int cmax = 0;\n\u00a0 \u00a0 \u00a0 \u00a0 fore(j, lf, rg) {\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 int x = a[j];\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 add(0, getXor(x), x);\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 cmax = max(cmax, calc(0, getXor(x - 1), x));\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 add(1, getXor(x - 1), -x);\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 cmax = max(cmax, calc(1, getXor(x), -x));\n\u00a0 \u00a0 \u00a0 \u00a0 }\n\u00a0\n\u00a0 \u00a0 \u00a0 \u00a0 ans[id] = max(ans[id], cmax);\n\u00a0 \u00a0 }\n}\n\u00a0\ninline void solve() {\n\u00a0 \u00a0 sort(q, q + m);\n\u00a0 \u00a0 forn(i, m) ans[i] = 0;\n\u00a0\n\u00a0 \u00a0 int i = 0, j = 0;\n\u00a0 \u00a0 const int S = 800;\n\u00a0 \u00a0 for (int lx = 0; lx < n; lx += S) {\n\u00a0 \u00a0 \u00a0 \u00a0 int rx = min(n, lx + S);\n\u00a0 \u00a0 \u00a0 \u00a0 while (j < m) {\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 assert(lx <= q[j].x.x);\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if (q[j].x.x >= rx) break;\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 j++;\n\u00a0 \u00a0 \u00a0 \u00a0 }\n\u00a0 \u00a0 \u00a0 \u00a0 solve(i, j, rx);\n\u00a0 \u00a0 \u00a0 \u00a0 i = j;\n\u00a0 \u00a0 \u00a0 \u00a0 cerr << \"lx=\" << lx << endl;\n\u00a0 \u00a0 }\n\u00a0\n\u00a0 \u00a0 forn(i, m) printf(\"%d\\n\", ans[i]);\n}\n\u00a0\nint main() {\n#ifdef SU1\n\u00a0 \u00a0 assert(freopen(\"input.txt\", \"rt\", stdin));\n\u00a0 \u00a0 assert(freopen(\"output.txt\", \"wt\", stdout));\n#endif\n\u00a0 \u00a0 \n\u00a0 \u00a0 cout << setprecision(10) << fixed;\n\u00a0 \u00a0 cerr << setprecision(5) << fixed;\n\u00a0\n\u00a0 \u00a0 while (read()) {\n\u00a0 \u00a0 \u00a0 \u00a0 solve();\n\u00a0 \u00a0 \u00a0 \u00a0 break;\n\u00a0 \u00a0 }\n\u00a0\n\u00a0 \u00a0 cerr << \"TIME=\" << clock() / ld(CLOCKS_PER_SEC) << endl;\n\u00a0 \u00a0 \n\u00a0 \u00a0 return 0;\n}\n        ", "interactive": false, "noSolution": false, "noTutorial": false}