{"link": "https://codeforces.com//contest/1194/problem/F", "problemId": "372220", "shortId": "1194F", "contest_number": "1194", "name": "F. Crossword Expert", "statement": "Today Adilbek is taking his probability theory test. Unfortunately, when Adilbek arrived at the university, there had already been a long queue of students wanting to take the same test. Adilbek has estimated that he will be able to start the test only  seconds after coming. Fortunately, Adilbek can spend time without revising any boring theorems or formulas. He has an app on this smartphone which contains  Japanese crosswords to solve. Adilbek has decided to solve them all one by one in the order they are listed in the app, without skipping any crossword. For each crossword, a number  is given that represents the time it takes an average crossword expert to solve this crossword (the time is given in seconds).Adilbek is a true crossword expert, but, unfortunately, he is sometimes unlucky in choosing the way to solve the crossword. So, it takes him either  seconds or  seconds to solve the -th crossword, equiprobably (with probability  he solves the crossword in exactly  seconds, and with probability  he has to spend an additional second to finish the crossword). All these events are independent.After  seconds pass (or after solving the last crossword, if he manages to do it in less than  seconds), Adilbek closes the app (if he finishes some crossword at the same moment, that crossword is considered solved; otherwise Adilbek does not finish solving the current crossword at all). He thinks it would be an interesting probability theory problem to calculate  \u2014 the expected number of crosswords he will be able to solve completely. Can you calculate it? Recall that the expected value of a discrete random variable is the probability-weighted average of all possible values \u2014 in this problem it means that the expected value of the number of solved crosswords can be calculated as , where  is the probability that Adilbek will solve exactly  crosswords. We can represent  as rational fraction  with . To give the answer, you should print .", "input": "The first line contains two integers  and  (, ) \u2014 the number of crosswords and the time Adilbek has to spend, respectively. The second line contains  integers  (), where  is the time it takes a crossword expert to solve the -th crossword. Note that Adilbek solves the crosswords in the order they are given in the input without skipping any of them.", "output": "Print one integer \u2014 the expected value of the number of crosswords Adilbek solves in  seconds, expressed in the form of .", "tutorial": "Let's use (as usual) linearity of an expected value.  where  is an indicator function and equal to  iff Adilbek will be able to solve the -th crossword.How to calculate ? If  then  is always . On the other hand, if  \u2014  is always . Otherwise, we need to calculate  \u2014 the needed probability.To calculate  we can iterate over  \u2014 the number of crosswords among first  ones which will require extra time. Obviously, if  then we don't have enough time to solve the -th crossword, also . Let's denote . There are  ways to choose crosswords with extra time among all  variants. So the final formula is following: The only problem is the efficiency. But we can find out several interesting properties. At first, . The other one: since , then . And this exactly the efficient way to transform  to : by multiplying and adding one coefficient we can transform the prefix sum of the -th row to the prefix sum of the  row. And to reduce the length of the prefix sum we can just subtract unnecessary coefficients.In result, the total complexity is  (maybe with extra  factor because of modular arithmetic).", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) int((a).size())\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef pair<int, int> pt;\n\ntemplate<class A, class B> ostream& operator <<(ostream& out, const pair<A, B> &p) {\n    return out << \"(\" << p.x << \", \" << p.y << \")\";\n}\ntemplate<class A> ostream& operator <<(ostream& out, const vector<A> &v) {\n    fore(i, 0, sz(v)) {\n        if(i) out << \" \";\n        out << v[i];\n    }\n    return out;\n}\n\nconst int MOD = int(1e9) + 7;\n\ninline int norm(int a) {\n    if(a >= MOD) a -= MOD;\n    if(a < 0) a += MOD;\n    return a;\n}\ninline int mul(int a, int b) {\n    return int(a * 1ll * b % MOD);\n}\ninline int binPow(int a, int k) {\n    int ans = 1;\n    while(k > 0) {\n        if(k & 1) ans = mul(ans, a);\n        a = mul(a, a);\n        k >>= 1;\n    }\n    return ans;\n}\ninline int inv(int a) {\n    return binPow(a, MOD - 2);\n}\n\nint n;\nli T;\nvector<li> t;\n\ninline bool read() {\n    if(!(cin >> n >> T))\n        return false;\n    t.resize(n);\n    fore(i, 0, n)\n        cin >> t[i];\n    return true;\n}\n\nvector<int> f, inf;\n\nint C(int n, li k) {\n    if(k > n || k < 0)\n        return 0;\n    return mul(f[n], mul(inf[k], inf[n - k]));\n}\n\ninline void solve() {\n    f.resize(n + 5);\n    inf.resize(n + 5);\n    f[0] = inf[0] = 1;\n    fore(i, 1, sz(f)) {\n        f[i] = mul(i, f[i - 1]);\n        inf[i] = mul(inf[i - 1], inv(i));\n    }\n\n    int sumC = 1;\n    li bd = T;\n    int pw2 = 1, i2 = (MOD + 1) / 2;\n\n    vector<int> p(n + 1, 0);\n    fore(i, 0, n) {\n        pw2 = mul(pw2, i2);\n\n        sumC = norm(mul(2, sumC) - C(i, bd));\n        li need = t[i];\n        if(bd > i + 1) {\n            li sub = min(bd - i - 1, need);\n            bd -= sub, need -= sub;\n        }\n        li rem = min(bd + 1, need);\n        fore(k, 0, rem)\n            sumC = norm(sumC - C(i + 1, bd - k));\n        bd -= rem;\n\n        p[i] = mul(sumC, pw2);\n    }\n\n    int ans = int(accumulate(p.begin(), p.end(), 0ll) % MOD);\n    cout << ans << endl;\n//    cerr << mul(ans, binPow(2, n)) << endl;\n}\n\nint main() {\n#ifdef _DEBUG\n    freopen(\"input.txt\", \"r\", stdin);\n    int tt = clock();\n#endif\n    cout << fixed << setprecision(15);\n\n    if(read()) {\n        solve();\n\n#ifdef _DEBUG\n        cerr << \"TIME = \" << clock() - tt << endl;\n        tt = clock();\n#endif\n    }\n    return 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}