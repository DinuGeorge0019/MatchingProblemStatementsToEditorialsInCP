{"link": "https://codeforces.com//contest/1795/problem/D", "problemId": "1785700", "shortId": "1795D", "contest_number": "1795", "name": "D. Triangle Coloring", "statement": "You are given an undirected graph consisting of  vertices and  edges, where  is divisible by . Each edge has a weight, which is a positive (greater than zero) integer.The graph has the following structure: it is split into  triples of vertices, the first triple consisting of vertices , the second triple consisting of vertices , and so on. Every pair of vertices from the same triple is connected by an edge. There are no edges between vertices from different triples.You have to paint the vertices of this graph into two colors, red and blue. Each vertex should have exactly one color, there should be exactly  red vertices and  blue vertices. The coloring is called valid if it meets these constraints.The weight of the coloring is the sum of weights of edges connecting two vertices with different colors.Let  be the maximum possible weight of a valid coloring. Calculate the number of valid colorings with weight , and print it modulo .", "input": "The first line contains one integer  (,  is divisible by ). The second line contains  integers  () \u2014 the weights of the edges. Edge  connects vertices  and , edge  connects vertices  and , edge  connects vertices  and , edge  connects vertices  and , edge  connects vertices  and , edge  connects vertices  and , and so on.", "output": "Print one integer \u2014 the number of valid colorings with maximum possible weight, taken modulo .", "tutorial": "Let's ignore the constraint on the number of red/blue vertices for a moment. What is the maximum possible weight of a coloring? From any triple, we can have any two edges connect vertices of different colors. So, the maximum possible weight of a coloring (not necessarily a valid one) is the sum of all edge weights except for the minimum weight in each triple.Let's show that it is always possible to choose a valid coloring to achieve this weight. In each triple, we should make sure that the two maximum edges connect vertices with different colors; to do this, we can color the vertex incident to both of these edges in one color, and the two other vertices will be painted in the other color. So, for each triple of vertices, there will be either one red vertex and two blue ones, or two red ones and one blue. Let's suppose the first  triples have one red vertex and two blue vertices each, and the other  triples have one blue vertex and two red vertices each. That way, we obtain a valid coloring with maximum possible weight.Okay, now let's try to find out how do we calculate the number of valid colorings with the maximum possible weight. Each triple of vertices will be either \"red\" (two red vertices, one blue), or \"blue\" (the other way around). Since exactly half of the vertices should be red, then exactly half of the triples should be red, so the number of ways to choose a \"color\" for all triples is .After choosing the color of each triple, let's choose how we actually color them. The triples are independent, so for each triple, we can introduce the coefficient , which is the number of ways to color it so that its weight is maximized, and the triple has some specific type (either red or blue, doesn't matter since these are symmetric). Choosing the vertex which will be different from its neighbors is equivalent to choosing the edge which will not be included in the weight of the coloring (this is the edge which is not incident to the chosen vertex). So,  is equal to the number of ways to choose that vertex in the -th triple so that the weight is maximized; i.\u2009e. the weight of the edge not incident to the chosen vertex should be minimized. Thus,  is just the number of minimum edge weights in the -th triple.The formula for the final answer is .", "solution": "#include <bits/stdc++.h>\n \nusing namespace std;\n\nconst int MOD = 998244353;\n\nint add(int x, int y)\n{\n    return ((x + y) % MOD + MOD) % MOD;\n}\n\nint mul(int x, int y)\n{\n    return x * 1ll * y % MOD;   \n}\n\nint binpow(int x, int y)\n{\n    int z = 1;\n    while(y)\n    {\n        if(y % 2 == 1) z = mul(z, x);\n        x = mul(x, x);\n        y /= 2;\n    }\n    return z;\n}\n\nint inv(int x)\n{\n    return binpow(x, MOD - 2);    \n}\n\nint divide(int x, int y)\n{\n    return mul(x, inv(y));\n}\n\nint main()\n{\n    int n;\n    cin >> n;\n    int ans = 1;\n    for(int i = 1; i <= n / 6; i++)\n        ans = mul(ans, divide(i + n / 6, i));\n    for(int i = 0; i < n / 3; i++)\n    {\n        vector<int> a(3);\n        for(int j = 0; j < 3; j++)\n            cin >> a[j];\n        int mn = *min_element(a.begin(), a.end());\n        int cnt_min = count(a.begin(), a.end(), mn);\n        ans = mul(ans, cnt_min);\n    }\n    cout << ans << endl;\n}", "interactive": false, "noSolution": false, "noTutorial": false}