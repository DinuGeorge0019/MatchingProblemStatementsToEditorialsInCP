{"link": "https://codeforces.com//contest/884/problem/C", "problemId": "130889", "shortId": "884C", "contest_number": "884", "name": "C. Bertown Subway", "statement": "The construction of subway in Bertown is almost finished! The President of Berland will visit this city soon to look at the new subway himself.There are  stations in the subway. It was built according to the :  For each station  there exists exactly one train that goes from this station. Its destination station is , possibly ;  For each station  there exists exactly one station  such that . The President will consider the  of subway after visiting it. The  is the number of ordered pairs  such that person can start at station  and, after taking some subway trains (possibly zero), arrive at station  ().The mayor of Bertown thinks that if the subway is not  enough, then the President might consider installing a new mayor (and, of course, the current mayor doesn't want it to happen). Before President visits the city mayor has enough time to rebuild some paths of subway, thus changing the values of  for . Of course, breaking the  is really bad, so the subway must be built according to the  even after changes.The mayor wants to do these changes in such a way that the  of the subway is maximized. Help him to calculate the maximum possible  he can get! ", "input": "The first line contains one integer number  () \u2014 the number of stations. The second line contains  integer numbers , , ...,  () \u2014 the current structure of the subway. All these numbers are distinct.", "output": "Print one number \u2014 the maximum possible value of .", "tutorial": "Let's notice that one swap can affect at most two cycles of this permutation. Moreover you can join two cycles into one with the length equal to the sums of lengths of initial ones. The function we are going to maximize is , where  and  are the lengths of the cycles we are joining together. . Now its easily seen that the maximum is achived when joining two cycles with the greatest product of lengths. Finally they are the two longest cycles in permutation.Overall complexity: .", "solution": "#include <array>\n#include <iterator>\n#include <functional>\n#include <utility>\n#include <cstdio>\n#include <vector>\n#include <map>\n\n\nstruct Range\n{   \n    struct It {   int num, step; int operator*(){return num;} void operator++(){num += step;} bool operator!=(const It& other){return num != other.num;} };\n    Range(int ee):b(0),e(ee){}\n    Range(int bb, int ee):b(bb), e(ee){}\n    It begin(){return {b, (b < e? 1: -1)};}\n    It end(){return {e, 0};}\n    int b, e;\n};\n\ntemplate<typename T> inline T& UMAX(T& x, T y){if(x < y)x = y; return x;}\ntemplate<typename T> inline T& UMIN(T& x, T y){if(y < x)x = y; return x;}\ntemplate<typename T, typename... Args> struct ArithmiticPromotion { typedef decltype(T() + typename ArithmiticPromotion<Args...>::type()) type; };\ntemplate<typename T, typename U> struct ArithmiticPromotion<T, U> { typedef decltype(T() + U()) type; };\ntemplate<typename T> struct ArithmiticPromotion<T, T> { typedef T type; };\ntemplate<typename T> struct ArithmiticPromotion<T> { typedef T type; };\ntemplate<typename T, typename U> typename ArithmiticPromotion<T, U>::type MAX(T a, U b) { return a < b? b: a; }\ntemplate<typename T, typename... Args> typename ArithmiticPromotion<T, Args...>::type MAX(T a, Args... args) { return MAX(a, MAX(args...)); }\ntemplate<typename T, typename U> typename ArithmiticPromotion<T, U>::type MIN(T a, U b) { return a < b? a: b; }\ntemplate<typename T, typename... Args> typename ArithmiticPromotion<T, Args...>::type MIN(T a, Args... args) { return MIN(a, MIN(args...)); }\n\n\n\ntemplate<typename T> struct ScanfSpecifier{};\n#define DEF(T,V) template<> struct ScanfSpecifier<T>{static constexpr const char* value = V;};\nDEF(char*,\"%s\")DEF(int,\"%d\")DEF(double,\"%lf\")DEF(float,\"%f\")DEF(char,\"%c\")DEF(const char*,\"%s\")DEF(unsigned long,\"%lu\")DEF(unsigned int, \"%u\")DEF(long double, \"%Lf\")\n#ifdef _MSC_VER\nDEF(long long int,\"%I64d\")\n#else\nDEF(long long int,\"%lld\")\n#endif\n#undef DEF\ntemplate<typename T> int RD(T& arg){return std::scanf(ScanfSpecifier<T>::value, &arg);}\ntemplate<int S> int RD(char (&arg)[S]){return std::scanf(\"%s\", arg);}\nint RD(char* arg){return std::scanf(\"%s\", arg);}\ntemplate<> int RD<char>(char& arg){return std::scanf(\" %c\", &arg);}\ntemplate<typename T, typename... Args> int RD(T& arg1, Args&... args) {return RD(arg1) + RD(args...);}\ntemplate<typename T> T RD(){T ret; RD(ret); return ret;}\ntemplate<typename It> void RDV(It begin, It end) { while(begin != end) RD(*begin++); }\ntemplate<typename C> void RDV(C& c) {RDV(std::begin(c), std::end(c));}\ntemplate<typename T> void WT(T arg) {std::printf(ScanfSpecifier<T>::value, arg); }\ntemplate<typename T, typename U> void WT(std::pair<T, U> arg) {std::printf(\"(\"); WT(arg.first); std::printf(\", \"); WT(arg.second); std::printf(\")\");}\ntemplate<typename... Args> void WT(Args... args) { int alc = 0; int dummy[] = {((alc++? std::printf(\" \"): 0), WT(args), 0)...}; }\n\ntemplate<typename... Args> void WTL(Args... args) { WT(args...); std::printf(\"\\n\"); }\ntemplate<typename It> void WTV(It begin, It end) { int alc = 0; while(begin != end) (alc++? std::printf(\" \"): 0), WT(*begin++); }\ntemplate<typename C> void WTV(const C& c) {WTV(std::begin(c), std::end(c));}\ntemplate<typename It> void WTVL(It begin, It end) { WTV(begin, end); std::printf(\"\\n\"); }\ntemplate<typename C> void WTVL(const C& c) {WTVL(std::begin(c), std::end(c));}\n\n#define _M_VARGS_NUM_IMPL(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, N, ...) N\n#define _M_VARGS_NUM(...) _M_VARGS_NUM_IMPL(__VA_ARGS__, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1)\n#define _W1(_1) (#_1[0] == '\"' || #_1[0] == '\\''? WT(\"\", _1, \"\"): WT('[', #_1, '=', _1, ']'))\n#define _W2(_1, _2) (_W1(_1), _W1(_2))\n#define _W3(_1, _2, _3) (_W1(_1), _W2(_2, _3))\n#define _W4(_1, _2, _3, _4) (_W1(_1), _W3(_2, _3, _4))\n#define _W5(_1, _2, _3, _4, _5) (_W1(_1), _W4(_2, _3, _4, _5))\n#define _W6(_1, _2, _3, _4, _5, _6) (_W1(_1), _W5(_2, _3, _4, _5, _6))\n#define _W7(_1, _2, _3, _4, _5, _6, _7) (_W1(_1), _W6(_2, _3, _4, _5, _6, _7))\n#define _W8(_1, _2, _3, _4, _5, _6, _7, _8) (_W1(_1), _W7(_2, _3, _4, _5, _6, _7, _8))\n#define _WW_IMPL2(num, ...) _W ## num(__VA_ARGS__)\n#define _WW_IMPL(num, ...) _WW_IMPL2(num, __VA_ARGS__)\n#define WW(...) (std::printf(\"(%03d) \", __LINE__), _WW_IMPL(_M_VARGS_NUM(__VA_ARGS__), __VA_ARGS__), WTL(\"\"))\n\n\n\n\n//alias\n//RD[L],RDV[L],WT[L],WTV[L] for i/o\nusing RG = Range;\n//template\n#include <vector>\n#include <string>\n#include <cstring>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdlib>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\ntypedef long long int ll;\n\nconst int SIZE = 100009;\nint P[SIZE];\n\nint main()\n{\n    int N;\n    RD(N);\n    RDV(P + 1, P + N + 1);\n\n    vector<ll> cad;\n    for(int i: RG(1, N + 1))\n        if(P[i])\n        {\n            int alc = 0;\n            for(int j = i; P[j]; )\n            {\n                int k = P[j];\n                P[j] = 0;\n                j = k;\n                alc++;\n            }\n\n            cad.push_back(alc);\n        }\n\n    sort(cad.begin(), cad.end());\n    if(cad.size() == 1)\n        WTL(cad[0] * cad[0]);\n    else\n    {\n        ll ans = cad.back() + cad.end()[-2];\n        cad.pop_back();\n        cad.pop_back();\n        ans *= ans;\n        for(ll v: cad)\n            ans += v * v;\n        WTL(ans);\n\n\n    }\n\n\n\n}\n\n\n\n\n", "interactive": false, "noSolution": false, "noTutorial": false}