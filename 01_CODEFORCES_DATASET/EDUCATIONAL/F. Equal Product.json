{"link": "https://codeforces.com//contest/1418/problem/F", "problemId": "727428", "shortId": "1418F", "contest_number": "1418", "name": "F. Equal Product", "statement": "You are given four integers , ,  and .Let's name a tuple  as  if:   ;  ;  ;  . Find any good tuple .", "input": "The first line contains two integers  and  (). The second line contains two integers  and  ().", "output": "For each  from  to  inclusive:    if there are no such four integers, print ;  otherwise, print four integers , ,  and . If there are multiple answers, print any of them. ", "tutorial": "Let's look at  where . It can be proven that there always exists such pair  (,  and ) that  and .Brief proof is following: calculate , then let  and . Obviously, such  will make  from  and  from  (if ). And since     and since  .As we can see  divides , so if we will iterate over all pairs  where  there will be  pairs in total.Let's fix value of . Then, from one side,  but, from the other side, since , then . Anyway, all valid  form a segment (possibly, empty segment). And we need to find any  that divides any  from the segment and  doesn't exceed . Obviously, it's optimally to find the minimum possible such  and just check inequality .We can find such  for a fixed  using, for example, built-in  in a set with all divisors for all valid . To maintain this set we can note that  (simillary, ). So we can move valid segment's ends as two pointers.Each pair  will be added and erased from the segment exactly once. That's why the total complexity of maintaining the set of divisors (as well as the total complexity of queries for each ) will be equal to .All pairs  (and ) can be precalculated in  using the sieve-like algorithm.", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) int((a).size())\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef pair<int, int> pt;\n\ntemplate<class A, class B> ostream& operator <<(ostream& out, const pair<A, B> &p) {\n    return out << \"(\" << p.x << \", \" << p.y << \")\";\n}\ntemplate<class A> ostream& operator <<(ostream& out, const vector<A> &v) {\n    out << \"[\";\n    fore(i, 0, sz(v)) {\n        if(i) out << \", \";\n        out << v[i];\n    }\n    return out << \"]\";\n}\n\nconst int INF = int(1e9);\nconst li INF64 = li(1e18);\n\nint n, m;\nli l, r;\n\ninline bool read() {\n    if(!(cin >> n >> m))\n        return false;\n    cin >> l >> r;\n    return true;\n}\n\nconst int N = int(2e5) + 555;\nvector<int> divs[N];\n\ninline void solve() {\n    fore(d, 1, N) {\n        for(int pos = d; pos < N; pos += d)\n            divs[pos].push_back(d);\n    }\n    \n    li lf = m + 1, rg = m;\n    vector<int> cnt(m + 1, 0);\n    vector<int> id(m + 1, -1);\n    set<int> curDivs;\n    \n    vector< vector<int> > ans(n + 1);\n    \n    fore(x1, 1, n + 1) {\n        li newlf = (l + x1 - 1) / x1;\n        li newrg = r / x1;\n        assert(newrg - newlf + 1 >= 0);\n        \n        while (lf > newlf) {\n            lf--;\n            for (int d : divs[lf]) {\n                if (cnt[d] == 0)\n                    curDivs.insert(d);\n                cnt[d]++;\n                id[d] = (int)lf;\n            }\n        }\n        while (rg > newrg) {\n            for (int d : divs[rg]) {\n                cnt[d]--;\n                if (cnt[d] == 0)\n                    curDivs.erase(d);\n            }\n            rg--;\n        }\n        \n        for (int a : divs[x1]) {\n            auto it = curDivs.upper_bound(a);\n            if (it == curDivs.end())\n                continue;\n            \n            int b = *it;\n            if (x1 / a * 1ll * b <= n) {\n                int y1 = id[b];\n                \n                ans[x1] = {x1, y1, x1 / a * b, y1 / b * a};\n            }\n        }\n    }\n    \n    fore(i, 1, n + 1) {\n        if (ans[i].empty())\n            cout << -1 << '\\n';\n        else {\n            cout << ans[i][0] << \" \" << ans[i][1] << \" \" << ans[i][2] << \" \" << ans[i][3] << '\\n';\n        }\n    }\n}\n\nint main() {\n#ifdef _DEBUG\n    freopen(\"input.txt\", \"r\", stdin);\n    int tt = clock();\n#endif\n    ios_base::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n    cout << fixed << setprecision(15);\n    \n    if(read()) {\n        solve();\n        \n#ifdef _DEBUG\n        cerr << \"TIME = \" << clock() - tt << endl;\n        tt = clock();\n#endif\n    }\n    return 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}