{"link": "https://codeforces.com//contest/1743/problem/E", "problemId": "1590320", "shortId": "1743E", "contest_number": "1743", "name": "E. FTL", "statement": "Monocarp is playing a video game. In the game, he controls a spaceship and has to destroy an enemy spaceship.Monocarp has two lasers installed on his spaceship. Both lasers  and  have two values:   \u00a0\u2014 the power of the laser;  \u00a0\u2014 the reload time of the laser. When a laser is fully charged, Monocarp can either shoot it or wait for the other laser to charge and shoot both of them at the same time.An enemy spaceship has  durability and  shield capacity. When Monocarp shoots an enemy spaceship, it receives  damage (i.\u2009e.  gets subtracted from its durability), where  is the total power of the lasers that Monocarp shoots (i.\u2009e.  if he only shoots laser  and  if he shoots both lasers at the same time). An enemy spaceship is considered destroyed when its durability becomes  or lower.Initially, both lasers are zero charged.What's the lowest amount of time it can take Monocarp to destroy an enemy spaceship?", "input": "The first line contains two integers  and  (; )\u00a0\u2014 the power and the reload time of the first laser. The second line contains two integers  and  (; )\u00a0\u2014 the power and the reload time of the second laser. The third line contains two integers  and  (; )\u00a0\u2014 the durability and the shield capacity of an enemy spaceship. Note that the last constraint implies that Monocarp will always be able to destroy an enemy spaceship.", "output": "Print a single integer\u00a0\u2014 the lowest amount of time it can take Monocarp to destroy an enemy spaceship.", "tutorial": "At any time, we have three possible choices: wait and shoot the first laser, the second laser and both lasers. Sometimes it makes sense to wait to both because you can deal  more damage than you would do by shooting both lasers separately.The first claim: greedy won't work. Maybe there is a sufficiently smart greedy, we weren't able to come up with it. The second claim: bruteforce won't work. The funny thing is that it actually worked on the constraints up to , but again, we couldn't code any sufficiently fast one for .Thus, let's try some dynamic programming. Since all the times are huge, we'd want to avoid having them as the states. What is small, however, is the durability of the enemy ship and the number of shots we have to make to destroy it.Ideally, we'd like to have some \u00a0\u2014 the smallest time to deal  damage to the enemy ship. This way,  would be the answer. Sadly, it's not immediately clear how to get rid of reload times completely. There might be states with different times until the charge with the same damage dealt, and we don't know which of those we want to keep.Thus, let's make the dp state more complicated. Let  be the smallest time it takes to deal  damage if the last shot was from both lasers at the same time. This way we know the reload times of both lasers\u00a0\u2014 they are full  and ., as moment  has both lasers zero charged as if after a shot.What are the transitions? Well, now we have to shoot each laser multiple times, then wait until both are charged and shoot both. Both lasers can now be considered independent of each other.Let the time between the previous double shot and the next one be some value . During this time, it never made sense to wait until shooting each laser. So we waited , shot the first laser, waited another , shot again, until we couldn't shoot anymore, since the laser wouldn't recharge in time before the double shot. Same for the second laser. Notice that if both  and , then you could just decrease  by  and shoot each laser the same number of times. Thus, only  that are multiples of either  or  are optimal.Thus, we can iterate over all possible waiting times . Just iterate over  and  for all  from  to . Having a fixed , calculate the number of shots of each laser, calculate the damage, go into the corresponding dp state.It could also happen that the last shot before destroying the ship wasn't a double one. However, it still follows the same ideas. It means that each laser was shooting non-stop until the ship was destroyed. Thus, the destruction time is still a multiple of either of the reload times.Overall complexity: .", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst long long INF64 = 1e18;\n\nint main() {\n\tvector<int> ps(2);\n\tvector<long long> ts(2);\n\tint h, s;\n\tforn(i, 2) scanf(\"%d%lld\", &ps[i], &ts[i]);\n\tscanf(\"%d%d\", &h, &s);\n\tlong long ans = INF64;\n\tvector<long long> dp(h + 1, INF64);\n\tdp[0] = 0;\n\tforn(i, h) for (int j = 1; j <= h - i; ++j) forn(k, 2){\n\t\tint ni = min((long long)h, i + j * (ps[k] - s) + j * ts[k] / ts[k ^ 1] * (ps[k ^ 1] - s));\n\t\tif (ni == h)\n\t\t\tans = min(ans, dp[i] + j * ts[k]);\n\t\tif (j * ts[k] >= ts[k ^ 1]){\n\t\t\tni = min((long long)h, i + (j - 1) * (ps[k] - s) + (j * ts[k] / ts[k ^ 1] - 1) * (ps[k ^ 1] - s) + (ps[0] + ps[1] - s));\n\t\t\tdp[ni] = min(dp[ni], dp[i] + j * ts[k]);\n\t\t}\n\t}\n\tans = min(ans, dp[h]);\n\tprintf(\"%lld\\n\", ans);\n}", "interactive": false, "noSolution": false, "noTutorial": false}