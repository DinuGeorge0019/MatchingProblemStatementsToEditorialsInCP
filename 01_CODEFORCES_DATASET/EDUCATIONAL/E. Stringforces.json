{"link": "https://codeforces.com//contest/1550/problem/E", "problemId": "1045985", "shortId": "1550E", "contest_number": "1550", "name": "E. Stringforces", "statement": "You are given a string  of length . Each character is either one of the first  lowercase Latin letters or a question mark.You are asked to replace every question mark with one of the first  lowercase Latin letters in such a way that the following value is maximized.Let  be the maximum length substring of string , which consists entirely of the -th Latin letter. A substring of a string is a contiguous subsequence of that string. If the -th letter doesn't appear in a string, then  is equal to .The value of a string  is the minimum value among  for all  from  to .What is the maximum value the string can have?", "input": "The first line contains two integers  and  (; )\u00a0\u2014 the length of the string and the number of first Latin letters used. The second line contains a string , consisting of  characters. Each character is either one of the first  lowercase Latin letters or a question mark.", "output": "Print a single integer\u00a0\u2014 the maximum value of the string after every question mark is replaced with one of the first  lowercase Latin letters.", "tutorial": "Notice that if there are substrings of length  for each letter, then there are also substrings of length . Thus, the function on the answer is monotonous, so the binary search is applicable.Let's have some answer  fixed by binary search. We have to place  blocks of letters of length  somewhere in a string. If we fix an order these blocks go into the string, then the greedy algorithm for placing them works. Put each block after the previous one but as far to the left as possible (the correctness can be proven by showing that picking not the furthest to the left position can't be more optimal). If there exists such an order that all blocks fit, then the answer is greater than or equal to .The common transition is to move from iterating over permutations to dynamic programming over submasks. Let  be the smallest prefix of the string, such that all blocks of letters from the mask fit into this prefix. The transitions are the same: pick a new block and place it as early after that prefix as possible.So far the solution works pretty slow, since for each of  masks we have to find the earliest possible position for a block. Let's use some precalculations to perform the transitions in .Notice that the transition doesn't depend on a mask, only on a length of the previous prefix. Thus, for every prefix and every letter, we can save the closest position for a block.Let  be the closest position for a prefix of length  and the -th letter.  is at least equal to . However, if the block can be placed at the -th position, then it should be updated. That can happen if the closest occurrence of any letter except  is not smaller than . Thus, we can also maintain the closest occurrence of every letter. With some smart iterations, we can do the precalculations in .The dynamic programming works in  then.Overall complexity: .", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nint n, k;\nstring s;\n\nbool check(int d){\n\tvector<int> lst(k, n);\n\tvector<vector<int>> pos(n + 1, vector<int>(k, n + 1));\n\tfor (int i = n - 1; i >= 0; --i){\n\t\tif (s[i] != '?'){\n\t\t\tlst[s[i] - 'a'] = i;\n\t\t}\n\t\tint cur = n;\n\t\tforn(j, k){\n\t\t\tpos[i][j] = (i + d <= cur ? i + d : pos[i + 1][j]);\n\t\t\tcur = min(cur, lst[j]);\n\t\t}\n\t\tcur = n;\n\t\tfor (int j = k - 1; j >= 0; --j){\n\t\t\tif (i + d > cur) pos[i][j] = pos[i + 1][j];\n\t\t\tcur = min(cur, lst[j]);\n\t\t}\n\t}\n\tvector<int> dp(1 << k, n + 1);\n\tdp[0] = 0;\n\tforn(mask, 1 << k) if (dp[mask] < n + 1){\n\t\tforn(i, k) if (!((mask >> i) & 1))\n\t\t\tdp[mask | (1 << i)] = min(dp[mask | (1 << i)], pos[dp[mask]][i]);\n\t}\n\treturn dp[(1 << k) - 1] <= n;\n}\n\nint main() {\n\tcin >> n >> k;\n\tcin >> s;\n\tint l = 1, r = n;\n\tint res = 0;\n\twhile (l <= r){\n\t\tint m = (l + r) / 2;\n\t\tif (check(m)){\n\t\t\tres = m;\n\t\t\tl = m + 1;\n\t\t}\n\t\telse{\n\t\t\tr = m - 1;\n\t\t}\n\t}\n\tcout << res << endl;\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}