{"link": "https://codeforces.com//contest/1569/problem/C", "problemId": "1103181", "shortId": "1569C", "contest_number": "1569", "name": "C. Jury Meeting", "statement": " people gathered to hold a jury meeting of the upcoming competition, the -th member of the jury came up with  tasks, which they want to share with each other.First, the jury decides on the order which they will follow while describing the tasks. Let that be a permutation  of numbers from  to  (an array of size  where each integer from  to  occurs exactly once).Then the discussion goes as follows:  If a jury member  has some tasks left to tell, then they tell one task to others. Otherwise, they are skipped.  If a jury member  has some tasks left to tell, then they tell one task to others. Otherwise, they are skipped.  ...  If a jury member  has some tasks left to tell, then they tell one task to others. Otherwise, they are skipped.  If there are still members with tasks left, then the process repeats from the start. Otherwise, the discussion ends. A permutation  is nice if none of the jury members tell two or more of their own tasks in a row. Count the number of nice permutations. The answer may be really large, so print it modulo .", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of test cases. The first line of the test case contains a single integer  ()\u00a0\u2014 number of jury members. The second line contains  integers  ()\u00a0\u2014 the number of problems that the -th member of the jury came up with. The sum of  over all test cases does not exceed .", "output": "For each test case, print one integer\u00a0\u2014 the number of nice permutations, taken modulo .", "tutorial": "Note that if there are at least two members with the maximum value of , then any permutation is nice.Now let's consider the case when there is only one maximum. Let's find out when the permutation is nice. Let  be the index of the jury member with the maximum number of tasks. Then, during the -th discussion round, they will be the only one who will tell their task, because the other members of the jury have already told all their tasks. So during the -th discussion round, there should be a jury member who tells a task after the -th jury member.Let  be the number of elements in the array  equal to . Then, if at least one of these  jury members goes after the jury member  in the permutation, then the permutation is nice. Using this, we will count the number of bad permutations. Let's fix the elements in the permutation that are not equal to  or , there are  of them, then the number of ways is . It remains to place  elements so that the maximum is in the last position among them, there are  such ways. The total number of bad permutations is . So the answer is .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MOD = 998244353;\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL); \n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int &x : a) cin >> x;\n    int mx = *max_element(a.begin(), a.end());\n    int cmx = count(a.begin(), a.end(), mx);\n    int k = count(a.begin(), a.end(), mx - 1);\n    int ans = 1, sub = 1;\n    for (long long i = 1; i <= n; ++i) {\n      ans = ans * i % MOD;\n      if (i != k + 1) sub = sub * i % MOD;\n    }\n    if (cmx == 1) ans = (ans - sub + MOD) % MOD;\n    cout << ans << '\\n';\n  }\n}", "interactive": false, "noSolution": false, "noTutorial": false}