{"link": "https://codeforces.com//contest/813/problem/C", "problemId": "108590", "shortId": "813C", "contest_number": "813", "name": "C. The Tag Game", "statement": "Alice got tired of playing the tag game by the usual rules so she offered Bob a little modification to it. Now the game should be played on an undirected rooted tree of  vertices. Vertex  is the root of the tree.Alice starts at vertex  and Bob starts at vertex  (). The moves are made in turns, Bob goes first. In one move one can either stay at the current vertex or travel to the neighbouring one.The game ends when Alice goes to the same vertex where Bob is standing. Alice wants to minimize the total number of moves and Bob wants to maximize it.You should write a program which will determine how many moves will the game last.", "input": "The first line contains two integer numbers  and  (, ). Each of the next  lines contains two integer numbers  and  () \u2014 edges of the tree. It is guaranteed that the edges form a valid tree.", "output": "Print the total number of moves Alice and Bob will make.", "tutorial": "If you check some games then you will notice that the most optimal strategy for Bob is always like this:  Climb up for some steps (possibly zero)  Go to the lowest vertex from it  Stay in this vertex till the end Thus let's precalc the depth (the distance from the root) of the lowest vertex of each subtree (using dfs), distance from Alice's starting node and from Bob's starting node to the vertex (again dfs/bfs).Now iterate over all vertices and check if Bob can reach this vertex earlier than Alice. If he can then update the answer with the lowest vertex that can be reached from this one.The answer is doubled depth of the obtained lowest reachable vertex. That is the time which will take Alice to get there.Overall complexity: .", "solution": "#include <bits/stdc++.h>\nusing namespace std;\n#define N 202020\nvector<int> v[ N ];\nint n , x , dep[ N ] , ans;\nvoid go( int now , int prt , int ndep ){\n  dep[ now ] = ndep;\n  for( int son : v[ now ] ){\n    if( son == prt ) continue;\n    go( son , now , ndep + 1 );\n  }\n}\nint bdr;\nvoid go2( int now , int prt ){\n  if( dep[ now ] <= bdr ) return;\n  ans = max( ans , dep[ now ] );\n  for( int son : v[ now ] ){\n    if( son == prt ) continue;\n    go2( son , now );\n  }\n}\nint main(){\n  cin >> n >> x;\n  for( int i = 1 ; i < n ; i ++ ){\n    int a , b; cin >> a >> b;\n    v[ a ].push_back( b );\n    v[ b ].push_back( a );\n  }\n  go( 1 , 1 , 0 );\n  bdr = dep[ x ] / 2;\n  go2( x , x );\n  printf( \"%d\\n\" , ans << 1 );\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}