{"link": "https://codeforces.com//contest/1251/problem/D", "problemId": "449547", "shortId": "1251D", "contest_number": "1251", "name": "D. Salary Changing", "statement": "You are the head of a large enterprise.  people work at you, and  is odd (i.\u2009e.  is not divisible by ).You have to distribute salaries to your employees. Initially, you have  dollars for it, and the -th employee should get a salary from  to  dollars. You have to distribute salaries in such a way that the median salary is .To find the median of a sequence of odd length, you have to sort it and take the element in the middle position after sorting. For example:  the median of the sequence  is ,  the median of the sequence  is . It is guaranteed that you have enough money to pay the minimum salary, i.e .You have to answer  test cases.", "input": "The first line contains one integer  () \u2014 the number of test cases. The first line of each query contains two integers  and  (, ) \u2014 the number of employees and the amount of money you have. The value  is not divisible by . The following  lines of each query contain the information about employees. The -th line contains two integers  and  (). It is guaranteed that the sum of all  over all queries does not exceed . It is also guaranteed that you have enough money to pay the minimum salary to each employee, i.\u2009e. .", "output": "For each test case print one integer \u2014 the maximum median salary that you can obtain.", "tutorial": "Let  be equal minimum amount of money to obtain the median salary at least . We'll solve this problem by binary search by . Suppose the have to calculate the minimum amount of money for obtaining median salary at least . Let's divide all salaries into three groups:  ;  ;  .  In order to the median salary be at least  there must be at least  salaries greater than or equal to . Let's denote the number of such salaries as .Note that salaries of the first group can't increment the value of , so it's beneficial for us to pay the minimum salary for this group. Salaries if second group always increment the value of , so it's also beneficial for us to pay the minimum salary.The salaries from the third group are more interesting. For each salary  in this group we can pay  and increment , or we can pay  and don't increase . The value of  should be increased by . So, if the size of the third group is less than  than we can't obtain the median salary . Otherwise, we can define how many salaries we can take with value  and chose the minimal ones.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(2e5) + 99;\nconst int INF = int(1e9) + 100;\n\nint t;\nint n;\nlong long s;\npair<int, int> p[N];\n\nbool ok(int mid){\n\tlong long sum = 0;\n\tint cnt = 0;\n\tvector <int> v;\n\tfor(int i = 0; i < n; ++i){\n\t\tif(p[i].second < mid)\n\t\t\tsum += p[i].first;\n\t\telse if(p[i].first >= mid){\n\t\t\tsum += p[i].first;\n\t\t\t++cnt;\n\t\t}\n\t\telse\n\t\t\tv.push_back(p[i].first);\n\t}\n\n\tassert(is_sorted(v.begin(), v.end()));\n\t\n\tint need = max(0, (n + 1) / 2 - cnt);\n\tif(need > v.size()) return false;\n\tfor(int i = 0; i < v.size(); ++i){\n\t\tif(i < v.size() - need)\n\t\t\tsum += v[i];\n\t\telse\n\t\t\tsum += mid;\n\t}\n\n\treturn sum <= s;\n}\n\nint main() {\t\n\tscanf(\"%d\", &t);\n\tfor(int tc = 0; tc < t; ++tc){\n\t\tscanf(\"%d %lld\", &n, &s);\n\t\tfor(int i = 0; i < n; ++i)\n\t\t\tscanf(\"%d %d\", &p[i].first, &p[i].second);\n\t\t\n\t\tsort(p, p + n);\n\t\tint lf = 1, rg = INF; ///WA -> 10^9\n\t\twhile(rg - lf > 1){\n\t\t\tint mid = (lf + rg) / 2;\n\t\t\tif(ok(mid)) lf = mid;\n\t\t\telse rg = mid;\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", lf);\n\t}\n\treturn 0;\n}                             \t", "interactive": false, "noSolution": false, "noTutorial": false}