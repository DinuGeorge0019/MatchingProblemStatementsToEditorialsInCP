{"link": "https://codeforces.com//contest/1187/problem/E", "problemId": "365121", "shortId": "1187E", "contest_number": "1187", "name": "E. Tree Painting", "statement": "You are given a tree (an undirected connected acyclic graph) consisting of  vertices. You are playing a game on this tree.Initially all vertices are white. On the first turn of the game you choose one vertex and paint it black. Then on each turn you choose a white vertex adjacent (connected by an edge) to  black vertex and paint it black.Each time when you choose a vertex (even during the first turn), you gain the number of points equal to the size of the connected component consisting only of white vertices that contains the chosen vertex. The game ends when all vertices are painted black.Let's see the following example:Vertices  and  are painted black already. If you choose the vertex , you will gain  points for the connected component consisting of vertices  and . If you choose the vertex , you will gain  points for the connected component consisting of vertices  and .Your task is to maximize the number of points you gain.", "input": "The first line contains an integer  \u2014 the number of vertices in the tree (). Each of the next  lines describes an edge of the tree. Edge  is denoted by two integers  and , the indices of vertices it connects (, ). It is guaranteed that the given edges form a tree.", "output": "Print one integer \u2014 the maximum number of points you gain if you will play optimally.", "tutorial": "I should notice that there is much simpler idea and solution for this problem without rerooting technique but I will try to explain rerooting as the main solution of this problem (it can be applied in many problems and this is just very simple example).What if the root of the tree is fixed? Then we can notice that the answer for a subtree can be calculated as , where  is the set of children of the vertex . The answer on the problem for the fixed root will be .How can we calculate all possible values of  for each root from  to  fast enough? We can apply rerooting! When we change the root of tree from the vertex  to the vertex , we can notice that only four values will change:  and . Firstly, we need to cut the subtree of  from the tree rooted at . Let's subtract  and  from , then let's change the size of the subtree of  (subtract  from it). Now we have the tree without the subtree of . Then we need to append  as a child of . Add  to  and add  and  to . Now we have  as a root of the tree and can update the answer with . When we changes the root of the tree back from  to , we just need to rollback all changes we made.So, overall idea is the following: calculate sizes of subtrees for some fixed root, calculate dynamic programming for this root, run dfs which will reroot the tree with any possible vertex and update the answer with the value of dynamic programming for each possible root.The code of function that reroots the tree seems like this: void dfs(int v, int p = -1) {\tans = max(ans, dp[v]);\tfor (auto to : g[v]) {\t\tif (to == p) continue;\t\t\t\tdp[v] -= dp[to];\t\tdp[v] -= siz[to];\t\tsiz[v] -= siz[to];\t\tsiz[to] += siz[v];\t\tdp[to] += siz[v];\t\tdp[to] += dp[v];\t\t\t\tdfs(to, v);\t\t\t\tdp[to] -= dp[v];\t\tdp[to] -= siz[v];\t\tsiz[to] -= siz[v];\t\tsiz[v] += siz[to];\t\tdp[v] += siz[to];\t\tdp[v] += dp[to];\t}}", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n;\nlong long ans;\nvector<int> siz;\nvector<long long> dp;\nvector<vector<int>> g;\n\nint calcsize(int v, int p = -1) {\n\tsiz[v] = 1;\n\tfor (auto to : g[v]) {\n\t\tif (to == p) continue;\n\t\tsiz[v] += calcsize(to, v);\n\t}\n\treturn siz[v];\n}\n\nlong long calcdp(int v, int p = -1) {\n\tdp[v] = siz[v];\n\tfor (auto to : g[v]) {\n\t\tif (to == p) continue;\n\t\tdp[v] += calcdp(to, v);\n\t}\n\treturn dp[v];\n}\n\nvoid dfs(int v, int p = -1) {\n\tans = max(ans, dp[v]);\n\tfor (auto to : g[v]) {\n\t\tif (to == p) continue;\n\t\t\n\t\tdp[v] -= dp[to];\n\t\tdp[v] -= siz[to];\n\t\tsiz[v] -= siz[to];\n\t\tsiz[to] += siz[v];\n\t\tdp[to] += siz[v];\n\t\tdp[to] += dp[v];\n\t\t\n\t\tdfs(to, v);\n\t\t\n\t\tdp[to] -= dp[v];\n\t\tdp[to] -= siz[v];\n\t\tsiz[to] -= siz[v];\n\t\tsiz[v] += siz[to];\n\t\tdp[v] += siz[to];\n\t\tdp[v] += dp[to];\n\t}\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tcin >> n;\n\tg = vector<vector<int>>(n);\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t--x, --y;\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t}\n\t\n\tans = 0;\n\tsiz = vector<int>(n);\n\tdp = vector<long long>(n);\n\t\n\tcalcsize(0);\n\tcalcdp(0);\n\tdfs(0);\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}