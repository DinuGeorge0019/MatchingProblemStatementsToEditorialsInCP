{"link": "https://codeforces.com//contest/818/problem/G", "problemId": "112251", "shortId": "818G", "contest_number": "818", "name": "G. Four Melodies", "statement": "Alice is a composer, and recently she had recorded two tracks that became very popular. Now she has got a lot of fans who are waiting for new tracks. This time Alice wants to form four melodies for her tracks.Alice has a sheet with  notes written on it. She wants to take four such non-empty non-intersecting subsequences that all of them form a  and sum of their lengths is maximal.Subsequence forms a melody when each two adjacent notes either differ by  or are congruent modulo .You should write a program which will calculate maximum sum of lengths of such four non-empty non-intersecting subsequences that all of them form a melody.", "input": "The first line contains one integer number  (). The second line contains  integer numbers  () \u2014 notes written on a sheet.", "output": "Print maximum sum of lengths of such four non-empty non-intersecting subsequences that all of them form a melody.", "tutorial": "Let's build a directed graph where vertices represent notes and a directed edge comes from vertex  to vertex  iff  and  and  can be consecutive notes in a melody. Now we have to find four longest vertex-disjoint paths in this graph.This problem can be solved with mincost -flow algorithms. We build a network where each vertex of the graph is split into two (let's denote the vertices that we obtain when we are splitting some vertex  as  and ). Then each directed edge  transforms into a directed edge from vertex  to vertex  in the network, the capacity of this edge is , and the cost is . Also we add directed edges from the source to every vertex  and from every vertex  to the sink (they have the same characteristics: capacity is , cost is ). And for each  we add a directed edge between  and ; these edges actually represent that we are using some note in a melody, so their capacities are also equal to , and their costs are . The answer to the problem is equal to the absolute value of minimum cost of -flow in this network.The bad thing is that the network is really large. So we have to use some advanced mincost algorithm here.Model solution uses Dijkstra's algorithm with Johnson's potentials to find augmenting paths of minimum cost. We set a number  for each vertex  of the network (these numbers are called potentials). Then we modify costs of the edges: if some edge  had cost , now it's cost is . It's easy to prove that if some path from vertex  to vertex  was the shortest one between these vertices without modifying the costs with potentinals, then after modifying it will also be the shortest between these vertices. So instead of looking for an augmenting path in the original network we can try looking for it in a network with modified edges. Why? Because it is always possible to set all potentials in such a way that all costs of edges will be non-negative (and we will be able to use Dijkstra to find the shortest path from the source to the sink).Before looking for the first augmenting path, we calculate potentials recursively: ,  (we check all 's such that there is an edge  in the network). The network is acyclic before we push flow, so there is always a way to calculate these potentials with dynamic programming. Then each time we want to find an augmenting path, we run Dijkstra's algoritm on modified network, push flow through the path we found and modify the potentials: new potential of each vertex  becomes , where  is the distance between the source and vertex  in the modified network (and we found this distance with Dijkstra). When we have found four augmenting paths, we are done and it's time to evaluate the cost of the flow.", "solution": "#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\ninline int getint(){\n  int _x=0; char _tc=getchar();    \n  while(_tc<'0'||_tc>'9') _tc=getchar();\n  while(_tc>='0'&&_tc<='9') _x*=10,_x+=(_tc-'0'),_tc=getchar();\n  return _x;\n}\n/*\n  A template for Min Cost Max Flow\n  tested with TIOJ 1724\n*/\nstruct MinCostMaxFlow{\n  static const int MAXV = 10010;\n  static const int INF  = 1000000;\n  struct Edge{\n    int v, cap, w, rev;\n    Edge(){}\n    Edge(int t2, int t3, int t4, int t5)\n    : v(t2), cap(t3), w(t4), rev(t5) {}\n  };\n  int V, s, t;\n  vector<Edge> g[MAXV];\n  void init(int n){\n    V = n+2;\n    s = n+1, t = n+2;\n    for(int i = 1; i <= V; i++) g[i].clear();\n  }\n  void addEdge(int a, int b, int cap, int w){\n    g[a].push_back(Edge(b, cap, w, (int)g[b].size()));\n    g[b].push_back(Edge(a, 0, -w, (int)g[a].size()-1));\n  }\n  int d[MAXV], id[MAXV], mom[MAXV];\n  bool inqu[MAXV];\n  //the size of qu should be much large than MAXV\n  int solve(){\n    int mxf = 0, mnc = 0;\n    while(1){\n      fill(d+1, d+1+V, INF);\n      fill(inqu+1, inqu+1+V, 0);\n      fill(mom+1, mom+1+V, -1);\n      mom[s] = s;\n      d[s] = 0;\n      queue<int> Q;\n      Q.push(s);\n      inqu[s] = 1;\n      while(not Q.empty()){\n        int u = Q.front(); Q.pop();\n        inqu[u] = 0;\n        for(int i = 0; i < (int) g[u].size(); i++){\n          Edge &e = g[u][i];\n          int v = e.v;\n          if(e.cap > 0 && d[v] > d[u]+e.w){\n            d[v] = d[u]+e.w;\n            mom[v] = u;\n            id[v] = i;\n            if(!inqu[v]) Q.push(v), inqu[v] = 1;\n          }\n        }\n      }\n      if(mom[t] == -1) break ;\n      int df = INF;\n      for(int u = t; u != s; u = mom[u])\n        df = min(df, g[mom[u]][id[u]].cap);\n      for(int u = t; u != s; u = mom[u]){\n        Edge &e = g[mom[u]][id[u]];\n        e.cap             -= df;\n        g[e.v][e.rev].cap += df;\n      }\n      mxf += df;\n      mnc += df*d[t];\n    }\n    return mnc;\n  }\n} flow;\n#define N 3030\nint n , a[ N ];\nvoid init(){\n  n = getint();\n  //n = 3000;\n  for( int i = 1 ; i <= n ; i ++ ){\n    a[ i ] = getint();\n    //a[ i ] = 2 - (i % 2);\n  }\n}\nvoid solve(){\n  flow.init( n + n + 1 );\n  int s = n + n + 1;\n  flow.addEdge( flow.s , s , 4 , 0 );\n// void addEdge(int a, int b, int cap, int w){\n  for( int i = 1 ; i <= n ; i ++ ){\n    flow.addEdge( s , i , 1 , 0 );\n    flow.addEdge( i , i + n , 1 , -1 );\n    flow.addEdge( i + n , flow.t , 1 , 0 );\n    //for( int j = i + 1 ; j <= n ; j ++ )\n      //if( abs( a[ i ] - a[ j ] ) == 1 or a[ i ] % 7 == a[ j ] % 7 )\n        //flow.addEdge( i + n , j , 1 , 0 );\n    int con = 0;\n    int neg = 0;\n    int pos = 0;\n#define MAGIC 55\n    for( int j = i + 1 ; j <= n ; j ++ ){\n      if( a[ j ] - a[ i ] == -1 and neg < MAGIC ){\n        neg ++;\n        flow.addEdge( i + n , j , 1 , 0 );\n      }\n      if( a[ j ] - a[ i ] == +1 and pos < MAGIC ){\n        pos ++;\n        flow.addEdge( i + n , j , 1 , 0 );\n      }\n      if( a[ j ] % 7 == a[ i ] % 7 and con < MAGIC ){\n        con ++;\n        flow.addEdge( i + n , j , 1 , 0 );\n      }\n    }\n  }\n  cout << -flow.solve() << endl;\n}\nint main(){\n  init();\n  solve();\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}