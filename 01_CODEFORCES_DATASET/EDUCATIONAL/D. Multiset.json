{"link": "https://codeforces.com//contest/1354/problem/D", "problemId": "623447", "shortId": "1354D", "contest_number": "1354", "name": "D. Multiset", "statement": "You are given a multiset consisting of  integers. You have to process queries of two types:  add integer  into the multiset;  find the -th order statistics in the multiset and remove it. -th order statistics in the multiset is the -th element in the sorted list of all elements of the multiset. For example, if the multiset contains elements , , , , , , , and , then you have to find the -rd element in , which is . If you try to delete an element which occurs multiple times in the multiset, only one occurence is removed. After processing all queries, print  number belonging to the multiset, or say that it is empty.", "input": "The first line contains two integers  and  () \u2014 the number of elements in the initial multiset and the number of queries, respectively. The second line contains  integers , , ...,  () \u2014 the elements of the multiset. The third line contains  integers , , ..., , each representing a query:    if , then the -th query is \"insert  into the multiset\";  if , then the -th query is \"remove the -th order statistics from the multiset\". For this query, it is guaranteed that  is not greater than the size of the multiset. ", "output": "If the multiset is empty after all queries, print . Otherwise, print any integer that belongs to the resulting multiset.", "tutorial": "First solution: write some data structure that would simulate the operations as they are given, for example, a segment tree or a Fenwick tree. Probably will require optimization since the limits are strict.Second solution: notice that we have to find only one number belonging to the multiset. For example, let's find the minimum element. We can do it with binary search as follows: let's write a function that, for a given element , tells the number of elements not greater than  in the resulting multiset. To implement it, use the fact that all elements  are indistinguishable, and all elements  are indistinguishable too, so the multiset can be maintained with just two counters.Okay, how does this function help? The minimum in the resulting multiset is the minimum  such that this function returns non-zero for it, and since the function is monotonous, we can find the answer with binary search.", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint n, q;\nvector<int> a, k;\n\nint count_le(int x)\n{\n\tint cnt = 0;\n\tfor(auto y : a)\n\t\tif(y <= x)\n\t\t\tcnt++;\n\tfor(auto y : k)\n\t{\n\t\tif(y > 0 && y <= x)\n\t\t\tcnt++;\n\t\tif(y < 0 && abs(y) <= cnt)\n\t\t\tcnt--;\n\t}\n\treturn cnt;\n}\n\nint main()\n{\n\tscanf(\"%d %d\", &n, &q);\n\ta.resize(n);\n\tk.resize(q);\n\tfor(int i = 0; i < n; i++)\n\t\tscanf(\"%d\", &a[i]);\n\tfor(int i = 0; i < q; i++)\n\t\tscanf(\"%d\", &k[i]);\n\tif(count_le(int(1e9)) == 0)\n\t{\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\tint lf = 0;\n\tint rg = int(1e6) + 1;\n\twhile(rg - lf > 1)\n\t{\n\t\tint mid = (lf + rg) / 2;\n\t\tif(count_le(mid) > 0)\n\t\t\trg = mid;\n\t\telse\n\t\t\tlf = mid;\n\t}\n\tprintf(\"%d\\n\", rg);\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}