{"link": "https://codeforces.com//contest/1796/problem/E", "problemId": "1802549", "shortId": "1796E", "contest_number": "1796", "name": "E. Colored Subgraphs", "statement": "Monocarp has a tree, consisting of  vertices.He is going to select some vertex  and perform the following operations on each vertex  from  to :   set  equal to the distance from  to  (the number of edges on the shortest path);  color  some color. A  coloring satisfies two conditions:   for each pair of vertices of the same color , there exists a path from  to  that only visits vertices of the same color;  for each pair of vertices of the same color , . Note that Monocarp can choose any amount of different colors he wants to use.For each used color, he then counts the number of vertices of this color. The  of the tree is the minimum of these numbers.What can be the maximum cost of the tree?", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of testcases. The first line of each testcase contains a single integer  ()\u00a0\u2014 the number of vertices in the tree. Each of the next  lines contains two integers  and  ()\u00a0\u2014 the description of an edge. The given edges form a tree. The sum of  over all testcases doesn't exceed .", "output": "For each testcase print a single integer\u00a0\u2014 the maximum possible cost of the tree.", "tutorial": "Let's start by choosing a vertex  naively. Iterate over all vertices and try each of them.Root the tree by  and observe what the conditions become.  for each  is just the depth of each vertex. Well, then the only case, when the connected subgraph of vertices of the same color has all values of  distinct, is when they form a vertical path in the tree.So the problem becomes the following. Split the tree into some vertical paths in such a way that the shortest path is as long as possible.Let's try greedy, I guess. Start the paths from the leaves and propagate them up. Consider some vertex  with at least two children. All children have some paths leading up to them. We'd love to continue them all with , but we can't do that. We can only continue one path and cut the rest. Pretty easy to see that the path to continue is the shortest path available. It's at least as optimal as any other path.Do that from the lowest vertices up, and you got yourself a working greedy. Also don't forget to stop all paths in root, since you can't continue any of them further up.Let's make this greedy more formal. Every time we update the answer is with a path that is:   the shortest in every vertex lower than the current one;  not the shortest in the current one. So we want to propagate the shortest child up and update the answer with the remaining children. Updating the answer means just taking the minimum of values. Thus, we can actually ignore all children except the second shortest in each vertex. Just don't forget to treat the root properly.Now we can actually solve the problem in  for a fixed . You can just find two minimums in each vertex. Well, now that we can solve the problem for a single root, let's try rerooting to solve for all of them. There are solutions in  but I found the solution in  the neatest. The constraints are low enough to allow it.For each vertex, maintain a multiset of lengths of vertical paths from its children. I chose to store nothing in the leaves\u00a0\u2014 that only makes the implementation cleaner. In order to update the vertex from its child, you can take the minimum element in the child's set and add  to it. If it's empty (the child is a leaf), return .Additionally, store a multiset of the second minimums of all vertices that have at least two children.In order to update the answer with the current root, find the minimum of that multiset and the shortest path from the root.To achieve , you will probably have to either store prefix and suffix second minimums over children of each vertex or store three shortest paths in it. It is kind of messy but it should still perform better.Overall complexity:  or  per testcase.", "solution": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define forn(i, n) for(int i = 0; i < int(n); i++) \n\nvector<vector<int>> g;\nvector<multiset<int>> len;\nmultiset<int> all;\n\nint getlen(int v){\n    return len[v].empty() ? 1 : *len[v].begin() + 1;\n}\n\nvoid init(int v, int p = -1){\n    for (int u : g[v]) if (u != p){\n        init(u, v);\n        len[v].insert(getlen(u));\n    }\n    if (int(len[v].size()) > 1){\n        all.insert(*(++len[v].begin()));\n    }\n}\n\nint ans;\n\nvoid dfs(int v, int p = -1){\n    ans = max(ans, min(*len[v].begin() + 1, *all.begin()));\n    \n    for (int u : g[v]) if (u != p){\n        if (int(len[v].size()) > 1) all.erase(all.find(*(++len[v].begin())));\n        len[v].erase(len[v].find(getlen(u)));\n        if (int(len[v].size()) > 1) all.insert(*(++len[v].begin()));\n        \n        if (int(len[u].size()) > 1) all.erase(all.find(*(++len[u].begin())));\n        len[u].insert(getlen(v));\n        if (int(len[u].size()) > 1) all.insert(*(++len[u].begin()));\n        \n        dfs(u, v);\n        \n        if (int(len[u].size()) > 1) all.erase(all.find(*(++len[u].begin())));\n        len[u].erase(len[u].find(getlen(v)));\n        if (int(len[u].size()) > 1) all.insert(*(++len[u].begin()));\n        \n        if (int(len[v].size()) > 1) all.erase(all.find(*(++len[v].begin())));\n        len[v].insert(getlen(u));\n        if (int(len[v].size()) > 1) all.insert(*(++len[v].begin()));\n    }\n}\n\nint main(){\n    int t;\n    scanf(\"%d\", &t);\n    while (t--){\n        int n;\n        scanf(\"%d\", &n);\n        g.assign(n, {});\n        forn(i, n - 1){\n            int v, u;\n            scanf(\"%d%d\", &v, &u);\n            --v, --u;\n            g[v].push_back(u);\n            g[u].push_back(v);\n        }\n        len.assign(n, {});\n        all.clear();\n        all.insert(n);\n        init(0);\n        ans = 0;\n        dfs(0);\n        printf(\"%d\\n\", ans);\n    }\n}", "interactive": false, "noSolution": false, "noTutorial": false}