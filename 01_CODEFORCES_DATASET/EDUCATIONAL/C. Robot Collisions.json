{"link": "https://codeforces.com//contest/1525/problem/C", "problemId": "987013", "shortId": "1525C", "contest_number": "1525", "name": "C. Robot Collisions", "statement": "There are  robots driving along an OX axis. There are also two walls: one is at coordinate  and one is at coordinate .The -th robot starts at an integer coordinate  and moves either left (towards the ) or right with the speed of  unit per second. No two robots start at the same coordinate.Whenever a robot reaches a wall, it turns around instantly and continues his ride in the opposite direction with the same speed.Whenever several robots meet at the same  coordinate, they collide and explode into dust. Once a robot has exploded, it doesn't collide with any other robot. Note that if several robots meet at a non-integer coordinate, nothing happens.For each robot find out if it ever explodes and print the time of explosion if it happens and  otherwise.", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of testcases. Then the descriptions of  testcases follow. The first line of each testcase contains two integers  and  (; )\u00a0\u2014 the number of robots and the coordinate of the right wall. The second line of each testcase contains  integers  ()\u00a0\u2014 the starting coordinates of the robots. The third line of each testcase contains  space-separated characters '' or ''\u00a0\u2014 the starting directions of the robots ('' stands for left and '' stands for right). All coordinates  in the testcase are distinct. The sum of  over all testcases doesn't exceed .", "output": "For each testcase print  integers\u00a0\u2014 for the -th robot output the time it explodes at if it does and  otherwise.", "tutorial": "Notice that the robots that start at even coordinates can never collide with the robots that start at odd coordinates. You can see that if a robot starts at an even coordinate, it'll be at an even coordinate on an even second and at an odd coordinate on an odd second.Thus, we'll solve the even and the odd cases separately.Sort the robots by their starting coordinate. Apparently, that step was an inconvenience for some of you. There is a common trick that can help you to implement that. Create a separate array of integer indices  and sort them with a comparator that looks up the value by indices provided to tell the order. This gives you the order of elements and doesn't require you to modify the original data in any way.Consider the task without reflections of the wall. Take a look at the first robot. If it goes to the left, then nothing ever happens to it. Otherwise, remember that it goes to the right. Look at the next one. If it goes to the left, then it can collide with the first one if that went to the right. Otherwise, remember that it also goes to the right. Now for the third one. If this one goes to the left, who does it collide with? Obviously, the rightmost alive robot that goes to the right.So the idea is to keep a stack of the alive robots. If a robot goes to the left, then check if the stack is empty. If it isn't, then the top of the stack robot is the one who will collide with it. Pop it from the stack, since it explodes. If a robot goes to the right, simply push it to the stack. The time of the collision is just the distance between the robots divided by .If there are robots left in the stack after every robot is processed, then they all go to the right together, so they never collide.What changes when the reflections are introduced?Almost nothing, actually. Well, now if the stack is empty and a robot goes to the left, then it behaves as a one going to the right. You can reflect the part of the way from its start to the wall. Just say that instead of starting at some  going to the left, it starts at  going to the right. Since there's no one alive to the left of him initially, that will change nothing. That  should be used for computing the collision time.However, the final robots in the stack also act differently. First, the top of the stack robots reflects off the wall and collides with the second on the stack one. Then the third and the fourth and so on. So you can pop them in pairs until  or  are left.The coordinate reflection trick can be used here as well. Imagine that the top of the stack starts at  and goes to the left instead of starting in  going to the right. For the same reason it changes nothing.Overall complexity: .", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nstruct bot{\n\tint x, d;\n};\n\nint main() {\n\tint t;\n\tcin >> t;\n\tforn(_, t){\n\t\tint n, m;\n\t\tscanf(\"%d%d\", &n, &m);\n\t\tvector<bot> a(n);\n\t\tforn(i, n) scanf(\"%d\", &a[i].x);\n\t\tforn(i, n){\n\t\t\tchar c;\n\t\t\tscanf(\" %c\", &c);\n\t\t\ta[i].d = c == 'L' ? -1 : 1;\n\t\t}\n\t\tvector<int> ord(n);\n\t\tiota(ord.begin(), ord.end(), 0);\n\t\tsort(ord.begin(), ord.end(), [&a](int x, int y){\n\t\t\treturn a[x].x < a[y].x;\n\t\t});\n\t\tvector<int> ans(n, -1);\n\t\tvector<vector<int>> par(2);\n\t\tfor (int i : ord){\n\t\t\tint p = a[i].x % 2;\n\t\t\tif (a[i].d == -1){\n\t\t\t\tif (par[p].empty())\n\t\t\t\t\tpar[p].push_back(i);\n\t\t\t\telse{\n\t\t\t\t\tint j = par[p].back();\n\t\t\t\t\tpar[p].pop_back();\n\t\t\t\t\tans[i] = ans[j] = (a[i].x - (a[j].d == 1 ? a[j].x : -a[j].x)) / 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tpar[p].push_back(i);\n\t\t\t}\n\t\t}\n\t\tforn(p, 2){\n\t\t\twhile (int(par[p].size()) > 1){\n\t\t\t\tint i = par[p].back();\n\t\t\t\tpar[p].pop_back();\n\t\t\t\tint j = par[p].back();\n\t\t\t\tpar[p].pop_back();\n\t\t\t\tans[i] = ans[j] = (2 * m - a[i].x - (a[j].d == 1 ? a[j].x : -a[j].x)) / 2;\n\t\t\t}\n\t\t}\n\t\tforn(i, n){\n\t\t\tprintf(\"%d \", ans[i]);\n\t\t}\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}