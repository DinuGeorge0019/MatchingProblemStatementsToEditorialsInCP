{"link": "https://codeforces.com//contest/1473/problem/A", "problemId": "864969", "shortId": "1473A", "contest_number": "1473", "name": "A. Replacing Elements", "statement": "You have an array . All  are positive integers.In one step you can choose three distinct indices , , and  (; ; ) and assign the sum of  and  to , i.\u00a0e. make .Can you make all  lower or equal to  using the operation above any number of times (possibly, zero)?", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of test cases. The first line of each test case contains two integers  and  (; )\u00a0\u2014 the number of elements in the array  and the value . The second line contains  integers  ()\u00a0\u2014 the array .", "output": "For each test case, print , if it's possible to make all elements  less or equal than  using the operation above. Otherwise, print . You may print each letter in any case (for example, , , ,  will all be recognized as positive answer).", "tutorial": "Let's note that since all  are positive, any . It means that we can't make the first and second minimums lower than they already are: suppose the first and second minimums are  and , if we choose any other element to replace, we can't make it less than  and if we choose to replace  or  we will only make them bigger.As a result, it means that we can choose for each element either not to change it or make it equal to . So, to be able to make all elements  we need just check that either  or maximum .We can do it, for example, by sorting our array  in increasing order and checking that either  or .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  int tc;\n  cin >> tc;\n  while (tc--) {\n    int n, d;\n    cin >> n >> d;\n    vector<int> a(n);\n    for (int& x : a) cin >> x;\n    sort(a.begin(), a.end());\n    cout << (a.back() <= d || a[0] + a[1] <= d ? \"YES\" : \"NO\") << endl;\n  }\n}", "interactive": false, "noSolution": false, "noTutorial": false}