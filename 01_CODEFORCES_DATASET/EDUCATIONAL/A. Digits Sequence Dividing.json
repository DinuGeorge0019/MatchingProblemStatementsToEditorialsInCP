{"link": "https://codeforces.com//contest/1107/problem/A", "problemId": "288734", "shortId": "1107A", "contest_number": "1107", "name": "A. Digits Sequence Dividing", "statement": "You are given a sequence  consisting of  digits from  to .You have to divide it into  segments (segment \u2014 is a consecutive sequence of elements) (in other words, you have to place separators between some digits of the sequence) in such a way that  and if the resulting division will be represented as an integer numbers sequence then each next element of this sequence will be  than the previous one.More formally: if the resulting division of the sequence is , where  is the number of element in a division, then for each  from  to  the condition  (using  comparing, it means that the integer representations of strings are compared) should be satisfied.For example, if  then you can divide it into parts  and it will be suitable division. But if you will divide it into parts  then it will be bad division because . If  then you can divide it into parts ,  but not into parts .Your task is to find  suitable division for each of the  independent queries.", "input": "The first line of the input contains one integer  () \u2014 the number of queries. The first line of the -th query contains one integer number  () \u2014 the number of digits in the -th query. The second line of the -th query contains one string  of length  consisting only of digits from  to .", "output": "If the sequence of digits in the -th query cannot be divided into  parts in a way described in the problem statement, print the single line \"\" for this query. Otherwise in the first line of the answer to this query print \"\", on the second line print  \u2014 the number of parts in your division of the -th query sequence and in the third line print  strings  \u2014 your division. Parts should be printed in order of the initial string digits. It means that if you write the parts one after another without changing their order then you'll get the string . See examples for better understanding.", "tutorial": "Since we just want to make two numbers such that the first number is smaller than the second, our best bet is to use only the first digit for the first number and the rest of the digits for the second number. Note that since the numbers can have up to 300 digits we shouldn't actually evaluate the second number. Instead, since the digits only include 1 through 9, we can handle that case by checking the number of digits. Code: 49002957\n", "solution": "#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int Q;\n    cin >> Q;\n\n    while (Q-- > 0) {\n        int N;\n        string S;\n        cin >> N >> S;\n\n        if (N == 2 && S[0] >= S[1]) {\n            cout << \"NO\" << '\\n';\n        } else {\n            cout << \"YES\" << '\\n';\n            cout << 2 << '\\n';\n            cout << S[0] << ' ' << S.substr(1) << '\\n';\n        }\n    }\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}