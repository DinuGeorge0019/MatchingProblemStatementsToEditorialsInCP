{"link": "https://codeforces.com//contest/1452/problem/D", "problemId": "802107", "shortId": "1452D", "contest_number": "1452", "name": "D. Radio Towers", "statement": "There are  towns located on a coordinate line, numbered from  to . The -th town is located at the point .You build a radio tower in each of the towns  with probability  (these events are independent). After that, you want to set the signal power on each tower to some integer from  to  (signal powers are not necessarily the same, but also not necessarily different). The signal from a tower located in a town  with signal power  reaches every city  such that .After building the towers, you want to choose signal powers in such a way that:  towns  and  don't get any signal from the radio towers;  towns  get signal from  one radio tower each. For example, if , and you have built the towers in towns ,  and , you may set the signal power of the tower in town  to , and the signal power of the towers in towns  and  to . That way, towns  and  don't get the signal from any tower, towns ,  and  get the signal from the tower in town , town  gets the signal from the tower in town , and town  gets the signal from the tower in town .Calculate the probability that, after building the towers, you will have a way to set signal powers to meet all constraints.", "input": "The first (and only) line of the input contains one integer  ().", "output": "Print one integer \u2014 the probability that there will be a way to set signal powers so that all constraints are met, taken modulo . Formally, the probability can be expressed as an irreducible fraction . You have to print the value of , where  is an integer such that .", "tutorial": "The crucial observation is that when the positions of towers are fixed, the way to set their signal powers is unique if it exists. That's because the first tower should have its signal power exactly equal to the required to cover all towns before it, the second tower should have signal power exactly equal to the required to cover all towns before it that weren't covered by the first one, and so on. So let's count the number of ways to cover all towns, and then divide it by .Covering all towns can be expressed as splitting  into the sum of several positive odd integers. It can be calculated with dynamic programming with prefix sums, but we can also prove that the number of ways to split  is exactly the -th integer in the Fibonacci sequence as follows (this proof uses mathematical induction):  for , it's quite obvious;  for  and , let's iterate on the length of the last segment. We have to sum ; ; ; , and so on, until we get ;  for  and , let's iterate on the length of the last segment, and add  to result since we can cover everything with a single segment. So, this is . , , and so on. So, the answer to the problem is .The last thing we have to consider is that we have to print a fraction modulo . Since  is a prime, using Fermat little theorem, we can calculate  as . Exponentiation must be done with some fast algorithm (for example, binary exponentiation).Note: it's common in problems requiring to calculate something modulo some prime number to have problems with overflow in intermediate calculations or some other issues when we forget to take the result of some expression modulo . I recommend using either special addition/multiplication/exponentiation functions that always take the result modulo  (an example how to write and use them can be viewed in the model solution), or a special modular integer data structure with overloaded operators that you have to implement by yourself.", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int MOD = 998244353;\n\nint add(int x, int y)\n{\n    x += y;\n    while(x >= MOD) x -= MOD;\n    while(x < 0) x += MOD;\n    return x;\n}\n\nint mul(int x, int y)\n{\n    return (x * 1ll * y) % MOD;\n}\n\nint binpow(int x, int y)\n{\n    int ans = 1;\n    while(y > 0)\n    {\n        if(y % 2 == 1)\n            ans = mul(ans, x);\n        x = mul(x, x);\n        y /= 2;\n    }\n    return ans;\n}\n\nint divide(int x, int y)\n{\n    return mul(x, binpow(y, MOD - 2));\n}\n\nint main()\n{\n    int n;\n    cin >> n;\n    vector<int> fib(n + 1);\n    fib[0] = 0;\n    fib[1] = 1;\n    for(int i = 2; i <= n; i++)\n        fib[i] = add(fib[i - 1], fib[i - 2]);\n    cout << divide(fib[n], binpow(2, n)) << endl;    \n}", "interactive": false, "noSolution": false, "noTutorial": false}