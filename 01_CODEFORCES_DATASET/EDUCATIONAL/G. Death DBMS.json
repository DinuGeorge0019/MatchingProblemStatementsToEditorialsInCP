{"link": "https://codeforces.com//contest/1437/problem/G", "problemId": "775845", "shortId": "1437G", "contest_number": "1437", "name": "G. Death DBMS", "statement": "For the simplicity, let's say that the \"Death Note\" is a notebook that kills a person when their name is written in it.It's easy to kill with it, but it's pretty hard to keep track of people you haven't killed and still plan to. You decided to make a \"Death Database Management System\"\u00a0\u2014 a computer program that provides the easy access to the database of possible victims. Let me describe its specifications to you.Let's define a victim entity: a victim has a name (not necessarily unique) that consists only of lowercase Latin letters and an integer suspicion value.At the start of the program the user enters a list of  victim names into a database, each suspicion value is set to .Then the user makes queries of two types:   \u00a0\u2014 set the suspicion value of the -th victim to ;  \u00a0\u2014 given a string  find the maximum suspicion value of a victim whose name is a contiguous substring of . Just to remind you, this program doesn't kill people, it only helps to search for the names to write down in an actual notebook. Thus, the list of the victims in the database doesn't change throughout the queries.What are you waiting for? Write that program now!", "input": "The first line contains two integers  and  ()\u00a0\u2014 the number of victims and the number of queries, respectively. Each of the next  lines contains a single string \u00a0\u2014 the name of the -th victim. Each name consists only of lowercase Latin letters. Each of the next  lines contains a query of one of two types:     (, )\u00a0\u2014 change the suspicion value of the -th victim to ;  \u00a0\u2014 given a string  consisting only of lowercase Latin letters find the maximum suspicion value of a victim whose name is a contiguous substring of .  There is at least one query of the second type. The total length of the strings  doesn't exceed . The total length of the strings  doesn't exceed . ", "output": "For each query of the second type print an integer value. If there is no victim name that is a contiguous substring of , then print . Otherwise, print the maximum suspicion value of a victim whose name is a contiguous substring of .", "tutorial": "I'm feeling extremely amused by the power of Aho-Corasick lately, so I will describe two solutions of this problem with it. Feel free to point out how cool you are solving the task with hashes or some suffix structure but Aho solutions will still be cooler. I also want to mention I'm quite proud of the name I came up with for that task :)First, let's assume that the words in the dictionary are unique.Build an Aho-Corasick automaton on the dictionary. Then build the tree of its suffix links.For the first solution you can use the fact that there are not a lot of words in the dictionary that can end in each position. To be exact, at most one word per unique word length. Thus, that's bounded by the square root of the total length.For that reason you can iterate over all the words that end in all positions of the queries in . How to do that fast? For each vertex of the automaton precalculate the closest vertex up the suffix link tree that's a terminal. Feed the query word into the automaton and from each vertex you stay at just jump up the tree until you reach the root. Take the maximum value over all the visited terminals.The second solution actually involves an extra data structure on top of that. No, it's not HLD. You are boring for using it.Let's abuse the fact that you are allowed to solve the problem fully offline. For each word you can save the list of pairs (time, value) of the times the value of the word changed. For each vertex of the automaton you can save all the times that vertex has been queried from.Now traverse the tree with dfs. When you enter the vertex, you want to apply all the updates that are saved for the words that are terminals here. What are the updates? From the list we obtained for a word you can generate such triples  that this word had value  from query  to query . Don't forget the  value from  to the first update to this word. Then ask all the queries. Then go to children. When you exit the vertex, you want all the updates to be gone. Well, there is a trick for these kinds of operations, it's called rollbacks. Maintain a segment tree over the query times, the -th leaf should store the maximum value during the -th query. The update operation updates the range with the new possible maximum. How to avoid using lazy propagation with such updates? Well, on point query you can collect all the values from the segtree nodes you visit on your way down. That way you don't have to push the updates all the way to the leaves. Not that it matters that much but the number of values to be saved for future rollbacks is decreased dramatically.That solution works in .", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int AL = 26;\n\nvector<int> val;\nvector<int> pos;\n\nstruct aho_corasick {\n\tstruct node {\n\t\tmap<int, int> nxt, go;\n\t\tint p, pch;\n\t\tint suf, ssuf;\n\t\tmultiset<int> vals;\n\t\tbool term;\n\t\t\n\t\tnode() {\n\t\t\tnxt.clear();\n\t\t\tgo.clear();\n\t\t\tsuf = ssuf = -1;\n\t\t\tterm = false;\n\t\t\tvals.clear();\n\t\t\tp = -1, pch = -1;\n\t\t}\n\t};\n\n\tvector<node> nodes;\n\t\n\taho_corasick() {\n\t\tnodes = vector<node>(1, node());\n\t}\n\n\tint add(const string& s) {\n\t\tint v = 0;\n\t\tforn(i, s.size()) {\n\t\t\tint c = s[i] - 'a';\n\t\t\tif (!nodes[v].nxt.count(c)) {\n\t\t\t\tnodes.push_back(node());\n\t\t\t\tnodes[v].nxt[c] = int(nodes.size()) - 1;\n\t\t\t\tnodes.back().p = v;\n\t\t\t\tnodes.back().pch = c;\n\t\t\t}\n\t\t\tv = nodes[v].nxt[c];\n\t\t}\n\t\tnodes[v].term = true;\n\t\tnodes[v].vals.insert(0);\n\t\treturn v;\n\t}\n\t\n\tint feed(const string &s){\n\t\tint v = 0;\n\t\tint ans = -1;\n\t\tforn(i, s.size()){\n\t\t\tint c = s[i] - 'a';\n\t\t\tv = go(v, c);\n\t\t\tint u = v;\n\t\t\twhile (u != 0){\n\t\t\t\tif (!nodes[u].vals.empty())\n\t\t\t\t\tans = max(ans, *nodes[u].vals.rbegin());\n\t\t\t\tu = ssuf(u);\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\tint go(int v, int c) {\n\t\tif (nodes[v].go.count(c))\n\t\t\treturn nodes[v].go[c];\n\t\tif (nodes[v].nxt.count(c))\n\t\t\treturn nodes[v].go[c] = nodes[v].nxt[c];\n\t\tif (v == 0)\n\t\t\treturn nodes[v].go[c] = 0;\n\t\treturn nodes[v].go[c] = go(suf(v), c);\n\t}\n\t\n\tint suf(int v) {\n\t\tif (nodes[v].suf != -1)\n\t\t\treturn nodes[v].suf;\n\t\tif (v == 0 || nodes[v].p == 0)\n\t\t\treturn nodes[v].suf = 0;\n\t\treturn nodes[v].suf = go(suf(nodes[v].p), nodes[v].pch);\n\t}\n\t\n\tint ssuf(int v) {\n\t\tif (nodes[v].ssuf != -1)\n\t\t\treturn nodes[v].ssuf;\n\t\tif (v == 0 || nodes[v].p == 0)\n\t\t\treturn nodes[v].ssuf = 0;\n\t\tint s = suf(v);\n\t\tif (nodes[s].term)\n\t\t\treturn nodes[v].ssuf = s;\n\t\treturn nodes[v].ssuf = ssuf(s);\n\t}\n};\n\naho_corasick ac;\n\nint main() {\n\tint n, m;\n\tios::sync_with_stdio(!cin.tie(0));\n\tcin >> n >> m;\n\tpos.resize(n);\n\tval.resize(n, 0);\n\t\n\tvector<int> tp2;\n\t\n\tac = aho_corasick();\n\t\n\tforn(i, n){\n\t\tstring s;\n\t\tcin >> s;\n\t\tpos[i] = ac.add(s);\n\t}\n\t\n\tforn(i, m){\n\t\tint t;\n\t\tcin >> t;\n\t\tif (t == 1){\n\t\t\tint j, x;\n\t\t\tcin >> j >> x;\n\t\t\t--j;\n\t\t\tac.nodes[pos[j]].vals.erase(ac.nodes[pos[j]].vals.find(val[j]));\n\t\t\tval[j] = x;\n\t\t\tac.nodes[pos[j]].vals.insert(val[j]);\n\t\t}\n\t\telse{\n\t\t\tstring q;\n\t\t\tcin >> q;\n\t\t\tprintf(\"%d\\n\", ac.feed(q));\n\t\t}\n\t}\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}