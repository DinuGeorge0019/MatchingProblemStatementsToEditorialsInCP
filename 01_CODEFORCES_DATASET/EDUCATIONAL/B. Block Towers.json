{"link": "https://codeforces.com//contest/1767/problem/B", "problemId": "1697001", "shortId": "1767B", "contest_number": "1767", "name": "B. Block Towers", "statement": "There are  block towers, numbered from  to . The -th tower consists of  blocks.In one move, you can move one block from tower  to tower , but only if . That move increases  by  and decreases  by . You can perform as many moves as you would like (possibly, zero).What's the largest amount of blocks you can have on the tower  after the moves?", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of testcases. The first line of each testcase contains a single integer  ()\u00a0\u2014 the number of towers. The second line contains  integers  ()\u00a0\u2014 the number of blocks on each tower. The sum of  over all testcases doesn't exceed .", "output": "For each testcase, print the largest amount of blocks you can have on the tower  after you make any number of moves (possibly, zero).", "tutorial": "Notice that it never makes sense to move blocks between the towers such that neither of them is tower $$$1$$$ as that can only decrease the heights. Moreover, it never makes sense to move blocks away from the tower $$$1$$$. Thus, all operations will be moving blocks from some towers to tower $$$1$$$.At the start, which towers can move at least one block to tower $$$1$$$? Well, only such $$$i$$$ that $$$a_i > a_1$$$. What happens after you move a block? Tower $$$1$$$ becomes higher, some tower becomes lower. Thus, the set of towers that can share a block can't become larger.Let's order the towers by the number of blocks in them. At the start, the towers that can share a block are at the end (on some suffix) in this order. After one move is made, the towers get reordered, and the suffix can only shrink.Ok, but if that suffix shrinks, what's the first tower that will become too low? The leftmost one that was available before. So, regardless of what the move is, the first tower that might become unavailable is the leftmost available tower. Thus, let's attempt using it until it's not too late.The algorithm then is the following. Find the lowest tower that can move the block to tower $$$1$$$, move a block, repeat. When there are no more towers higher than tower $$$1$$$, the process stops.However, the constraints don't allow us to do exactly that. We'll have to make at most $$$10^9$$$ moves per testcase.Ok, let's move the blocks in bulk every time. Since the lowest available tower will remain the lowest until you can't use it anymore, make all the moves from it at the same time. If the current number of blocks in tower $$$1$$$ is $$$x$$$ and the current number of blocks in that tower is $$$y$$$, $$$\\lceil\\frac{y - x}{2}\\rceil$$$ blocks can be moved.You can also avoid maintaining the available towers by just iterating over the towers in the increasing order of their height.Overall complexity: $$$O(n \\log n)$$$ per testcase.", "solution": "for _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    x = a[0]\n    a = sorted(a[1:])\n    for y in a:\n        if y > x:\n            x += (y - x + 1) // 2\n    print(x)", "interactive": false, "noSolution": false, "noTutorial": false}