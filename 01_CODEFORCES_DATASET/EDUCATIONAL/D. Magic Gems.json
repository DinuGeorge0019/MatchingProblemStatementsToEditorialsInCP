{"link": "https://codeforces.com//contest/1117/problem/D", "problemId": "300044", "shortId": "1117D", "contest_number": "1117", "name": "D. Magic Gems", "statement": "Reziba has many magic gems. Each magic gem can be split into  normal gems. The amount of space each magic (and normal) gem takes is  unit. A normal gem cannot be split.Reziba wants to choose a set of magic gems and split some of them, so the total space occupied by the resulting set of gems is  units. If a magic gem is chosen and split, it takes  units of space (since it is split into  gems); if a magic gem is not split, it takes  unit.How many different configurations of the resulting set of gems can Reziba have, such that the total amount of space taken is  units? Print the answer modulo  (). Two configurations are considered different if the number of magic gems Reziba takes to form them differs, or the indices of gems Reziba has to split differ.", "input": "The input contains a single line consisting of  integers  and  (, ).", "output": "Print one integer, the total number of configurations of the resulting set of gems, given that the total amount of space taken is  units. Print the answer modulo  ().", "tutorial": "Let's reformulate the solution to the form of dynamic programming.  \u2014 the number of ways to split the gems so that the total amount of space taken is . Then there are obvious transitions of either splitting the last gem or not. .And that can be easily rewritten in such a way that matrix exponentiation becomes the solution.Overall complexity: .", "solution": "#include<bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define MOD 1000000007\n#define MOD9 1000000009\n#define pi 3.1415926535\n#define ms(s, n) memset(s, n, sizeof(s))\n#define prec(n) fixed<<setprecision(n)\n#define eps 0.000001\n#define all(v) v.begin(), v.end()\n#define allr(v) v.rbegin(), v.rend()\n#define bolt ios::sync_with_stdio(0)\n#define light cin.tie(0);cout.tie(0)\n#define forr(i,p,n) for(ll i=p;i<n;i++)\n#define MAXN 1000003\ntypedef long long ll;\nusing namespace std;\nll mult(ll a,ll b, ll p=MOD){return ((a%p)*(b%p))%p;}\nll add(ll a, ll b, ll p=MOD){return (a%p + b%p)%p;}\nll fpow(ll n, ll k, ll p = MOD) {ll r = 1; for (; k; k >>= 1) {if (k & 1) r = r * n%p; n = n * n%p;} return r;}\nll inv(ll a, ll p = MOD) {return fpow(a, p - 2, p);}\nll inv_euclid(ll a, ll m = MOD){ll m0 = m;ll y = 0, x = 1;if (m == 1)return 0;while (a > 1){ll q = a / m;ll t = m;m = a % m, a = t;t = y;y = x - q * y;x = t;}if (x < 0)x += m0;return x;}\n\nll bin[103][103];\n\nvoid mult_mat(ll m, ll ans[][100], ll bin[][100]){\n    ll mult[m][m];\n    forr(i,0,m){\n        forr(j,0,m){\n            mult[i][j]=0;\n            forr(k,0,m){\n                mult[i][j]+=ans[i][k]*bin[k][j];\n                if(mult[i][j]>=MOD){\n                    mult[i][j]%=MOD;\n                }\n            }\n        }\n    }\n    forr(i,0,m){\n        forr(j,0,m){\n            ans[i][j]=mult[i][j];\n        }\n    }\n}\n\nvoid pow_mat(ll n, ll fin[][100], ll m){\n    ll ans[m][100];\n    ll b[m][100];\n    forr(i,0,m){\n        forr(j,0,m){\n            ans[i][j]=bin[i][j];\n            b[i][j]=bin[i][j];\n        }\n    }\n    n--;\n    while(n>0){\n        if(n%2==1){\n            mult_mat(m,ans,b);\n            n--;\n        }else{\n            n=n/2;\n            mult_mat(m,b,b);\n        }\n    }\n    forr(i,0,m){\n        forr(j,0,m){\n            fin[i][j]=ans[i][j];\n        }\n    }\n}\n\nint main(){\n    bolt;\n    ll n,m;\n    cin>>n>>m;\n    bin[0][0]=1;\n    bin[0][m-1]=1;\n    for(ll i=1;i<m;i++){\n        bin[i][i-1]=1;\n    }\n    if(n<m){\n        cout<<1<<\"\\n\";\n    }else{\n        ll fin[m+1][100];\n        pow_mat(n-m+1,fin,m);\n        ll ans=0;\n        forr(i,0,m){\n            ans+=fin[0][i];\n            if(ans>=MOD){\n                ans-=MOD;\n            }\n        }\n        cout<<ans<<\"\\n\";\n    }\n}", "interactive": false, "noSolution": false, "noTutorial": false}