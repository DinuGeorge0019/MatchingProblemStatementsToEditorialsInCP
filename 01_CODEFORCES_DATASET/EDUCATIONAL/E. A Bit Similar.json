{"link": "https://codeforces.com//contest/1469/problem/E", "problemId": "847530", "shortId": "1469E", "contest_number": "1469", "name": "E. A Bit Similar", "statement": "Let's call two strings  and  (both of length )  if they have the same character in some position, i.\u00a0e. there exists at least one  such that .You are given a binary string  of length  (a string of  characters  and/or ) and an integer . Let's denote the string  as the substring of  starting from the -th character and ending with the -th character (that is, ).Let's call a binary string  of length   if it is  to all substrings of  having length exactly ; that is, it is  to .Your goal is to find the  smallest string  that is , or report that no such string exists. String  is lexicographically less than string  if either  is a prefix of  (and ), or there exists such  (), that , and for any  () .", "input": "The first line contains one integer  () \u2014 the number of test cases. Each test case consists of two lines. The first line of each test case contains two integers  and  (). The second line contains the string , consisting of  characters (each character is either  or ). It is guaranteed that the sum of  over all test cases does not exceed .", "output": "For each test case, print the answer as follows:   if it is impossible to construct a  string, print one line containing the string  (note: , you can't print , for example);  otherwise, print two lines. The first line should contain the string  (exactly in upper case as well); the second line \u2014 the lexicographically smallest  string, consisting of  characters  and/or . ", "tutorial": "Let's denote  as the number of substrings of  having length exactly  (so, ).The first and crucial observation is that if , then the answer always exists. Each of  substrings forbids one of the strings from being the answer (a string is forbidden if every each character differs from the corresponding character in one of the substrings); we can forbid at most  strings from being the answer, and the number of possible candidates for the answer is . This observation leads us to a more strong fact that actually allows us to find a solution: we can set the first  characters in the answer to ; all the remaining characters are enough to find the answer.There are at most  possible combinations of the last characters, and this number is not greater than . Let's iterate on each substring of  of length  and check which combination it forbids by inverting the last  characters of the substring. After that, find the minimum unforbidden combination. Note that there may be a case when a substring doesn't actually forbid any combination \u2014 if there are zeroes in the first  characters of the substring, it is  to the answer no matter which combination we choose. This can be checked by precalculating the closest position of zero to the left/right of each index.The whole solution works in  per test case \u2014 the hardest part is inverting the suffix of each substring we are interested in.", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1000043;                 \nint q;\nchar buf[N];\nint n, k;\n\nint ceilLog(int x)\n{\n    int y = 0;\n    while((1 << y) < x)\n        y++;\n    return y;\n}\n\nint main()\n{\n    scanf(\"%d\", &q);\n    for(int i = 0; i < q; i++)\n    {\n        scanf(\"%d %d\", &n, &k);\n        scanf(\"%s\", buf);\n        string s = buf;\n        int m = min(k, ceilLog(n - k + 2));\n        vector<int> used(1 << m, 0);\n        vector<int> next0(n, int(1e9));\n        if(s[n - 1] == '0')\n            next0[n - 1] = n - 1;\n        for(int j = n - 2; j >= 0; j--)\n            if(s[j] == '0')\n                next0[j] = j;\n            else\n                next0[j] = next0[j + 1];\n        int d = k - m;\n        for(int j = 0; j < n - k + 1; j++)\n        {\n            if(next0[j] - j < d)\n                continue;\n            int cur = 0;\n            for(int x = j + d; x < j + k; x++)\n                cur = cur * 2 + (s[x] - '0');\n            used[((1 << m) - 1) ^ cur] = 1;    \n        }\n        int ans = -1;\n        for(int j = 0; j < (1 << m); j++)\n            if(used[j] == 0)\n            {\n                ans = j;\n                break;    \n            }\n        if(ans == -1)\n            puts(\"NO\");\n        else\n        {\n            puts(\"YES\");\n            string res(d, '0');\n            string res2;\n            for(int j = 0; j < m; j++)\n            {\n                res2.push_back('0' + (ans % 2));\n                ans /= 2;\n            }\n            reverse(res2.begin(), res2.end());\n            res += res2;\n            puts(res.c_str());\n        }\n    }\n}", "interactive": false, "noSolution": false, "noTutorial": false}