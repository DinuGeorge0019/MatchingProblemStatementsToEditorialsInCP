{"link": "https://codeforces.com//contest/1796/problem/D", "problemId": "1802548", "shortId": "1796D", "contest_number": "1796", "name": "D. Maximum Subarray", "statement": "You are given an array , consisting of  integers. You are also given two integers  and .You have to perform the following operation exactly once: add  to the elements on    positions, and subtract  from all the others.For example, if , , , and we have picked the first element, then after the operation the array .Let  be the maximum possible sum of a subarray of . The subarray of  is a contiguous part of the array , i.\u2009e. the array  for some . An empty subarray should also be considered, it has sum .Let the array  be the array  after applying the aforementioned operation. Apply the operation in such a way that  is the maximum possible, and print the maximum possible value of .", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of test cases. The first line of each test case contains three integers ,  and  (; ; ). The second line contains  integers  ().  The sum of  over all test cases doesn't exceed .", "output": "For each test case, print one integer\u00a0\u2014 the maximum possible value of .", "tutorial": "There are greedy and dynamic programming solutions. We will describe dynamic programming solution.The main task is to choose some segment that is the answer to the problem, while choosing  positions to increase by . To do this, we can use dynamic programming , where  is the number of positions that have already been considered (from  to ),  is the number of elements that have already been increased by  (from  to ),  is the flag showing the current state (whether we are before the chosen segment, inside the segment, or after the segment). Transitions in such dynamic programming are quite simple: we have a choice either to increase  by , then the value of the -th element is , or not to increase, then the value of the -th element is ; we can also change the state of the flag (note that you can only switch from the current state to the subsequent ones, i.e., for example, you cannot switch from the state \"the segment has already ended\" to the state \"inside the segment\"). If the current state of the flag is \"inside the segment\", then  or  (depending on the selected transition) should be added to the dynamic programming value itself.So, we got a solution in .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing li = long long;\n\nconst int N = 222222;\nconst int K = 22;\nconst li INF = 1e18;\n\nint n, k, x;\nint a[N];\nli dp[N][K][3];\n\nint main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  int tc;\n  cin >> tc;\n  while (tc--) {\n    cin >> n >> k >> x;\n    for (int i = 0; i < n; ++i) cin >> a[i];\n    for (int i = 0; i <= n; ++i) {\n      for (int j = 0; j <= k; ++j) { \n        for (int t = 0; t < 3; ++t) {\n          dp[i][j][t] = -INF;\n        }\n      }\n    }\n    dp[0][0][0] = 0;\n    for (int i = 0; i < n; ++i) {\n      for (int j = 0; j <= k; ++j) {\n        for (int t = 0; t < 3; ++t) {\n          if (dp[i][j][t] == -INF) continue;\n          for (int jj = j; jj <= min(k, j + 1); ++jj) {\n            li add = a[i] + (j == jj ? -x : x);\n            for (int tt = t; tt < 3; ++tt) {\n              dp[i + 1][jj][tt] = max(dp[i + 1][jj][tt], dp[i][j][t] + (tt == 1 ? add : 0));\n            }\n          }\n        }\n      }\n    }\n    cout << max(dp[n][k][1], dp[n][k][2]) << '\\n';\n  }\n}", "interactive": false, "noSolution": false, "noTutorial": false}