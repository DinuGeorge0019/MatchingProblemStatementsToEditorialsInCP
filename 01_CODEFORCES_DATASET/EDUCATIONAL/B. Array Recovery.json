{"link": "https://codeforces.com//contest/1739/problem/B", "problemId": "1559864", "shortId": "1739B", "contest_number": "1739", "name": "B. Array Recovery", "statement": "For an array of  integers  of size , we construct another array  as follows: ,  for .Your task is to restore the array  from a given array , or to report that there are multiple possible arrays. ", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of test cases. The first line of each test case contains one integer  ()\u00a0\u2014 the size of the arrays  and . The second line contains  integers  ()\u00a0\u2014 the elements of the array . It can be shown that there always exists at least one suitable array  under these constraints.", "output": "For each test case, print the elements of the array , if there is only one possible array . Otherwise, print .", "tutorial": "Note that  or . Since there is no upper bound for the values of , the case where  for all  always exists. It remains to check if there are other ways. To do this, it is enough to check whether there is such a position  that:   ;  ;  the change  to  doesn't result in a negative value of . The reason for  is that for  no matter the plus or minus we choose, the array  doesn't change. If you could change at least one sign to minus, that would be another answer.", "solution": "for _ in range(int(input())):\n\tn = int(input())\n\tans = [0]\n\tfor x in map(int, input().split()):\n\t\tif x != 0 and ans[-1] - x >= 0:\n\t\t\tprint(-1)\n\t\t\tbreak\n\t\telse:\n\t\t\tans.append(ans[-1] + x)\n\telse:\n\t\tprint(*ans[1:])", "interactive": false, "noSolution": false, "noTutorial": false}