{"link": "https://codeforces.com//contest/1626/problem/B", "problemId": "1263148", "shortId": "1626B", "contest_number": "1626", "name": "B. Minor Reduction", "statement": "You are given a decimal representation of an integer  without leading zeros.You have to perform the following reduction on it : take two neighboring digits in  and replace them with their sum without leading zeros (if the sum is , it's represented as a single ).For example, if , the possible reductions are:   choose the first and the second digits  and , replace them with ; the result is ;  choose the second and the third digits  and , replace them with ; the result is also ;  choose the third and the fourth digits  and , replace them with ; the result is still ;  choose the fourth and the fifth digits  and , replace them with ; the result is . What's the largest number that can be obtained?", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of testcases. Each testcase consists of a single integer  ().  doesn't contain leading zeros. The total length of the decimal representations of  over all testcases doesn't exceed .", "output": "For each testcase, print a single integer\u00a0\u2014 the largest number that can be obtained after the reduction is applied exactly once. The number should not contain leading zeros.", "tutorial": "Let's think how a reduction changes the length of . There are two cases. If two adjacent letters sum up to  or greater, then the length doesn't change. Otherwise, the length decreases by one.Obviously, if there exists a reduction that doesn't change the length, then it's better to use it. Which among such reduction should you choose? Well, notice that such a reduction always makes the number strictly smaller (easy to see with some case analysis). Thus, the logical conclusion is to leave the longest possible prefix of  untouched. So, the rightmost such reduction will change the number as little as possible.If all reductions decrease the length, then a similar argument can be applied. The sum will be a single digit, but a digit that is greater than or equal to the left one of the adjacent pair. If it was just greater, it's easy to see that the leftmost such reduction will make the number the largest possible. The equal case adds more case analysis on top of the proof, but the conclusion remains the same: the leftmost reduction is the best one.As an implementation note, since all the reductions are of the same type, the leftmost reduction always includes the first and the second digits.Overall complexity:  per testcase.", "solution": "for _ in range(int(input())):\n  x = [ord(c) - ord('0') for c in input()]\n  n = len(x)\n  for i in range(n - 2, -1, -1):\n    if x[i] + x[i + 1] >= 10:\n      x[i + 1] += x[i] - 10\n      x[i] = 1\n      break\n  else:\n    x[1] += x[0]\n    x.pop(0)\n  print(''.join([chr(c + ord('0')) for c in x]))", "interactive": false, "noSolution": false, "noTutorial": false}