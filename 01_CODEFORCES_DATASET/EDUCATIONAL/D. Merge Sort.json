{"link": "https://codeforces.com//contest/873/problem/D", "problemId": "127822", "shortId": "873D", "contest_number": "873", "name": "D. Merge Sort", "statement": "Merge sort is a well-known sorting algorithm. The main function that sorts the elements of array  with indices from  can be implemented as follows:  If the segment  is already sorted in non-descending order (that is, for any  such that  ), then end the function call;  Let ;  Call ;  Call ;  Merge segments  and , making the segment  sorted in non-descending order. The merge algorithm doesn't call any other functions. The array in this problem is -indexed, so to sort the whole array, you need to call .The number of calls of function  is very important, so Ivan has decided to calculate it while sorting the array. For example, if , then there will be  call of  \u2014 , which will check that the array is sorted and then end. If , then the number of calls is : first of all, you call , which then sets  and calls  and , which do not perform any recursive calls because segments  and  are sorted.Ivan has implemented the program that counts the number of  calls, but now he needs to test it. To do this, he needs to find an array  such that  is a permutation of size  (that is, the number of elements in  is , and every integer number from  can be found in this array), and the number of  calls when sorting the array is exactly .Help Ivan to find an array he wants!", "input": "The first line contains two numbers  and  (, ) \u2014 the size of a desired permutation and the number of  calls required to sort it.", "output": "If a permutation of size  such that there will be exactly  calls of  while sorting it doesn't exist, output . Otherwise output  integer numbers  \u2014 the elements of a permutation that would meet the required conditions. If there are multiple answers, print any of them.", "tutorial": "First of all, if  is even, then there is no solution, since the number of calls is always odd (one call in the beginning, and each call makes either  or  recursive calls).Then, if  is odd, let's try to start with a sorted permutation and try to \"unsort\" it. Let's make a function  that will do it. When we \"unsort\" a segment, we can either keep it sorted (if we already made enough calls), or make it non-sorted and then call  and , if we need more calls. When we make a segment non-sorted, it's better to keep its both halves sorted; an easy way to handle this is to swap two middle element.It's easy to see that the number of  calls is equal to the number of  calls to sort the resulting permutation, so we can use this approach to try getting exactly  calls.", "solution": "#include <bits/stdc++.h>\n\n#define all(a) (a).begin(), (a).end()\n#define sz(a) (int)(a).size()\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef double ld;\ntypedef pair<ll, ll> pll;\n\nconst int nmax = 100500;\n\nint dp[nmax];\n\nvector<int> ans;\nbool ok = true;\n\nvoid solve(int lf, int rg, int k, int a, int b) {\n\tif (k == 1) {\n\t\tfor (int i = lf; i <= rg; ++i) {\n\t\t\tans[i] = a + (i - lf);\n\t\t}\n\t\treturn;\n\t}\n\tif (k <= 2) {\n\t\tok = false;\n\t\treturn;\n\t}\n\tint l = lf, r = rg + 1;\n\tint m = (l + r) >> 1;\n\t--k;\n\tif (dp[m - l] + 1 >= k) {\n\t\tsolve(lf, m - 1, k - 1, a + rg - m + 1, b);\n\t\tfor (int i = m; i <= rg; ++i) {\n\t\t\tans[i] = a + (i - m);\n\t\t}\n\t} else {\n\t\tk -= dp[m - l];\n\t\tsolve(lf, m - 1, dp[m - l], a + rg - m + 1, b);\n\t\tsolve(m, rg, k, a, a + rg - m);\n\t}\n}\n\nint main() {\n\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\n\t//ifstream cin(\"input.txt\");\n\t//ofstream cout(\"output.txt\");\n\n\tdp[1] = 1;\n\tfor (int n = 2; n < nmax; ++n) {\n\t\tint l = 0, r = n;\n\t\tint m = (l + r) >> 1;\n\t\tdp[n] = 1 + dp[m - l] + dp[r - m];\n\t}\n\n\tint n, k;\n\tcin >> n >> k;\n\tif (dp[n] < k) {\n\t\tcout << \"-1\\n\";\n\t\treturn 0;\n\t}\n\n\tans.resize(n);\n\tsolve(0, n - 1, k, 1, n);\n\n\tif (!ok) {\n\t\tcout << \"-1\\n\";\n\t\treturn 0;\n\t}\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tcout << ans[i] << \" \";\n\t}\n\tcout << \"\\n\";\n\n}", "interactive": false, "noSolution": false, "noTutorial": false}