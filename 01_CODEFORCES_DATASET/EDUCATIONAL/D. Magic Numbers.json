{"link": "https://codeforces.com//contest/628/problem/D", "problemId": "48826", "shortId": "628D", "contest_number": "628", "name": "D. Magic Numbers", "statement": "Consider the decimal presentation of an integer. Let's call a number  if digit  appears in decimal presentation of the number on even positions and nowhere else.For example, the numbers , ,  are  but , , , ,  are not . On the other hand the number  is ,  is ,  is  and  is .Find the number of  numbers in the segment  that are multiple of . Because the answer can be very huge you should only find its value modulo  (so you should find the remainder after dividing by ).", "input": "The first line contains two integers  (, ) \u2014 the parameters from the problem statement. The second line contains positive integer  in decimal presentation (without leading zeroes). The third line contains positive integer  in decimal presentation (without leading zeroes). It is guaranteed that , the number of digits in  and  are the same and don't exceed .", "output": "Print the only integer  \u2014 the remainder after dividing by  of the number of  numbers in segment  that are multiple of .", "tutorial": "Denote the answer to the problem . Note that  or what is the same , where  equals to one if  is a magic number, otherwise  equals to zero. Let's solve the problem for the segment .\nHere is described the standard technique for this kind of problems, sometimes it is called 'dynamic programming by digits'. It can be realized in a two ways. The first way is to iterate over the length of the common prefix with number . Next digit should be less than corresponding digit in  and other digits can be arbitrary. Below is the description of the second approach.\nLet  be the number of magic prefixes of length  with remainder  modulo . If  than the prefix should be less than the corresponding prefix in  and if  than the prefix should be equal to the prefix of  (it can not be greater). Let's do 'forward dynamic programming'. Let's iterate over digit  in position . We should check that if the position is even than  should be equal to , otherwise it cannot be equal to . Also we should check for   should be not greater than corresponding digit in . Now let's see what will be the next state. Of course . By Horner scheme . Easy to see that . To update the next state we should increase it: . Of course all calculations should be done modulo .\n", "solution": "\n            #include <bits/stdc++.h>\n\u00a0\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n#define ford(i, n) for (int i = int(n) - 1; i >= 0; i--)\n#define fore(i, l, r) for (int i = int(l); i < int(r); i++)\n#define correct(x, y, n, m) (0 <= (x) && (x) < (n) && 0 <= (y) && (y) < (m))\n#define all(a) (a).begin(), (a).end()\n#define sz(a) int((a).size())\n#define pb(a) push_back(a)\n#define mp(x, y) make_pair((x), (y))\n#define x first\n#define y second\n\u00a0\nusing namespace std;\n\u00a0\ntypedef long long li;\ntypedef long double ld;\ntypedef pair<int, int> pt;\n\u00a0\ntemplate<typename X> inline X abs(const X& a) { return a < 0? -a: a; }\ntemplate<typename X> inline X sqr(const X& a) { return a * a; }\n\u00a0\nconst int INF = int(1e9);\nconst li INF64 = li(1e18);\nconst ld EPS = 1e-9, PI = 3.1415926535897932384626433832795;\n\u00a0\nint m, d;\nstring a, b;\n\u00a0\ninline bool read() {\n\u00a0 \u00a0 if (!(cin >> m >> d)) return false;\n\u00a0 \u00a0 assert(cin >> a >> b);\n\u00a0 \u00a0 return true;\n}\n\u00a0\nconst int mod = 1000 * 1000 * 1000 + 7;\n\u00a0\ninline int add(int a, int b) { return a + b >= mod ? a + b - mod : a + b; }\ninline void inc(int& a, int b) { a = add(a, b); }\ninline int sub(int a, int b) { return a - b < 0 ? a - b + mod : a - b; }\ninline void dec(int& a, int b) { a = sub(a, b); }\n\u00a0\nconst int N = 2020;\n\u00a0\nint z[N][N][2];\n\u00a0\nint solve(string s) {\n\u00a0 \u00a0 int n = sz(s);\n\u00a0 \u00a0 forn(i, n + 1) forn(j, m) forn(k, 2) z[i][j][k] = 0;\n\u00a0 \u00a0 z[0][0][1] = 1;\n\u00a0 \u00a0 forn(i, n)\n\u00a0 \u00a0 \u00a0 \u00a0 forn(j, m)\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 forn(k, 2)\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 for (int p = 0; p <= (k ? int(s[i] - '0') : 9); p++) {\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if ((i & 1) && p != d) continue;\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if (!(i & 1) && p == d) continue;\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if (!i && !p) continue;\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 int ni = i + 1;\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 int nj = (j * 10 + p) % m;\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 int nk = k && (p == int(s[i] - '0'));\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 inc(z[ni][nj][nk], z[i][j][k]);\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\n\u00a0 \u00a0 int ans = 0;\n\u00a0 \u00a0 forn(k, 2) inc(ans, z[n][0][k]);\n\u00a0 \u00a0 return ans;\n}\n\u00a0\nbool good(string s) {\n\u00a0 \u00a0 int rm = 0;\n\u00a0 \u00a0 forn(i, sz(s)) {\n\u00a0 \u00a0 \u00a0 \u00a0 int p = int(s[i] - '0');\n\u00a0 \u00a0 \u00a0 \u00a0 if ((i & 1) && p != d) return false;\n\u00a0 \u00a0 \u00a0 \u00a0 if (!(i & 1) && p == d) return false;\n\u00a0 \u00a0 \u00a0 \u00a0 rm = (rm * 10 + p) % m;\n\u00a0 \u00a0 }\n\u00a0 \u00a0 return !rm;\n}\n\u00a0\ninline void solve() {\n\u00a0 \u00a0 int ans = 0;\n\u00a0 \u00a0 inc(ans, solve(b));\n\u00a0 \u00a0 dec(ans, solve(a));\n\u00a0 \u00a0 inc(ans, good(a));\n\u00a0 \u00a0 cout << ans << endl;\n}\n\u00a0\ninline ld gett() { return ld(clock()) / CLOCKS_PER_SEC; }\n\u00a0\nint main() {\n#ifdef SU1\n\u00a0 \u00a0 assert(freopen(\"input.txt\", \"rt\", stdin));\n\u00a0 \u00a0 //assert(freopen(\"output.txt\", \"wt\", stdout));\n#endif\n\u00a0 \u00a0 \n\u00a0 \u00a0 cout << setprecision(10) << fixed;\n\u00a0 \u00a0 cerr << setprecision(5) << fixed;\n\u00a0\n\u00a0 \u00a0 while (read()) {\n\u00a0 \u00a0 \u00a0 \u00a0 ld stime = gett();\n\u00a0 \u00a0 \u00a0 \u00a0 solve();\n\u00a0 \u00a0 \u00a0 \u00a0 cerr << gett() - stime << endl;\n\u00a0 \u00a0 }\n\u00a0 \u00a0 \n\u00a0 \u00a0 return 0;\n}\n        ", "interactive": false, "noSolution": false, "noTutorial": false}