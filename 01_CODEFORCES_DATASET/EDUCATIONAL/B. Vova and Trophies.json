{"link": "https://codeforces.com//contest/1082/problem/B", "problemId": "64161", "shortId": "1082B", "contest_number": "1082", "name": "B. Vova and Trophies", "statement": "Vova has won  trophies in different competitions. Each trophy is either golden or silver. The trophies are arranged in a row.The  of the arrangement is the length of the longest subsegment consisting of golden trophies. Vova wants to swap two trophies (not necessarily adjacent ones) to make the arrangement as beautiful as possible \u2014 that means, to maximize the length of the longest such subsegment.Help Vova! Tell him the maximum possible beauty of the arrangement if he is allowed to do at most one swap.", "input": "The first line contains one integer  () \u2014 the number of trophies. The second line contains  characters, each of them is either  or . If the -th character is , then the -th trophy is a golden one, otherwise it's a silver trophy. ", "output": "Print the maximum possible length of a subsegment of golden trophies, if Vova is allowed to do at most one swap.", "tutorial": "Let  be the maximal segment of gold cups that begins in the cup . Let  be the maximum segment of gold cups that ends in the cup . Also, let the total number of gold cups be .Note that it makes no sense to change the cups of the same color. Then let's consider the silver cup, which will change with the gold cup, let its number be . Then if , then we will update the answer with the value , and otherwise with the value . This will not work if all the cups are golden. In this case, the answer is .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n;\nstring s;\n\nint main() {\n\t\n\tcin >> n >> s;\n\t\n\tvector <int> l(n), r(n);\n\tfor(int i = 0; i < n; ++i){\n\t\tif(s[i] == 'G'){\n\t\t\tl[i] = 1;\n\t\t\tif(i > 0) l[i] += l[i - 1];\n\t\t}\n\t}\n\tfor(int i = n - 1; i >= 0; --i){\n\t\tif(s[i] == 'G'){\n\t\t\tr[i] = 1;\n\t\t\tif(i + 1 < n) r[i] += r[i + 1];\n\t\t}\n\t}\n\t\n\t\n\tint res = 0;\n\tint cntG = 0;\n\tfor(int i = 0; i < n; ++i)\n\t\t\tcntG += s[i] == 'G';\n\t\t\t\n\tfor(int i = 0; i < n; ++i){\n\t\tif(s[i] == 'G') continue;\n\t\tint nres = 1;\n\t\tif(i > 0) nres += l[i - 1];\n\t\tif(i + 1 < n) nres += r[i + 1];\n\t\tres = max(res, nres);\n\t}\n\t\n\tres = min(res, cntG);\n\tif(cntG == n) res = cntG;\n\tcout << res << endl;\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}