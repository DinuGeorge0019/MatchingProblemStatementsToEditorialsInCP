{"link": "https://codeforces.com//contest/1550/problem/F", "problemId": "1045986", "shortId": "1550F", "contest_number": "1550", "name": "F. Jumping Around", "statement": "There is an infinite pond that can be represented with a number line. There are  rocks in the pond, numbered from  to . The -th rock is located at an integer coordinate . The coordinates of the rocks are pairwise distinct. The rocks are numbered in the increasing order of the coordinate, so .A robot frog sits on the rock number . The frog is programmable. It has a base jumping distance parameter . There also is a setting for the jumping distance range. If the jumping distance range is set to some integer , then the frog can jump from some rock to any rock at a distance from  to  inclusive in any direction. The distance between two rocks is an absolute difference between their coordinates.You are assigned a task to implement a feature for the frog. Given two integers  and  determine if the frog can reach a rock number  from a rock number  performing a sequence of jumps with the jumping distance range set to . The sequence can be arbitrarily long or empty.You will be given  testcases for that feature, the -th testcase consists of two integers  and . Print \"\" if the -th rock is reachable and \"\" otherwise.You can output \"\" and \"\" in any case (for example, strings \"\", \"\", \"\" and '\"' will be recognized as a positive answer).", "input": "The first line contains four integers , ,  and  (; ; )\u00a0\u2014 the number of rocks, the number of testcases, the starting rock and the base jumping distance parameter. The second line contains  integers  ()\u00a0\u2014 the coordinates of the rocks. The coordinates of the rocks are pairwise distinct. The rocks are numbered in the increasing order of distance from the land, so . Each of the next  lines contains two integers  and  (; )\u00a0\u2014 the parameters to the testcase.", "output": "For each of the testcases print an answer. If there is a sequence of jumps from a rock number  to a rock number  with the jumping distance range set to , then print \"\". Otherwise, print \"\".", "tutorial": "Notice that increasing  only increases the range of the jump distances in both directions. So every rock that was reachable with some , will be reachable with  as well. Thus, let's try to find the smallest possible value of  to reach each rock.Let's imagine this problem as a graph one and consider the following algorithm. For every pair of rocks, make an edge of weight equal to the smallest  required to jump from one to another. For some rocks  and  that is . How to check the reachability with these edges? Well, if the jump range value is , then there should exist of path by edges of weight no more than . So we can start with an empty graph, first add the edges of the smallest weight, then the second smallest, and so on. The first time a pair of vertices becomes reachable from each other is the minimum such weight.An experienced reader can notice the resemblance with the Kruskal algorithm for finding the minimum spanning tree. After the spanning tree is constructed, the minimum  is the maximum value on a path between the vertices.The issue is that Kruskal requires  to construct an MST for a complete graph. Prim can make it , which is still too much. Thus, the solution is to resort to Boruvka.On each iteration of Boruvka we have to find the smallest weight edge from each component to some other one. We can solve it the following way. Maintain a sorted set of rocks coordinates. The smallest weight edges are the ones that are the closest to  distance from each rock. So we could query a lower_bound of  and  on each rock  to find them. Don't forget to look at the both sides of the lower_bound result.However, the issue is that we can bump into the rocks from the same component. Thus, let's process components one by one. When processing a component, first remove all its vertices from the set. Then query the edges for each vertex. Then add the vertices back. This way, only the edges to other components will be considered.That makes it an  construction, with one log from the number of Boruvka iterations and another  from finding the edges. That should pass if coded carefully enough, and that is basically the intended solution.Still, there exists a  construction. That will require a  algorithm for finding the edges. So there are four possible edges for each rock : the closest to  from the left, from the right and the same for . Let's consider only the first case, the rest will be similar.The coordinates are sorted beforehand, and we are processing the rocks from left to right. We can maintain a pointer to the latest encountered rock to the left of . The issue with it being from the same component is still there. Let's go around it by also storing the second latest encountered rock such that it's from the different component from the actual latest one. This can be updated in the same manner one calculates the second maximum of the array.Now you just have to do that for all four cases. This two pointers approach makes it  for each iteration, thus making the construction .Since the queries ask for a path from some fixed vertex  to a certain vertex , it's the same as calculating the maximum edge on a path from the root of the tree to each vertex. Can be done with a simple dfs. The only thing left is to check if the minimum possible  is less than or equal to the one provided in the query.Overall complexity:  or .", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int INF = 1e9;\n\nstruct edge2{\n\tint u, w;\n};\n\nvector<vector<edge2>> g;\n\nstruct edge3{\n\tint v, u, w;\n};\n\nbool operator <(const edge3 &a, const edge3 &b){\n\tif (a.w != b.w)\n\t\treturn a.w < b.w;\n\tif (min(a.v, a.u) != min(b.v, b.u))\n\t\treturn min(a.v, a.u) < min(b.v, b.u);\n\treturn max(a.v, a.u) < max(b.v, b.u);\n}\n\nvector<vector<int>> comps;\nvector<int> p;\n\nbool unite(int a, int b){\n\ta = p[a], b = p[b];\n\tif (a == b) return false;\n\tif (comps[a].size() < comps[b].size()) swap(a, b);\n\tfor (int v : comps[b]){\n\t\tp[v] = a;\n\t\tcomps[a].push_back(v);\n\t}\n\tcomps[b].clear();\n\treturn true;\n}\n\nvector<int> mn;\n\nvoid dfs(int v, int p, int d){\n\tmn[v] = d;\n\tfor (auto e : g[v]) if (e.u != p)\n\t\tdfs(e.u, v, max(d, e.w));\n}\n\nint main() {\n\tint n, q, s, d;\n\tscanf(\"%d%d%d%d\", &n, &q, &s, &d);\n\t--s;\n\tvector<int> a(n);\n\tforn(i, n) scanf(\"%d\", &a[i]);\n\tvector<int> idx(a[n - 1] + 1);\n\tforn(i, n) idx[a[i]] = i;\n\tcomps.resize(n);\n\tp.resize(n);\n\tforn(i, n) comps[i] = vector<int>(1, i), p[i] = i;\n\tg.resize(n);\n\tset<int> pos(a.begin(), a.end());\n\tint cnt = n;\n\twhile (cnt > 1){\n\t\tvector<edge3> es;\n\t\tfor (const vector<int> &comp : comps) if (!comp.empty()){\n\t\t\tfor (int i : comp)\n\t\t\t\tpos.erase(a[i]);\n\t\t\tedge3 mn = {-1, -1, INF};\n\t\t\tfor (int i : comp){\n\t\t\t\tfor (int dx : {-d, d}){\n\t\t\t\t\tauto it = pos.lower_bound(a[i] + dx);\n\t\t\t\t\tif (it != pos.end())\n\t\t\t\t\t\tmn = min(mn, {i, idx[*it], abs(abs(a[i] - *it) - d)});\n\t\t\t\t\tif (it != pos.begin()){\n\t\t\t\t\t\t--it;\n\t\t\t\t\t\tmn = min(mn, {i, idx[*it], abs(abs(a[i] - *it) - d)});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i : comp)\n\t\t\t\tpos.insert(a[i]);\n\t\t\tassert(mn.v != -1);\n\t\t\tes.push_back(mn);\n\t\t}\n\t\tfor (auto e : es){\n\t\t\tif (unite(e.v, e.u)){\n\t\t\t\t--cnt;\n\t\t\t\tg[e.v].push_back({e.u, e.w});\n\t\t\t\tg[e.u].push_back({e.v, e.w});\n\t\t\t}\n\t\t}\n\t}\n\tmn.resize(n);\n\tdfs(s, -1, 0);\n\tforn(_, q){\n\t\tint i, k;\n\t\tscanf(\"%d%d\", &i, &k);\n\t\t--i;\n\t\tputs(mn[i] <= k ? \"Yes\" : \"No\");\n\t}\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}