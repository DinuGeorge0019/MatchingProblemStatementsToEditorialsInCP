{"link": "https://codeforces.com//contest/1132/problem/G", "problemId": "307701", "shortId": "1132G", "contest_number": "1132", "name": "G. Greedy Subsequences", "statement": "For some array , let's denote a  as a sequence of indices , , ...,  such that , and for each ,  is the minimum number such that  and .You are given an array . For each its subsegment of length , calculate the length of its longest greedy subsequence.", "input": "The first line contains two integers  and  () \u2014 the length of array  and the length of subsegments. The second line contains  integers  () \u2014 array .", "output": "Print  integers \u2014 the maximum lengths of greedy subsequences of each subsegment having length . The first number should correspond to subsegment , the second \u2014 to subsegment , and so on.", "tutorial": "Let's calculate for each position  position  \u2014 \"the closest greater from the right\" element to  and add directed edge from  to . Then we will get oriented forest (or tree if we'd add fictive vertex) where all edges are directed to some root.So, we can look at current subsegment we need to calculate the answer for as at a number of marked vertices in the tree. Then, the answer itself is a longest path up to the tree consisting only from marked vertices. Key observation is next: if  and  are marked and  is an ancestor of  then any vertex  on path from  to  is also marked.So, \"the longest path up to the tree consisting only from marked vertices\" has length equal to a number of marked vertices on path to the root. And we have three types of queries: mark a vertex, unmark a vertex and calculate maximum number of marked vertices among all paths to the root.It can be done with Segment Tree on Euler Tour of the tree: if we calculate  and  for each vertex in dfs order, then marking/unmarking is just adding  to a segment , and maximum among all paths is a maximum on the whole tree.Result time complexity is  and space complexity is .", "solution": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) int((a).size())\n\n#define x first\n#define y second\n\nint n, k;\nvector<int> a;\n\ninline bool read() {\n\tif(!(cin >> n >> k))\n\t\treturn false;\n\ta.assign(n, 0);\n\tfore(i, 0, n)\n\t\tcin >> a[i];\n\treturn true;\n}\n\nint T = 0;\nvector< vector<int> > g;\nvector<int> tin, tout;\n\nvoid dfs(int v) {\n\ttin[v] = T++;\n\tfor(int to : g[v])\n\t\tdfs(to);\n\ttout[v] = T;\n}\n\nvector<int> Tmax, Tadd;\n\ninline void push(int v) {\n\tTadd[2 * v + 1] += Tadd[v];\n\tTadd[2 * v + 2] += Tadd[v];\n\tTadd[v] = 0;\n}\ninline int getmax(int v) {\n\treturn Tmax[v] + Tadd[v];\n}\n\nvoid addVal(int v, int l, int r, int lf, int rg, int val) {\n\tif(l == lf && r == rg) {\n\t\tTadd[v] += val;\n\t\treturn;\n\t}\n\tint mid = (l + r) >> 1;\n\tpush(v);\n\tif(lf < mid) addVal(2 * v + 1, l, mid, lf, min(mid, rg), val);\n\tif(rg > mid) addVal(2 * v + 2, mid, r, max(lf, mid), rg, val);\n\tTmax[v] = max(getmax(2 * v + 1), getmax(2 * v + 2));\n}\n\ninline void solve() {\n\tg.resize(n + 1);\n\ttin.resize(n + 1, 0);\n\ttout.resize(n + 1, 0);\n\tvector<int> st;\n\tfor(int i = n - 1; i >= 0; i--) {\n\t\twhile(!st.empty() && a[st.back()] <= a[i])\n\t\t\tst.pop_back();\n\t\tint nxt = st.empty() ? n : st.back();\n\t\tg[nxt].push_back(i);\n\t\tst.push_back(i);\n\t}\n\tdfs(n);\n\tTmax.assign(4 * (n + 1), 0);\n\tTadd.assign(4 * (n + 1), 0);\n\t\n\tfore(i, 0, k - 1)\n\t\taddVal(0, 0, n + 1, tin[i], tout[i], +1);\n\t\n\tfor(int l = 0; l + k <= n; l++) {\n\t\taddVal(0, 0, n + 1, tin[l + k - 1], tout[l + k - 1], +1);\n\t\tcout << getmax(0) << \" \";\n\t\taddVal(0, 0, n + 1, tin[l], tout[l], -1);\n\t}\n\tcout << endl;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint tt = clock();\n#endif\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0), cout.tie(0);\n\tcout << fixed << setprecision(15);\n\t\n\tif(read()) {\n\t\tsolve();\n\t\t\n#ifdef _DEBUG\n\t\tcerr << \"TIME = \" << clock() - tt << endl;\n\t\ttt = clock();\n#endif\n\t}\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}