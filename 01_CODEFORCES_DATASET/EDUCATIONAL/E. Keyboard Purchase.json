{"link": "https://codeforces.com//contest/1238/problem/E", "problemId": "434109", "shortId": "1238E", "contest_number": "1238", "name": "E. Keyboard Purchase", "statement": "You have a password which you often type \u2014 a string  of length . Every character of this string is one of the first  lowercase Latin letters.Since you spend a lot of time typing it, you want to buy a new keyboard.A keyboard is a permutation of the first  Latin letters. For example, if , then there are six possible keyboards: , , , ,  and .Since you type your password with one finger, you need to spend time moving your finger from one password character to the next. The time to move from character  to character  is equal to the distance between these characters on keyboard. The total time you have to spend typing the password with a keyboard is called the  of this keyboard.More formaly, the slowness of keyboard is equal to , where  is position of letter  in keyboard.For example, if  is  and the keyboard is , then the total time of typing this password is  =  = .Before buying a new keyboard you want to know the minimum possible slowness that the keyboard can have. ", "input": "The first line contains two integers  and  (). The second line contains the string  consisting of  characters. Each character is one of the first  Latin letters (lowercase).", "output": "Print one integer \u2013 the minimum slowness a keyboard can have.", "tutorial": "Let's solve this problem by subset dynamic programming.Let's denote  as the number of adjacent characters ( and ) in  such that  or .Let's  be some intermediate result (further it will be explained what kind of intermediate result) if we already added letters corresponding to subset  to the keyboard (and we don't care about the order of these letters).Now let's consider how to recalculate values of this dynamic programming using some . Let's iterate over a new letter  on keyboard (and we know the position of this letter on the keyboard: it's equal to the number of elements in ). After adding this new letter, we want to calculate what it added to the . Let consider some letter  and calculate how much time will be spent on moving  and . There are two cases. If letter  is already on current keyboard, then we should add to answer , and  otherwise (where  is the position of character  on the keyboard). But we don't know the position of the letter . Let's fix it as follows. We will add the contribution of some letter when it will be added to the keyboard. So, when we added letter , we should add the value .So, the total complexity is .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvoid upd(int &a, int b){\n\ta = min(a, b);\n}\n\nconst int N = 20;\nconst int M = (1 << N) + 55;\nconst int INF = int(1e9) + 100;\n\nint a, n;\nstring s;\nint cnt[N][N];\nint d[M][N];\nint dp[M];\nint cntBit[M];\nint minBit[M];\n\nint main() {\t\n\tcin >> n >> a >> s;\n\t\n\tint B = (1 << a) - 1;\n\tfor(int i = 1; i < s.size(); ++i){\n\t\t++cnt[s[i] - 'a'][s[i - 1] - 'a'];\n\t\t++cnt[s[i - 1] - 'a'][s[i] - 'a'];\n\t}\n\tfor(int i = 0; i < M; ++i)\n\t\tdp[i] = INF;\n\tdp[0] = 0;\n\tfor(int msk = 1; msk < M; ++msk){\n\t\tcntBit[msk] = 1 + cntBit[msk & (msk - 1)];\n\t\tfor(int i = 0; i < N; ++i) if((msk >> i) & 1){\n\t\t\tminBit[msk] = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int msk = 1; msk < M; ++msk)\n\t\tfor(int i = 0; i < a; ++i){\n\t\t\tint b = minBit[msk];\n\t\t\td[msk][i] = d[msk ^ (1 << b)][i] + cnt[i][b];\t\t\n\t\t}\n\n\tfor(int msk = 0; msk < (1 << a); ++msk){\n\t\tfor(int i = 0; i < a; ++i){\n\t\t\tif((msk >> i) & 1) continue;\n\t\t\t//i -> x\n\t\t\tint pos = cntBit[msk];\n\t\t\tint nmsk = msk | (1 << i);\n\t\t\tupd(dp[nmsk], dp[msk] + pos * (d[msk][i] - d[B ^ nmsk][i]));\n\t\t}\n\t}\t\n\n\tcout << dp[B] << endl;\n\treturn 0;\n} \n", "interactive": false, "noSolution": false, "noTutorial": false}