{"link": "https://codeforces.com//contest/1697/problem/C", "problemId": "1427642", "shortId": "1697C", "contest_number": "1697", "name": "C. awoo's Favorite Problem", "statement": "You are given two strings  and , both of length . Each character in both string is '', '' or ''.In one move, you can perform one of the following actions:   choose an occurrence of \"\" in  and replace it with \"\";  choose an occurrence of \"\" in  and replace it with \"\". You are allowed to perform an arbitrary amount of moves (possibly, zero). Can you change string  to make it equal to string ?", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of testcases. The first line of each testcase contains a single integer  ()\u00a0\u2014 the length of strings  and . The second line contains string  of length . Each character is '', '' or ''. The third line contains string  of length . Each character is '', '' or ''. The sum of  over all testcases doesn't exceed .", "output": "For each testcase, print \"\" if you can change string  to make it equal to string  by performing an arbitrary amount of moves (possibly, zero). Otherwise, print \"\".", "tutorial": "First, check that the counts of all letters are the same in both strings.Then consider the following restatement of the moves. The letters '' in the string  are stationary. Letters '' and '', however, move around the string. The move of the first type moves a letter '' to the right. The move of the second type moves a letter '' to the left.Notice that letters '' and '' can never swap with each other. Thus, if you remove all letters '' from both strings, the remaining strings should be the same.Again, since letters '' and '' can never swap with each other, you can deduce where each of these letters should end up after the swaps. The first letter '{a}' in  should be on the position of the first letter '' in  and so on.After that, we recall that ''s can only move to the right and ''s can only move to the left. Thus, we check that the -th occurrence of '' in  is to the left or equal to the -th occurrences of '' in  and vice versa for ''s.Finally, we can see that this is a sufficient condition. Easy to show by construction: you can just fix the positions one after another left to right.Overall complexity:  per testcase.", "solution": "for _ in range(int(input())):\n\tn = int(input())\n\ts = input()\n\tt = input()\n\tif s.count('b') != t.count('b'):\n\t\tprint(\"NO\")\n\t\tcontinue\n\tj = 0\n\tfor i in range(n):\n\t\tif s[i] == 'b':\n\t\t\tcontinue\n\t\twhile t[j] == 'b':\n\t\t\tj += 1\n\t\tif s[i] != t[j] or (s[i] == 'a' and i > j) or (s[i] == 'c' and i < j):\n\t\t\tprint(\"NO\")\n\t\t\tbreak\n\t\tj += 1\n\telse:\n\t\tprint(\"YES\")", "interactive": false, "noSolution": false, "noTutorial": false}