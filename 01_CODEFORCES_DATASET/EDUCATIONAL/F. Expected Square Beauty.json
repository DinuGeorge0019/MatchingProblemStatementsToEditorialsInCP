{"link": "https://codeforces.com//contest/1187/problem/F", "problemId": "365122", "shortId": "1187F", "contest_number": "1187", "name": "F. Expected Square Beauty", "statement": "Let  be an array of integers . Let's define  as a minimal size of a partition of  into subsegments such that all elements in each subsegment are equal. For example,  using next partition: .Now you don't have any exact values of , but you know that  can be any integer value from  () uniformly at random. All  are independent.Calculate expected value of , or . It's guaranteed that the expected value can be represented as rational fraction  where , so print the value .", "input": "The first line contains the single integer  () \u2014 the size of the array . The second line contains  integers  (). The third line contains  integers  ().", "output": "Print the single integer \u2014  as .", "tutorial": "As usual with tasks on an expected value, let's denote  as indicator function:  if  and  otherwise; . Then we can note that . Now we can make some transformations: .Now we'd like to make some casework:   if  ( and  aren't consecutive) then  and  are independent, that's why ;  if  then ;   need further investigation. For the simplicity let's transform segment  to  by increasing .Let's denote  as the probability that :  and . Let's denote . In result, .The final observation is the following:  is equal to the probability that  and  and can be calculated by inclusion-exclusion principle: , where .In result,  and can be calculated in  time.", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) int((a).size())\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef pair<int, int> pt;\n\nconst int MOD = int(1e9) + 7;\n\nint norm(int a) {\n\twhile(a >= MOD) a -= MOD;\n\twhile(a < 0) a += MOD;\n\treturn a;\n}\nint mul(int a, int b) {\n\treturn int(a * 1ll * b % MOD);\n}\nint binPow(int a, int k) {\n\tint ans = 1;\n\tfor(; k > 0; k >>= 1) {\n\t\tif(k & 1)\n\t\t\tans = mul(ans, a);\n\t\ta = mul(a, a);\n\t}\n\treturn ans;\n}\nint inv(int a) {\n\tint b = binPow(a, MOD - 2);\n\tassert(mul(a, b) == 1);\n\treturn b;\n}\n\nint n;\nvector<int> l, r;\n\ninline bool read() {\n\tif(!(cin >> n))\n\t\treturn false;\n\tl.resize(n);\n\tr.resize(n);\n\t\n\tfore(i, 0, n)\n\t\tcin >> l[i];\n\tfore(i, 0, n) {\n\t\tcin >> r[i];\n\t\tr[i]++;\n\t}\n\treturn true;\n}\n\nvector<int> p;\n\nint calcEq(int i0) { \n\tint i1 = i0 + 1;\n\tint pSame = 0;\n\tif(i0 > 0) {\n\t\tint cnt = max(0, min({r[i0 - 1], r[i0], r[i1]}) - max({l[i0 - 1], l[i0], l[i1]}));\n\t\tpSame = mul(cnt, inv(mul(mul(r[i0 - 1] - l[i0 - 1], r[i0] - l[i0]), r[i1] - l[i1])));\n\t}\n\treturn norm(1 - norm(2 - p[i0] - p[i1]) + pSame);\n}\n\ninline void solve() {\n\tp.assign(n, 0);\n\tp[0] = 1;\n\tfore(i, 1, n) {\n\t\tint cnt = max(0, min(r[i - 1], r[i]) - max(l[i - 1], l[i]));\n\t\tp[i] = norm(1 - mul(cnt, inv(mul(r[i - 1] - l[i - 1], r[i] - l[i]))));\n\t}\n\t\n\tint sum = 0;\n\tfore(i, 0, n)\n\t\tsum = norm(sum + p[i]);\n\t\n\tint ans = 0;\n\tfore(i, 0, n) {\n\t\tint curS = sum;\n\t\tfor(int j = max(0, i - 1); j < min(n, i + 2); j++)\n\t\t\tcurS = norm(curS - p[j]);\n\t\t\n\t\tans = norm(ans + mul(p[i], curS));\n\t\t\n\t\tif(i > 0)\n\t\t\tans = norm(ans + calcEq(i - 1));\n\t\tans = norm(ans + p[i]);\n\t\tif(i + 1 < n)\n\t\t\tans = norm(ans + calcEq(i));\n\t}\n\t\n\tcout << ans << endl;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint tt = clock();\n#endif\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0), cout.tie(0);\n\tcout << fixed << setprecision(15);\n\t\n\tif(read()) {\n\t\tsolve();\n\t\t\n#ifdef _DEBUG\n\t\tcerr << \"TIME = \" << clock() - tt << endl;\n\t\ttt = clock();\n#endif\n\t}\n\treturn 0;\n} ", "interactive": false, "noSolution": false, "noTutorial": false}