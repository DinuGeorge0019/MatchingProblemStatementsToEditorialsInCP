{"link": "https://codeforces.com//contest/1366/problem/F", "problemId": "646804", "shortId": "1366F", "contest_number": "1366", "name": "F. Jog Around The Graph", "statement": "You are given a simple weighted connected undirected graph, consisting of  vertices and  edges.A path in the graph of length  is a sequence of  vertices  such that for each   the edge  is present in the graph. A path from some vertex  also has vertex . Note that edges and vertices are allowed to be included in the path multiple times.The weight of the path is the total weight of edges in it.For each  from  to  consider a path from vertex  of length  of the maximum weight. What is the sum of weights of these  paths?Answer can be quite large, so print it modulo .", "input": "The first line contains a three integers , ,  (; ; )\u00a0\u2014 the number of vertices in the graph, the number of edges in the graph and the number of lengths that should be included in the answer. Each of the next  lines contains a description of an edge: three integers , ,  (; )\u00a0\u2014 two vertices  and  are connected by an undirected edge with weight . The graph contains no loops and no multiple edges. It is guaranteed that the given edges form a connected graph.", "output": "Print a single integer\u00a0\u2014 the sum of the weights of the paths from vertex  of maximum weights of lengths  modulo .", "tutorial": "Let's observe what does the maximum weight of some fixed length path look like. Among the edges on that path the last one has the maximum weight. If it wasn't then the better total weight could be achieved by choosing a bigger weight edge earlier and going back and forth on it for the same number of steps. It actually helps us arrive to a conclusion that all optimal paths look like that: some simple path to an edge and then back and forth movement on it.Any simple path in the graph has its length at most . Let's separate the queries into two parts. will be handled in a straightforward manner. Let  be the maximum weight of a path that ends in  and has exactly  edges in it. That's pretty easy to calculate in .You can also think of this  as some kind of Ford-Bellman algorithm\u00a0\u2014 let  on the -th step be the maximum weight of the path to  of length . Iterate over all edges and try to update  and  for each edge  (that's what I do in my solution if you refer to it).Now for . There was a very common assumption that after a bit more steps some edge will become the most optimal and will stay the most optimal until the end of time. However, that \"a bit\" cut-off is in fact too high to rely on (it must be somewhere around ).So the best path of length exactly  ending in each vertex  is . Let the maximum weight adjacent edge to vertex  be . So the path of length  will have weight . Treat it like a line  with coefficients  and .How do determine which line is the best for some ? Sure, experienced participants will immediately answer \"convex hull\". Build a lower envelope of the convex hull of these lines. If  was a little smaller than we could query with binary search for each , the same how convex hull is usually used. We have to examine the hull further. Each line in it becomes the best in some point, then stays the best for some interval and then never appears the best again. What are these line changing points? Well, it's just the intersection point of the adjacent lines in the hull. So having these points and the parameters of the line we can calculate its contribution to the answer with a sum of arithmetic progression formula.There were just  lines in the hull so you can build the hull in any complexity, I think I saw up to  performances in the participants codes.There is a cool solution that involves some kind of Divide&Conquer on these lines. I personally thought of it in a sense of traversing a Li-Chao tree without actually building it. If anyone wants to explain this solution, feel free to do it in comments.Overall complexity: .", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst long long INF = 1e18;\nconst int MOD = 1000'000'007;\nconst int inv2 = (MOD + 1) / 2;\n\nstruct edge{\n\tint v, u, w;\n};\n\nstruct frac{\n\tlong long x, y;\n\tfrac(long long a, long long b){\n\t\tif (b < 0) a = -a, b = -b;\n\t\tx = a, y = b;\n\t}\n};\n\nbool operator <=(const frac &a, const frac &b){\n\treturn a.x * b.y <= a.y * b.x;\n}\n\nstruct line{\n\tlong long m, c;\n\tfrac intersectX(const line &l) { return frac(c - l.c, l.m - m); }\n};\n\nint add(int a, int b){\n\ta += b;\n\tif (a >= MOD)\n\t\ta -= MOD;\n\tif (a < 0)\n\t\ta += MOD;\n\treturn a;\n}\n\nint mul(int a, int b){\n\treturn a * 1ll * b % MOD;\n}\n\nint calc(int a1, int d, int n){\n\tassert(n >= 0);\n\treturn mul(mul(n, inv2), add(mul(2, a1), mul(add(n, -1), d)));\n}\n\nint main() {\n\tint n, m;\n\tlong long q;\n\tscanf(\"%d%d%lld\", &n, &m, &q);\n\tvector<edge> e(m);\n\tvector<int> hv(n);\n\tforn(i, m){\n\t\tscanf(\"%d%d%d\", &e[i].v, &e[i].u, &e[i].w);\n\t\t--e[i].v, --e[i].u;\n\t\thv[e[i].v] = max(hv[e[i].v], e[i].w);\n\t\thv[e[i].u] = max(hv[e[i].u], e[i].w);\n\t}\n\t\n\tint ans = 0;\n\tvector<long long> d(n, -INF), nd(n);\n\td[0] = 0;\n\tforn(val, m){\n\t\tlong long mx = 0;\n\t\tforn(i, n)\n\t\t\tmx = max(mx, d[i]);\n\t\tif (val)\n\t\t\tans = add(ans, mx % MOD);\n\t\tnd = d;\n\t\tforn(i, m){\n\t\t\tnd[e[i].v] = max(nd[e[i].v], d[e[i].u] + e[i].w);\n\t\t\tnd[e[i].u] = max(nd[e[i].u], d[e[i].v] + e[i].w);\n\t\t}\n\t\td = nd;\n\t}\n\t\n\tvector<line> fin;\n\tforn(i, n) fin.push_back({hv[i], d[i]});\n\tsort(fin.begin(), fin.end(), [](const line &a, const line &b){\n\t\tif (a.m != b.m)\n\t\t\treturn a.m < b.m;\n\t\treturn a.c > b.c;\n\t});\n\tfin.resize(unique(fin.begin(), fin.end(), [](const line &a, const line &b){\n\t\treturn a.m == b.m;\n\t}) - fin.begin());\n\t\n\tvector<line> ch;\n\tfor (auto cur : fin){\n\t\twhile (ch.size() >= 2 && cur.intersectX(ch.back()) <= ch.back().intersectX(ch[int(ch.size()) - 2]))\n\t\t\tch.pop_back();\n\t\tch.push_back(cur);\n\t}\n\t\n\tlong long prv = 0;\n\tq -= m;\n\tforn(i, int(ch.size()) - 1){\n\t\tfrac f = ch[i].intersectX(ch[i + 1]);\n\t\tif (f.x < 0) continue;\n\t\tlong long lst = min(q, f.x / f.y);\n\t\tif (lst < prv) continue;\n\t\tans = add(ans, calc((ch[i].c + ch[i].m * prv) % MOD, ch[i].m % MOD, lst - prv + 1));\n\t\tprv = lst + 1;\n\t}\n\tans = add(ans, calc((ch.back().c + ch.back().m * prv) % MOD, ch.back().m % MOD, q - prv + 1));\n\t\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}