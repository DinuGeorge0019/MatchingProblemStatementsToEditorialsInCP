{"link": "https://codeforces.com//contest/1476/problem/D", "problemId": "881705", "shortId": "1476D", "contest_number": "1476", "name": "D. Journey", "statement": "There are  cities, numbered from  to .  roads connect these cities, the -th road connects cities  and  ().Each road has a direction. The directions are given by a string of  characters such that each character is either  or . If the -th character is , it means that the -th road initially goes from the city  to the city ; otherwise it goes from the city  to the city .A traveler would like to visit as many cities of this country as possible. Initially, they will choose some city to start their journey from. Each day, the traveler  go from the city where they currently are to a neighboring city using one of the roads, and they can go along a road only if it is directed in the same direction they are going; i.\u2009e., if a road is directed from city  to the city , it is possible to travel from  to , but not from  to . After the traveler moves to a neighboring city,  roads change their directions . If the traveler cannot go from their current city to a neighboring city, their journey ends; it is also possible to end the journey whenever the traveler wants to.The goal of the traveler is to visit as many different cities as possible (they can visit a city multiple times, but only the first visit is counted). For each city , calculate the maximum number of different cities the traveler can visit during  if they start in the city . ", "input": "The first line contains one integer  () \u2014 the number of test cases. Each test case consists of two lines. The first line contains one integer  (). The second line contains the string  consisting of exactly  characters, each character is either  or . It is guaranteed that the sum of  over all test cases does not exceed .", "output": "For each test case, print  integers. The -th integer should be equal to the maximum number of different cities the traveler can visit during one journey if this journey starts in the -th city.", "tutorial": "There are two key observations to this problem:  after each pair of moves, the directions go back to the original ones;  after each move, we can immediately go back (and combining these observations, we can derive that if we go from city  to some other city , we can always go back). One of the solutions we can write using these observations is to build an undirected graph on  vertices. Each vertex represents a pair , where  is the city we are currently staying in, and  is the number of moves we made, modulo . Since each move is to a neighboring city, each vertex  is unreachable from , and vice versa. And since we can always go back, and each pair of steps doesn't change the directions, this graph is actually an undirected one. So, we can find the connected components of this graph using DFS/BFS/DSU, and for each city , print the size of the component the vertex  belongs to.Another solution is to find the leftmost and the rightmost city reachable from each city. For example, finding the leftmost reachable city can be done with the following dynamic programming: let  be the leftmost city reachable from . Then, if we can't go left from , ; if we can make only one step to the left from , ; and if we can make two steps, we can take the answer from the city : . The same approach can be used to calculate the rightmost reachable city.", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = int(1e9);\n\nchar buf[300043];\n\nint main()\n{\n    int t;\n    scanf(\"%d\", &t);\n    for(int _ = 0; _ < t; _++)\n    {\n        int n;\n        scanf(\"%d\", &n);\n        scanf(\"%s\", buf);\n        string s = buf;\n        vector<vector<int>> g(2 * n + 2);\n        for(int i = 0; i < n; i++)\n            if(s[i] == 'L')\n            {\n                g[(i + 1) * 2].push_back(i * 2 + 1);\n                g[i * 2 + 1].push_back((i + 1) * 2);\n            }\n            else\n            {\n                g[i * 2].push_back((i + 1) * 2 + 1);\n                g[(i + 1) * 2 + 1].push_back(i * 2);   \n            }\n        vector<int> comp(2 * n + 2, -1);\n        vector<int> cnt;\n        for(int i = 0; i < 2 * n + 2; i++)\n        {\n            if(comp[i] != -1) continue;\n            int c = 1;\n            int cc = cnt.size();\n            queue<int> q;\n            comp[i] = cc;\n            q.push(i);\n            while(!q.empty())\n            {\n                int k = q.front();\n                q.pop();\n                for(auto y : g[k])\n                {\n                    if(comp[y] == -1)\n                    {\n                        c++;\n                        comp[y] = cc;\n                        q.push(y);\n                    }\n                }\n            }\n            cnt.push_back(c);\n        }\n        for(int i = 0; i <= n; i++)\n            printf(\"%d%c\", cnt[comp[i * 2]], \" \\n\"[i == n]);\n    }\n}", "interactive": false, "noSolution": false, "noTutorial": false}