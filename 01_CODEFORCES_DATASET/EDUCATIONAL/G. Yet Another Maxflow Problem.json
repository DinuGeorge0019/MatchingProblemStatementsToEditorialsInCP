{"link": "https://codeforces.com//contest/903/problem/G", "problemId": "138456", "shortId": "903G", "contest_number": "903", "name": "G. Yet Another Maxflow Problem", "statement": "In this problem you will have to deal with a very special network.The network consists of two parts: part  and part . Each part consists of  vertices; -th vertex of part  is denoted as , and -th vertex of part  is denoted as .For each index  () there is a directed edge from vertex  to vertex , and from  to , respectively. Capacities of these edges are given in the input. Also there might be several directed edges going from part  to part  (but never from  to ).You have to calculate the maximum flow value from  to  in this network. Capacities of edges connecting  to  might sometimes change, and you also have to maintain the maximum flow value after these changes. Apart from that, the network is fixed (there are no changes in part , no changes of edges going from  to , and no edge insertions or deletions).Take a look at the example and the notes to understand the structure of the network better.", "input": "The first line contains three integer numbers ,  and  (, ) \u2014 the number of vertices in each part, the number of edges going from  to  and the number of changes, respectively. Then  lines follow, -th line contains two integers  and  denoting that the edge from  to  has capacity  and the edge from  to  has capacity  (). Then  lines follow, describing the edges from  to . Each line contains three integers ,  and  denoting an edge from  to  with capacity  (, ). There might be multiple edges from  to . And then  lines follow, describing a sequence of changes to the network. -th line contains two integers  and , denoting that the capacity of the edge from  to  is set to  (, ).", "output": "Firstly, print the maximum flow value in the original network. Then print  integers, -th of them must be equal to the maximum flow value after -th change.", "tutorial": "First of all, let's calculate minimum cut instead of maximum flow.The value of the cut is minimum if we choose  (the first set of the cut) as  first vertices of part  and  first vertices of part  (, ). That's because if  is the minimum index such that , then we don't have to add any vertices  such that  to , because that would only increase the value of the cut. Similarly, if  is the maximum index such that , then it's optimal to add every vertex  such that  to .Okay, so we can try finding minimum cut as a function  \u2014 value of the cut if we choose  as the union of  first vertices in  and  first vertices in .To find its minimum, let's rewrite it as , where  is the sum of capacities of edges added to the cut in part  (it doesn't depend on part ),  is the sum of capacities added to the cut from part , and  is the sum of capacities added to the cut by edges going from  to .These functions can be denoted this way:   if ; otherwise  is the capacity of the edge going from  to ;   if ; otherwise  is the capacity of the edge going from  to ;   is the sum of capacities over all edges  such that  and . Since only the values of  are not fixed, we can solve this problem with the following algorithm:  For each  (), find the minimum possible sum of . Let's denote this as , and let's denote ;  Build a segment tree that allows to get minimum value and modify a single value over the values of . When we need to change capacity of an edge, we add the difference between new and old capacities to ; and to calculate the maximum flow, we query minimum over the whole tree. But how can we calculate the values of ? We can do it using another segment tree that allows to query minimum on segment and add some value to the segment. First of all, let's set  and build this segment tree over values of . The value of  is fixed for given , so it is not modified; the value of  is initially  since when , there are no vertices belonging to  in the part .And then we calculate the values of  one by one. When we increase , we need to process all edges leading from  to part . When we process an edge leading to vertex  with capacity , we have to add  to every value of  such that  (since if , then ), and this can be performed by addition on segment in the segment tree. After processing each edge leading from  to part , we can query  as the minimum value in the segment tree.Time complexity of this solution is . ", "solution": "#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, \"/STACK:336777216\")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 18;\nconst ll MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-9;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define Se second\n#define Fi first\n\nclass Node {\npublic:\n\tll mn, v;\n\tNode() {\n\t\tmn = v = 0;\n\t}\n};\nNode indt[600000];\nvoid propagate(int n) {\n\tll v = indt[n].v;\n\tindt[2 * n].mn += v;\n\tindt[2 * n].v += v;\n\tindt[2 * n + 1].mn += v;\n\tindt[2 * n + 1].v += v;\n\tindt[n].v = 0;\n}\nvoid update(int st, int en, int S, int E, int n, ll v) {\n\tif (en < S || E < st) return;\n\tif (st <= S && E <= en) {\n\t\tindt[n].v += v;\n\t\tindt[n].mn += v;\n\t\treturn;\n\t}\n\tpropagate(n);\n\n\tint M = (S + E) / 2;\n\tupdate(st, en, S, M, 2 * n, v);\n\tupdate(st, en, M + 1, E, 2 * n + 1, v);\n\tindt[n].mn = min(indt[2 * n].mn, indt[2 * n + 1].mn);\n}\nll getmn(int st, int en, int S, int E, int n) {\n\tif (en < S || E < st) return LL_INF;\n\tif (st <= S && E <= en) return indt[n].mn;\n\tpropagate(n);\n\n\tint M = (S + E) / 2;\n\treturn min(getmn(st, en, S, M, 2 * n), getmn(st, en, M + 1, E, 2 * n + 1));\n}\n\nll X[200050];\nll Y[200050];\nvector <pll> Ve[200050];\n\nll ans[200050];\nmultiset <ll> Sa;\nint main() {\n\tint N, M, Q, i, j;\n\tscanf(\"%d %d %d\", &N, &M, &Q);\n\tfor (i = 1; i < N; i++) scanf(\"%lld %lld\", &X[i], &Y[i]);\n\n\tfor (i = 1; i < N; i++) update(i, i, 0, IT_MAX - 1, 1, Y[i]);\n\twhile (M--) {\n\t\tint t1, t2, t3;\n\t\tscanf(\"%d %d %d\", &t1, &t2, &t3);\n\t\tVe[t1].emplace_back(t3, t2);\n\t}\n\n\tfor (i = 1; i <= N; i++) {\n\t\tfor (auto it : Ve[i]) update(0, it.second - 1, 0, IT_MAX - 1, 1, it.first);\n\t\tans[i] = getmn(0, N - 1, 0, IT_MAX - 1, 1);\n\t}\n\tfor (i = 1; i <= N; i++) {\n\t\tans[i] += X[i];\n\t\tSa.insert(ans[i]);\n\t}\n\tprintf(\"%lld\\n\", *(Sa.begin()));\n\twhile (Q--) {\n\t\tint t1, t2;\n\t\tscanf(\"%d %d\", &t1, &t2);\n\t\tSa.erase(Sa.lower_bound(ans[t1]));\n\t\tans[t1] -= X[t1];\n\t\tX[t1] = t2;\n\t\tans[t1] += X[t1];\n\t\tSa.insert(ans[t1]);\n\t\tprintf(\"%lld\\n\", *(Sa.begin()));\n\t}\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}