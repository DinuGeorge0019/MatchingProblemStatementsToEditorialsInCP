{"link": "https://codeforces.com//contest/1207/problem/D", "problemId": "393974", "shortId": "1207D", "contest_number": "1207", "name": "D. Number Of Permutations", "statement": "You are given a sequence of  pairs of integers: . This sequence is called bad if it is sorted in non-descending order by first elements or if it is sorted in non-descending order by second elements. Otherwise the sequence is good. There are examples of good and bad sequences:   is bad because the sequence of first elements is sorted: ;   is bad because the sequence of second elements is sorted: ;   is bad because both sequences (the sequence of first elements and the sequence of second elements) are sorted;   is good because neither the sequence of first elements  nor the sequence of second elements  is sorted. Calculate the number of permutations of size  such that after applying this permutation to the sequence  it turns into a good sequence. A permutation  of size  is a sequence  consisting of  distinct integers from  to  (). If you apply permutation  to the sequence  you get the sequence . For example, if  and  then  turns into .", "input": "The first line contains one integer  (). The next  lines contains description of sequence . The -th line contains two integers  and  () \u2014 the first and second elements of -th pair in the sequence. .", "output": "Print the number of permutations of size  such that after applying this permutation to the sequence  it turns into a good sequence. Print the answer modulo  (a prime number).", "tutorial": "Let's suppose that all  permutation are good. We counted the permutations giving the sequences where the first elements are sorted (we denote the number of such permutations as ) and the permutations giving the sequences where the second elements are sorted (we denote the number of such permutations as ). Then the answer is , right? No, because we subtracted the number of sequences where first and second elements are sorted simultaneously (we denote this number as ) twice. So, the answer is .How can we calculate the value of ? It's easy to understand that the elements having equal  can be arranged in any order. So, , where  is the number of elements equal to  among .  can be calculated the same way.How can we calculate the value of ? First of all, there is a case where it is impossible to arrange the elements of the sequence so that the first elements and the second elements are sorted. To check that, we may sort the given sequence comparing two elements by , and if  are equal \u2014 by . If the sequence of second elements in the resulting sequence is not sorted, then . Otherwise, equal elements of the given sequence can be arranged in any order. So , where , , ...,  are the elements that appear in the given sequence of pairs at least once.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(3e5) + 99;\nconst int MOD = 998244353;\n\nint mul(int a, int b){\n    return (a * 1LL * b) % MOD;\n}\n\n\nint sum(int a, int b){\n    return (a + b) % MOD;\n}\n\nint n;\npair<int, int> a[N];\nint f[N];\n\nint main() {\n    scanf(\"%d\", &n);\n    for(int i = 0; i < n; ++i)\n        scanf(\"%d%d\", &a[i].first, &a[i].second);\n\n    f[0] = 1;\n    for(int i = 1; i < N; ++i)\n        f[i] = mul(i, f[i - 1]);\n\n    int res = f[n];\n    for(int c = 0; c < 2; ++c){\n        int d = 1;\n        sort(a, a + n);\n        int l = 0;\n        while(l < n){\n            int r = l + 1;\n            while(r < n && a[l].first == a[r].first) ++r;\n            d = mul(d, f[r - l]);\n            l = r;\n        }\n        res = sum(res, MOD - d);\n        for(int i = 0; i < n; ++i) \n            swap(a[i].first, a[i].second);\n    }       \n\n    sort(a, a + n);\n    int l = 0;\n    int d = 1;\n    while(l < n){\n        int r = l + 1;\n        while(r < n && a[l].first == a[r].first) ++r;\n        map<int, int> m;\n        for(int i = l; i < r; ++i) ++m[a[i].second];\n        for(auto p : m) d = mul(d, f[p.second]);\n        l = r;\n    }\n    for(int i = 1; i < n; ++i) \n        if(a[i - 1].second > a[i].second) d = 0;\n\n    res = sum(res, d);\n    printf(\"%d\\n\", res);\n    return 0;\n}                               ", "interactive": false, "noSolution": false, "noTutorial": false}