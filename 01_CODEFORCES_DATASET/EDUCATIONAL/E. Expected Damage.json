{"link": "https://codeforces.com//contest/1418/problem/E", "problemId": "727427", "shortId": "1418E", "contest_number": "1418", "name": "E. Expected Damage", "statement": "You are playing a computer game. In this game, you have to fight  monsters.To defend from monsters, you need a shield. Each shield has two parameters: its current durability  and its defence rating . Each monster has only one parameter: its strength .When you fight a monster with strength  while having a shield with current durability  and defence , there are three possible outcomes:  if , then you receive  damage;  if  and , you receive no damage, but the current durability of the shield decreases by ;  if  and , nothing happens. The -th monster has strength , and you will fight each of the monsters exactly once, in some random order (all  orders are equiprobable). You have to consider  different shields, the -th shield has initial durability  and defence rating . For each shield, calculate the expected amount of damage you will receive if you take this shield and fight the given  monsters in random order.", "input": "The first line contains two integers  and  () \u2014 the number of monsters and the number of shields, respectively. The second line contains  integers , , ...,  (), where  is the strength of the -th monster. Then  lines follow, the -th of them contains two integers  and  (; ) \u2014 the description of the -th shield.", "output": "Print  integers, where the -th integer represents the expected damage you receive with the -th shield as follows: it can be proven that, for each shield, the expected damage is an irreducible fraction , where  is coprime with . You have to print the value of , where  is the inverse element for  ().", "tutorial": "First of all, let's find a solution in . We will use the lineriality of expectation: the answer for some shield  is equal to , where  is the probability that the monster  will deal damage if we use the -th shield. Let's see how to calculate .Consider a monster  such that . To deal damage, he should be preceded by at least  other monsters having . We can write a complicated formula with binomial coefficients to calculate the probability of this happening, and then simplify it, but a much easier solution is to consider the order of these \"strong\" monsters. Suppose there are  of them, then there are  strong monsters that will deal damage. Since all orderings are equiprobable, the probability that our fixed monster will deal damage is  \u2014 since it is the probability that it will take one of the last places in the order.Okay, what about \"weak\" monsters? It turns out that we can use the same approach: to deal damage, a weak monster should be preceded by at least  strong monsters. Consider the relative order of  strong monsters and that weak monster we are analyzing. There are  positions where the weak monster will deal damage, so the probability of weak monster dealing damage is .Okay, we got a solution in . How to make it faster? Whenever we consider a shield, all monsters are split into two types: strong and weak, and we may sort the monsters beforehand, so the number of strong monsters (and their total strength) can be found with binary search. Since the probabilities for all strong monsters are the same, we can multiply their total strength by the probability that one fixed strong monster will deal damage (we already described how to calculate it). The same applies for the weak monsters, so the total complexity is .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(2e5) + 9;\nconst int MOD = 998244353;\n\nint mul(int a, int b) {\n    return (a * 1LL * b) % MOD;\n}\n\nint bp(int a, int n) {\n    int res = 1;\n    for (; n > 0; n /= 2) {\n        if (n & 1) res = mul(res, a);\n        a = mul(a, a);\n    }\n    \n    return res;\n}\n\nint inv(int a) {\n    int ia = bp(a, MOD - 2);\n    assert(mul(a, ia) == 1);\n    return ia;\n}\n\nint n, m;\nint d[N];\nlong long sd[N];\n\nlong long sum (int l, int r) {\n    return (sd[r] - sd[l]) % MOD;\n}\n\nint main(){\n    cin >> n >> m;\n    for (int i = 0; i < n; ++i)\n        scanf(\"%d\", d + i);\n    sort(d, d + n);\n    for (int i = 0; i < n; ++i)\n        sd[i + 1] = sd[i] + d[i];\n        \n    for (int i = 0; i < m; ++i) {\n        int a, b;\n        scanf(\"%d%d\", &a, &b); // dur, def\n        int cnt = (d + n) - lower_bound(d, d + n, b);\n        int res = 0;\n        if (cnt >= a) {\n            res = mul( mul(cnt - a, inv(cnt)), sum(n - cnt, n) );\n            res += mul( mul(cnt - a + 1, inv(cnt + 1)), sum(0, n - cnt) );\n            res %= MOD;\n        }\n        printf(\"%d\\n\", res);\n    }\n    \n    return 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}