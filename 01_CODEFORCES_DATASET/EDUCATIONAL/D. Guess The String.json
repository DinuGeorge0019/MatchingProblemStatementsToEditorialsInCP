{"link": "https://codeforces.com//contest/1697/problem/D", "problemId": "1427643", "shortId": "1697D", "contest_number": "1697", "name": "D. Guess The String", "statement": " You may use  in C++,  in Java,  in Python or  in Pascal to flush the output. If you use some other programming language, consult its documentation. You may also refer to the guide on interactive problems: https://codeforces.com/blog/entry/45307.The jury has chosen a string  consisting of  characters; each character of  is a lowercase Latin letter. Your task is to guess this string; initially, you know only its length.You may ask queries of two types:    \u2014 the query of the first type, where  is an integer from  to . In response to this query, the jury will tell you the character ;     \u2014 the query of the second type, where  and  are integers such that . In response to this query, the jury will tell you the number of different characters among . You are allowed to ask no more than  queries of the first type, and no more than  queries of the second type. Your task is to restore the string .For each test in this problem, the string  is fixed beforehand, and will be the same for every submission.", "input": "Initially, the jury program sends one integer  on a separate line \u2014 the size of  ().", "output": "To give the answer, print one line  , where  should be the string picked by the jury. After that, your program should flush the output and terminate gracefully.", "tutorial": "There are several ways to solve this problem. The model solution does it as follows:Restore the characters of  from left to right. The first character is restored by query . For each of the next characters, let's ask if this character is new (by querying  and comparing the result with the number of different characters on the segment ). If it's new, ask  to obtain the -th character (there will be at most  such queries).Otherwise, we can find the previous occurrence of the -th character with binary search. Let  be the number of different characters from position  to position . If we want to find the previous occurrence of the -th character, we need to find the last index  such that . Since the value  does not decrease when we increase , we can find the last  such that , with binary search.Unfortunately, the number of queries of type  will be too large if we just use binary search over the whole segment . To decrease the number of queries, we can use the fact that the value of  we are interested in is the last occurrence of some character we already met; there are at most  such values, and binary search among them will need only  iterations.", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nchar ask_character(int i)\n{\n    cout << \"? 1 \" << i << endl;\n    cout.flush();\n    string s;\n    cin >> s;\n    return s[0];\n}\n\nint ask_cnt(int l, int r)\n{\n    cout << \"? 2 \" << l << \" \" << r << endl;\n    cout.flush();\n    int x;\n    cin >> x;\n    return x;\n}\n\nint main()\n{\n    int n;\n    cin >> n;\n    string s = \"\";\n    vector<vector<int>> cnt(n + 1);\n    for(int i = 0; i < n; i++)\n    {\n        if(i == 0)\n        {\n            s.push_back(ask_character(1));\n            cnt[0] = {1};\n        }\n        else\n        {\n             int cur = ask_cnt(1, i + 1);\n             if(cur > cnt[i - 1][0])\n                s.push_back(ask_character(i + 1));\n             else\n             {\n                map<char, int> last;\n                for(int j = 0; j < s.size(); j++)\n                    last[s[j]] = j;\n                vector<int> lasts;\n                for(auto x : last) lasts.push_back(x.second);\n                sort(lasts.begin(), lasts.end());\n                int l = 0;\n                int r = lasts.size();\n                // there is always an occurrence in [lasts[l], i)\n                // there is no occurrence in [lasts[r], i)\n                while(r - l > 1)\n                {\n                    int m = (l + r) / 2;\n                    int c = ask_cnt(lasts[m] + 1, i + 1);\n                    if (c == cnt[i - 1][lasts[m]])\n                        l = m;\n                    else\n                        r = m;\n                }   \n                s.push_back(s[lasts[l]]);                                                \n             }\n             cnt[i].resize(i + 1);\n             set<char> q;\n             for(int j = i; j >= 0; j--)\n             {\n                q.insert(s[j]);\n                cnt[i][j] = q.size();\n             }\n        }\n    }\n    cout << \"! \" << s << endl;\n    cout.flush();\n    return 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}