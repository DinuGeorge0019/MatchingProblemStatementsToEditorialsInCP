{"link": "https://codeforces.com//contest/1463/problem/E", "problemId": "836005", "shortId": "1463E", "contest_number": "1463", "name": "E. Plan of Lectures", "statement": "Ivan is a programming teacher. During the academic year, he plans to give  lectures on  different topics. Each topic should be used in exactly one lecture. Ivan wants to choose which topic will he explain during the -st, -nd, ..., -th lecture \u2014 formally, he wants to choose some permutation of integers from  to  (let's call this permutation ).  is the index of the topic Ivan will explain during the -th lecture.For each topic (except ), there exists a prerequisite topic (for the topic , the prerequisite topic is ). Ivan cannot give a lecture on a topic before giving a lecture on its prerequisite topic. There exists at least one valid ordering of topics according to these prerequisite constraints.Ordering the topics correctly can help students understand the lectures better. Ivan has  special pairs of topics  such that he knows that the students will understand the -th topic better if the lecture on it is conducted  the lecture on the -th topic. Ivan wants to satisfy the constraints on every such pair, that is, for every , there should exist some  such that  and .Now Ivan wants to know if there exists an ordering of topics that satisfies all these constraints, and if at least one exists, find any of them. ", "input": "The first line contains two integers  and  (, ) \u2014 the number of topics and the number of special pairs of topics, respectively. The second line contains  integers , , ...,  (), where  is the prerequisite topic for the topic  (or  if the -th topic has no prerequisite topics). Exactly one of these integers is . At least one ordering of topics such that for every  the -th topic is placed before the -th topic exists. Then  lines follow, the -th line contains two integers  and  (; ) \u2014 the topics from the -th special pair. All values of  are pairwise distinct; similarly, all valus of  are pairwise distinct.", "output": "If there is no ordering of topics meeting all the constraints, print . Otherwise, print  pairwise distinct integers , , ...,  () \u2014 the ordering of topics meeting all of the constraints. If there are multiple answers, print any of them.", "tutorial": "The prerequisites for each lecture form a rooted tree, so let's forget about the legend and learn how to find such an order of vertices of a tree that all conditions work.Let's introduce some algorithm that produces an ordering of vertices for every possible case. If any valid ordering exists, it should produce a valid one. So we will only have to check if the resulting ordering is fine and output it if it is.If there were no special pairs, the task would be perfectly solvable with an algorithm of topological sorting. Thus, let's come up with a way to modify the graph, so that topsort could still be a solution.We know that the vertices that are in the special pairs should follow each other in the ordering. Look at these special pairs as edges as well. Let's first imagine they are undirected. These edges connect some vertices in the tree into components. Each component should be a segment of vertices in a valid answer. So how about we compress them into one vertex first each, find some answer for a compressed version and decompress them back?Let each of these connected components be a vertex in the new graph. Two components are connected by an edge if there is a edge in the tree between vertices of the corresponding components. Topsort in this graph will tell us the order the components should go.However, we should also find the order the vertices should go inside each component. Let's topsort the graph of all directed special pairs and sort the vertices in that order in every component. We can sort the entire graph instead of sorting each component separately because the components are totally independent. Finally, write down the answer: iterate over the compressed vertices of the first new graph in the order of its topsort, for each one write down all the actual vertices inside it in the order of the topsort of the second new graph. Check if each vertex has its parent earlier than itself in the answer. If all the graphs were topologically sortable and that holds, then the answer exists, and we found it. Otherwise, the answer doesn't exist.Overall complexity: $$$O(n \\log n)$$$.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define forn(i, n) for(int i = 0; i < int(n); i++) \n\nvector<vector<int>> g, h, ng;\n\nvector<int> rk, p;\n\nint getp(int a){\n\treturn a == p[a] ? a : p[a] = getp(p[a]);\n}\n\nvoid unite(int a, int b){\n\ta = getp(a), b = getp(b);\n\tif (a == b) return;\n\tif (rk[a] < rk[b]) swap(a, b);\n\trk[a] += rk[b];\n\tp[b] = a;\n}\n\nvector<vector<int>> comp;\n\nvector<int> ord;\nvector<int> used;\nbool fl;\n\nvoid ts(int v, const vector<vector<int>> &g){\n\tused[v] = 1;\n\tfor (int u : g[v]){\n\t\tif (used[u] == 0)\n\t\t\tts(u, g);\n\t\telse if (used[u] == 1)\n\t\t\tfl = false;\n\t\tif (!fl) return;\n\t}\n\tord.push_back(v);\n\tused[v] = 2;\n}\n\nbool topsort(const vector<vector<int>> &g){\n\tint n = g.size();\n\tused.assign(n, 0);\n\tord.clear();\n\tfl = true;\n\tforn(i, n) if (!used[i]){\n\t\tts(i, g);\n\t\tif (!fl) return false;\n\t}\n\treverse(ord.begin(), ord.end());\n\treturn true;\n}\n\nvector<int> pos;\n\nbool dfs(int v){\n\tfor (int u : g[v]){\n\t\tif (pos[u] < pos[v])\n\t\t\treturn false;\n\t\tif (!dfs(u))\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nint main() {\n\tint n, m;\n\tscanf(\"%d%d\", &n, &m);\n\tg.resize(n);\n\th.resize(n);\n\tng.resize(n);\n\tint rt = -1;\n\tforn(i, n){\n\t\tint p;\n\t\tscanf(\"%d\", &p);\n\t\t--p;\n\t\tif (p == -1)\n\t\t\trt = i;\n\t\telse\n\t\t\tg[p].push_back(i);\n\t}\n\trk.assign(n, 1);\n\tp.resize(n);\n\tiota(p.begin(), p.end(), 0);\n\tforn(i, m){\n\t\tint v, u;\n\t\tscanf(\"%d%d\", &v, &u);\n\t\t--v, --u;\n\t\th[v].push_back(u);\n\t\tunite(v, u);\n\t}\n\tif (!topsort(h)){\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\tauto ord1 = ord;\n\tvector<int> pos1(n);\n\tforn(i, n) pos1[ord1[i]] = i;\n\tforn(v, n) for (int u : g[v]) if (getp(v) != getp(u))\n\t\tng[getp(v)].push_back(getp(u));\n\tif (!topsort(ng)){\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\tcomp.resize(n);\n\tforn(i, n) comp[getp(i)].push_back(i);\n\tvector<int> fin;\n\tfor (int it : ord){\n\t\tsort(comp[it].begin(), comp[it].end(), [&](int v, int u){ return pos1[v] < pos1[u]; });\n\t\tfor (int v : comp[it])\n\t\t\tfin.push_back(v);\n\t}\n\tpos.resize(n);\n\tforn(i, n) pos[fin[i]] = i;\n\tif (!dfs(rt)){\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\tfor (int v : fin)\n\t\tprintf(\"%d \", v + 1);\n\tputs(\"\");\n}", "interactive": false, "noSolution": false, "noTutorial": false}