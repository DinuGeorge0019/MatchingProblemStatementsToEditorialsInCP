{"link": "https://codeforces.com//contest/1728/problem/D", "problemId": "1534225", "shortId": "1728D", "contest_number": "1728", "name": "D. Letter Picking", "statement": "Alice and Bob are playing a game. Initially, they are given a non-empty string , consisting of lowercase Latin letters. The length of the string is even. Each player also has a string of their own, initially empty.Alice starts, then they alternate moves. In one move, a player takes either the first or the last letter of the string , removes it from  and  (adds to the beginning) it to their own string.The game ends when the string  becomes empty. The winner is the player with a lexicographically smaller string. If the players' strings are equal, then it's a draw.A string  is lexicographically smaller than a string  if there exists such position  that  for all  and .What is the result of the game if both players play optimally (e.\u2009g. both players try to win; if they can't, then try to draw)?", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of testcases. Each testcase consists of a single line\u00a0\u2014 a non-empty string , consisting of lowercase Latin letters. The length of the string  is even. The total length of the strings over all testcases doesn't exceed .", "output": "For each testcase, print the result of the game if both players play optimally. If Alice wins, print \"Alice\". If Bob wins, print \"Bob\". If it's a draw, print \"Draw\".", "tutorial": "What do we do, when the array loses elements only from the left or from the right and the constraints obviously imply some quadratic solution? Well, apply dynamic programming, of course.The classic \u00a0\u2014 what is the outcome if only the letters from positions  to  (non-inclusive) are left.  is the answer.  is the base case\u00a0\u2014 the draw (both strings are empty). Let  mean that Alice wins,  be a draw and  mean that Bob wins.How to recalculate it? Let's consider a move of both players at the same time. From some state , first, Alice goes, then Bob. The new state becomes , Alice picked some letter , Bob picked some letter . What's that pick exactly? So, they both got a letter, prepended it to their own string. Then continued the game on a smaller string  and prepended even more letters to the string. Thus, if we want to calculate  from , we say that we  letters  and . Now it's easy. If  is not a draw, then the new letters change nothing\u00a0\u2014 the result is still the same. Otherwise, the result of the game is the same as the comparison of letters  and .How to perform both moves at once? First, we iterate over the Alice's move: whether she picks from  or from . After that we iterate over the Bob's move: whether he picks from  or from . Since we want  to be the best outcome for Alice, we do the following. For any Alice move, we choose the worse of the Bob moves\u00a0\u2014 the maximum of . Among the Alice's moves we choose the better one\u00a0\u2014 the minimum one.Overall complexity:  per testcase.", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nint comp(char c, char d){\n\treturn c < d ? -1 : (c > d ? 1 : 0);\n}\n\nint main() {\n\tint t;\n\tcin >> t;\n\tforn(_, t){\n\t\tstring s;\n\t\tcin >> s;\n\t\tint n = s.size();\n\t\tvector<vector<int>> dp(n + 1, vector<int>(n + 1));\n\t\tfor (int len = 2; len <= n; len += 2) forn(l, n - len + 1){\n\t\t\tint r = l + len;\n\t\t\tdp[l][r] = 1;\n\t\t\t{\n\t\t\t\tint res = -1;\n\t\t\t\tif (dp[l + 1][r - 1] != 0)\n\t\t\t\t\tres = max(res, dp[l + 1][r - 1]);\n\t\t\t\telse\n\t\t\t\t\tres = max(res, comp(s[l], s[r - 1]));\n\t\t\t\tif (dp[l + 2][r] != 0)\n\t\t\t\t\tres = max(res, dp[l + 2][r]);\n\t\t\t\telse\n\t\t\t\t\tres = max(res, comp(s[l], s[l + 1]));\n\t\t\t\tdp[l][r] = min(dp[l][r], res);\n\t\t\t}\n\t\t\t{\n\t\t\t\tint res = -1;\n\t\t\t\tif (dp[l + 1][r - 1] != 0)\n\t\t\t\t\tres = max(res, dp[l + 1][r - 1]);\n\t\t\t\telse\n\t\t\t\t\tres = max(res, comp(s[r - 1], s[l]));\n\t\t\t\tif (dp[l][r - 2] != 0)\n\t\t\t\t\tres = max(res, dp[l][r - 2]);\n\t\t\t\telse\n\t\t\t\t\tres = max(res, comp(s[r - 1], s[r - 2]));\n\t\t\t\tdp[l][r] = min(dp[l][r], res);\n\t\t\t}\n\t\t}\n\t\tif (dp[0][n] == -1)\n\t\t\tcout << \"Alice\\n\";\n\t\telse if (dp[0][n] == 0)\n\t\t\tcout << \"Draw\\n\";\n\t\telse\n\t\t\tcout << \"Bob\\n\";\n\t}\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}