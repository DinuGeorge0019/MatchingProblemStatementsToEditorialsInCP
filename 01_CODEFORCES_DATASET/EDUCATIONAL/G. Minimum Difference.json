{"link": "https://codeforces.com//contest/1476/problem/G", "problemId": "881708", "shortId": "1476G", "contest_number": "1476", "name": "G. Minimum Difference", "statement": "You are given an integer array  of size .You have to perform  queries. Each query has one of two types:   \"   \" \u2014 calculate the minimum value  such that there are exist   integers  such that  (for every ) and  (for every ), where  is the number of occurrences of  in the subarray . If it is impossible to choose  integers, report it;  \"  \" \u2014 assign . ", "input": "The first line contains two integers  and  () \u2014 the size of the array  and the number of queries. The second line contains  integers  (). Next  lines contain queries (one per line). Each query has one of two types:    \"   \" ()  \"  \" ().  It's guaranteed that there is at least one query of the first type.", "output": "For each query of the first type, print the minimum value of  that satisfies all required conditions, or  if it is impossible to choose  distinct integers.", "tutorial": "Let's consider a problem without queries of the second type.Now we can try to solve the problem using Mo's algorithm. Let's maintain array  \u2014 the number of occurrences of  on the current segment and array  \u2014 array  sorted in descending order.Let's take a look at how we should handle adding an element equal to . Surely, we should increase  by , but now we should erase an element equal to  from the array  and insert an element  is such a way that the array is still sorted. Instead, we can increase the leftmost element equal to  by . Similarly, we can handle deleting an element (decrease the rightmost element equal to  by ). In order to quickly find the leftmost (rightmost) element equal to , we can store the left and the right bounds of the array  where all the numbers are equal to .To answer the query of type , we should find two elements in the  array at distance  whose absolute difference is minimal. Since the size of the array  (without zero elements) is , we can't look at the whole array. But using the fact that there are no more than  different values in the  array, we can create an auxiliary array of pairs  (the value from the array  and the number of occurrences of that value). In such an array, we need to find a subarray where the sum of the second elements in the pairs is at least , and the absolute difference between the first elements in the pairs is minimal. That can be solved using standard two pointers method in .The total complexity of the solution is .In fact, we can use Mo's algorithm even with updates. But its complexity is . You can read the editorial of the problem 940F on Codeforces or the following blog to learn about processing updates in Mo: https://codeforces.com/blog/entry/72690", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n#define sz(a) int((a).size())\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n\ntypedef pair<int, int> pt;\n\nconst int N = 100 * 1000 + 13;\nconst int P = 2000;\n\nstruct query {\n  int t, l, r, k, i;\n};\n\nint main() {\n  int n, m;\n  scanf(\"%d%d\", &n, &m);\n  vector<int> a(n);\n  forn(i, n) scanf(\"%d\", &a[i]);\n  \n  vector<query> q;\n  vector<array<int, 3>> upd;\n  \n  forn(i, m) {\n    int tp;\n    scanf(\"%d\", &tp);\n    if (tp == 1) {\n      int l, r, k;\n      scanf(\"%d%d%d\", &l, &r, &k);\n      q.push_back({sz(upd), l - 1, r - 1, k, sz(q)});\n    } else {\n      int p, x;\n      scanf(\"%d%d\", &p, &x); --p;\n      upd.push_back({p, a[p], x});\n      a[p] = x;\n    }\n  }\n  \n  sort(q.begin(), q.end(), [](const query &a, const query &b) {\n    if (a.t / P != b.t / P)\n      return a.t < b.t;\n    if (a.l / P != b.l / P)\n      return a.l < b.l;\n    if ((a.l / P) & 1)\n      return a.r < b.r;\n    return a.r > b.r; \n  });\n  \n  for (int i = sz(upd) - 1; i >= 0; --i)\n    a[upd[i][0]] = upd[i][1];\n  \n  vector<int> cnt(N), ord(N);\n  vector<pt> bounds(N, {N, 0});\n  bounds[0] = {0, N - 1};\n  int L = 0, R = -1, T = 0;\n  \n  auto add = [&](int x) {\n    int c = cnt[x];\n    ++ord[bounds[c].x];\n    bounds[c + 1].y = bounds[c].x;\n    if (bounds[c + 1].x == N)\n      bounds[c + 1].x = bounds[c].x;\n    if (bounds[c].x == bounds[c].y)\n      bounds[c].x = N - 1;\n    ++bounds[c].x;\n    ++cnt[x];\n  };\n  \n  auto rem = [&](int x) {\n    int c = cnt[x];\n    --ord[bounds[c].y];\n    if (bounds[c - 1].x == N)\n      bounds[c - 1].y = bounds[c].y;\n    bounds[c - 1].x = bounds[c].y;\n    if (bounds[c].x == bounds[c].y)\n      bounds[c].x = N;\n    --bounds[c].y;\n    --cnt[x];\n  };\n  \n  auto apply = [&](int i, int fl) {\n    int p = upd[i][0];\n    int x = upd[i][fl + 1];\n    if (L <= p && p <= R) {\n      rem(a[p]);\n      add(x);\n    }\n    a[p] = x;\n  };\n  \n  vector<int> ans(sz(q));\n  \n  for (auto qr : q) {\n    int t = qr.t, l = qr.l, r = qr.r, k = qr.k;\n    while (T < t) apply(T++, 1);\n    while (T > t) apply(--T, 0);\n    while (R < r) add(a[++R]);\n    while (L > l) add(a[--L]);\n    while (R > r) rem(a[R--]);\n    while (L < l) rem(a[L++]);\n    \n    int res = N;\n    for (int i = 0, j = 0, sum = 0; i < N && ord[i] > 0; i = bounds[ord[i]].y + 1) {\n      while (j < N && ord[j] > 0 && sum < k) {\n        sum += bounds[ord[j]].y - bounds[ord[j]].x + 1;\n        j = bounds[ord[j]].y + 1;\n      }\n      if (sum >= k) res = min(res, ord[i] - ord[j - 1]);\n      sum -= bounds[ord[i]].y - bounds[ord[i]].x + 1;\n    }\n    if (res == N) res = -1;\n    ans[qr.i] = res;\n  }\n  \n  for (int x : ans) printf(\"%d\\n\", x);\n}", "interactive": false, "noSolution": false, "noTutorial": false}