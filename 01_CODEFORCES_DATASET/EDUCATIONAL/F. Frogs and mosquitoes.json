{"link": "https://codeforces.com//contest/609/problem/F", "problemId": "43549", "shortId": "609F", "contest_number": "609", "name": "F. Frogs and mosquitoes", "statement": "There are  frogs sitting on the coordinate axis . For each frog two values  are known \u2014 the position and the initial length of the tongue of the -th frog (it is guaranteed that all positions  are different).  mosquitoes one by one are landing to the coordinate axis. For each mosquito two values are known  \u2014 the coordinate of the position where the -th mosquito lands and  \u2014 the size of the -th mosquito. Frogs and mosquitoes are represented as points on the coordinate axis.The frog can eat mosquito if mosquito is in the same position with the frog or to the right, and the distance between them is not greater than the length of the tongue of the frog.If at some moment several frogs can eat a mosquito the leftmost frog will eat it (with minimal ). After eating a mosquito the length of the tongue of a frog increases with the value of the size of eaten mosquito. It's possible that after it the frog will be able to eat some other mosquitoes (the frog should eat them in this case).For each frog print two values \u2014 the number of eaten mosquitoes and the length of the tongue after landing all mosquitoes and after eating all possible mosquitoes by frogs.Each mosquito is landing to the coordinate axis only after frogs eat all possible mosquitoes landed before. Mosquitoes are given in order of their landing to the coordinate axis.", "input": "First line contains two integers  () \u2014 the number of frogs and mosquitoes. Each of the next  lines contains two integers  () \u2014 the position and the initial length of the tongue of the -th frog. It is guaranteed that all  are different. Next  lines contain two integers each  () \u2014 the position and the size of the -th mosquito.", "output": "Print  lines. The -th line should contain two integer values  \u2014 the number of mosquitoes eaten by the -th frog and the length of the tongue of the -th frog.", "tutorial": "Let's maintain the set of not eaten mosquitoes (for example with set in C++ or with TreeSet in Java) and process mosquitoes in order of their landing. Also we will maintain the set of segments (ai,\u2009bi), where ai is the position of the i-th frog and bi\u2009=\u2009ai\u2009+\u2009li, where li is the current length of the tongue of the i-th frog. Let the current mosquito landed in the position x. Let's choose segment (ai,\u2009bi) with minimal ai such that bi\u2009\u2265\u2009x. If the value ai\u2009\u2264\u2009x we found the frog that will eat mosquito. Otherwise the current mosquito will not be eaten and we should add it to our set. If the i-th frog will eat mosquito then it's tongue length will be increased by the size of mosquito and we should update segment (ai,\u2009bi). After that we should choose the nearest mosquito to the right the from frog and if it's possible eat that mosquito by the i-th frog (this can be done with lower_bound in C++). Possibly we should eat several mosquitoes, so we should repeat this process several times.\nSegments (ai,\u2009bi) we can store in segment tree by position ai and value bi. Now to find segment we need we can do binary search by the value of ai and check the maximum bi value on the prefix to be at least x. This will work in O(nlog2n) time. We can improve this solution. Let's go down in segment tree in the following manner: if the maximum value bi in the left subtree of segment tree is at least x then we will go to the left, otherwise we will go to the right.\nComplexity: O((n\u2009+\u2009m)log(n\u2009+\u2009m)).\n", "solution": "/*\nSmashing the human horde, crushing religious filth\nNailing invertedly the ones who plant the seeds of doubt\nWasting inherent truth, confronting an inner hell\nCursing subconsciously the ones who reap the seeds of doubt\n\nHow can humans play God when all they all are slaves?\nTheir lack of souls will lead them to an early grave\nCondemned to live a life of unrelenting praise\nTheir rotted corpse remains when death replaces life\n\nTearing the vocal chords of prophets\nThat spoke of lies unwanted\nThey are the ones controlling the seeds of doubt\n\nHow can humans play God when all they all are slaves?\nTheir lack of souls will lead them to an early grave\nCondemned to live a life of unrelenting praise\nTheir rotted corpse remains when death replaces life\n\nFearing their fate, they chose a random date\nWhen all life would cease and rapture would release\nTrampling the meek, the gospel they did speak\nForetelling demise, speaking only lies, lies, lies, lies, lies\n\nFeeding the senseless souls of mindless\nInhabitants not knowing they are the ones consuming the seeds of doubt\nFinding the source of stimulation, unnurtured realization\nOf fools who will always against their will just end their lives\n\nHow can humans play God when all they all are slaves?\nTheir lack of souls will lead them to an early grave\nCondemned to live a life of unrelenting praise\nTheir rotted corpse remains when death replaces life\n*/\n\n//#pragma comment(linker, \"/STACK:16777216\")\n#define _CRT_SECURE_NO_WARNINGS\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <complex>\n#include <math.h>\n#include <set>\n#include <vector>\n#include <map>  \n#include <queue>\n#include <stdio.h>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <ctime>\n#include <memory.h>\n#include <ctime> \n#include <assert.h>\n\n#define y0 sdkfaslhagaklsldk\n#define y1 aasdfasdfasdf\n#define yn askfhwqriuperikldjk\n#define j1 assdgsdgasghsf\n#define tm sdfjahlfasfh\n#define lr asgasgash\n\n#define eps 1e-8\n#define M_PI 3.141592653589793\n#define bs 1234567891\n#define bsize 512\n\nconst int SZ = 410000;\n\nusing namespace std;\n\nint n, m;\nint orig_x[SZ];\nvector<int> xs, ux;\nint p[SZ], b[SZ];\nint x[SZ];\nint t[SZ];\nint orig_p[SZ];\nint N;\nvector<pair<int, int> > events[SZ];\nint first_shot[SZ];\nmultiset<int> active;\nmultiset<pair<int, int> >alive;\nint id_by_x[SZ];\nint killed[SZ];\nlong long ohead[SZ];\n\nvoid compress()\n{\n\tsort(xs.begin(), xs.end());\n\tfor (int i = 0; i < xs.size(); i++)\n\t{\n\t\tif (i == 0 || xs[i] != xs[i - 1])\n\t\t\tux.push_back(xs[i]);\n\t}\n}\n\nint get_x(int x)\n{\n\tint id = upper_bound(ux.begin(), ux.end(), x) - ux.begin();\n\treturn id-1;\n}\n\nint get_first()\n{\n\tif (active.size() == 0)\n\t\treturn 1e9;\n\tmultiset<int>::iterator it = active.begin();\n\treturn *it;\n}\n\nint T[SZ*4];\nint topush[SZ*4];\n\nvoid build(int v, int tl, int tr)\n{\n\tif (tl == tr)\n\t{\n\t\tT[v] = first_shot[tl];\n\t\ttopush[v] = 1e9;\n\t\t//cout << tl << \"^\" << tr << \" \" << T[v] << endl;\n\t\treturn;\n\t}\n\tint tm = tl + tr;\n\ttm /= 2;\n\tbuild(v * 2, tl, tm);\n\tbuild(v * 2 + 1, tm + 1, tr);\n\tT[v] = 1e9;\n\ttopush[v] = 1e9;\n}\n\nvoid push(int v)\n{\n\tT[v * 2] = min(T[v * 2], topush[v]);\n\tT[v * 2 + 1] = min(T[v * 2 + 1], topush[v]);\n\ttopush[v * 2] = min(topush[v * 2], topush[v]);\n\ttopush[v * 2 + 1] = min(topush[v * 2 + 1], topush[v]);\n}\n\nint get(int v, int tl, int tr, int ps)\n{\n\tif (tl == tr)\n\t{\n\t\treturn T[v];\n\t}\n\tpush(v);\n\tint tm = tl + tr;\n\ttm /= 2;\n\tif (ps <= tm)\n\t\treturn get(v * 2, tl, tm, ps);\n\telse\n\t\treturn get(v * 2 + 1, tm + 1, tr, ps);\n}\n\nvoid update(int v, int tl, int tr, int l, int r, int val)\n{\n\tif (l > r)\n\t\treturn;\n\tif (tl == l&&tr == r)\n\t{\n\t\tT[v] = min(T[v], val);\n\t\ttopush[v] = min(topush[v], val);\n\t\treturn;\n\t}\n\tpush(v);\n\tint tm = tl + tr;\n\ttm /= 2;\n\tupdate(v * 2, tl, tm, l, min(r, tm), val);\n\tupdate(v * 2 + 1, tm + 1, tr, max(tm + 1, l), r, val);\n}\n\nvoid kill(int A, int B)\n{\n\t//cout << \"!\" << A << \" ^ \" << B << endl;\n\n\tohead[A] += b[B];\n\tkilled[A] += 1;\n\tlong long nb = orig_x[A] + ohead[A]+t[A];\n\tif (nb > 2e9)\n\t\tnb = 2e9;\n\tint rb = get_x(nb);\n\tupdate(1, 0, N - 1, x[A], rb, x[A]);\n}\n\nbool can_extend(int id)\n{\n\tif (alive.size() == 0)\n\t\treturn false;\n\tmultiset<pair<int, int> > ::iterator it;\n\tit = alive.lower_bound(make_pair(x[id], -1));// begin();\n\tif (it == alive.end())\n\t\treturn false;\n\tint ps = (*it).first;\n\tlong long reach = orig_x[id] + ohead[id] + t[id];\n\tif (reach > 2e9)\n\t\treach = 2e9;\n\treturn (ps <= get_x(reach));\n}\n\nvoid extend(int id)\n{\n\tmultiset<pair<int, int> > ::iterator it;\n\tit = alive.lower_bound(make_pair(x[id], -1));\n\tint ps = (*it).first;\n\tint id2 = (*it).second;\n\talive.erase(it);\n\tkill(id, id2);\n}\n\nint main(){\n\t//freopen(\"beavers.in\",\"r\",stdin);\n\t//freopen(\"beavers.out\",\"w\",stdout);\n\t//freopen(\"F:/in.txt\",\"r\",stdin);\n\t//freopen(\"F:/output.txt\",\"w\",stdout);\n\tios_base::sync_with_stdio(0);\n\t//cin.tie(0);\n\n\tcin >> n >> m;\n\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tcin >> x[i] >> t[i];\n\t\torig_x[i] = x[i];\n\t\txs.push_back(x[i]);\n\t}\n\n\tfor (int i = 1; i <= m; i++)\n\t{\n\t\tcin >> p[i] >> b[i];\n\t\torig_p[i] = p[i];\n\t\txs.push_back(p[i]);\n\t}\n\n\tcompress();\n\n\tfor (int i = 1; i <= n; i++)\n\t\tx[i] = get_x(x[i]);\n\tfor (int i = 1; i <= m; i++)\n\t\tp[i] = get_x(p[i]);\n\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tid_by_x[x[i]] = i;\n\t}\n\t\n\t/*\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tcout << x[i] << \"% \";\n\t}\n\tcout << endl;\n\tfor (int i = 1; i <= m; i++)\n\t{\n\t\tcout << p[i] << \"^ \";\n\t}\n\tcout << endl;\n\t*/\n\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tevents[x[i]].push_back(make_pair(-1, i));\n\t\tevents[get_x(orig_x[i] + t[i])+1].push_back(make_pair(1, i));\n\t\t//cout << x[i] << \"^\" << get_x(orig_x[i] + t[i]) + 1 << endl;\n\n\t}\n\n\tN = ux.size();\n\n\tfor (int i = 0; i < ux.size(); i++)\n\t{\n\t\tfor (int j = 0; j < events[i].size(); j++)\n\t\t{\n\t\t\tint tp = events[i][j].first;\n\t\t\tint id = events[i][j].second;\n\t\t\tif (tp == -1)// open\n\t\t\t{\n\t\t\t\tactive.insert(x[id]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tactive.erase(active.find(x[id]));\n\t\t\t}\n\t\t}\n\t\tfirst_shot[i] = get_first();\n\t}\n\t/*\n\tfor (int i = 0; i < N; i++)\n\t\tcout << ux[i] << \" \";\n\tcout << endl;\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tcout << first_shot[i] << \"^\";\n\t}\n\tcout << endl;\n\t*/\n\tbuild(1, 0, N-1);\n\n\tfor (int i = 1; i <= m; i++)\n\t{\n\t\t//cout << \"%\" << i << endl;\n\n\t\tint kicks = get(1, 0, N-1, p[i]);\n//\t\tcout << \"%!\" << kicks << \" \"<<p[i]<<endl;\n\t\tif (kicks > 1e7)\n\t\t{\n\t\t\talive.insert(make_pair(p[i],i));\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tkicks = id_by_x[kicks];\n\t\t//cout << \"^\" << kicks << \"&\"<<i<<endl;\n\n\t\tkill(kicks, i);\n\t\twhile (true)\n\t\t{\n\t\t//\tcout << \"@\" << kicks<<endl;\n\t\t\tif (can_extend(kicks))\n\t\t\t{\n\t\t\t\t//cout << \"!\" << endl;\n\t\t\t\textend(kicks);\n\t\t\t}\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tcout << killed[i] << \" \" << ohead[i] + t[i] << \"\\n\";\n\t}\n\n\tcin.get();cin.get();\n\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}