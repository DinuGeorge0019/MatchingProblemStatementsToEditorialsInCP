{"link": "https://codeforces.com//contest/1073/problem/E", "problemId": "243300", "shortId": "1073E", "contest_number": "1073", "name": "E. Segment Sum", "statement": "You are given two integers  and  (). Your task is to calculate the sum of numbers from  to  (including  and ) such that each number contains   different digits, and print this sum modulo .For example, if  then you have to calculate all numbers from  to  such that each number is formed using only one digit. For  the answer is .", "input": "The only line of the input contains three integers ,  and  () \u2014 the borders of the segment and the maximum number of different digits.", "output": "Print one integer \u2014 the sum of numbers from  to  such that each number contains at most  different digits, modulo .", "tutorial": "Let's calculate the answer as the sum of suitable numbers in range  minus the sum of suitable numbers in range . Now our problem is to calculate the sum of suitable numbers in range .The main approach for  problem is digit DP. Let's calculate two dynamic programmings  and .  means that now we are at the -th digit of the number  (at the digit corresponding to , where  is the decimal length of a number),  is a binary mask describing digits we already use and  equals  if the current prefix of number we trying to obtain is the same as the prefix of number  (otherwise  equals ).So what means ? It means the count of numbers (in general, not numbers but their prefixes) in range  of length   without leading zeroes corresponding to this state. So what the point of this DP? Its point is helping us to calculate the main DP, , which means the sum of numbers (in general, not numbers but their prefixes) in range  of length   without leading zeroes corresponding to this state.How do we calculate the answer? Firstly, let  be the length of . Let  be the function calculating the sum of numbers from  to  containing at most  different digits. How to calculate it? Let  be the sum of numbers from  to  containing at most  different digits and having length exactly . Then  seems to be pretty easy: for each length  from  to  add to the answer . And the last step is to add to the answer .How to calculate dynamic programmings? Initially, all states are zeroes (excluding , which is ).Firstly, let's calculate . After calculating it we can calculate  in almost the same way. Let's iterate over all possible lengths and over all possible masks. Let the current state is . Then let's iterate over next digit we will place in this number and place it. If  then  otherwise . The transition is pretty easy: . There  is the bitwise  operation. For  transitions are almost the same expect the restrictions on digit we place and the state we update. If we now at the position  with mask  and  then the current digit of  is . Then let's iterate over next digit:  if  otherwise . The transition is also easy: .After calculating the previous DP we can calculate . All the process is the same as in the previous dynamic programming expect the value we will add in transitions. In the previous DP this value was equal , in the current DP this value equals to . Don't forget to calculate it modulo !So after calculating all the values of DPs, what is the answer for ? It is  for all masks with at most  bits.I'm pretty sure that there is another way to avoid leading zeroes in calculating these DPs but this one is very straight-forward and simple.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n\ntypedef pair<long long, int> pt;\n\nconst int N = 20;\nconst int M = 1 << 10;\nconst int MOD = 998244353;\n\nint k;\nint pw10[N];\nint bitCnt[M];\n\npt dp[N][M][2];\n\nint add(int a, int b) {\n\ta += b;\n\tif (a >= MOD) a -= MOD;\n\tif (a < 0) a += MOD;\n\treturn a;\n}\n\nint mul(int a, int b) {\n\treturn a * 1ll * b % MOD;\n}\n\nint calc(const string &s) {\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tdp[i][j][0] = dp[i][j][1] = { 0ll, 0 };\n\t\t}\n\t}\n\t\n\tint len = s.size();\n\tdp[0][0][1] = { 1ll, 0 };\n\tfor (int i = 0; i < len; ++i) {\n\t\tint cdig = s[i] - '0';\n\t\tfor (int mask = 0; mask < M; ++mask) {\n\t\t\tif (dp[i][mask][0].x == 0 && dp[i][mask][1].x == 0) continue;\n\t\t\tfor (int dig = (i == 0); dig <= 9; ++dig) {\n\t\t\t\tint nmask = mask | (1 << dig);\n\t\t\t\tlong long cnt = dp[i][mask][0].x;\n\t\t\t\tint sum = add(dp[i][mask][0].y, mul(dig, mul(pw10[len - i - 1], cnt % MOD)));\n\t\t\t\tdp[i + 1][nmask][0].x += cnt;\n\t\t\t\tdp[i + 1][nmask][0].y = add(dp[i + 1][nmask][0].y, sum);\n\t\t\t}\n\t\t\t\n\t\t\tfor (int dig = (i == 0); dig <= cdig; ++dig) {\n\t\t\t\tint nmask = mask | (1 << dig);\n\t\t\t\tlong long cnt = dp[i][mask][1].x;\n\t\t\t\tint sum = add(dp[i][mask][1].y, mul(dig, mul(pw10[len - i - 1], cnt % MOD)));\n\t\t\t\tdp[i + 1][nmask][dig == cdig].x += cnt;\n\t\t\t\tdp[i + 1][nmask][dig == cdig].y = add(dp[i + 1][nmask][dig == cdig].y, sum);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\tfor (int mask = 0; mask < M; ++mask) {\n\t\tif (bitCnt[mask] > k) continue;\n\t\tans = add(ans, dp[len][mask][0].y);\n\t\tans = add(ans, dp[len][mask][1].y);\n\t}\n\treturn ans;\n}\n\nint calc(long long n) {\n\tint len = to_string(n).size();\n\tint ans = 0;\n\tfor (int l = 1; l < len; ++l) {\n\t\tans = add(ans, calc(string(l, '9')));\n\t}\n\tans = add(ans, calc(to_string(n)));\n\treturn ans;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tpw10[0] = 1;\n\tfor (int i = 1; i < N; ++i) {\n\t\tpw10[i] = mul(pw10[i - 1], 10);\n\t}\n\tfor (int i = 0; i < M; ++i) {\n\t\tbitCnt[i] = __builtin_popcount(i);\n\t}\n\t\n\tlong long l, r;\n\tcin >> l >> r >> k;\n\tint ans = add(calc(r), -calc(l - 1));\n\tcout << ans << endl;\n\t\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}