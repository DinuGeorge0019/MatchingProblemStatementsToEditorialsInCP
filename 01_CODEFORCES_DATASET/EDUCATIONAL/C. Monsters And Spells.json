{"link": "https://codeforces.com//contest/1626/problem/C", "problemId": "1263149", "shortId": "1626C", "contest_number": "1626", "name": "C. Monsters And Spells", "statement": "Monocarp is playing a computer game once again. He is a wizard apprentice, who only knows a single spell. Luckily, this spell can damage the monsters.The level he's currently on contains  monsters. The -th of them appears  seconds after the start of the level and has  health points. As an additional constraint,  for all . All  are different.Monocarp can cast the spell at moments which are positive integer amounts of second after the start of the level:  The damage of the spell is calculated as follows. If he didn't cast the spell at the previous second, the damage is . Otherwise, let the damage at the previous second be . Then he can choose the damage to be either  or . A spell uses mana: casting a spell with damage  uses  mana. Mana doesn't regenerate.To kill the -th monster, Monocarp has to cast a spell with damage at least  at the exact moment the monster appears, which is .Note that Monocarp can cast the spell even when there is no monster at the current second.The mana amount required to cast the spells is the sum of mana usages for all cast spells. Calculate the least amount of mana required for Monocarp to kill all monsters.It can be shown that it's always possible to kill all monsters under the constraints of the problem.", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of testcases. The first line of the testcase contains a single integer  ()\u00a0\u2014 the number of monsters in the level. The second line of the testcase contains  integers  ()\u00a0\u2014 the number of second from the start the -th monster appears at. All  are different,  are provided in the increasing order. The third line of the testcase contains  integers  ()\u00a0\u2014 the health of the -th monster. The sum of  over all testcases doesn't exceed .", "output": "For each testcase, print a single integer\u00a0\u2014 the least amount of mana required for Monocarp to kill all monsters.", "tutorial": "Consider the problem with . There is a single monster with some health  that appears at some second . In order to kill it, we have to wind up our spell until it has damage . So we have to use it from second  to second . Look at it as a segment  on a timeline.Actually, to avoid handling zero length segments, let's instead say that a segment covers the time from  non-inclusive to  inclusive, producing a half-interval . This way, the total mana cost will be , where  is the length of the half-interval.Now . There are two time segments.If they don't intersect (segments  and  don't intersect, since they are half-intervals), then it's always better to wind up the spell for the monsters separately instead of saving the damage.However, if they intersect, then we don't have the choice other than to save the damage from the earlier one to the later one. Otherwise, there won't be enough time to wind up the spell.What that means in a mathematic sense? The answer is the union of two half-intervals. If they don't intersect, they are left as is. Otherwise, they become one half-interval that covers them both.Now add the third monster into the construction. The same argument applies. While there exists a pair of intersecting half-intervals, keep uniting them.The union of all half-intervals can be found in , but the constraints allowed slower approaches as well.", "solution": "for _ in range(int(input())):\n  n = int(input())\n  k = list(map(int, input().split()))\n  h = list(map(int, input().split()))\n  st = []\n  for i in range(n):\n    st.append([k[i] - h[i], k[i]])\n  st.sort()\n  l, r = -1, -1\n  ans = 0\n  for it in st:\n    if it[0] >= r:\n      ans += (r - l) * (r - l + 1) // 2\n      l, r = it\n    else:\n      r = max(r, it[1])\n  ans += (r - l) * (r - l + 1) // 2\n  print(ans)", "interactive": false, "noSolution": false, "noTutorial": false}