{"link": "https://codeforces.com//contest/1716/problem/D", "problemId": "1494203", "shortId": "1716D", "contest_number": "1716", "name": "D. Chip Move", "statement": "There is a chip on the coordinate line. Initially, the chip is located at the point . You can perform any number of moves; each move increases the coordinate of the chip by some positive integer (which is called ). The length of the first move you make should be divisible by , the length of the second move\u00a0\u2014 by , the third\u00a0\u2014 by , and so on.For example, if , then the sequence of moves may look like this: , because  is divisible by ,  is divisible by ,  is divisible by ,  is divisible by .You are given two positive integers  and . Your task is to count the number of ways to reach the point , starting from , for every . The number of ways can be very large, so print it modulo . Two ways are considered different if they differ as sets of visited positions.", "input": "The first (and only) line of the input contains two integers  and  ().", "output": "Print  integers\u00a0\u2014 the number of ways to reach the point , starting from , for every , taken modulo .", "tutorial": "Let's calculate dynamic programming \u00a0\u2014 the number of ways to achieve  in  moves. From the state , you can make a transition to the states , where  and  is divisible by .Let's try to estimate the maximum number of moves, because it seems that there can't be very many of them. For  moves, the minimum distance by which a chip can be moved is  or . From here one can see that the maximum number of transitions does not exceed  (maximum at ). So it remains to make transitions in dynamic programming faster than  from a single state for a fast enough solution. Let's use the fact that . Let's iterate over the value of  and maintain the sum of dynamic programming values with smaller indices for each remainder modulo  in a separate array.The final complexity of such a solution is .It remains to solve the memory problem, because with the existing limits, it is impossible to save the entire  matrix of size . However, this is easy to solve if you notice that only the previous layer is used for transitions in dp, i.e. it is enough to store  to calculate .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MOD = 998244353;\n\nint main() {\n  int n, k;\n  cin >> n >> k;\n  vector<int> dp(n + 1), ans(n + 1);\n  dp[0] = 1;\n  for (int mn = 0; mn + k <= n; mn += k++) {\n    vector<int> sum(k);\n    for (int i = mn; i <= n; ++i) {\n      int cur = dp[i];\n      dp[i] = sum[i % k];\n      (sum[i % k] += cur) %= MOD;\n      (ans[i] += dp[i]) %= MOD;\n    }\n  }\n  for (int i = 1; i <= n; ++i) cout << ans[i] << ' ';\n}", "interactive": false, "noSolution": false, "noTutorial": false}