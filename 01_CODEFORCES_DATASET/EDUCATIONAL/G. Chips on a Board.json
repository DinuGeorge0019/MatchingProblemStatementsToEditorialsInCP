{"link": "https://codeforces.com//contest/1511/problem/G", "problemId": "955218", "shortId": "1511G", "contest_number": "1511", "name": "G. Chips on a Board", "statement": "Alice and Bob have a rectangular board consisting of  rows and  columns. Alice and Bob play the following game. They choose two integers  and  such that  and cut the board in such a way that only the part of it between column  and column  (inclusive) remains. So, all columns to the left of column  and all columns to the right of column  no longer belong to the board.After cutting the board, they move chips on the remaining part of the board (the part from column  to column ). They make alternating moves, and the player which cannot make a move loses the game. The first move is made by Alice, the second \u2014 by Bob, the third \u2014 by Alice, and so on. During their move, the player must choose one of the chips from the board and move it any positive number of cells to the left (so, if the chip was in column , it can move to any column , and the chips in the leftmost column cannot be chosen).Alice and Bob have  pairs of numbers  and . For each such pair, they want to determine who will be the winner of the game if  and . Note that these games should be considered independently (they don't affect the state of the board for the next games), and both Alice and Bob play optimally.", "input": "The first line contains two integers  and  () \u2014 the number of rows and columns on the board, respectively. The second line contains  integers  (), where  is the index of the column where the chip in the -th row is located (so, the chip in the -th row is in the -th column). The third line contains one integer  (). Then  lines follow, the -th of them contains two integers  and  ().", "output": "Print a string of  characters. The -th character should be  if Alice wins the game with  and , or  if Bob wins it.", "tutorial": "The model solution is , where , but it seems that there are faster ones. I'll explain the model solution nevertheless.It's easy to see (using simple Nim theory) that the answer for a query  is  iff the xor of  for all chips such that  is equal to . Let's calculate this xor for every query. This number contains at most  bits, and we will process these bits differently: we will choose some number  and use one solution to calculate  lowest bits, and another solution to compute  highest bits. One idea is common in both solutions: we split each query into two queries \u2014 a query  can be represented as a combination of two queries  and , where  is the xor of all numbers  such that . After converting the queries, for every , store each query of the form  in some sort of vector (or any other data structure). We will use an approach similar to sweep line: iterate on  and solve the queries for the current . These ideas will be used both for the solution calculating  lowest bits and for the solution calculating  highest bits.How to find  lowest bits in each query? Iterate on  from  to  and maintain the number of occurrences of each number  we met so far. Then, at a moment we want to calculate , simply iterate on all of the values of  and process each value in  (if the number of occurrences of some value  is odd, update the current answer to the query by xoring the number with , otherwise just skip it). And since we are interested only in  lowest bits, for each , we need only the remainder , so the number of different values is . Thus, this part of the solution runs in .Okay, what about  highest bits in each query? We can see that, for every number , the highest bits of  don't change too often when we iterate on : there will be about  segments where the highest bits of  have different values. We can build a data structure that allows use to process two queries: xor all numbers on a segment with some value and get the value in some position (Fenwick trees and segment trees can do it). Then, we again iterate on  from  to . When we want to process a number , we find the segments where the highest bits of  have the same value and perform updates on these segments in our data structure. When we process a query of the form , we simply get the value in the position  from our data structure. This part of the solution works in .By choosing  optimally, we can combine these two parts into a solution with complexity of .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 200043;\nconst int K = 10;\nconst int Z = 1 << K;\n\nint rem[Z];\nint t[N];\n\nint get(int r)\n{\n    int result = 0;\n    for (; r >= 0; r = (r & (r + 1)) - 1)\n        result ^= t[r];\n    return result;\n}\n\nvoid change(int i, int delta)\n{\n    for (; i < N; i = (i | (i + 1)))\n        t[i] ^= delta;\n}\n\nint get(int l, int r)\n{\n    return get(r) - get(l - 1);\n}\n\nint ans[N];\nint c[N];\nint cnt[N];\nint n, m;\nint ls[N];\nint rs[N];\nvector<int> qs[N];\nvector<int> qs2[N];\n\nint main()\n{\n    scanf(\"%d %d\", &n, &m);\n    for(int i = 0; i < n; i++)\n    {\n        scanf(\"%d\", &c[i]);\n        cnt[c[i]]++;\n    }\n    int q;\n    scanf(\"%d\", &q);\n    for(int i = 0; i < q; i++)\n    {\n        int l, r;\n        scanf(\"%d %d\", &l, &r);\n        ls[i] = l;                                                                         \n        rs[i] = r;\n        qs[l].push_back(i);\n        qs2[r + 1].push_back(i);\n    }\n    for(int i = m; i >= 1; i--)\n    {\n        for(int j = 0; j < cnt[i]; j++)\n        {\n            rem[i % (1 << K)]++;\n            int r = i;\n            while(true)\n            {\n                int l = r - Z + 1;\n                l = max(1, l);\n                if(l > r)\n                    break;\n                int diff = i - l;\n                diff >>= K;\n                change(l, diff);\n                change(r + 1, diff);\n                r -= Z;\n            }\n        }\n        for(auto x : qs[i])\n        {\n            int cur = (get(i)) << K;\n            for(int k = 0; k < Z; k++)\n            {\n                int dist = (k - i) % Z;\n                if(dist < 0)\n                    dist += Z;\n                if(rem[k] & 1)\n                    cur ^= dist;\n            }\n            ans[x] ^= cur;\n        }\n        for(auto x : qs2[i])\n        {\n            int cur = (get(ls[x])) << K;\n            for(int k = 0; k < Z; k++)\n            {\n                int dist = (k - ls[x]) % Z;\n                if(dist < 0)\n                    dist += Z;\n                if(rem[k] & 1)\n                    cur ^= dist;\n            }\n            ans[x] ^= cur;\n        }\n    }\n    for(int i = 0; i < q; i++)\n        if(ans[i] == 0)\n            printf(\"B\");\n        else\n            printf(\"A\");\n}", "interactive": false, "noSolution": false, "noTutorial": false}