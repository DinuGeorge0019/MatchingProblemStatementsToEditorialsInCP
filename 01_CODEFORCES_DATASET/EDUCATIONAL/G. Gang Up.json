{"link": "https://codeforces.com//contest/1187/problem/G", "problemId": "365123", "shortId": "1187G", "contest_number": "1187", "name": "G. Gang Up", "statement": "The leader of some very secretive organization has decided to invite all other members to a meeting. All members of the organization live in the same town which can be represented as  crossroads connected by  two-directional streets. The meeting will be held in the leader's house near the crossroad . There are  members of the organization invited to the meeting; -th of them lives near the crossroad . All members of the organization receive the message about the meeting at the same moment and start moving to the location where the meeting is held. In the beginning of each minute each person is located at some crossroad. He or she can either wait a minute at this crossroad, or spend a minute to walk from the current crossroad along some street to another crossroad (obviously, it is possible to start walking along the street only if it begins or ends at the current crossroad). In the beginning of the first minute each person is at the crossroad where he or she lives. As soon as a person reaches the crossroad number , he or she immediately comes to the leader's house and attends the meeting.Obviously, the leader wants all other members of the organization to come up as early as possible. But, since the organization is very secretive, the leader does not want to attract much attention. Let's denote the  of the leader as follows  initially the discontent is ;  whenever a person reaches the crossroad number , the discontent of the leader increases by , where  is some fixed constant, and  is the number of minutes it took the person to reach the crossroad number ;  whenever  members of the organization walk ,  is added to the discontent, where  is some fixed constant. This is not cumulative: for example, if two persons are walking along the same street in the same direction at the same moment, then  is added to the discontent, not . Before sending a message about the meeting, the leader can tell each member of the organization which path they should choose and where they should wait. Help the leader to establish a plan for every member of the organization so they all reach the crossroad , and the discontent is minimized.", "input": "The first line of the input contains five integer numbers , , ,  and  (, , ) \u2014 the number of crossroads, the number of streets, the number of persons invited to the meeting and the constants affecting the discontent, respectively. The second line contains  numbers , , ...,  () \u2014 the crossroads where the members of the organization live. Then  lines follow, each denoting a bidirectional street. Each line contains two integers  and  (, ) denoting a street connecting crossroads  and . . It is guaranteed that every crossroad can be reached from every other crossroad using the given streets. ", "output": "Print one integer: the minimum discontent of the leader after everyone reaches crossroad .", "tutorial": "First of all, one crucial observation is that no person should come to the meeting later than  minutes after receiving the message: the length of any simple path in the graph won't exceed , and even if all organization members should choose the same path, we can easily make them walk alone if the first person starts as soon as he receives the message, the second person waits one minute, the third person waits two minutes, and so on.Let's model the problem using mincost flows. First of all, we need to expand our graph: let's create  \"time layer\" of the graph, where -th layer represents the state of the graph after  minutes have passed. The members of the organization represent the flow in this graph. We should add a directed edge from the source to every crossroad where some person lives, with capacity equal to the number of persons living near that crossroad (of course, this edge should lead into -th time layer, since everyone starts moving immediately). To model that some person can wait without moving, we can connect consecutive time layers: for every vertex representing some crossroad  in time layer , let's add a directed edge with infinite capacity to the vertex representing the same crossroad in the layer . To model that people can walk along the street, for every street  and every layer  let's add several edges going from crossroad  in the layer  to crossroad  in the layer  (the costs and the capacities of these edges will be discussed later). And to model that people can attend the meeting, for each layer  let's add a directed edge from the vertex representing crossroad  in that layer to the sink (the capacity should be infinite, the cost should be equal to ).Okay, if we find a way to model the increase of discontent from the companies of people going along the same street at the same moment, then the minimum cost of the maximum flow in this network is the answer: maximization of the flow ensures that all people attend the meeting, and minimization of the cost ensures that the discontent is minimized. To model the increase of discontent from the companies of people, let's convert each edge  of the original graph into a large set of edges: for each layer , let's add  edges with capacity  from the crossroad  in the layer  to the crossroad  in the layer . The first edge should have the cost equal to , the second edge \u2014 equal to , the third \u2014  and so on, so if we choose  minimum cost edges between this pair of nodes, their total cost will be equal to . Don't forget that each edge in the original graph is undirected, so we should do the same for the node representing  in layer  and the node representing  in layer .Okay, now we have a network with  vertices and  edges, and we have to find the minimum cost flow in it (and the total flow does not exceed ). Strangely enough, we could not construct a test where the basic implementation of Ford-Bellman algorithm with a queue runs for a long time (but perhaps it's possible to fail it). But if you are not sure about its complexity, you can improve it with the following two optimizations:  use Dijkstra with potentials instead of Ford-Bellman with queue;  compress all edges that connect the same nodes of the network into one edge with varying cost. ", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct edge\n{\n\tint y, c, f, cost;\n\tedge() {};\n\tedge(int y, int c, int f, int cost) : y(y), c(c), f(f), cost(cost) {};\n};\n\nvector<edge> e;\n\nconst int N = 14043;\nvector<int> g[N];\n\nlong long ans = 0;\nlong long d[N];\nint p[N];\nint pe[N];\nint inq[N];\n\nconst long long INF64 = (long long)(1e18);\n\nint s = N - 2;\nint t = N - 1;\n\nint rem(int x)\n{\n\treturn e[x].c - e[x].f;\n}\n\nvoid push_flow()\n{\n\tfor(int i = 0; i < N; i++) d[i] = INF64, p[i] = -1, pe[i] = -1, inq[i] = 0;\n\td[s] = 0;\n\tqueue<int> q;\n\tq.push(s);\n\tinq[s] = 1;\n\twhile(!q.empty())\n\t{\n\t\tint k = q.front();\n\t\tq.pop();\n\t\tinq[k] = 0;\n\t\tfor(auto x : g[k])\n\t\t{\n\t\t\tif(!rem(x)) continue;\n\t\t\tint c = e[x].cost;\n\t\t\tint y = e[x].y;\n\t\t\tif(d[y] > d[k] + c)\n\t\t\t{\n\t\t\t\td[y] = d[k] + c;\n\t\t\t\tp[y] = k;\n\t\t\t\tpe[y] = x;\n\t\t\t\tif(inq[y] == 0)\n\t\t\t\t{\n\t\t\t\t\tinq[y] = 1;\n\t\t\t\t\tq.push(y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint cur = t;\n//\tvector<int> zz(1, cur);\n\twhile(cur != s)\n\t{\n\t\te[pe[cur]].f++;\n\t\te[pe[cur] ^ 1].f--;\n\t\tcur = p[cur];\n//\t\tzz.push_back(cur);\n\t}\n//\treverse(zz.begin(), zz.end());\n//\tfor(auto x : zz) cerr << x << \" \";\n//\tcerr << endl;\n\tans += d[t];\n}\n\nvoid add_edge(int x, int y, int c, int cost)\n{\n\tg[x].push_back(e.size());\n\te.push_back(edge(y, c, 0, cost));\n\tg[y].push_back(e.size());\n\te.push_back(edge(x, 0, 0, -cost));\n}\n\nint main()\n{\n\tint n, m, k, c, d;\n\tcin >> n >> m >> k >> c >> d;\n\tfor(int i = 0; i < k; i++)\n\t{\n\t\tint x;\n\t\tcin >> x;\n\t\t--x;\n\t\tadd_edge(s, x, 1, 0);\n\t}\n\tint tt = 101;\n\tfor(int i = 0; i < tt; i++)\n\t\tadd_edge(0 + i * n, t, k, i * c);\n\tfor(int i = 0; i < m; i++)\n\t{\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t--x;\n\t\t--y;\n\t\tfor(int i = 0; i < tt - 1; i++)\n\t\t\tfor(int j = 0; j < k; j++)\n\t\t\t\tadd_edge(x + i * n, y + i * n + n, 1, d * (j * 2 + 1));\n\t\tfor(int i = 0; i < tt - 1; i++)\n\t\t\tfor(int j = 0; j < k; j++)\n\t\t\t\tadd_edge(y + i * n, x + i * n + n, 1, d * (j * 2 + 1));\n \t}\n \tfor(int i = 0; i < n; i++)\n \t\tfor(int j = 0; j < tt - 1; j++)\n \t\t\tadd_edge(i + j * n, i + j * n + n, k, 0);\n \tfor(int i = 0; i < k; i++)\n \t\tpush_flow();\n \tcout << ans << endl;\n}", "interactive": false, "noSolution": false, "noTutorial": false}