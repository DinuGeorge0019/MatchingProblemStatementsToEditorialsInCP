{"link": "https://codeforces.com//contest/691/problem/E", "problemId": "65090", "shortId": "691E", "contest_number": "691", "name": "E. Xor-sequences", "statement": "You are given  integers .A sequence of integers  is called a \"\" if for every  the number of ones in the binary representation of the number   's is a multiple of  and  for all . The symbol  is used for the binary exclusive or operation.How many \"\" of length  exist? Output the answer modulo .", "input": "The first line contains two integers  and  (, ) \u2014 the number of given integers and the length of the \"\". The second line contains  integers  ().", "output": "Print the only integer  \u2014 the number of \"\" of length  modulo .", "tutorial": "Let  be the number of xor-sequences of length  with the last element equal to . Let  be equal to one if  contains the number of ones in binary presentation that is multiple of three. Otherwise let  be equal to zero. Consider a vectors ,  and a matrix . Easy to see that . So . Let's use the associative property of matrix multiplication: at first let's calculate  with binary matrix exponentiation and then multiply it to the vector .\n", "solution": "const int N = 101;\n\nint n;\nli k;\nli a[N];\n\nbool read() {\n\tif (!(cin >> n >> k)) return false;\n\tforn(i, n) assert(cin >> a[i]);\n\treturn true;\n}\n\nconst int mod = 1000 * 1000 * 1000 + 7;\n\ninline int add(int a, int b) { return a + b >= mod ? a + b - mod : a + b; }\ninline void inc(int& a, int b) { a = add(a, b); }\ninline int mul(int a, int b) { return int(a * 1ll * b % mod); }\n\nint count(li x) {\n\tint ans = 0;\n\twhile (x) {\n\t\tans++;\n\t\tx &= x - 1;\n\t}\n\treturn ans;\n}\n\nvoid mul(int a[N][N], int b[N][N], int n) {\n\tstatic int c[N][N];\n\tforn(i, n)\n\t\tforn(j, n) {\n\t\t\tc[i][j] = 0;\n\t\t\tforn(k, n) inc(c[i][j], mul(a[i][k], b[k][j]));\n\t\t}\n\tforn(i, n) forn(j, n) a[i][j] = c[i][j];\n}\n\nvoid bin_pow(int a[N][N], li b, int n) {\n\tstatic int ans[N][N];\n\tforn(i, n) forn(j, n) ans[i][j] = i == j;\n\n\twhile (b) {\n\t\tif (b & 1) mul(ans, a, n);\n\t\tmul(a, a, n);\n\t\tb >>= 1;\n\t}\n\n\tforn(i, n) forn(j, n) a[i][j] = ans[i][j];\n}\n\nvoid solve() {\n\tstatic int a[N][N];\n\tmemset(a, 0, sizeof(a));\n\tforn(i, n) {\n\t\tforn(j, n)\n\t\t\ta[i][j] = count(::a[i] ^ ::a[j]) % 3 == 0;\n\t\ta[i][n] = 1;\n\t}\n\n\t//forn(i, n + 1) clog << mp(a[i], n + 1) << endl;\n\n\tbin_pow(a, k, n + 1);\n\n\tint ans = 0;\n\tforn(i, n + 1) inc(ans, a[i][n]);\n\tcout << ans << endl;\n}", "interactive": false, "noSolution": false, "noTutorial": false}