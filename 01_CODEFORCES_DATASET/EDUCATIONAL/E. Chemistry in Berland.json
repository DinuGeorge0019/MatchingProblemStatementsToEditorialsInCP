{"link": "https://codeforces.com//contest/846/problem/E", "problemId": "121001", "shortId": "846E", "contest_number": "846", "name": "E. Chemistry in Berland", "statement": "Igor is a post-graduate student of chemistry faculty in Berland State University (BerSU). He needs to conduct a complicated experiment to write his thesis, but laboratory of BerSU doesn't contain all the materials required for this experiment.Fortunately, chemical laws allow material transformations (yes, chemistry in Berland differs from ours). But the rules of transformation are a bit strange.Berland chemists are aware of  materials, numbered in the order they were discovered. Each material can be transformed into some other material (or vice versa). Formally, for each   there exist two numbers  and  that denote a possible transformation:  kilograms of material  can be transformed into  kilogram of material , and  kilogram of material  can be transformed into  kilogram of material . Chemical processing equipment in BerSU allows only such transformation that the amount of resulting material is .For each  () Igor knows that the experiment requires  kilograms of material , and the laboratory contains  kilograms of this material. Is it possible to conduct an experiment after transforming some materials (or none)?", "input": "The first line contains one integer number  () \u2014 the number of materials discovered by Berland chemists. The second line contains  integer numbers  () \u2014 supplies of BerSU laboratory. The third line contains  integer numbers  () \u2014 the amounts required for the experiment. Then  lines follow. -th of them contains two numbers  and  that denote transformation of -th material ().", "output": "Print  if it is possible to conduct an experiment. Otherwise print .", "tutorial": "Since , then the transformation graph is a tree. Let's solve the problem recursively.Suppose that material  is a leaf in the tree (there is no  such that ). Then if we don't have enough material , we have to transform some of material  into . Let's transform the amount required to set current amount of material  to ; if we don't have the required amount of material , then this amount will temporarily be negative. And if we have more material  than we need to conduct the experiment, then we will transform it to . The same algorithm can be applied to any non-root node, but we first need to do this for all its children. This algorithm is optimal because each time we take the minimum possible amount from the parent.After this the root will be the only node such that  is not necessarily equal to current amount of material . Since we solved the problem for all other materials and did it optimally, now the answer is YES iff current amount of material  is not less than .This must be implemented carefully. Since the total amount of materials never increases, then if some material's current amount is less than, for example, , then the answer is already NO. Also overflows in multiplication must be avoided; to do this, we can firstly check if the result of multiplication is not too big by multiplying values as real numbers.", "solution": "#include <bits/stdc++.h>\nusing namespace std;\n#define N 101010\ntypedef long long LL;\nLL n , d[ N ] , p[ N ];\nvector< pair<LL,LL> > v[ N ];\nconst LL inf = 100000000000000000LL;\nvoid DP( int now ){\n  for( auto e : v[ now ] ){\n    LL son = e.first;\n    LL ki = e.second;\n    DP( son );\n    if( d[ son ] >= 0 )\n      d[ now ] += d[ son ];\n    else{\n      LL nd = -d[ son ];\n      if( nd >= inf / ki ){\n        puts( \"NO\" );\n        exit(0);\n      }\n      d[ now ] -= nd * ki;\n      if( d[ now ] < -inf ){\n        puts( \"NO\" );\n        exit(0);\n      }\n    }\n  }\n}\nint main(){\n  scanf( \"%lld\" , &n );\n  for( LL i = 1 , x ; i <= n ; i ++ ){\n    scanf( \"%lld\" , &x );\n    d[ i ] += x;\n  }\n  for( LL i = 1 , x ; i <= n ; i ++ ){\n    scanf( \"%lld\" , &x );\n    d[ i ] -= x;\n  }\n  for( LL i = 2 , x ; i <= n ; i ++ ){\n    scanf( \"%lld%lld\" , &p[ i ] , &x );\n    v[ p[ i ] ].push_back( { i , x } );\n  }\n  DP( 1 );\n  puts( d[ 1 ] >= 0 ? \"YES\" : \"NO\" );\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}