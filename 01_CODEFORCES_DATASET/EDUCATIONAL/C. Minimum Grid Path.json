{"link": "https://codeforces.com//contest/1499/problem/C", "problemId": "928251", "shortId": "1499C", "contest_number": "1499", "name": "C. Minimum Grid Path", "statement": "Let's say you are standing on the -plane at point  and you want to reach point .You can move only in two directions:   to the , i.\u00a0e. horizontally and in the direction that increase your  coordinate,  or , i.\u00a0e. vertically and in the direction that increase your  coordinate. In other words, your path will have the following structure:   initially, you choose to go to the right or up;  then you go some  distance in the chosen direction (distances can be chosen independently);  after that you change your direction (from right to up, or from up to right) and repeat the process. You don't like to change your direction too much, so you will make no more than  direction changes.As a result, your path will be a polygonal chain from  to , consisting of   line segments where each segment has positive integer length and vertical and horizontal segments alternate.Not all paths are equal. You have  integers  where  is the cost of the -th segment.Using these costs we can define the  as the sum of lengths of the segments of this path multiplied by their cost, i.\u00a0e. if the path consists of  segments (), then the cost of the path is equal to  (segments are numbered from  to  in the order they are in the path).Find the path of the minimum cost and print its cost.", "input": "The first line contains the single integer  ()\u00a0\u2014 the number of test cases. The first line of each test case contains the single integer  (). The second line of each test case contains  integers  ()\u00a0\u2014 the costs of each segment. It's guaranteed that the total sum of  doesn't exceed .", "output": "For each test case, print the minimum possible cost of the path from  to  consisting of at most  alternating segments.", "tutorial": "Suppose we decided to make exactly  turns or, in other words, our path will consist of exactly  segments. Since we should finish at point  and vertical and horizontal segments alternates, then it means that  and .From the other side we should minimize . But it means that we can minimize  and  independently.How to minimize  if we know that  and ? It's easy to prove that it's optimal to assign all  except minimum  and assign to this minimum  the remaining part .In other words, to calculate the optimal path consisting of  segments, we need to know the sum of  on odd and even positions among  and also minimum  among odd and even positions. Then we can drive out the answer as a quite easy formula   .Finally, we should iterate over all  from  to  and find the minimum answer among all variants. It's easy to recalculate sums and minimums when we make transition form  to .Complexity is .", "solution": "fun main() {\n    repeat(readLine()!!.toInt()) {\n        val n = readLine()!!.toInt()\n        val c = readLine()!!.split(' ').map { it.toInt() }\n\n        val mn = intArrayOf(1e9.toInt(), 1e9.toInt())\n        val rem = longArrayOf(n.toLong(), n.toLong())\n        var sum = 0L\n        var ans = 1e18.toLong()\n        for (i in c.indices) {\n            mn[i % 2] = minOf(mn[i % 2], c[i])\n            rem[i % 2]--\n            sum += c[i]\n            if (i > 0) {\n                val cur = sum + rem[0] * mn[0] + rem[1] * mn[1]\n                ans = minOf(ans, cur)\n            }\n        }\n        println(ans)\n    }\n}", "interactive": false, "noSolution": false, "noTutorial": false}