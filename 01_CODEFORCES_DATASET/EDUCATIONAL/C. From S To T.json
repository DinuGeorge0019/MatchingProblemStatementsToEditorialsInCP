{"link": "https://codeforces.com//contest/1194/problem/C", "problemId": "372217", "shortId": "1194C", "contest_number": "1194", "name": "C. From S To T", "statement": "You are given three strings ,  and  consisting of lowercase Latin letters. You may perform any number (possibly, zero) operations on these strings.During each operation you choose any character from , erase it from  and insert it into string  (you may insert this character anywhere you want: in the beginning of , in the end or between any two consecutive characters). For example, if  is , and  is , then the following outcomes are possible (the character we erase from  and insert into  is highlighted):    ,   ;    ,   ;    ,   ;    ,   ;    ,   ;    ,   ;    ,   ;    ,   ;    ,   ; Your goal is to perform several (maybe zero) operations so that  becomes equal to . Please determine whether it is possible.Note that you have to answer  independent queries.", "input": "The first line contains one integer  () \u2014 the number of queries. Each query is represented by three consecutive lines. The first line of each query contains the string  () consisting of lowercase Latin letters. The second line of each query contains the string  () consisting of lowercase Latin letters. The third line of each query contains the string  () consisting of lowercase Latin letters.", "output": "For each query print  if it is possible to make  equal to , and  otherwise. You may print every letter in any case you want (so, for example, the strings , ,  and  will all be recognized as positive answer).", "tutorial": "If the answer exists then each element of string  matches with some element of string . Thereby string  must be a subsequence of string .Let  equal to the number of occurrences of the letter  in the string . Then for any letter  condition  must be hold.So the answer to the query is  if following conditions hold:   string  is subsequence of string ;   for any Latin latter . ", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint q;\nstring s, t, p;\nint cnt[30];\n\nint main() {\n\tcin >> q;\n\tfor(int iq = 0; iq < q; ++iq){\n\t\tcin >> s >> t >> p;\n\t\tmemset(cnt, 0, sizeof cnt);\n\t\tfor(auto x : p)\n\t\t\t++cnt[x - 'a'];\n\n\t\tbool ok = true;\n\t\tint is = 0, it = 0;\n\t\twhile(is < s.size()){\n\t\t\tif(it == t.size()){\n\t\t\t\tok = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tif(s[is] == t[it]){\n\t\t\t\t++is, ++it;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\t--cnt[t[it] - 'a'];\n\t\t\t++it;\n\t\t}\n        while(it < t.size()){\n            --cnt[t[it] - 'a'];\n\t\t\t++it;\n        }\n        \n\t\tif(*min_element(cnt, cnt + 30) < 0)\n\t\t\tok = false;\n\n\t\tif(ok) cout << \"YES\\n\";\n\t\telse cout << \"NO\\n\";\n\t}\t\t\n\treturn 0;\n}                             \t\n\n\n\n}                             \t\n\n\n", "interactive": false, "noSolution": false, "noTutorial": false}