{"link": "https://codeforces.com//contest/1303/problem/F", "problemId": "538605", "shortId": "1303F", "contest_number": "1303", "name": "F. Number of Components", "statement": "You are given a matrix , initially filled with zeroes. We define  as the element in the -th row and the -th column of the matrix.Two cells of the matrix are  if they share a side, and the elements in these cells are equal. Two cells of the matrix belong to the same  if there exists a sequence , , ...,  such that  is the first cell,  is the second cell, and for every ,  and  are connected.You are given  queries of the form    (). For every such query, you have to do the following:  replace the element  with ;  count the number of connected components in the matrix. There is one additional constraint: for every , .", "input": "The first line contains three integers ,  and  (, ) \u2014 the number of rows, the number of columns and the number of queries, respectively. Then  lines follow, each representing a query. The -th line contains three integers ,  and  (, , ). For every , .", "output": "Print  integers, the -th of them should be equal to the number of components in the matrix after the first  queries are performed.", "tutorial": "Note that because of the low constraints on the number of colors, the problem can be solved independently for each color. Now you can divide the queries into two types: add a cell to the field and delete it. You have to maintain the number of components formed by added cells. Cell deletions will occur after all additions because of the condition . The first part of the solution will be to calculate the number of components while adding new cells. This is a standard problem that can be solved using the DSU.After that, we should note that if we consider the process of removing cells from the end, this process is similar to the process of adding. Therefore, we have to process delete requests from the end in the same way as add requests, only their contribution to the number of components will be opposite in sign.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n#define pb push_back\n#define mp make_pair\n#define sqr(a) ((a) * (a))\n#define sz(a) int((a).size())\n#define all(a) (a).begin(), (a).end()\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define fore(i, l, r) for (int i = int(l); i < int(r); ++i)\n#define forr(i, r, l) for (int i = int(r) - 1; i >= int(l); --i)\n\ntypedef pair<int, int> pt;\n\nconst int M = 310;\nconst int N = 2000 * 1000 + 13;\n\nint n, m, q;\nint a[M][M];\n\nint dx[] = {-1, 0, 1, 0};\nint dy[] = {0, -1, 0, 1};\n\nbool in(int x, int y) {\n    return 0 <= x && x < n && 0 <= y && y < m;\n}\n\nint p[M * M], rk[M * M];\n\nint getp(int v) {\n    return p[v] == v ? v : p[v] = getp(p[v]);\n}\n\nbool unite(int a, int b) {\n    a = getp(a); b = getp(b);\n    if (a == b) return false;\n    if (rk[a] < rk[b]) swap(a, b);\n    p[b] = a;\n    rk[a] += rk[b];\n    return true;\n}\n\nint dif[N];\nvector<pt> add[N], del[N];\n\nvoid recalc(const vector<pt>& ev, int coeff)  {\n    forn(i, n) forn(j, m) a[i][j] = 0;\n    forn(i, n * m) p[i] = i, rk[i] = 1;\n        \n    for (auto it : ev) {\n        int cur = 1;\n        int x = it.x / m, y = it.x % m;\n        a[x][y] = 1;\n        \n        forn(k, 4) {\n            int nx = x + dx[k];\n            int ny = y + dy[k];\n            if (in(nx, ny) && a[nx][ny] == 1)\n                cur -= unite(nx * m + ny, x * m + y);\n        }\n        \n        dif[it.y] += cur * coeff;\n    }\n}\n\nint main() {\n    scanf(\"%d%d%d\", &n, &m, &q);\n    int clrs = 1;\n    forn(i, q) {\n        int x, y, c;\n        scanf(\"%d%d%d\", &x, &y, &c);\n        --x; --y;\n        if (a[x][y] == c) continue;\n        clrs = c + 1;\n        add[c].pb(mp(x * m + y, i));\n        del[a[x][y]].pb(mp(x * m + y, i));\n        a[x][y] = c;\n    }\n    \n    forn(x, n) forn(y, m)\n        del[a[x][y]].pb(mp(x * m + y, q));\n    \n    forn(i, clrs) reverse(all(del[i]));\n    \n    forn(i, clrs) recalc(add[i], +1);\n    forn(i, clrs) recalc(del[i], -1);\n    \n    int cur = 1;\n    forn(i, q) {\n        cur += dif[i];\n        printf(\"%d\\n\", cur);\n    }\n}", "interactive": false, "noSolution": false, "noTutorial": false}