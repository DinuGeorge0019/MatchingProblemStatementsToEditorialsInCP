{"link": "https://codeforces.com//contest/691/problem/D", "problemId": "65089", "shortId": "691D", "contest_number": "691", "name": "D. Swaps in Permutation", "statement": "You are given a permutation of the numbers  and  pairs of positions .At each step you can choose a pair from the given positions and swap the numbers in that positions. What is the lexicographically maximal permutation one can get?Let  and  be two permutations of the numbers .  is lexicographically smaller than the  if a number  exists, so  for  and .", "input": "The first line contains two integers  and  () \u2014 the length of the permutation  and the number of pairs of positions. The second line contains  distinct integers  () \u2014 the elements of the permutation . Each of the last  lines contains two integers  () \u2014 the pairs of positions to swap. Note that you are given a , not the values to swap.", "output": "Print the only line with  distinct integers  () \u2014 the lexicographically maximal permutation one can get.", "tutorial": "Consider a graph with  vertices whose edges is the pairs from the input. It's possible to swap any two values with the positions in some connected component in that graph. So we can sort the values from any component in decreasing order. Easy to see that after sorting the values of each component we will get the lexicographically maximal permutation.\n", "solution": "const int N = 1200300;\n\nint n, m;\nint p[N];\npti a[N];\n\nbool read() {\n\tif (!(cin >> n >> m)) return false;\n\tforn(i, n) {\n\t\tassert(scanf(\"%d\", &p[i]) == 1);\n\t\tp[i]--;\n\t}\n\tforn(i, m) {\n\t\tassert(scanf(\"%d%d\", &a[i].x, &a[i].y) == 2);\n\t\ta[i].x--, a[i].y--;\n\t}\n\treturn true;\n}\n\nbool used[N];\nvector<int> g[N];\nvector<int> perm, pos;\n\nvoid dfs(int v) {\n\tif (used[v]) return;\n\tused[v] = true;\n\tpos.pb(v);\n\tperm.pb(p[v]);\n\n\tfor (auto to : g[v]) dfs(to);\n}\n\nint ans[N];\n\nvoid solve() {\n\tforn(i, n) {\n\t\tg[i].clear();\n\t\tused[i] = false;\n\t}\n\n\tforn(i, m) {\n\t\tg[a[i].x].pb(a[i].y);\n\t\tg[a[i].y].pb(a[i].x);\n\t}\n\n\tint cnt = 0;\n\tforn(i, n)\n\t\tif (!used[i]) {\n\t\t\tcnt++;\n\t\t\tpos.clear();\n\t\t\tperm.clear();\n\t\t\tdfs(i);\n\t\t\tsort(all(pos));\n\t\t\tsort(all(perm), greater<int>());\n\t\t\tforn(j, sz(perm))\n\t\t\t\tans[pos[j]] = perm[j];\n\t\t}\n\n\tforn(i, n) {\n\t\tif (i) putchar(' ');\n\t\tprintf(\"%d\", ans[i] + 1);\n\t}\n\tputs(\"\");\n}", "interactive": false, "noSolution": false, "noTutorial": false}