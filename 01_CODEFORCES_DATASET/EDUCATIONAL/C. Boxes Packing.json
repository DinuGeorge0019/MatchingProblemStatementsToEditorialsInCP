{"link": "https://codeforces.com//contest/903/problem/C", "problemId": "138452", "shortId": "903C", "contest_number": "903", "name": "C. Boxes Packing", "statement": "Mishka has got  empty boxes. For every  (), -th box is a cube with side length .Mishka can put a box  into another box  if the following conditions are met:  -th box is not put into another box;  -th box doesn't contain any other boxes;  box  is smaller than box  (). Mishka can put boxes into each other an arbitrary number of times. He wants to minimize the number of  boxes. A box is called  iff it is not put into some another box.Help Mishka to determine the minimum possible number of  boxes!", "input": "The first line contains one integer  () \u2014 the number of boxes Mishka has got. The second line contains  integers , , ...,  (), where  is the side length of -th box.", "output": "Print the minimum possible number of  boxes.", "tutorial": "You can always show that the answer is equal to the amount of boxes of the size appearing the most in array. Result can be easily obtained by constructive algorithm: take these most appearing boxes, put smaller boxes in decreasing order of their size into free ones (there always be space) and put resulting boxes into the larger ones in increasing order.Overall complexity: .", "solution": "#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, \"/STACK:336777216\")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 20;\nconst ll MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-9;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define Se second\n#define Fi first\n\nmap <int, int> Mx;\nint main() {\n\tint N, i;\n\tscanf(\"%d\", &N);\n\twhile (N--) {\n\t\tscanf(\"%d\", &i);\n\t\tMx[i]++;\n\t}\n\n\tint ans = 0;\n\tfor (auto it : Mx) ans = max(ans, it.second);\n\treturn !printf(\"%d\\n\", ans);\n}", "interactive": false, "noSolution": false, "noTutorial": false}