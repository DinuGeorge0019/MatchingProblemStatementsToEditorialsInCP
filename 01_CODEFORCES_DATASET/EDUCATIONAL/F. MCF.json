{"link": "https://codeforces.com//contest/1766/problem/F", "problemId": "1690151", "shortId": "1766F", "contest_number": "1766", "name": "F. MCF", "statement": "You are given a graph consisting of  vertices and  directed arcs. The -th arc goes from the vertex  to the vertex , has capacity  and weight . No arc goes into the vertex , and no arc goes from the vertex . There are no cycles of negative weight in the graph (it is impossible to travel from any vertex to itself in such a way that the total weight of all arcs you go through is negative).You have to assign each arc a flow (an integer between  and its capacity, inclusive). For every vertex , the total flow on the arcs going to this vertex must be equal to the total flow on the arcs going from that vertex. Let the flow on the -th arc be , then the cost of the flow is equal to . You have to find a flow which  the cost.Sounds classical, right? Well, we have some additional constraints on the flow on every edge:  if  is even,  must be even;  if  is odd,  must be odd. Can you solve this problem?", "input": "The first line contains two integers  and  (; ). Then  lines follow. The -th of them contains four integers , , , and  (; ; ; ; ). These integers describe the -th arc. Additional constraints on the input:   there are no negative cycles in the graph. ", "output": "If a flow satisfying all of the constraints does not exist, print . Otherwise, print two lines:   the first line should contain one word ;  the second line should contain  integers .  If there are multiple answers, print any of them. Note that the cost of the flow should be minimized.", "tutorial": "This problem is solved using minimum cost flows (duh).Suppose all arcs have even capacity. Then we can just divide each arc's capacity by  and solve a usual minimum cost flow problem. However, when we have arcs with odd capacity, it's not that simple. We will deal with them as follows: split an arc with capacity  into two arcs: one with capacity , the other with capacity , and somehow enforce that the second arc must be saturated. We cannot divide all arcs by  now, because that would lead to non-integer capacities; instead, we will exclude these arcs with capacity  and somehow handle the fact that they must be saturated, and only then divide all capacities by .Okay, how do we handle the edges we deleted? For each vertex, let's check if the number of such arcs connected to it is even. If it is not \u2014 the total flow for this vertex cannot be , so it's impossible to find the answer (the only case when it might be possible is if this vertex is the source or the sink; in this case, we need to check that both of these vertices have an odd number of arcs we want to delete connected to them, and consider an additional arc  with capacity  and weight  to make it even). If for each vertex, the number of odd arcs connected to it is even, let's consider how much excess flow these arcs bring into the vertices. For example, if a vertex has  ingoing odd arcs, it has  units of flow going into it, which will be lost if we remove the edges we want to ignore. To handle this, add a new source and a new sink to our network (let's call them  and ), and process excess flow going into the vertex using an arc from  to that vertex (in the previous example, we can add an arc from  to the vertex with capacity  \u2014 not  since we divide all capacities by ). Similarly, excess flow going outside the vertex can be processed with an arc from that vertex to . We need to make sure that all these edges must be saturated.Okay, what about actually running the flow from  to ? We can do it as in \"flow with lower bounds\" problem by adding an arc  with infinite capacity... Wait a minute, this may cause a negative cycle to appear! If your implementation of mincost flow handles them, you can use this approach; but if you don't want to mess with negative cycles, instead do the following:  add an arc  and an arc , both with infinite capacities, to make sure that flow can go from  to ;  since these arcs don't have to be saturated, but other arcs going from  or into  must be saturated, set the costs of these \"other\" arcs to . Okay, that's it \u2014 we just need to find the minimum cost flow in the resulting network. The constraints are low enough so any minimum cost flow algorith can pass.", "solution": "#include <bits/stdc++.h>     \n\nusing namespace std;\n\nconst int N = 243;\n\nstruct edge\n{\n    int y, c, w, f;\n    edge() {};\n    edge(int y, int c, int w, int f) : y(y), c(c), w(w), f(f) {};\n};\n\nvector<edge> e;\nvector<int> g[N];\n\nint rem(int x)\n{\n    return e[x].c - e[x].f;\n}\n\nvoid add_edge(int x, int y, int c, int w)\n{\n    g[x].push_back(e.size());\n    e.push_back(edge(y, c, w, 0));\n    g[y].push_back(e.size());\n    e.push_back(edge(x, 0, -w, 0));\n}\n\nint n, m, s, t, v;\n\npair<int, long long> MCMF()\n{\n    int flow = 0;\n    long long cost = 0;\n    while(true)\n    {\n        vector<long long> d(v, (long long)(1e18));\n        vector<int> p(v, -1);\n        vector<int> pe(v, -1);\n        queue<int> q;\n        vector<bool> inq(v);\n        q.push(s);\n        inq[s] = true;\n        d[s] = 0;\n        while(!q.empty())\n        {\n            int k = q.front();\n            q.pop();\n            inq[k] = false;\n            for(auto ei : g[k])\n            {\n                if(rem(ei) == 0) continue;\n                int to = e[ei].y;\n                int w = e[ei].w;\n                if(d[to] > d[k] + w)\n                {\n                    d[to] = d[k] + w;\n                    p[to] = k;\n                    pe[to] = ei;\n                    if(!inq[to])\n                    {\n                        inq[to] = true;\n                        q.push(to);\n                    }\n                }\n            }\n        }\n        if(p[t] == -1 || d[t] >= 0) break;\n        flow++;\n        cost += d[t];\n        int cur = t;\n        while(cur != s)\n        {\n            e[pe[cur]].f++;\n            e[pe[cur] ^ 1].f--;\n            cur = p[cur];\n        }\n    }\n    return make_pair(flow, cost);\n}\n\nvoid no_answer()\n{\n    cout << \"Impossible\" << endl;\n    exit(0);\n}\n\nint main()\n{                              \n    cin >> n >> m;\n    vector<int> excess_flow(n, 0);\n    vector<int> orc(m);\n    for(int i = 0; i < m; i++)\n    {\n        int x, y, c, w;\n        cin >> x >> y >> c >> w;\n        orc[i] = c;\n        --x;\n        --y;\n        add_edge(x, y, c / 2, w);\n        if(c % 2 == 1)\n        {\n            excess_flow[x]--;\n            excess_flow[y]++;\n        }\n    }\n    s = n;\n    t = n + 1;\n    v = n + 2;\n    int total_excess = 0;\n    if(excess_flow[0] % 2 == -1)\n    {\n        excess_flow[0]--;\n        excess_flow[n - 1]++;\n    }\n    for(int i = 0; i < n; i++)\n    {\n        if(excess_flow[i] % 2 != 0)\n            no_answer();\n        int val = abs(excess_flow[i]) / 2;\n        if(excess_flow[i] > 0)\n        {\n            total_excess += val;\n            add_edge(s, i, val, -int(1e9));\n        }\n        if(excess_flow[i] < 0)\n        {\n            add_edge(i, t, val, -int(1e9));\n        }\n    }\n    add_edge(s, 0, 100000, 0);\n    add_edge(n - 1, t, 100000, 0);\n    auto ans = MCMF();\n    bool good_answer = true;\n    for(int x = 0; x < e.size(); x++)\n        if(e[x].w == -int(1e9) && rem(x) != 0)\n            good_answer = false;\n    if(!good_answer)\n        no_answer();\n    cout << \"Possible\" << endl;\n    for(int i = 0; i < 2 * m; i += 2)\n    {\n        if(i) cout << \" \";\n        cout << e[i].f * 2 + orc[i / 2] % 2;\n    }\n    cout << endl;\n}", "interactive": false, "noSolution": false, "noTutorial": false}