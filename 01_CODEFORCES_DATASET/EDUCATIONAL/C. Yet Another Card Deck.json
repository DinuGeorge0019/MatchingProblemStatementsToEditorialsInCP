{"link": "https://codeforces.com//contest/1511/problem/C", "problemId": "955214", "shortId": "1511C", "contest_number": "1511", "name": "C. Yet Another Card Deck", "statement": "You have a card deck of  cards, numbered from top to bottom, i.\u00a0e. the top card has index  and bottom card\u00a0\u2014 index . Each card has its color: the -th card has color .You should process  queries. The -th query is described by integer . For each query you should:   find the highest card in the deck with color , i.\u00a0e. the card with minimum index;  print the position of the card you found;  take the card and place it on top of the deck. ", "input": "The first line contains two integers  and  (; )\u00a0\u2014 the number of cards in the deck and the number of queries. The second line contains  integers  ()\u00a0\u2014 the colors of cards. The third line contains  integers  ()\u00a0\u2014 the query colors. It's guaranteed that .", "output": "Print  integers\u00a0\u2014 the answers for each query.", "tutorial": "Let's look at one fixed color. When we search a card of such color, we take the card with minimum index and after we place it on the top of the deck it remains the one with minimum index.It means that for each color we take and move the same card\u00a0\u2014 one card for each color. In other words, we need to keep track of only  cards, where  is the number of colors (). As a result, if  is the position of a card of color  then we can simulate a query in the following way: for each color  such that  we increase  by one (since the card will move down) and then set . Complexity is .But, if we look closely, we may note that we don't even need array . We can almost manually find the first card of color  and move it to the first position either by series of swaps or, for example, using  function (present in C++) and it will work fast.Why? Let's look at one color . For the first time it will cost  operations to search the corresponding card and move it to the position . But after that, at any moment of time, the position of the card won't exceed , since all cards before are pairwise different (due to the nature of queries). So, all next moves the color  costs only  time.As a result, the complexity of such almost naive solution is .", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  int n, q;\n  scanf(\"%d%d\", &n, &q);\n  vector<int> a(n);\n  for (int& x : a) scanf(\"%d\", &x);\n  while (q--) {\n    int x;\n    scanf(\"%d\", &x);\n    int p = find(a.begin(), a.end(), x) - a.begin();\n    printf(\"%d \", p + 1);\n    rotate(a.begin(), a.begin() + p, a.begin() + p + 1);\n  }\n}", "interactive": false, "noSolution": false, "noTutorial": false}