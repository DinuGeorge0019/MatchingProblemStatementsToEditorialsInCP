{"link": "https://codeforces.com//contest/1036/problem/C", "problemId": "216419", "shortId": "1036C", "contest_number": "1036", "name": "C. Classy Numbers", "statement": "Let's call some positive integer  if its decimal representation contains no more than  non-zero digits. For example, numbers , ,  are  and numbers , ,  are not.You are given a segment . Count the number of  integers  such that .Each testcase contains several segments, for each of them you are required to solve the problem separately.", "input": "The first line contains a single integer  () \u2014 the number of segments in a testcase. Each of the next  lines contains two integers  and  ().", "output": "Print  lines \u2014 the -th line should contain the number of  integers on a segment .", "tutorial": "There are quite a few approaches to the problem. I'll describe the two of them which I actually implemented.First approach - combinatoric one:Problems of the form \"count the number of beautiful numbers from  to \" usually require counting the numbers on  and  (or not inclusively  and ) and subtracting one from another. Let's try this thing here, counting  not inclusively.Let's fix some prefix of the upper border number. We want to calculate the amount of numbers having the same prefix but being smaller in the next digit. If we count it for all prefixes (including the empty one), we will get the answer. And that is pretty easy. Let the prefix include  non-zero digits, the length of the suffix be  and the digit after the chosen prefix is . If  is zero then there the result is obviously zero. Otherwise we can either put  or any of the  non-zero digits. Then the formula is: + .We choose  positions from the suffix to put non-zero digits in them (any digit from  to ) and fill the rest with zeros.Overall complexity: .Second approach - precalc one:This is a bit easier to implement. Actually, there are just about 700000 valid numbers, you can generate them all, put them into the array in sorted order and binary search for the given queries.Overall complexity: .", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nlong long C[20][20];\nlong long pw[4];\n\nlong long cnk(int n, int k){\n    if (k < 0 || k > n) return 0;\n    return C[n][k];\n}\n\nlong long get(int n, int lft){\n    long long tot = 0;\n    forn(i, lft + 1)\n        tot += cnk(n, i) * pw[i];\n    return tot;\n}\n\nlong long calc(long long x){\n    string s = to_string(x);\n    \n    long long res = 0;\n    int cur = 3;\n    int n = s.size();\n    \n    forn(i, n){\n        if (s[i] == '0') continue;\n        res += get(n - i - 1, cur);\n        --cur;\n        if (cur == -1) break;\n        res += get(n - i - 1, cur) * (s[i] - '1');\n    }\n    \n    return res;\n}\n\nint main() {\n    forn(i, 20){\n        C[i][0] = C[i][i] = 1;\n        for (int j = 1; j < i; ++j)\n            C[i][j] = C[i - 1][j] + C[i - 1][j - 1];\n    }\n    pw[0] = 1, pw[1] = 9, pw[2] = 81, pw[3] = 729;\n    int T;\n    scanf(\"%d\", &T);\n    forn(i, T){\n        long long L, R;\n        scanf(\"%lld%lld\", &L, &R);\n        printf(\"%lld\\n\", calc(R + 1) - calc(L));\n    }\n    return 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}