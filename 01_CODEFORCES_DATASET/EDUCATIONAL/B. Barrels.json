{"link": "https://codeforces.com//contest/1430/problem/B", "problemId": "755154", "shortId": "1430B", "contest_number": "1430", "name": "B. Barrels", "statement": "You have  barrels lined up in a row, numbered from left to right from one. Initially, the -th barrel contains  liters of water.You can pour water from one barrel to another. In one act of pouring, you can choose two different barrels  and  (the -th barrel shouldn't be empty) and pour any possible amount of water from barrel  to barrel  (possibly, all water). You may assume that barrels have infinite capacity, so you can pour any amount of water in each of them. Calculate the maximum possible difference between the maximum and the minimum amount of water in the barrels, if you can pour water   times.Some examples:   if you have four barrels, each containing  liters of water, and , you may pour  liters from the second barrel into the fourth, so the amounts of water in the barrels are , and the difference between the maximum and the minimum is ;  if all barrels are empty, you can't make any operation, so the difference between the maximum and the minimum amount is still . ", "input": "The first line contains one integer  ()\u00a0\u2014 the number of test cases. The first line of each test case contains two integers  and  ()\u00a0\u2014 the number of barrels and the number of pourings you can make. The second line contains  integers  (), where  is the initial amount of water the -th barrel has. It's guaranteed that the total sum of  over test cases doesn't exceed .", "output": "For each test case, print the maximum possible difference between the maximum and the minimum amount of water in the barrels, if you can pour water   times.", "tutorial": "A greedy strategy always works: take  largest barrels, choose one barrel among them and pour all water from those barrels to the chosen barrel. That way, we make the minimum amount equal to  (it's quite obvious that we can't do anything better here), and the maximum amount as large as possible, so the difference between them will be as large as possible.", "solution": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <cassert>\n#include <iomanip>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <ctime>\n#include <cmath>\n\n#define forn(i, n) for(int i=0;i<n;++i)\n#define fore(i, l, r) for(int i = int(l); i <= int(r); ++i)\n#define sz(v) int(v.size())\n#define all(v) v.begin(), v.end()\n#define pb push_back\n#define mp make_pair\n#define x first\n#define y1 ________y1\n#define y second\n#define ft first\n#define sc second\n#define pt pair<int, int>\n\ntemplate<typename X> inline X abs(const X& a) { return a < 0? -a: a; }\ntemplate<typename X> inline X sqr(const X& a) { return a * a; }\n\ntypedef long long li;\ntypedef long double ld;\n\nusing namespace std;\n\nconst int INF = 1000 * 1000 * 1000;\nconst ld EPS = 1e-9;\nconst ld PI = acos(-1.0);\nconst int N = 200 * 1000 + 13;\n\nint n, k;\nint a[N];\n\ninline void read() {\t\n\tcin >> n >> k;\n\tfor (int i = 0; i < n; i++) cin >> a[i];\n}\n\ninline void solve() {\n\tsort(a, a + n);\n\treverse(a, a + n);\n\tli ans = 0;\n\tfor (int i = 0; i <= k; i++) {\n\t\tans += a[i];\n\t}\n\tcout << ans << endl;\n}\n\nint main () {\n#ifdef fcspartakm\n    freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n#endif\n    cerr << setprecision(10) << fixed;\n    \n    int t; cin >> t;\n    while(t--) {\n    \tread();\n    \tsolve();\n \t}\n    //cerr << \"TIME: \" << clock() << endl;\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}