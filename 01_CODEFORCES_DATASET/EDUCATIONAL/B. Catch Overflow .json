{"link": "https://codeforces.com//contest/1175/problem/B", "problemId": "354214", "shortId": "1175B", "contest_number": "1175", "name": "B. Catch Overflow ", "statement": "You are given a function  written in some basic language. The function accepts an integer value, which is immediately written into some variable .  is an integer variable and can be assigned values from  to . The function contains three types of commands:  for  \u2014 for loop;  end \u2014 every command between \"for \" and corresponding \"end\" is executed  times;  add \u2014 adds  to . After the execution of these commands, value of  is returned.Every \"for \" is matched with \"end\", thus the function is guaranteed to be valid. \"for \" can be immediately followed by \"end\".\"add\" command can be outside of any for loops.Notice that \"add\" commands might overflow the value of ! It means that the value of  becomes greater than  after some \"add\" command. Now you run  and wonder if the resulting value of  is correct or some overflow made it incorrect.If overflow happened then output \"OVERFLOW!!!\", otherwise print the resulting value of .", "input": "The first line contains a single integer  () \u2014 the number of lines in the function. Each of the next  lines contains a single command of one of three types:   for  () \u2014 for loop;  end \u2014 every command between \"for \" and corresponding \"end\" is executed  times;  add \u2014 adds  to . ", "output": "If overflow happened during execution of , then output \"OVERFLOW!!!\", otherwise print the resulting value of .", "tutorial": "One can notice (or actually derive using some maths) that the answer is the sum of products of nested for loops iterations for every \"add\" command.Let's learn to simulate that in linear complexity. Maintain the stack of multipliers: on \"for \" push the top of stack multiplied by  to the stack, on \"end\" pop the last value, on \"add\" add the top of the stack to the answer.The problem, however, is the values are really large. Notice that once you add the value greater or equal to  to the answer, it immediately becomes \"OVERFLOW!!!\". Thus let's push not the real multiplier to the stack but min(multiplier, ). That way the maximum value you can achieve is about , which fits into the 64-bit integer.Overall complexity: .", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for(int i = 0; i < int(n); i++) \n\nusing namespace std;\n\nconst long long INF = 1ll << 32;\n\nint main(){\n\tint l;\n\tcin >> l;\n\t\n\tstack<long long> cur;\n\tcur.push(1);\n\t\n\tlong long res = 0;\n\tforn(_, l){\n\t\tstring t;\n\t\tcin >> t;\n\t\tif (t == \"for\"){\n\t\t\tint x;\n\t\t\tcin >> x;\n\t\t\tcur.push(min(INF, cur.top() * x));\n\t\t}\n\t\telse if (t == \"end\"){\n\t\t\tcur.pop();\n\t\t}\n\t\telse{\n\t\t\tres += cur.top();\n\t\t}\n\t}\n\t\n\tif (res >= INF)\n\t\tcout << \"OVERFLOW!!!\" << endl;\n\telse\n\t\tcout << res << endl;\n}", "interactive": false, "noSolution": false, "noTutorial": false}