{"link": "https://codeforces.com//contest/1651/problem/E", "problemId": "1324100", "shortId": "1651E", "contest_number": "1651", "name": "E. Sum of Matchings", "statement": "Let's denote the size of the maximum matching in a graph  as .You are given a bipartite graph. The vertices of the first part are numbered from  to , the vertices of the second part are numbered from  to . .For a tuple of four integers , where  and , let's define  as the graph which consists of all vertices of the given graph that are included in the segment  or in the segment , and all edges of the given graph such that each of their endpoints belongs to one of these segments. In other words, to obtain  from the original graph, you have to remove all vertices  such that  and , and all edges incident to these vertices.Calculate the sum of  over all tuples of integers  having  and .", "input": "The first line contains one integer  ()\u00a0\u2014 the number of vertices in each part. Then  lines follow, each denoting an edge of the graph. The -th line contains two integers  and  (; )\u00a0\u2014 the endpoints of the -th edge. There are no multiple edges in the given graph, and each vertex has  two incident edges.", "output": "Print one integer\u00a0\u2014 the sum of  over all tuples of integers  having  and .", "tutorial": "Instead of counting the edges belonging to the maximum matching, it is easier to count the vertices. So, we will calculate the total number of vertices saturated by the maximum matching over all possible tuples , and then divide the answer by . Furthermore, it's easier to calculate the number of unsaturated vertices than the number of saturated vertices, so we can subtract it from the total number of vertices in all graphs we consider and obtain the answer.Let's analyze how to calculate the total number of unsaturated vertices. Each graph  is a subgraph of the given graph, so it is still bipartite, and the degree of each vertex is still not greater than . A bipartite graph where the degree of each vertex is at most  can be represented as a set of cycles and paths, and the maximum matching over each of these cycles/paths can be considered independently. Each cycle has an even number of vertices (since otherwise the graph would not be bipartite), so we can saturate all vertices on a cycle with the matching. For a path, the number of unsaturated vertices depends on its length: if the number of vertices in a path is even, we can match all vertices on it; otherwise, one vertex will be unsaturated. So the problem reduces to counting paths with odd number of vertices in all possible graphs .Every path with an odd number of vertices has a center (the vertex which is exactly in the middle of the path). Let's iterate on the center of the path and its length, and calculate the number of times this path occurs in all graphs we consider. Suppose the center of the path is the vertex , and the number of vertices in it is . Then, for this path to exist, two conditions must hold:  every vertex  such that the distance from  to  is not greater than  should be present in the graph;  every vertex  such that the distance from  to  is   should be excluded from the graph. It means that, for each of the two parts of the graph, there are several vertices that should be present in the graph, and zero or two vertices that should be excluded from the graph. It's easy to see that among the vertices we have to include, we are only interested in the minimum one and the maximum one (all vertices between them will be included as well if these two are included). So, we need to implement some kind of function that allows us to calculate the number of segments that cover the minimum and the maximum vertex we need, and don't cover any of the vertices that we have to exclude \u2014 this can be easily done in . Note that the segments should be considered independently for both parts of the graph.Overall, for each vertex we have to consider at most  different lengths of odd paths with the center in this vertex. The minimum/maximum indices of vertices in both parts we have to include in the graph can be maintained while we increase the length of the path, so the whole solution works in .", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 3043;\n\nvector<int> g[2 * N];\nint n;\nint used[2 * N];\n\nint choose2(int n)\n{\n    return n * (n + 1) / 2;\n}\n\nint count_ways(int L, int R, const vector<int>& forbidden)\n{\n    if(L > R)\n    {\n        int ml = *min_element(forbidden.begin(), forbidden.end());\n        int mr = *max_element(forbidden.begin(), forbidden.end());\n        return choose2(ml) + choose2(mr - ml - 1) + choose2(n - 1 - mr);\n    }\n    int minl = 0;\n    int maxl = L;\n    int minr = R;\n    int maxr = n - 1;\n    for(auto x : forbidden)\n    {\n        if(L <= x && x <= R)\n            return 0;\n        else if(x < L) minl = max(minl, x + 1);\n        else maxr = min(maxr, x - 1);\n    }                            \n    return (maxl - minl + 1) * (maxr - minr + 1);\n}\n\nvector<int> cur;\n\nvoid dfs(int x)\n{\n    if(used[x] == 1) return;\n    used[x] = 1;\n    cur.push_back(x);\n    for(auto y : g[x]) dfs(y);\n}\n\nlong long calc(const vector<int>& cycle)\n{\n    int m = cycle.size();\n    int k = m / 2;\n    long long ans = 0;\n    for(int i = 0; i < m; i++)\n    {\n        int z = cycle[i];\n        if(z >= n) z -= n;\n        ans += choose2(n) * 1ll * (choose2(z) + 0ll + choose2(n - z - 1));\n        int l = n - 1, r = 0, L = n - 1, R = 0;\n        int pl = i, pr = i;\n        for(int j = 0; j < k; j++)\n        {\n            for(auto x : vector<int>({cycle[pl], cycle[pr]}))\n            {\n                if(x < n)\n                {\n                    l = min(l, x);\n                    r = max(r, x);\n                }\n                else\n                {\n                    L = min(L, x - n);\n                    R = max(R, x - n);\n                }\n            }\n            vector<int> f, F;\n            pl--;\n            if(pl < 0) pl += m;\n            pr++;\n            if(pr >= m) pr -= m;\n            for(auto x : vector<int>({cycle[pl], cycle[pr]}))\n            {                     \n                if(x < n) f.push_back(x);\n                else F.push_back(x - n);\n            }\n            long long add = count_ways(l, r, f) * 1ll * count_ways(L, R, F);\n            ans += add;\n        }\n    }\n    return ans;       \n}\n\nint main()\n{\n    cin >> n;\n    for(int i = 0; i < 2 * n; i++)\n    {\n        int x, y;\n        cin >> x >> y;\n        --x;\n        --y;\n        g[x].push_back(y);\n        g[y].push_back(x);\n    }\n    long long ans = n * 1ll * choose2(n) * 1ll * choose2(n) * 2ll;\n    for(int i = 0; i < n; i++)\n    {\n        if(used[i]) continue;\n        dfs(i);\n        vector<int> cycle = cur;\n        ans -= calc(cycle);\n        cur = vector<int>();\n    }\n    cout << ans / 2 << endl;\n}", "interactive": false, "noSolution": false, "noTutorial": false}