{"link": "https://codeforces.com//contest/1574/problem/B", "problemId": "1115675", "shortId": "1574B", "contest_number": "1574", "name": "B. Combinatorics Homework", "statement": "You are given four integer values , ,  and .Check if there exists a string that contains:    letters '';   letters '';   letters '';  no other letters;  exactly  pairs of adjacent equal letters (exactly  such positions  that the -th letter is equal to the -th one). ", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of testcases. Each of the next  lines contains the description of the testcase\u00a0\u2014 four integers , ,  and  (; ).", "output": "For each testcase print \"\" if there exists a string that satisfies all the requirements. Print \"\" if there are no such strings. You may print every letter in any case you want (so, for example, the strings , ,  and  will all be recognized as positive answer).", "tutorial": "Let's start with a simple assumption. For some fixed values , the values of  that the answers exist for, make up a range. So there's the smallest possible number of adjacent equal pairs one can construct and the largest one\u00a0\u2014 everything in-between exists as well.The largest number is simple\u00a0\u2014 put all A's, then all B's, then all C's. So this value is .The smallest number is trickier. Let's instead investigate when it's equal to . WLOG, assume . Imagine the following construction. There are  letters C which separate blocks of letters A and B. There are  ( if you consider the ones to the sides of all letters C, but we want the smallest value, so we shouldn't consider them) such blocks, thus it's possible that each block contains no more than one letter A and no more than one letter B. So letters A and B will never produce adjacent pairs.If there are empty blocks, then there are adjacent letters C. So the condition to still have no empty blocks is to have at least  letters A and B in total. If , then any extra letter C can only be put adjacent to another letter C, thus producing an extra pair (at least one extra pair, but since we are examining the lower bound, we can always do exactly one). That means that the lower bound is .Now for the proof of the fact that every value in-between is also achievable. Since we have a construction for , let's try modifying it. Let's reduce the test to  the following way. While , decrease the count of the letter that appears the most by  and decrease  by . Now build the string for  with the reduced values. After that put the letters back, placing them next to the last occurrence of the same letter (there is at least one occurrence of each letter, the proof is trivial). That increases  by  and the count of this letter by . Thus, we'll return to the initial test.Overall complexity:  per testcase.", "solution": "for _ in range(int(input())):\n\ta, b, c, m = map(int, input().split())\n\ta, b, c = sorted([a, b, c])\n\tprint(\"YES\" if c - (a + b + 1) <= m <= a + b + c - 3 else \"NO\")", "interactive": false, "noSolution": false, "noTutorial": false}