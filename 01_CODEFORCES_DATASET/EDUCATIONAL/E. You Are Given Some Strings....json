{"link": "https://codeforces.com//contest/1202/problem/E", "problemId": "385666", "shortId": "1202E", "contest_number": "1202", "name": "E. You Are Given Some Strings...", "statement": "You are given a string  and  strings . All strings consist of lowercase Latin letters.Let  be the number of occurences of string  in string . For example, , and .Calculate the value of , where  is the concatenation of strings  and . Note that if there are two pairs ,  and ,  such that , you should include both  and  in answer.", "input": "The first line contains string  (). The second line contains integer  (). Each of next  lines contains string  (). It is guaranteed that . All strings consist of lowercase English letters.", "output": "Print one integer \u2014 the value of .", "tutorial": "Let's look at any occurrence of arbitrary pair . There is exactly one special split position, where the  ends and  starts. So, instead of counting occurrences for each pair, we can iterate over the position of split and count the number of pairs. This transformation is convenient, since any , which ends in split position can be paired with any  which starts here. So, all we need is to calculate for each suffix the number of strings , which starts here, and for each prefix \u2014 the number of strings , which ends here. But calculating the prefixes can be transformed to calculating suffixes by reversing both  and all .Now we need, for each position , calculate the number of strings  which occur from . It can be done by Aho-Corasick, Suffix Array, Suffix Automaton, Suffix Tree, but do we really need them since constrains are pretty low? The answer is NO. We can use sqrt-heuristic!Let's divide all  in two groups: short and long. The  is short if . There are no more than  long strings and, for each such string, we can find all its occurrences with z-function (or prefix-function). It will cost as .What to do with short strings? Let's add them to trie! The trie will have  vertices, but only  depth. So we can, for each , move down through the trie, while counting the occurrences, using only  substring. It will cost us .So, if we choose  we can acquire  complexity, using only basic string structures.", "solution": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define forn(i, n) fore(i, 0, n)\n\n#define sz(a) (int)(a).size()\n#define all(a) (a).begin(), (a).end()\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef pair<int, int> pt;\n\nconst int INF = int(1e9) + 7;\nconst li INF64 = li(1e18) + 7;\n\nconst int N = 500005;\nconst int A = 27;\nconst int MAG = 500;\n\nstruct node {\n    node *to[A];\n    int cnt;\n} nodes[N];\nint szn = 0;\n\ntypedef node* vt;\n\nvt getNode() {\n    assert(szn < N);\n    fore(i, 0, A)\n        nodes[szn].to[i] = NULL;\n    nodes[szn].cnt = 0;\n    return &nodes[szn++];\n}\n\nvoid addWord(vt v, const string &s) {\n    fore(i, 0, sz(s)) {\n        int c = s[i] - 'a';\n        if (!v->to[c])\n            v->to[c] = getNode();\n        v = v->to[c];\n    }\n    v->cnt++;\n}\n\nint calcCnt(vt v, const string &s, int pos) {\n    assert(v->cnt == 0);\n    int ans = 0;\n    while(pos < sz(s)) {\n        int c = s[pos] - 'a';\n        if (!v->to[c])\n            break;\n        v = v->to[c];\n        ans += v->cnt;\n        pos++;\n    }\n    return ans;\n}\n\nvector<int> zf(string s) {\n    vector<int> z(sz(s), 0);\n    for (int i = 1, l = 0, r = 0; i < sz(s); ++i) {\n        if(i < r)\n            z[i] = min(r - i, z[i - l]);\n        while (i + z[i] < sz(s) && s[i + z[i]] == s[z[i]])\n            z[i]++;\n\n        if(i + z[i] > r)\n            l = i, r = i + z[i];\n    }\n    return z;\n}\n\nstring t;\nint n;\nvector<string> s;\n\ninline bool read() {\n    if(!(cin >> t))\n        return false;\n    cin >> n;\n    s.resize(n);\n    fore(i, 0, n)\n        cin >> s[i];\n    return true;\n}\n\ninline void solve() {\n    vector<int> cnt[2];\n    fore(k, 0, 2) {\n        cnt[k].assign(sz(t) + 1, 0);\n        szn = 0;\n        vt root = getNode();\n\n        forn(i, n) {\n            if (sz(s[i]) > MAG) {\n                auto z = zf(s[i] + t);\n                fore(j, 0, sz(t))\n                    cnt[k][j] += (z[sz(s[i]) + j] >= sz(s[i]));\n            } else {\n                addWord(root, s[i]);\n            }\n        }\n\n        fore(i, 0, sz(t))\n            cnt[k][i] += calcCnt(root, t, i);\n\n        reverse(all(t));\n        fore(i, 0, n)\n            reverse(all(s[i]));\n    }\n\n    li ans = 0;\n    fore(i, 0, sz(t) + 1)\n        ans += cnt[0][i] * 1ll * cnt[1][sz(t) - i];\n    cout << ans << endl;\n}\n\nint main() {\n#ifdef _DEBUG\n    freopen(\"input.txt\", \"r\", stdin);\n    int tt = clock();\n#endif\n    ios_base::sync_with_stdio(0);\n    cin.tie(0), cout.tie(0);\n    cerr << fixed << setprecision(15);\n\n    if(read()) {\n        solve();\n\n#ifdef _DEBUG\n        cerr << \"TIME = \" << clock() - tt << endl;\n        tt = clock();\n#endif\n    }\n    return 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}