{"link": "https://codeforces.com//contest/792/problem/C", "problemId": "100426", "shortId": "792C", "contest_number": "792", "name": "C. Divide by Three", "statement": "A positive integer number  is written on a blackboard. It consists of not more than  digits. You have to transform it into a  number by erasing some of the digits, and you want to erase as few digits as possible.The number is called beautiful if it consists of at least one digit, doesn't have leading zeroes and is a multiple of . For example, , ,  are beautiful numbers, and , ,  are not.Write a program which for the given  will find a beautiful number such that  can be transformed into this number by erasing as few digits as possible. You can erase an arbitraty set of digits. For example, they don't have to go one after another in the number .If it's impossible to obtain a beautiful number, print . If there are multiple answers, print any of them.", "input": "The first line of input contains  \u2014 a positive integer number without leading zeroes ().", "output": "Print one number \u2014 any beautiful number obtained by erasing as few as possible digits. If there is no answer, print .", "tutorial": "Let's declare a function which takes number as a string and erases minimal number of digits in substring from -nd to last character to obtain beautiful number.Note that if the answer for given string exists, then this function will erase no more than  digits. If the number is divisible by  then sum of its digits is also divisible by . So here are the only options for the function:  Sum of digits is already equal to  modulo . Thus you don't have to erase any digits.  There exists such a digit that equals sum modulo . Then you just have to erase this digit.  All of the digits are neither divisible by , nor equal to sum modulo . So two of such digits will sum up to number, which equals sum modulo  (  ,   ). Let positions of non-zero numbers be . Then you can easily see that its enough to check only three function outputs: on substrings ,  \u0438 . We imply that all digits to the left of the taken non-zero digit are erased. As we can erase no more than  digits, these options will cover all the cases.If there exists no answer for any of substrings, than you need to check if the number contains  \u2014 it will be answer in that case. If there is no , then answer is .Otherwise the answer is the function output of maximal length.Overall complexity: .", "solution": "#include <iostream>\n#include <fstream>\n#include <set>\n#include <map>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <queue>\n\n#define mp make_pair\n#define pb push_back\n\n\ntypedef long long ll;\ntypedef long double ld;\n\nusing namespace std;\n\n#ifndef LOCAL\n#define cerr _cer\nstruct _cert\n{\n    template <typename T> _cert& operator << (T) { return *this; }\n};\n_cert _cer;\n#endif\n\ntemplate <typename T> void dprint(T begin, T end) {\n    for (auto i = begin; i != end; i++) {\n\t\tcerr << (*i) << \" \";\n    }\n    cerr << \"\\n\";\n}\n\nstring s;\n\nvector<string> vv;\n\nstring tr(string s) {\n\tint now = 0;\n\twhile (now + 1 < s.size() && s[now] == '0')\n\t\t++now;\n\treturn s.substr(now);\n}\n\nint main() {\n\tcin >> s;\n\tint sum = 0;\n\tfor (int i = 0; i < s.size(); ++i)\n\t\tsum += (s[i] - '0');\n\tsum %= 3;\n\tif (sum != 0) {\n\t\tfor (int i = s.size() - 1; i >= 0; --i) {\n\t\t\tif ((s[i] - '0') % 3 == sum) {\n\t\t\t\tstring t = s.substr(0, i) + s.substr(i + 1);\n\t\t\t\tt = tr(t);\n\t\t\t\tif (!t.empty())\n\t\t\t\t\tvv.push_back(t);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tint p1 = -1;\n\t\tfor (int i = s.size() - 1; i >= 0; --i) {\n\t\t\tif ((s[i] - '0') % 3 == 0)\n\t\t\t\tcontinue;\n\t\t\tif ((s[i] - '0') % 3 == sum)\n\t\t\t\tcontinue;\n\t\t\tif (p1 == -1) {\n\t\t\t\tp1 = i;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tstring t = s.substr(0, i) + s.substr(i + 1, p1 - i - 1) + s.substr(p1 + 1);\n\t\t\tt = tr(t);\n\t\t\tif (!t.empty())\n\t\t\t\tvv.push_back(t);\n\t\t\tbreak;\n\t\t}\n\t}\n\telse {\n\t\ts = tr(s);\n\t\tif (!s.empty())\n\t\t\tvv.push_back(s);\n\t}\n\tstring ans = \"\";\n\tfor (string t: vv)\n\t\tif (t.size() > ans.size())\n\t\t\tans = t;\n\tif (ans.empty())\n\t\tcout << -1 << \"\\n\";\n\telse\n\t\tcout << ans << \"\\n\";\n\treturn 0;\n}\n\n\n", "interactive": false, "noSolution": false, "noTutorial": false}