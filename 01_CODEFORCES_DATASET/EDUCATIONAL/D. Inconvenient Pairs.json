{"link": "https://codeforces.com//contest/1569/problem/D", "problemId": "1103182", "shortId": "1569D", "contest_number": "1569", "name": "D. Inconvenient Pairs", "statement": "There is a city that can be represented as a square grid with corner points in  and .The city has  vertical and  horizontal streets that goes across the whole city, i.\u00a0e. the -th vertical streets goes from  to  and the -th horizontal street goes from  to . All streets are bidirectional. Borders of the city are streets as well.There are  persons staying : the -th person at point  (so either  equal to some  or  equal to some , or both).Let's say that a pair of persons form an  if the shortest path from one person to another going only by streets is  than the Manhattan distance between them.Calculate the number of inconvenient pairs of persons (pairs  and  are the same pair).Let's recall that Manhattan distance between points  and  is .", "input": "The first line contains a single integer  ()\u00a0\u2014 the number of test cases. The first line of each test case contains three integers ,  and  (; )\u00a0\u2014 the number of vertical and horizontal streets and the number of persons. The second line of each test case contains  integers  ()\u00a0\u2014 the -coordinates of vertical streets. The third line contains  integers  ()\u00a0\u2014 the -coordinates of horizontal streets. Next  lines contains description of people. The -th line contains two integers  and  (;  or )\u00a0\u2014 the coordinates of the -th person. All points are distinct. It guaranteed that sum of  doesn't exceed , sum of  doesn't exceed  and sum of  doesn't exceed .", "output": "For each test case, print the number of inconvenient pairs.", "tutorial": "Firstly, let's look at some point . Let's find closest to it vertical and horizontal lines. We will name the closest vertical lines from left and right as  and  (and  and  as closest horizontal lines). So,  and  (we can also note that either  or ).Now, let's note that if for some other point   either  or  then to reach  from  we must go reach either  or  (or,  or ), so the shortest distance will be strictly greater than the Manhattan distance. If neither  nor , then we can show that it's always possible to find the shortest path equal to the Manhattan distance. As a result, for each point  we should find the number of points  such that  and  or . The exception here is when  lies on the same line as , so we should not count such points.We can note that since either  or  there is no such point  that  and  simultaneously, so we can calculate the pairs by  and  coordinates independently.Let's focus on  coordinates (to calculate for  coordinates, we can just swap all coordinates). Let's sort all points by  coordinate. To get rid of the case when points  and  lies on the same vertical street, we can group them by  coordinate and process by group (since we sorted by , groups are just segments). There are no problems with the case when points lie on the same horizontal street, since then  and there are no other  with .If we store for each horizontal line  the number of point inside the interval  then, when we need for point  calculate the number of points  with  and , we can just ask for value assigned to , because  and  are consecutive elements in the array .So, we go through each group two times: first collecting answer, then updating values in appropriate -s. Note, that we can calculate  and  with binary search (using built-in functions).The resulting complexity is .", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) int((a).size())\n#define all(a) (a).begin(), (a).end()\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef pair<int, int> pt;\n\ntemplate<class A, class B> ostream& operator <<(ostream& out, const pair<A, B> &p) {\n\treturn out << \"(\" << p.x << \", \" << p.y << \")\";\n}\ntemplate<class A> ostream& operator <<(ostream& out, const vector<A> &v) {\n\tfore(i, 0, sz(v)) {\n\t\tif(i) out << \" \";\n\t\tout << v[i];\n\t}\n\treturn out;\n}\n\nconst int INF = int(1e9);\nconst li INF64 = li(1e18);\n\nint n, m, k;\nvector<int> x, y;\nvector<pt> ps;\n\ninline bool read() {\n\tif(!(cin >> n >> m >> k))\n\t\treturn false;\n\tx.resize(n);\n\tfore (i, 0, n)\n\t\tcin >> x[i];\n\ty.resize(m);\n\tfore (i, 0, m)\n\t\tcin >> y[i];\n\tps.resize(k);\n\tfore (i, 0, k)\n\t\tcin >> ps[i].x >> ps[i].y;\n\t\n\treturn true;\n}\n\ninline void solve() {\n\tli ans = 0;\n\t\n\tfore (_i, 0, 2) {\n\t\tvector<int> cntY(m, 0);\n\t\tsort(all(ps));\n\t\t\n\t\tvector<pt> bord(k);\n\t\t\n\t\tint u = 0;\n\t\twhile (u < k) {\n\t\t\tint v = u;\n\t\t\twhile (v < k && ps[v].x == ps[u].x)\n\t\t\t\tv++;\n\t\t\t\n\t\t\tfore (i, u, v) {\n\t\t\t\tint r = int(lower_bound(all(y), ps[i].y) - y.begin());\n\t\t\t\tint l = r;\n\t\t\t\tif (y[l] > ps[i].y)\n\t\t\t\t\tl--;\n\t\t\t\tassert(y[l] <= ps[i].y && ps[i].y <= y[r]);\n\t\t\t\t\n\t\t\t\tbord[i] = {l, r};\n\t\t\t}\n\t\t\t\n\t\t\tfore (i, u, v) if (bord[i].x < bord[i].y)\n\t\t\t\tans += cntY[bord[i].x];\n\t\t\t\n\t\t\tfore (i, u, v) if (bord[i].x < bord[i].y)\n\t\t\t\tcntY[bord[i].x]++;\n\t\t\t\n\t\t\tu = v;\n\t\t}\n\t\t\n\t\t\n\t\tfore (i, 0, k)\n\t\t\tswap(ps[i].x, ps[i].y);\n\t\tswap(x, y);\n\t\tswap(n, m);\n\t}\n\t\n\tcout << ans << endl;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint tt = clock();\n#endif\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0), cout.tie(0);\n\tcout << fixed << setprecision(15);\n\t\n\tint t; cin >> t;\n\twhile (t--) {\n\t\tread();\n\t\tsolve();\n\t\t\n#ifdef _DEBUG\n\t\tcerr << \"TIME = \" << clock() - tt << endl;\n\t\ttt = clock();\n#endif\n\t}\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}