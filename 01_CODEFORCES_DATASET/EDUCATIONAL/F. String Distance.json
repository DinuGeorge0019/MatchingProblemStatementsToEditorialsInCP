{"link": "https://codeforces.com//contest/1535/problem/F", "problemId": "1005287", "shortId": "1535F", "contest_number": "1535", "name": "F. String Distance", "statement": "Suppose you are given two strings  and . You can apply the following operation any number of times: choose any  substring of  or , and sort the characters in it in non-descending order. Let  the minimum number of operations you have to apply in order to make them equal (or  if it is impossible to make  and  equal using these operations).For example:   ;   (in one operation, we can sort the whole first string);   (in one operation, we can sort the substring of the second string starting from the -nd character and ending with the -th character);  . You are given  strings  having equal length. Calculate .", "input": "The first line contains one integer  () \u2014 the number of strings. Then  lines follow, each line contains one of the strings , consisting of lowercase Latin letters. , and . All these strings are pairwise distinct.", "output": "Print one integer: .", "tutorial": "Disclaimer: the model solution is very complicated compared to most participants' solutions. Feel free to discuss your approaches in the comments!First of all, it's easy to determine when two strings cannot be made equal using these operations: it's when their multisets of characters differ. So, we divide the strings into different equivalence classes, and for any pair of strings from different classes, the answer is . For any pair of strings from the same class, the answer is either  or , since  operations are always enough to make the strings from the same equivalence class equal (we just sort both of them). Okay, now, for each class, we have to calculate the number of pairs of strings with the distance equal to .Okay, suppose you have two strings  and , and you want to make them equal using one operation. Suppose that  lexicographically. Since applying an operation can't result in getting a lexicographically larger string, we should apply the operation on the string , not . Suppose we choose a substring  of the string  and sort it. All characters to the left of position  and to the right of position  are untouched, and all characters in  are ordered in non-descending order; so, in order to transform  into , we should choose a subsegment  such that all characters outside this segment are the same in both strings, and the substring  of  is sorted. So, the best way to choose a subsegment  is to compute the longest common prefix of  and , the longest common suffix of  and , and try sorting everything in the middle in . This gives us a solution in : for a pair of strings, we can check that one of them can be transformed into the other in . To do so, we need to build some data structure allowing to query longest common prefixes/suffixes in  (a trie with  LCA or precalculating LCP and building a sparse table of them can do the trick); furthermore, we want to be able to check if some subsegment of some string is sorted in  (but precalculating them is quite easy). So, we have a solution that works if the strings are long (in the model solution, this approach is used on classes having not more than  strings).The second approach can be used on classes having many strings. If the number of strings is big, it means that they are short, so we can do the following thing: for each string, iterate on the subsegment we will sort and check if the resulting string exists. The model solution uses some very complicated data structures to implement this, but I believe that it's quite easy to get this approach working using string hashes.The only dangerous thing in the second solution you have to consider is that choosing different substrings to sort may result in getting the same resulting string. One good way to deal with this is to ignore some substrings if sorting them doesn't change the leftmost or the rightmost character in the substring; for example, if we sort the substring  in the string , the character in the beginning of this substring is unchanged, so we can get the same result by sorting . So, we consider sorting the substring only if it changes both the first and the last characters of the substring.Okay, so we have two approaches: one works well with a small number of long strings, and the other works well with a big number of short strings. We can choose which of them to run depending on the size of the equivalence class we are considering, and this idea gives us a working solution.", "solution": "#include<bits/stdc++.h>   \nusing namespace std;\n\nconst int LN = 20;\nconst int K = 12000;\n\nint pw2[1 << LN];\n\nvector<int> sorted_segments(const string& s)\n{\n \tint n = int(s.size()) - 1;\n \tvector<int> res(n);\n \tfor(int i = 0; i < n; i++)\n \t\tif(s[i] <= s[i + 1])\n \t\t\tres[i] = 0;\n \t\telse\n \t\t\tres[i] = 1;\n \treturn res;\n}\n\nvector<int> prefix_sum(const vector<int>& s)\n{\n \tint n = s.size();\n \tvector<int> p(n + 1);\n \tfor(int i = 0; i < n; i++)\n \t\tp[i + 1] = p[i] + s[i];\n \treturn p;\n}\n\nint naiveLCP(const string& s, const string& t)\n{\n \tint ans = 0;\n \tint n = s.size();\n \tint m = t.size();\n \twhile(ans < n && ans < m && s[ans] == t[ans])\n \t\tans++;\n \treturn ans;\n}\n\nvector<vector<int>> build_table(const vector<int>& a)\n{\n\tint n = a.size();\n\tvector<vector<int>> table(LN, vector<int>(n));\n\tfor(int i = 0; i < n; i++)\n\t\ttable[0][i] = a[i];\n\tfor(int i = 1; i < LN; i++)\n\t\tfor(int j = 0; j < n; j++)\n\t\t\tif(j + (1 << (i - 1)) < n)\n\t\t\t\ttable[i][j] = min(table[i - 1][j], table[i - 1][j + (1 << (i - 1))]);\n\t\t\telse\n\t\t\t\ttable[i][j] = table[i - 1][j];\n\treturn table; \t\n}\n\nstruct LCP\n{\n \tvector<int> idx;\n \tvector<vector<int>> table;\n\n \tint query_inner(int x, int y)\n \t{\n \t \tif(x > y) swap(x, y);\n \t \tint len = y - x;\n \t \tint d = pw2[len];\n \t \treturn min(table[d][x], table[d][y - (1 << d)]);\n \t}\n\n \tint query(int x, int y)\n \t{\n \t \treturn query_inner(idx[x], idx[y]);\n \t}\n\n \tLCP() {};\n \tLCP(vector<string> s) \n \t{\n \t\tint n = s.size();\n\t\tvector<pair<string, int>> t;\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t \tt.push_back(make_pair(s[i], i));\n\t   \t}\n\t   \tsort(t.begin(), t.end());\n\t   \tidx.resize(n);\n\t   \tfor(int i = 0; i < n; i++)\n\t   \t{\n\t   \t\tidx[t[i].second] = i;\n\t   \t}\n\t   \tvector<int> LCPs;\n\t   \tfor(int i = 0; i < n - 1; i++)\n\t   \t\tLCPs.push_back(naiveLCP(t[i].first, t[i + 1].first));\n\t   \ttable = build_table(LCPs);\t\t\n \t};\n};\n\nconst int T = int(2e7);\n\nmap<char, int> nxt[T];\nint cur = 1;\nint root = 0;\nint cnt[T];\n\nvoid clear_trie()\n{\n \troot = cur++;\n}\n\nint go(int x, char c)\n{\n \tif(!nxt[x].count(c))\n \t\tnxt[x][c] = cur++;\n \treturn nxt[x][c];\n}\n\nvoid add(int v, const string& s, int l, int r, int n, bool sw, const vector<int>& ps)\n{\n\tif(sw && l + r < n - 1 && ps[n - r - 1] == ps[l])\n\t{\n\t\tcnt[v]++;\n\t}\n\tif(sw)\n\t{\n\t\tif(l + r < n - 1)\n\t\t\tadd(go(v, s[n - r - 1]), s, l, r + 1, n, sw, ps);\n \t}\n \telse\n \t{\n \t\tadd(go(v, '$'), s, l, r, n, true, ps);\n \t\tif(l < n - 1)\n \t\t\tadd(go(v, s[l]), s, l + 1, r, n, sw, ps);\n \t}\n}\n\nint calc(int v, const string& s, int l, int r, int n, bool sw, const vector<vector<int>>& good)\n{\n\tint ans = 0;\n\tif(sw && l + r < n - 1 && good[l][r])\n\t{\n\t\tans = cnt[v];\n\t}\n\tif(sw)\n\t{\n\t\tif(l + r < n)\n\t\t\tans += calc(go(v, s[n - r - 1]), s, l, r + 1, n, sw, good);\n\t}\n\telse\n\t{\n\t \tans += calc(go(v, '$'), s, l, r, n, true, good);\n\t \tif(l < n)\n\t \t\tans += calc(go(v, s[l]), s, l + 1, r, n, sw, good);\t\n\t}\n\treturn ans;\n}\n\nlong long solve_short(vector<string> s, int n)\n{\n\tlong long ans = 0;\n \tclear_trie();\n \tsort(s.begin(), s.end());\n \tfor(int i = 0; i < n; i++)\n \t{\n \t \tstring cur = s[i];\n \t \tint len = cur.size();\n \t \tvector<vector<int>> good(len + 1, vector<int>(len + 1));\n \t \tfor(int l = 0; l < len; l++)\n \t \t{\n \t \t \tset<char> q;\n \t \t \tfor(int r = l; r < len; r++)\n \t \t \t{\n \t \t \t \tq.insert(cur[r]);\n \t \t \t \tif(cur[l] != *q.begin() && cur[r] != *q.rbegin())\n \t \t \t \t{\n \t \t \t \t\tgood[l][len - r - 1] = 1;\n \t \t \t \t}\n \t \t \t}\n \t \t}\n \t \tvector<int> p = prefix_sum(sorted_segments(cur));\n \t \tadd(root, cur, 0, 0, len, false, p);\n \t \tans += calc(root, cur, 0, 0, len, false, good);\n \t}\n \tans = n * 1ll * (n - 1) - ans;\n \treturn ans;\n}\n\nlong long solve_long(vector<string> s, int n)\n{                     \n\tint len = s[0].size();\n \tsort(s.begin(), s.end());\n \tvector<string> t = s;\n \tfor(int i = 0; i < n; i++)\n \t\treverse(t[i].begin(), t[i].end());\n \tLCP ls(s);\n \tLCP lt(t);\n \tlong long ans = 0;\n \tfor(int i = 0; i < n; i++)\n \t{\n \t \tvector<int> aux = prefix_sum(sorted_segments(s[i]));\n \t \tfor(int j = i + 1; j < n; j++)\n \t \t{\n \t \t \tint lf = ls.query(i, j);\n \t \t \tint rg = lt.query(i, j);\n \t \t \tif(aux[len - rg - 1] - aux[lf] == 0)\n \t \t \t\tans++;\n \t \t \telse\n \t \t \t\tans += 2;\n \t \t}\n\t}\n\treturn ans;\n}\n\nlong long solve_class(vector<string> s, int n)\n{                       \n\tif(n <= K)\n\t\treturn solve_long(s, n);\n\telse\n\t\treturn solve_short(s, n); \t\n}\n\nvector<int> get_class(string s)\n{\n\tvector<int> c(26);\n\tfor(auto x : s) c[x - 'a']++;\n\treturn c;\n}\n\nint main()\n{\n\tpw2[1] = 0;\n\tfor(int i = 2; i < (1 << LN); i++)\n\t\tpw2[i] = pw2[i >> 1] + 1;\n\tint n;\n\tcin >> n;\n\tvector<string> s(n);\n\tfor(int i = 0; i < n; i++)   \n\t\tcin >> s[i];         \n\tlong long ans = 0;\n\tmap<vector<int>, vector<string>> classes;\n\tfor(int i = 0; i < n; i++)\n\t\tclasses[get_class(s[i])].push_back(s[i]);\n\tint cnt = 0;\n\tfor(auto x : classes)\n\t{                       \n\t \tans += solve_class(x.second, x.second.size());\n\t \tans += cnt * 1337ll * x.second.size();\n\t \tcnt += x.second.size();\n\t}\n\tcout << ans << endl;\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}