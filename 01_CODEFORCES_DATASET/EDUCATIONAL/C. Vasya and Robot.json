{"link": "https://codeforces.com//contest/1073/problem/C", "problemId": "243298", "shortId": "1073C", "contest_number": "1073", "name": "C. Vasya and Robot", "statement": "Vasya has got a robot which is situated on an infinite Cartesian plane, initially in the cell . Robot can perform the following four kinds of operations:    \u2014 move from  to ;   \u2014 move from  to ;   \u2014 move from  to ;   \u2014 move from  to . Vasya also has got a sequence of  operations. Vasya wants to modify this sequence so after performing it the robot will end up in .Vasya wants to change the sequence so the length of changed subsegment is minimum possible. This length can be calculated as follows: , where  is the maximum index of a changed operation, and  is the minimum index of a changed operation. For example, if Vasya changes  to , then the operations with indices ,  and  are changed, so the length of changed subsegment is . Another example: if Vasya changes  to , then the length of changed subsegment is . Help Vasya! Tell him the minimum length of subsegment that he needs to change so that the robot will go from  to , or tell him that it's impossible.", "input": "The first line contains one integer number  \u2014 the number of operations. The second line contains the sequence of operations \u2014 a string of  characters. Each character is either , ,  or . The third line contains two integers  \u2014 the coordinates of the cell where the robot should end its path.", "output": "Print one integer \u2014 the minimum possible length of subsegment that can be changed so the resulting sequence of operations moves the robot from  to . If this change is impossible, print .", "tutorial": "Denote . If , then the answer is -1, since the robot will not have the time to reach  cell in  steps. Also, if  and  have different parity, then the answer is also -1, as in one move the robot changes the parity of the sum of its coordinates.In all other cases, the answer exists. Let's use binary search to solve this problem. Consider all segments of length . For a fixed length of the segment , let's iterate over the position of the beginning of the segment . At the same time, we will maintain the cell that the robot will stop at if it execute all commands, except commands with indices . We denote this position as . We also calculate the distances from the cell  to the cell  \u2014 the value . If there is at least one position of the beginning of the segment for which , then we can change the segment of length  so that the robot comes to the  cell, otherwise it can't.", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(1e5) + 9;\n\nstring s;\nint n;\nint x, y;\n\nvoid upd(pair<int, int> &pos, char mv, int d){\n\tif(mv == 'U')\n\t\tpos.second += d;\n\tif(mv == 'D')\n\t\tpos.second -= d;\n\tif(mv == 'L')\n\t\tpos.first -= d;\n\tif(mv == 'R')\n\t\tpos.first += d;\n}\n\nbool can(pair<int, int> u, pair<int, int> v, int len){\n\tint d = abs(u.first - v.first) + abs(u.second - v.second);\n\tif(d % 2 != len % 2) return false;\n\treturn len >= d;\n}\n\nbool ok(int len){\n\tpair<int, int> pos = make_pair(0, 0);\n\tfor(int i = len; i < n; ++i)\n\t\tupd(pos, s[i], 1);\n\n\tint l = 0, r = len;\n\twhile(true){\n\t\tif(can(pos, make_pair(x, y), len))\n\t\t\treturn true;\n\t\t\n\t\tif(r == n) break;\n\t\tupd(pos, s[l++], 1);\n\t\tupd(pos, s[r++], -1);\t\t\n\t}\n\t\n\treturn false;\n}\n\nint main() {\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t\n\tcin >> n;\n\tcin >> s;\n\tcin >> x >> y;\n\t\n\tif(!ok(n)){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\t\n\tint l = -1, r = n;\n\twhile(r - l > 1){\n\t\tint mid = (l + r) / 2;\n\t\tif(ok(mid)) r = mid;\n\t\telse l = mid;\n\t}\n\t\n\tcout << r << endl;\n    return 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}