{"link": "https://codeforces.com//contest/976/problem/F", "problemId": "179790", "shortId": "976F", "contest_number": "976", "name": "F. Minimal k-covering", "statement": "You are given a bipartite graph ,  is the set of vertices of the first part,  is the set of vertices of the second part and  is the set of edges. There might be multiple edges.Let's call some subset of its edges   iff the graph  has each of its vertices incident to at least  edges.  is such a -covering that the size of the subset  is minimal possible.Your task is to find minimal -covering for each , where  is the minimal degree of any vertex in graph .", "input": "The first line contains three integers ,  and  (, ) \u2014 the number of vertices in the first part, the number of vertices in the second part and the number of edges, respectively. The -th of the next  lines contain two integers  and  () \u2014 the description of the -th edge,  is the index of the vertex in the first part and  is the index of the vertex in the second part.", "output": "For each  print the subset of edges (minimal -covering) in separate line. The first integer  of the -th line is the number of edges in minimal -covering of the graph. Then  integers follow \u2014 original indices of the edges which belong to the minimal -covering, these indices should be pairwise distinct. Edges are numbered  through  in order they are given in the input.", "tutorial": "To get the answer for some  we can build the following network: connect the source to every vertex of the first part with edge with capacity  (where  is the degree of vertex), then transform every edge of the original graph into a directed edge with capacity , and then connect each vertex from the second part to the sink with capacity . Then edges saturated by the maxflow are not present in the answer (and all other edges are in the answer).To solve it fastly, we might just iterate on  from its greatest value to  and each time augment the flow we found on previous iteration. Since maxflow in the network is at most , and we will do not more than  searches that don't augment the flow, this solution is .", "solution": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n\n#define sz(a) int((a).size())\n#define x first\n#define y second\n\nconst int INF = int(1e9);\nconst int N = 4221;\n\nstruct edge {\n    int to, c, f, id;\n\n    edge(int to = 0, int c = 0, int f = 0, int id = -1) : to(to), c(c), f(f), id(id) {}\n};\n\nvector<edge> es;\nvector<int> g[N];\n\nvoid add_edge(int fr, int to, int cap, int id) {\n    g[fr].push_back(sz(es));\n    es.emplace_back(to, cap, 0, id);\n    g[to].push_back(sz(es));\n    es.emplace_back(fr, 0, 0, id);\n}\n\nint pw[N];\nint n1, n2, m;\n\ninline bool read() {\n    if(!(cin >> n1 >> n2 >> m))\n        return false;\n\n    fore(id, 0, m) {\n        int u, v;\n        assert(cin >> u >> v);\n        u--, v--;\n\n        pw[u]++;\n        pw[n1 + v]++;\n\n        add_edge(u, n1 + v, 1, id);\n    }\n    return true;\n}\n\nint d[N], q[N], hd, tl;\ninline bool bfs(int s, int t, int n) {\n    fore(i, 0, n)\n        d[i] = INF;\n    hd = tl = 0;\n\n    d[s] = 0;\n    q[tl++] = s;\n    while(hd != tl) {\n        int v = q[hd++];\n        if(v == t)\n            break;\n\n        for(int id : g[v]) {\n            if(es[id].c - es[id].f == 0)\n                continue;\n\n            int to = es[id].to;\n            if(d[to] > d[v] + 1) {\n                d[to] = d[v] + 1;\n                q[tl++] = to;\n            }\n        }\n    }\n    return d[t] < INF;\n}\n\nint nxt[N];\n\nint dfs(int v, int t, int mx) {\n    if(v == t) return mx;\n    if(mx == 0) return 0;\n\n    int sum = 0;\n    for(; nxt[v] < sz(g[v]); nxt[v]++) {\n        int id = g[v][nxt[v]];\n        int rem = es[id].c - es[id].f;\n        int to = es[id].to;\n\n        if(rem == 0 || d[to] != d[v] + 1)\n            continue;\n\n        int cur = 0;\n        if((cur = dfs(to, t, min(mx - sum, rem))) > 0) {\n            es[id].f += cur;\n            es[id ^ 1].f -= cur;\n            sum += cur;\n        }\n\n        if(sum == mx)\n            break;\n    }\n    return sum;\n}\n\ninline int dinic(int s, int t, int n) {\n    int mf = 0;\n    while(bfs(s, t, n)) {\n        fore(i, 0, n)\n            nxt[i] = 0;\n\n        int cf = 0;\n        while((cf = dfs(s, t, INF)) > 0)\n            mf += cf;\n    }\n    return mf;\n}\n\nvector<int> res[N];\n\ninline void getCert(int k) {\n    fore(v, 0, n1) {\n        for(int id : g[v]) {\n            if(es[id].to < n1 || es[id].to >= n1 + n2)\n                continue;\n            assert(es[id].c > 0);\n            if(es[id].f > 0)\n                continue;\n\n            res[k].push_back(es[id].id);\n        }\n    }\n}\n\nvoid solve() {\n    int cnt = *min_element(pw, pw + n1 + n2);\n\n    int s = n1 + n2; int t = s + 1;\n    fore(i, 0, n1)\n        add_edge(s, i, pw[i] - cnt, -1);\n    fore(i, n1, n1 + n2)\n        add_edge(i, t, pw[i] - cnt, -1);\n\n    int mf = 0, mn = cnt;\n    while(mn >= 0) {\n        mf += dinic(s, t, n1 + n2 + 2);\n        getCert(mn);\n\n        if(mn > 0) {\n            for (int id : g[s]) {\n                assert(es[id].id < 0);\n                assert((id & 1) == 0);\n                es[id].c++;\n            }\n            for (int id : g[t]) {\n                assert(es[id].id < 0);\n                assert(es[id].c == 0);\n                es[id ^ 1].c++;\n            }\n        }\n        mn--;\n    }\n\n    fore(i, 0, cnt + 1) {\n        printf(\"%d \", sz(res[i]));\n        for(int id : res[i])\n            printf(\"%d \", id + 1);\n        puts(\"\");\n    }\n}\n\nint main() {\n#ifdef _DEBUG\n    freopen(\"input.txt\", \"r\", stdin);\n#endif\n\n    if(read()) {\n        solve();\n    }\n    return 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}