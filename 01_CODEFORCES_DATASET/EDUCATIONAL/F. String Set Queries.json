{"link": "https://codeforces.com//contest/710/problem/F", "problemId": "68764", "shortId": "710F", "contest_number": "710", "name": "F. String Set Queries", "statement": "You should process  queries over a set  of strings. Each query is one of three kinds:  Add a string  to the set . It is guaranteed that the string  was not added before.  Delete a string  from the set . It is guaranteed that the string  is in the set .  For the given string  find the number of occurrences of the strings from the set . If some string  from  has several occurrences in  you should count all of them. Note that you should solve the problem in  mode. It means that you can't read the whole input at once. You can read each query only after writing the answer for the last query of the third type. Use functions  in  and  in  languages after each writing in your program.", "input": "The first line contains integer  () \u2014 the number of queries. Each of the next  lines contains integer  () and nonempty string  \u2014 the kind of the query and the string to process. All strings consist of only lowercase English letters. The sum of lengths of all strings in the input will not exceed .", "output": "For each query of the third kind print the only integer  \u2014 the desired number of occurrences in the string .", "tutorial": "Let's get rid of the queries for deleting a string. There are no strings that will be added two times, so we can calculate the answer for the added (but not deleted strings) and for the deleted separately and subtract the second from the first to get the answer. So we can consider that there are no queries of deletion.\nNow let's use Aho-Corasik algorithm. The only difficulty is that the strings are adding in online mode, but Aho-Corasik algorithm works only after adding all the strings. Note that the answer for the given set of strings equal to the answer for any part of the set plus the answer for the remaining part. Let's use the trick with converting the static data structure (Aho-Corasik in this case) to the dynamic one.\nFor the set of  strings let's maintain a set of no more than  sets of the strings with sizes of different powers of two. After adding new string we should move the sets from the lowest powers of two to the largest until we got an invariant set of sets.\nEasy to see that each string will be moved no more than  times, so we can process each query in  time.\n", "solution": "const int N = 4 * 300300, A = 26, LOGN = 20;\n\nstruct node {\n    char c;\n    int parent, link, output;\n    int next[A], automata[A];\n\t\tint cnt;\n    \n    node(char c = -1, int parent = -1, int link = -1, int output = -1, int cnt = -1):\n        c(c), parent(parent), link(link), output(output), cnt(cnt) {\n        memset(next, -1, sizeof(next));\n        memset(automata, -1, sizeof(automata));\n    }\n};\nnode t[N];\n\nvector<int> ids;\ninline int get_idx() {\n\tassert(!ids.empty());\n\tint ans = ids.back();\n\tids.pop_back();\n\tt[ans] = node();\n\treturn ans;\n}\ninline void return_idx(int idx) {\n\tids.pb(idx);\n}\n\ninline int add(const string& s, int root) {\n    int v = root;\n    forn(i, sz(s)) {\n        if (t[v].next[s[i] - 'a'] == -1) {\n\t\t\t\t\tint idx = get_idx();\n\t\t\t\t\tt[v].next[s[i] - 'a'] = idx;\n\t\t\t\t\tt[idx] = node(s[i], v, -1, -1);\n        }\n        v = t[v].next[s[i] - 'a'];\n    }\n    t[v].output = v;\n    return v;\n}\nint link(int v, int root) {\n    int& ans = t[v].link;\n    if (ans != -1) return ans;\n\t\tif (v == root || t[v].parent == root) return ans = root;\n    char c = t[v].c;\n    int vv = link(t[v].parent, root);\n    while (vv != root && t[vv].next[c - 'a'] == -1)\n        vv = link(vv, root);\n    return ans = (t[vv].next[c - 'a'] == -1? root: t[vv].next[c - 'a']);\n}\nint output(int v, int root) {\n    int& ans = t[v].output;\n    if (ans != -1) return ans;\n    return ans = (v == root? root: output(link(v, root), root));\n}\nint cnt(int v, int root) {\n\tint& ans = t[v].cnt;\n\tif (ans != -1) return ans;\n\tv = output(v, root);\n\tif (v == root) return ans = 0;\n\treturn ans = 1 + cnt(link(v, root), root);\n}\nint next(int v, char c, int root) {\n    int& ans = t[v].automata[c - 'a'];\n    if (ans != -1) return ans;\n    if (t[v].next[c - 'a'] != -1)\n        return ans = t[v].next[c - 'a'];\n    return ans = (v == root? root: next(link(v, root), c, root));\n}\n\nvoid dfs_clear(int v) {\n\tforn(i, A) if (t[v].next[i] != -1) dfs_clear(t[v].next[i]);\n\treturn_idx(v);\n}\n\nstring a[N];\n\nint build(int root, const vector<int>& ids) {\n\tdfs_clear(root);\n\troot = get_idx();\n\tforn(i, sz(ids)) add(a[ids[i]], root);\n\treturn root;\n}\n\nint calc(int root, int idx) {\n\tint ans = 0;\n\tconst string& s = a[idx];\n\tint v = root;\n\tforn(i, sz(s)) {\n\t\tv = next(v, s[i], root);\n\t\tans += cnt(v, root);\n\t}\n\treturn ans;\n}\n\nint m;\n\nbool read() {\n\treturn !!(cin >> m);\n}\n\nstruct blocks {\n\tint root[LOGN];\n\tvector<int> block[LOGN];\n\n\tvoid clear() {\n\t\tforn(i, LOGN) {\n\t\t\tblock[i].clear();\n\t\t\troot[i] = get_idx();\n\t\t}\n\t}\n\n\tvoid insert(int i) {\n\t\tvector<int> cur(1, i);\n\t\tforn(i, LOGN)\n\t\t\tif (sz(block[i]) == sz(cur)) {\n\t\t\t\tcur.insert(cur.end(), all(block[i]));\n\t\t\t\tblock[i].clear();\n\t\t\t\troot[i] = build(root[i], block[i]);\n\t\t\t} else {\n\t\t\t\tblock[i] = cur;\n\t\t\t\troot[i] = build(root[i], block[i]);\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\n\tli calc2(int idx) {\n\t\tli ans = 0;\n\t\tforn(i, LOGN) {\n\t\t\tans += calc(root[i], idx);\n\t\t}\n\t\treturn ans;\n\t}\n};\n\nchar buf[N];\nblocks z1, z2;\n\nvoid solve() {\n\tids.clear();\n\tnfor(i, N) ids.pb(i);\n\n\tz1.clear();\n\tz2.clear();\n\n\tforn(i, m) {\n\t\tint type;\n\t\tassert(scanf(\"%d%s\", &type, buf) == 2);\n\t\ta[i] = buf;\n\n\t\tif (type == 1) {\n\t\t\tz1.insert(i);\n\t\t} else if (type == 2) {\n\t\t\tz2.insert(i);\n\t\t} else if (type == 3) {\n\t\t\tli ans = z1.calc2(i) - z2.calc2(i);\n\t\t\tprintf(\"%lld\\n\", ans);\n\t\t\tfflush(stdout);\n\t\t} else throw;\n\t}\n}", "interactive": false, "noSolution": false, "noTutorial": false}