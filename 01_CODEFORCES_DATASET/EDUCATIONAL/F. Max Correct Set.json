{"link": "https://codeforces.com//contest/1463/problem/F", "problemId": "836006", "shortId": "1463F", "contest_number": "1463", "name": "F. Max Correct Set", "statement": "Let's call the set of positive integers   if the following two conditions are met:   ;  if  and , then  and . For the given values , , and , you have to find the maximum size of the  set.", "input": "A single line contains three integers ,  and  (; ). ", "output": "Print one integer \u2014 the maximum size of the  set.", "tutorial": "The key idea of the task is to prove that there is an optimal answer where the chosen elements in  has a period equal to . Let's work with  instead of .Firstly, let's prove that if we've chosen correct set  in interval  then if we take all  then set  will be corect as well. By contradiction: suppose we have  (), then  () or  ()\u00a0\u2014 contradiction.It means that if we take the correct set in interval  we can create a periodic answer by copying this interval several times.Next, let's prove that there is an optimal periodic answer. Let's look at any optimal answer and its indicator vector (binary vector of length  where  iff  is in the set). Let .Let's split the vector in  intervals: . The -st, -rd, -th... segments have length  and -nd, -th,... segments have length . If we choose any two consecutive segments its total length will be equal to  and we can use it to make periodic answer by replacing all length  segments with the chosen one and  segments with the other one.We can prove that we can always find such two consecutive segments that the induced answer will be greater or equal to the initial one. If we create vector where  is equal to the sum of  in the -th segment, then the task is equivalent to finding  and  such that replacing all  by  and all  by  won't decrease array  sum. The proof is down below.Now, since the answer is periodical, taking element  () is equivalent to taking all elements , so for each  we can calc \u00a0\u2014 the number of integers with the same remainder. And for each  we either take it or not.So we can write , where  is the maximum sum if we processed  elements and last  elements are described by mask . We start with  and, when look at the -th element, either take it (if we can) or skip it.Time complexity is .==========Let's prove that for any array  we can find pair  such that replacing all  with  and all  with  won't decrease the total sum.Let's define  and . Let's make array , where  and . The meaning behind  is how changes the total sum if we replace corresponding elements by .Note, that finding a good pair  is equivalent to finding . Also, note that  and analogically, .Let's prove by contradiction: suppose that for any  . Let's look at . But from the other side, we know that , , ..., , so , otherwise  will be negative.In the same way, since , , ..., , then . Analogically we can prove that each , but \u00a0\u2014 contradiction. So, there is always a pair , i.\u00a0e. a pair . ", "solution": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1e9;\nconst int N = 22;\n\nint dp[2][1 << N];\nint val[2 * N];\n\nint main() {\n\tint n, x, y;\n\tscanf(\"%d%d%d\", &n, &x, &y);\n\t\n\tint k = x + y;\n\tint m = max(x, y);\n\tint FULL = (1 << m) - 1;\n\t\n\tfor (int i = 0; i < k; ++i)\n\t\tval[i] = n / k + (i < n % k);\n\tfor (int mask = 0; mask < (1 << m); ++mask)\n\t\tdp[0][mask] = -INF;\n\tdp[0][0] = 0;\n\t\n\tfor (int i = 0; i < k; ++i) {\n\t\tfor (int mask = 0; mask < (1 << m); ++mask)\n\t\t\tdp[1][mask] = -INF;\n\t\tfor (int mask = 0; mask < (1 << m); ++mask) {\n\t\t\tif (dp[0][mask] == -INF)\n\t\t\t\tcontinue;\n\t\t\tint nmask = (mask << 1) & FULL;\n\t\t\tdp[1][nmask] = max(dp[1][nmask], dp[0][mask]);\n\t\t\tif (((mask >> (x - 1)) & 1) | ((mask >> (y - 1)) & 1))\n\t\t\t\tcontinue;\n\t\t\tnmask |= 1;\n\t\t\tdp[1][nmask] = max(dp[1][nmask], dp[0][mask] + val[i]);\n\t\t}\n\t\tswap(dp[0], dp[1]);\n\t}\n\t\n\tint ans = 0;\n\tfor (int mask = 0; mask < (1 << m); ++mask) \n\t\tans = max(ans, dp[0][mask]);\n\tprintf(\"%d\\n\", ans);\n}", "interactive": false, "noSolution": false, "noTutorial": false}