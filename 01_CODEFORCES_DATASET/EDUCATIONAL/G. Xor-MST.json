{"link": "https://codeforces.com//contest/888/problem/G", "problemId": "133220", "shortId": "888G", "contest_number": "888", "name": "G. Xor-MST", "statement": "You are given a complete undirected graph with  vertices. A number  is assigned to each vertex, and the weight of an edge between vertices  and  is equal to .Calculate the weight of the minimum spanning tree in this graph.", "input": "The first line contains  () \u2014 the number of vertices in the graph. The second line contains  integers , , ...,  () \u2014 the numbers assigned to the vertices.", "output": "Print one number \u2014 the weight of the minimum spanning tree in the graph.", "tutorial": "We can use Boruvka's algorithm to solve this problem.This algorithm usually works in : initially MST is empty, and then we run a number of iterations. During each iteration we find connected components in the graph formed by already added edges, and for each component we find the shortest edge that leads out of this component. Then we add the edges we found to the MST (but we should be careful to avoid adding edges that form cycles in MST). The number of iterations is at most , and each of iterations can be done in .However, in this problem we need to speed up this algorithm. We can do each iteration in  time using a binary trie. We can store all values from  in a trie. When we need to find the shortest edge that connects some component with vertices outside of it, we firstly remove all values contained in this component from the trie. After that, for each vertex in the component we can find the closest vertex outside the component in  by descending the trie. And then we insert the values of  belonging to the component back into the trie. Since for each vertex we descend the trie three times (to remove it, to find closest vertex and to add it back), each iteration requries , and the whole algorithm works in  time.", "solution": "// eddy1021\n#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef double D;\ntypedef long double LD;\ntypedef long long LL;\ntypedef pair<int,int> PII;\ntypedef pair<LL,LL> PLL;\n#define mod9 1000000009LL\n#define mod7 1000000007LL\n#define INF  1023456789LL\n#define INF16 10000000000000000LL\n#define eps 1e-9\n#define SZ(x) (int)(x).size()\n#define ALL(x) (x).begin(), (x).end()\n#define IOS ios_base::sync_with_stdio(0); cin.tie(0)\n#ifndef ONLINE_JUDGE\n#define debug(...) printf(__VA_ARGS__)\n#else \n#define debug(...)\n#endif\ninline LL getint(){\n  LL _x=0,_tmp=1; char _tc=getchar();    \n  while( (_tc<'0'||_tc>'9')&&_tc!='-' ) _tc=getchar();\n  if( _tc == '-' ) _tc=getchar() , _tmp = -1;\n  while(_tc>='0'&&_tc<='9') _x*=10,_x+=(_tc-'0'),_tc=getchar();\n  return _x*_tmp;\n}\ninline LL add( LL _x , LL _y , LL _mod = mod7 ){\n  _x += _y;\n  return _x >= _mod ? _x - _mod : _x;\n}\ninline LL sub( LL _x , LL _y , LL _mod = mod7 ){\n  _x -= _y;\n  return _x < 0 ? _x + _mod : _x;\n}\ninline LL mul( LL _x , LL _y , LL _mod = mod7 ){\n  _x *= _y;\n  return _x >= _mod ? _x % _mod : _x;\n}\nLL mypow( LL _a , LL _x , LL _mod ){\n  if( _x == 0 ) return 1LL;\n  LL _ret = mypow( mul( _a , _a , _mod ) , _x >> 1 , _mod );\n  if( _x & 1 ) _ret = mul( _ret , _a , _mod );\n  return _ret;\n}\nLL mymul( LL _a , LL _x , LL _mod ){\n  if( _x == 0 ) return 0LL;\n  LL _ret = mymul( add( _a , _a , _mod ) , _x >> 1 , _mod );\n  if( _x & 1 ) _ret = add( _ret , _a , _mod );\n  return _ret;\n}\ninline bool equal( D _x ,  D _y ){\n  return _x > _y - eps && _x < _y + eps;\n}\nvoid sleep( double sec = 1021 ){\n  clock_t s = clock();\n  while( clock() - s < CLOCKS_PER_SEC * sec );\n}\n#define Bye exit(0)\nint __ = 1 , _cs;\n/*********default*********/\nvoid build(){\n\n}\n#define N 201010\nint p[ N ];\nint f( int x ){\n  return x == p[ x ] ? x : p[ x ] = f( p[ x ] );\n}\nvoid uni( int x , int y ){\n  p[ f( x ) ] = f( y );\n}\nstruct Nd{\n  Nd *t[ 2 ];\n  Nd(){\n    t[ 0 ] = t[ 1 ] = NULL;\n  }\n};\nvoid modify( Nd* now , int vl , int bt ){\n  if( bt < 0 ) return;\n  int son = (vl >> bt) & 1;\n  if( !now->t[ son ] )\n    now->t[ son ] = new Nd();\n  modify( now->t[ son ] , vl , bt - 1 );\n}\nint n , a[ N ];\nvoid init(){\n  n = getint();\n  for( int i = 0 ; i < n ; i ++ )\n    a[ i ] = getint();\n  sort( a , a + n );\n  n = unique( a , a + n ) - a;\n}\nLL ans;\nmap<int,int> id;\nvector< pair<int,pair<int,int>> > e;\nvoid add_edge( int i1 , int i2 , int c ){\n  e.push_back( { c , { i1 , i2 } } );\n}\nvoid gogo( Nd* now , int vl , int bt , int cur , bool same ){\n  if( bt < 0 ){\n    if( same ) return;\n    //cerr << vl << \" \" << cur << endl;\n    add_edge( id[ vl ] , id[ cur ] , vl ^ cur );\n    return;\n  }\n  if( same ){\n    for( int i = 0 ; i < 2 ; i ++ )\n      if( now->t[ i ] )\n        gogo( now->t[ i ] , vl , bt - 1 , cur + i * (1 << bt) , \n              i == ((vl >> bt) & 1));\n  }else{\n    int nd = (vl >> bt) & 1;\n    for( int i = 0 ; i < 2 ; i ++ )\n      if( now->t[ i ^ nd ] ){\n        gogo( now->t[ i ^ nd ] , vl , bt - 1 , \n              cur + (i ^ nd) * (1 << bt) ,\n              false );\n        break;\n      }\n  }\n}\nvoid solve(){\n  Nd *root = new Nd();\n  for( int i = 0 ; i < n ; i ++ ){\n    modify( root , a[ i ] , 29 );\n    id[ a[ i ] ] = i;\n  }\n  for( int i = 0 ; i < n ; i ++ )\n    gogo( root , a[ i ] , 29 , 0 , true );\n  sort( e.begin() , e.end() );\n  ans = 0;\n  for( int i = 0 ; i < n ; i ++ )\n    p[ i ] = i;\n  for( auto i : e )\n    if( f( i.second.first ) !=\n        f( i.second.second ) ){\n      ans += i.first;\n      uni( i.second.first ,\n           i.second.second );\n    }\n  cout << ans << endl;\n}\nint main(){\n  build();\n  //__ = getint();\n  while( __ -- ){\n    init();\n    solve();\n  }\n}\n", "interactive": false, "noSolution": false, "noTutorial": false}