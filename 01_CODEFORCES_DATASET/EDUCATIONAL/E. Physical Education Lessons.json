{"link": "https://codeforces.com//contest/915/problem/E", "problemId": "146472", "shortId": "915E", "contest_number": "915", "name": "E. Physical Education Lessons", "statement": "This year Alex has finished school, and now he is a first-year student of Berland State University. For him it was a total surprise that even though he studies programming, he still has to attend physical education lessons. The end of the term is very soon, but, unfortunately, Alex still hasn't attended a single lesson!Since Alex doesn't want to get expelled, he wants to know the number of working days left until the end of the term, so he can attend physical education lessons during these days. But in BSU calculating the number of working days is a complicated matter:There are  days left before the end of the term (numbered from  to ), and initially all of them are working days. Then the university staff sequentially publishes  orders, one after another. Each order is characterised by three numbers ,  and :  If , then all days from  to  (inclusive) become non-working days. If some of these days are made working days by some previous order, then these days still become non-working days;  If , then all days from  to  (inclusive) become working days. If some of these days are made non-working days by some previous order, then these days still become working days. Help Alex to determine the number of working days left after each order!", "input": "The first line contains one integer , and the second line \u2014 one integer  (, ) \u2014 the number of days left before the end of the term, and the number of orders, respectively. Then  lines follow, -th line containing three integers ,  and  representing -th order (, ).", "output": "Print  integers. -th of them must be equal to the number of working days left until the end of the term after the first  orders are published.", "tutorial": "Let's store current intervals with non-working days in set sorted by the right border. When new query comes you search for the first interval to have its right border greater or equal than the currect left border and update all intervals to intersect the query (either fully delete or insert back its part which doesn't intersect query). Finally, if  then insert the query into current set. Updates on the number of working days can be done while deleting segments on the fly.Overall complexity: .", "solution": "#define _CRT_SECURE_NO_DEPRECATE\n#pragma comment(linker, \"/STACK:167772160000\")\n#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <stdio.h>\n#include <cstdlib>\n#include <stdlib.h>\n#include <string>\n#include <list>\n#include <fstream>\n#include <algorithm>\n#include <cmath>\n#include <map>\n#include <vector>\n#include <iomanip>\n#include <queue>\n#include <deque>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <assert.h>\n#include <functional>\n#include <climits>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\n//typedef uint64_t ull;\n//typedef std::pair<long double,long double> pdd;\n#define for8(i) for( i = 1; i<=8; i++)\n#define fori(N)          for(int i = 0; i<(N); i++)\n#define forj(N)         for(int j = 0; j<(N); j++)\n#define fork(N)         for(int k = 0; k<(N); k++)\n#define forl(N)         for(int l = 0; l<(N); l++)\n#define ford(N)         for(int d = 0; d<(N); d++)\n#define fori1(N)          for(int i = 1; i<=(N); i++)\n#define forj1(N)         for(int j = 1; j<=(N); j++)\n#define fork1(N)         for(int k = 1; k<=(N); k++)\n#define ford1(N)         for(int d = 1; d<=(N); d++)\n#define PI (2*asin(1))\n#define read(n) scanf(\"%d\", &n);\n#define read2(n, m) scanf(\"%d%d\", &n, &m);\n#define readll(n) scanf(\"%I64d\", &n);\n#define mp make_pair\n\nmap<int, int>working;\nint main()\n{\n\tios::sync_with_stdio(false); cin.tie(0);\n#if defined(_DEBUG) || defined(_RELEASE)\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\tint n, q; cin >> n >> q;\n\tworking[-1] = -1;\n\tworking[2E9] = 2E9;\n\tworking[1] = n;\n\tint answer = n;\n\twhile (q--) {\n\t\tint l, r, k; cin >> l >> r >> k;\n\t\tint haveNow = 0;\n\t\tmap<int, int>::iterator it = working.lower_bound(l);\n\t\tit--;\n\t\tif (it->second >= l) {\n\t\t\tworking[l] = it->second;\n\t\t\tit->second = l-1;\n\t\t}\n\t\tit++;\n\t\twhile (it->first <= r) {\n\t\t\tif (it->second > r) {\n\t\t\t\thaveNow += r + 1 - it->first;\n\t\t\t\tworking[r + 1] = it->second;\n\n\t\t\t}\n\t\t\telse\n\t\t\t\thaveNow += it->second - it->first + 1;\n\t\t\tmap<int, int>::iterator it2 = it;\n\t\t\tit++;\n\t\t\tworking.erase(it2);\n\t\t}\n\t\tif (k == 1) {\n\t\t\tanswer -= haveNow;\n\t\t}\n\t\telse {\n\t\t\tanswer -= haveNow;\n\t\t\tworking[l] = r;\n\t\t\tanswer += r - l + 1;\n\t\t}\n\t\tcout << answer << \"\\n\";\n\t}\n\n\treturn 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}