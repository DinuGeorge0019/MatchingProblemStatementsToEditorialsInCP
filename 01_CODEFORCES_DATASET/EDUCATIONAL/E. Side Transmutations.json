{"link": "https://codeforces.com//contest/1065/problem/E", "problemId": "235282", "shortId": "1065E", "contest_number": "1065", "name": "E. Side Transmutations", "statement": "Consider some set of distinct characters  and some string , consisting of exactly  characters, where each character is present in .You are given an array of  integers  (). You are allowed to perform the following move on the string :  Choose some valid  and set ;  Take the first  characters of ;  Take the last  characters of ;  Substitute the first  characters of  with the reversed ;  Substitute the last  characters of  with the reversed . For example, let's take a look at  \"\" and .  \"\",  \"\". Reversed  \"\",  \"\". Thus, the resulting  is \"\".The move can be performed arbitrary number of times (possibly zero). Any  can be selected multiple times over these moves.Let's call some strings  and  equal if and only if there exists such a sequence of moves to transmute string  to string . For the above example strings \"\" and \"\" are equal. Also note that this implies .The task is simple. Count the number of distinct strings.The answer can be huge enough, so calculate it modulo .", "input": "The first line contains three integers ,  and  (, , ) \u2014 the length of the strings, the size of the array  and the size of the set , respectively. The second line contains  integers  (, ).", "output": "Print a single integer \u2014 the number of distinct strings of length  with characters from set  modulo .", "tutorial": "Let's take a look at any operation. You can notice that each letter can only go from position  to  (-indexed). Then, doing some operation twice is the same as doing that operation zero times.Now consider some set of operations , sorted in increasing order. Actually, they do the following altogether. Replace segment  with the reversed segment  and vice versa. Then replace segment  with the reversed segment  and vice versa. And continue until you reach the first pair. Segment  might also be included in the answer when the parity is right.Moreover, every subset of segments  is achievable. So for each segment you can either swap it or not. Let's translate it to math language.Let  be the number of such pairs of strings  and  that . Why is there such an order? You want to consider only unique strings, thus, you need to pick exactly one of equal strings from each component. Let it be the smallest one.Then for each segment of the set you have  pairs to choose from, where  is the length of that segment.And that part of the formula is:.However, the part covered by zero segments is left. There are  possible strings up there. is actually a number of all pairs of strings of length  plus the number of all pairs of equal strings of length  divided by . .Overall complexity: .", "solution": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int N = 200 * 1000 + 13;\nconst int MOD = 998244353;\n\nint n, m, A;\nint b[N];\n\nint add(int a, int b){\n    a += b;\n    if (a >= MOD)\n        a -= MOD;\n    return a;\n}\n\nint mul(int a, int b){\n    return (a * 1ll * b) % MOD;\n}\n\nint binpow(int a, int b){\n    int res = 1;\n    while (b){\n        if (b & 1)\n            res = mul(res, a);\n        a = mul(a, a);\n        b >>= 1;\n    }\n    return res;\n}\n\nint cnt(int x){\n    int base = binpow(A, x);\n    return mul(add(mul(base, base), base), (MOD + 1) / 2);\n}\n\nint main() {\n    scanf(\"%d%d%d\", &n, &m, &A);\n    forn(i, m)\n        scanf(\"%d\", &b[i]);\n    \n    int ans = binpow(A, n - b[m - 1] * 2);\n    ans = mul(ans, cnt(b[0]));\n    forn(i, m - 1)\n        ans = mul(ans, cnt(b[i + 1] - b[i]));\n    \n    printf(\"%d\\n\", ans);\n    return 0;\n}", "interactive": false, "noSolution": false, "noTutorial": false}